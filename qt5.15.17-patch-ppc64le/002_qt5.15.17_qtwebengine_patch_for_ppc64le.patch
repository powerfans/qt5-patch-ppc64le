diff -Naur a/qtwebengine/build-tests-unknown_linux_generic_elf_64bit-Debug/Makefile b/qtwebengine/build-tests-unknown_linux_generic_elf_64bit-Debug/Makefile
--- a/qtwebengine/build-tests-unknown_linux_generic_elf_64bit-Debug/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/build-tests-unknown_linux_generic_elf_64bit-Debug/Makefile	2025-06-10 10:36:39.472786840 +0800
@@ -0,0 +1,657 @@
+#############################################################################
+# Makefile for building: tests
+# Generated by qmake (3.1) (Qt 5.15.17)
+# Project:  ../tests/tests.pro
+# Template: subdirs
+# Command: /opt/qt/5.15.17/bin/qmake -o Makefile ../tests/tests.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug
+#############################################################################
+
+MAKEFILE      = Makefile
+
+EQ            = =
+
+first: make_first
+QMAKE         = /opt/qt/5.15.17/bin/qmake
+DEL_FILE      = rm -f
+CHK_DIR_EXISTS= test -d
+MKDIR         = mkdir -p
+COPY          = cp -f
+COPY_FILE     = cp -f
+COPY_DIR      = cp -f -R
+INSTALL_FILE  = install -m 644 -p
+INSTALL_PROGRAM = install -m 755 -p
+INSTALL_DIR   = cp -f -R
+QINSTALL      = /opt/qt/5.15.17/bin/qmake -install qinstall
+QINSTALL_PROGRAM = /opt/qt/5.15.17/bin/qmake -install qinstall -exe
+DEL_FILE      = rm -f
+SYMLINK       = ln -f -s
+DEL_DIR       = rmdir
+MOVE          = mv -f
+TAR           = tar -cf
+COMPRESS      = gzip -9f
+DISTNAME      = tests1.0.0
+DISTDIR = /home/qt/qt+webengine-5.15.17/qtwebengine/build-tests-unknown_linux_generic_elf_64bit-Debug/.obj/tests1.0.0
+SUBTARGETS    =  \
+		sub-auto \
+		sub-quicktestbrowser
+
+
+sub-auto-qmake_all:  FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug
+	cd auto/ && $(MAKE) -f Makefile qmake_all
+sub-auto: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile
+sub-auto-make_first: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile 
+sub-auto-all: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile all
+sub-auto-clean: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile clean
+sub-auto-distclean: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile distclean
+sub-auto-install_subtargets: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile install
+sub-auto-uninstall_subtargets: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile uninstall
+sub-quicktestbrowser-qmake_all:  FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug
+	cd quicktestbrowser/ && $(MAKE) -f Makefile qmake_all
+sub-quicktestbrowser: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile
+sub-quicktestbrowser-make_first: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile 
+sub-quicktestbrowser-all: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile all
+sub-quicktestbrowser-clean: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile clean
+sub-quicktestbrowser-distclean: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile distclean
+sub-quicktestbrowser-install_subtargets: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile install
+sub-quicktestbrowser-uninstall_subtargets: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile uninstall
+
+Makefile: ../tests/tests.pro ../.qmake.conf /opt/qt/5.15.17/mkspecs/linux-g++/qmake.conf /opt/qt/5.15.17/mkspecs/features/spec_pre.prf \
+		/opt/qt/5.15.17/mkspecs/common/unix.conf \
+		/opt/qt/5.15.17/mkspecs/common/linux.conf \
+		/opt/qt/5.15.17/mkspecs/common/sanitize.conf \
+		/opt/qt/5.15.17/mkspecs/common/gcc-base.conf \
+		/opt/qt/5.15.17/mkspecs/common/gcc-base-unix.conf \
+		/opt/qt/5.15.17/mkspecs/common/g++-base.conf \
+		/opt/qt/5.15.17/mkspecs/common/g++-unix.conf \
+		/opt/qt/5.15.17/mkspecs/qconfig.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3danimation.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3danimation_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dcore.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dcore_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dextras.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dextras_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dinput.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dinput_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dlogic.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dlogic_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquick.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquick_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickanimation.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickanimation_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickextras.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickextras_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickinput.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickinput_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickrender.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickrender_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickscene2d.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickscene2d_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3drender.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3drender_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_accessibility_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_bluetooth.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_bluetooth_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_bodymovin_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_bootstrap_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_charts.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_charts_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_concurrent.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_concurrent_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_core.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_core_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_datavisualization.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_datavisualization_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_dbus.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_dbus_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_designer.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_designer_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_designercomponents_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_devicediscovery_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_edid_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_egl_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_fb_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_fontdatabase_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_gamepad.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_gamepad_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_glx_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_gui.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_gui_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_help.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_help_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_input_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_kms_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_location.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_location_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimedia.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimedia_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimediagsttools_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimediawidgets.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimediawidgets_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_network.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_network_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_networkauth.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_networkauth_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_nfc.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_nfc_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_opengl.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_opengl_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_openglextensions.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_openglextensions_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_packetprotocol_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdf.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdf_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdfwidgets.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdfwidgets_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_platformcompositor_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioning.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioning_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioningquick.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioningquick_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_printsupport.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_printsupport_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_purchasing.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_purchasing_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qml.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qml_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmldebug_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmldevtools_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlmodels.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlmodels_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmltest.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmltest_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlworkerscript.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlworkerscript_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qtmultimediaquicktools_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3d.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3d_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dassetimport.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dassetimport_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3drender.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3drender_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3druntimerender.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3druntimerender_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dutils.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dutils_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickcontrols2.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickcontrols2_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickparticles_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickshapes_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quicktemplates2.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quicktemplates2_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickwidgets.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickwidgets_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_remoteobjects.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_remoteobjects_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_repparser.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_repparser_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_script.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_script_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_scripttools.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_scripttools_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_scxml.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_scxml_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_sensors.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_sensors_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialbus.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialbus_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialport.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialport_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_service_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_sql.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_sql_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_svg.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_svg_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_testlib.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_testlib_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_texttospeech.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_texttospeech_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_theme_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_uiplugin.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_uitools.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_uitools_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_virtualkeyboard.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_virtualkeyboard_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandclient.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandclient_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandcompositor.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandcompositor_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webchannel.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webchannel_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webengine.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webengine_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginecore.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginecore_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginecoreheaders_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginewidgets.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginewidgets_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_websockets.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_websockets_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webview.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webview_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_widgets.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_widgets_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_x11extras.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_x11extras_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_xkbcommon_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_xml.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_xml_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_xmlpatterns.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_xmlpatterns_private.pri \
+		/opt/qt/5.15.17/mkspecs/features/qt_functions.prf \
+		/opt/qt/5.15.17/mkspecs/features/qt_config.prf \
+		/opt/qt/5.15.17/mkspecs/linux-g++/qmake.conf \
+		/opt/qt/5.15.17/mkspecs/features/spec_post.prf \
+		/opt/qt/5.15.17/mkspecs/qmodule.pri \
+		/opt/qt/5.15.17/mkspecs/features/qt_prefix_build_check.prf \
+		/opt/qt/5.15.17/mkspecs/features/qt_build_config.prf \
+		../.qmake.conf \
+		../.qmake.stash \
+		/opt/qt/5.15.17/mkspecs/features/exclusive_builds.prf \
+		/opt/qt/5.15.17/mkspecs/features/toolchain.prf \
+		/opt/qt/5.15.17/mkspecs/features/default_pre.prf \
+		../src/buildtools/config/support.pri \
+		../mkspecs/features/functions.prf \
+		../mkspecs/features/default_pre.prf \
+		/opt/qt/5.15.17/mkspecs/features/resolve_config.prf \
+		/opt/qt/5.15.17/mkspecs/features/default_post.prf \
+		/opt/qt/5.15.17/mkspecs/features/qml_debug.prf \
+		/opt/qt/5.15.17/mkspecs/features/exceptions_off.prf \
+		/opt/qt/5.15.17/mkspecs/features/qt_example_installs.prf \
+		/opt/qt/5.15.17/mkspecs/features/precompile_header.prf \
+		/opt/qt/5.15.17/mkspecs/features/unix/largefile.prf \
+		/opt/qt/5.15.17/mkspecs/features/warn_on.prf \
+		/opt/qt/5.15.17/mkspecs/features/qmake_use.prf \
+		/opt/qt/5.15.17/mkspecs/features/file_copies.prf \
+		/opt/qt/5.15.17/mkspecs/features/qt_build_extra.prf \
+		/opt/qt/5.15.17/mkspecs/features/qt_docs_targets.prf \
+		/opt/qt/5.15.17/mkspecs/features/testcase_targets.prf \
+		/opt/qt/5.15.17/mkspecs/features/yacc.prf \
+		/opt/qt/5.15.17/mkspecs/features/lex.prf \
+		../tests/tests.pro
+	$(QMAKE) -o Makefile ../tests/tests.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug
+/opt/qt/5.15.17/mkspecs/features/spec_pre.prf:
+/opt/qt/5.15.17/mkspecs/common/unix.conf:
+/opt/qt/5.15.17/mkspecs/common/linux.conf:
+/opt/qt/5.15.17/mkspecs/common/sanitize.conf:
+/opt/qt/5.15.17/mkspecs/common/gcc-base.conf:
+/opt/qt/5.15.17/mkspecs/common/gcc-base-unix.conf:
+/opt/qt/5.15.17/mkspecs/common/g++-base.conf:
+/opt/qt/5.15.17/mkspecs/common/g++-unix.conf:
+/opt/qt/5.15.17/mkspecs/qconfig.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3danimation.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3danimation_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dcore.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dcore_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dextras.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dextras_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dinput.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dinput_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dlogic.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dlogic_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquick.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquick_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickanimation.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickanimation_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickextras.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickextras_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickinput.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickinput_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickrender.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickrender_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickscene2d.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickscene2d_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3drender.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3drender_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_accessibility_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_bluetooth.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_bluetooth_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_bodymovin_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_bootstrap_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_charts.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_charts_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_concurrent.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_concurrent_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_core.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_core_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_datavisualization.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_datavisualization_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_dbus.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_dbus_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_designer.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_designer_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_designercomponents_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_devicediscovery_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_edid_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_egl_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_fb_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_fontdatabase_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_gamepad.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_gamepad_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_glx_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_gui.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_gui_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_help.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_help_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_input_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_kms_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_location.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_location_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimedia.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimedia_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimediagsttools_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimediawidgets.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimediawidgets_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_network.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_network_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_networkauth.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_networkauth_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_nfc.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_nfc_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_opengl.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_opengl_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_openglextensions.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_openglextensions_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_packetprotocol_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdf.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdf_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdfwidgets.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdfwidgets_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_platformcompositor_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioning.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioning_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioningquick.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioningquick_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_printsupport.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_printsupport_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_purchasing.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_purchasing_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qml.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qml_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmldebug_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmldevtools_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlmodels.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlmodels_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmltest.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmltest_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlworkerscript.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlworkerscript_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qtmultimediaquicktools_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3d.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3d_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dassetimport.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dassetimport_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3drender.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3drender_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3druntimerender.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3druntimerender_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dutils.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dutils_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickcontrols2.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickcontrols2_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickparticles_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickshapes_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quicktemplates2.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quicktemplates2_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickwidgets.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickwidgets_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_remoteobjects.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_remoteobjects_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_repparser.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_repparser_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_script.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_script_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_scripttools.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_scripttools_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_scxml.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_scxml_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_sensors.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_sensors_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialbus.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialbus_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialport.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialport_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_service_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_sql.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_sql_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_svg.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_svg_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_testlib.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_testlib_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_texttospeech.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_texttospeech_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_theme_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_uiplugin.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_uitools.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_uitools_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_virtualkeyboard.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_virtualkeyboard_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandclient.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandclient_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandcompositor.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandcompositor_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webchannel.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webchannel_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webengine.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webengine_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginecore.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginecore_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginecoreheaders_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginewidgets.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginewidgets_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_websockets.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_websockets_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webview.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webview_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_widgets.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_widgets_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_x11extras.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_x11extras_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_xkbcommon_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_xml.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_xml_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_xmlpatterns.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_xmlpatterns_private.pri:
+/opt/qt/5.15.17/mkspecs/features/qt_functions.prf:
+/opt/qt/5.15.17/mkspecs/features/qt_config.prf:
+/opt/qt/5.15.17/mkspecs/linux-g++/qmake.conf:
+/opt/qt/5.15.17/mkspecs/features/spec_post.prf:
+/opt/qt/5.15.17/mkspecs/qmodule.pri:
+/opt/qt/5.15.17/mkspecs/features/qt_prefix_build_check.prf:
+/opt/qt/5.15.17/mkspecs/features/qt_build_config.prf:
+../.qmake.conf:
+../.qmake.stash:
+/opt/qt/5.15.17/mkspecs/features/exclusive_builds.prf:
+/opt/qt/5.15.17/mkspecs/features/toolchain.prf:
+/opt/qt/5.15.17/mkspecs/features/default_pre.prf:
+../src/buildtools/config/support.pri:
+../mkspecs/features/functions.prf:
+../mkspecs/features/default_pre.prf:
+/opt/qt/5.15.17/mkspecs/features/resolve_config.prf:
+/opt/qt/5.15.17/mkspecs/features/default_post.prf:
+/opt/qt/5.15.17/mkspecs/features/qml_debug.prf:
+/opt/qt/5.15.17/mkspecs/features/exceptions_off.prf:
+/opt/qt/5.15.17/mkspecs/features/qt_example_installs.prf:
+/opt/qt/5.15.17/mkspecs/features/precompile_header.prf:
+/opt/qt/5.15.17/mkspecs/features/unix/largefile.prf:
+/opt/qt/5.15.17/mkspecs/features/warn_on.prf:
+/opt/qt/5.15.17/mkspecs/features/qmake_use.prf:
+/opt/qt/5.15.17/mkspecs/features/file_copies.prf:
+/opt/qt/5.15.17/mkspecs/features/qt_build_extra.prf:
+/opt/qt/5.15.17/mkspecs/features/qt_docs_targets.prf:
+/opt/qt/5.15.17/mkspecs/features/testcase_targets.prf:
+/opt/qt/5.15.17/mkspecs/features/yacc.prf:
+/opt/qt/5.15.17/mkspecs/features/lex.prf:
+../tests/tests.pro:
+qmake: FORCE
+	@$(QMAKE) -o Makefile ../tests/tests.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug
+
+qmake_all: sub-auto-qmake_all sub-quicktestbrowser-qmake_all FORCE
+
+make_first: sub-auto-make_first sub-quicktestbrowser-make_first  FORCE
+all: sub-auto-all sub-quicktestbrowser-all  FORCE
+clean: sub-auto-clean sub-quicktestbrowser-clean  FORCE
+distclean: sub-auto-distclean sub-quicktestbrowser-distclean  FORCE
+	-$(DEL_FILE) Makefile
+install_subtargets: sub-auto-install_subtargets sub-quicktestbrowser-install_subtargets FORCE
+uninstall_subtargets: sub-auto-uninstall_subtargets sub-quicktestbrowser-uninstall_subtargets FORCE
+
+html_docs:
+	$(MAKE) -f $(MAKEFILE) prepare_docs && $(MAKE) -f $(MAKEFILE) generate_docs
+
+docs:
+	$(MAKE) -f $(MAKEFILE) html_docs && $(MAKE) -f $(MAKEFILE) qch_docs
+
+sub-auto-install_html_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile install_html_docs
+sub-quicktestbrowser-install_html_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile install_html_docs
+install_html_docs: sub-auto-install_html_docs sub-quicktestbrowser-install_html_docs
+
+sub-auto-uninstall_html_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile uninstall_html_docs
+sub-quicktestbrowser-uninstall_html_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile uninstall_html_docs
+uninstall_html_docs: sub-auto-uninstall_html_docs sub-quicktestbrowser-uninstall_html_docs
+
+sub-auto-install_qch_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile install_qch_docs
+sub-quicktestbrowser-install_qch_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile install_qch_docs
+install_qch_docs: sub-auto-install_qch_docs sub-quicktestbrowser-install_qch_docs
+
+sub-auto-uninstall_qch_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile uninstall_qch_docs
+sub-quicktestbrowser-uninstall_qch_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile uninstall_qch_docs
+uninstall_qch_docs: sub-auto-uninstall_qch_docs sub-quicktestbrowser-uninstall_qch_docs
+
+sub-auto-install_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile install_docs
+sub-quicktestbrowser-install_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile install_docs
+install_docs: sub-auto-install_docs sub-quicktestbrowser-install_docs
+
+sub-auto-uninstall_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile uninstall_docs
+sub-quicktestbrowser-uninstall_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile uninstall_docs
+uninstall_docs: sub-auto-uninstall_docs sub-quicktestbrowser-uninstall_docs
+
+sub-auto-qch_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile qch_docs
+sub-quicktestbrowser-qch_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile qch_docs
+qch_docs: sub-auto-qch_docs sub-quicktestbrowser-qch_docs
+
+sub-auto-prepare_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile prepare_docs
+sub-quicktestbrowser-prepare_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile prepare_docs
+prepare_docs: sub-auto-prepare_docs sub-quicktestbrowser-prepare_docs
+
+sub-auto-generate_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile generate_docs
+sub-quicktestbrowser-generate_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile generate_docs
+generate_docs: sub-auto-generate_docs sub-quicktestbrowser-generate_docs
+
+sub-auto-check:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile check
+sub-quicktestbrowser-check:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile check
+check: sub-auto-check sub-quicktestbrowser-check
+
+sub-auto-benchmark:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile benchmark
+sub-quicktestbrowser-benchmark:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -f Makefile benchmark
+benchmark: sub-auto-benchmark sub-quicktestbrowser-benchmark
+install:install_subtargets  FORCE
+
+uninstall: uninstall_subtargets FORCE
+
+FORCE:
+
+dist: distdir FORCE
+	(cd `dirname $(DISTDIR)` && $(TAR) $(DISTNAME).tar $(DISTNAME) && $(COMPRESS) $(DISTNAME).tar) && $(MOVE) `dirname $(DISTDIR)`/$(DISTNAME).tar.gz . && $(DEL_FILE) -r $(DISTDIR)
+
+distdir: sub-auto-distdir sub-quicktestbrowser-distdir FORCE
+	@test -d $(DISTDIR) || mkdir -p $(DISTDIR)
+	$(COPY_FILE) --parents ../.qmake.conf ../.qmake.stash ../src/buildtools/config/support.pri ../mkspecs/features/functions.prf ../mkspecs/features/default_pre.prf ../tests/tests.pro $(DISTDIR)/
+
+sub-auto-distdir: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -e -f Makefile distdir DISTDIR=$(DISTDIR)/auto
+
+sub-quicktestbrowser-distdir: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=debug CONFIG+=qml_debug ) && $(MAKE) -e -f Makefile distdir DISTDIR=$(DISTDIR)/quicktestbrowser
+
diff -Naur a/qtwebengine/build-tests-unknown_linux_generic_elf_64bit-Release/Makefile b/qtwebengine/build-tests-unknown_linux_generic_elf_64bit-Release/Makefile
--- a/qtwebengine/build-tests-unknown_linux_generic_elf_64bit-Release/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/build-tests-unknown_linux_generic_elf_64bit-Release/Makefile	2025-06-10 10:37:52.461745220 +0800
@@ -0,0 +1,657 @@
+#############################################################################
+# Makefile for building: tests
+# Generated by qmake (3.1) (Qt 5.15.17)
+# Project:  ../tests/tests.pro
+# Template: subdirs
+# Command: /opt/qt/5.15.17/bin/qmake -o Makefile ../tests/tests.pro -spec linux-g++ CONFIG+=qtquickcompiler
+#############################################################################
+
+MAKEFILE      = Makefile
+
+EQ            = =
+
+first: make_first
+QMAKE         = /opt/qt/5.15.17/bin/qmake
+DEL_FILE      = rm -f
+CHK_DIR_EXISTS= test -d
+MKDIR         = mkdir -p
+COPY          = cp -f
+COPY_FILE     = cp -f
+COPY_DIR      = cp -f -R
+INSTALL_FILE  = install -m 644 -p
+INSTALL_PROGRAM = install -m 755 -p
+INSTALL_DIR   = cp -f -R
+QINSTALL      = /opt/qt/5.15.17/bin/qmake -install qinstall
+QINSTALL_PROGRAM = /opt/qt/5.15.17/bin/qmake -install qinstall -exe
+DEL_FILE      = rm -f
+SYMLINK       = ln -f -s
+DEL_DIR       = rmdir
+MOVE          = mv -f
+TAR           = tar -cf
+COMPRESS      = gzip -9f
+DISTNAME      = tests1.0.0
+DISTDIR = /home/qt/qt+webengine-5.15.17/qtwebengine/build-tests-unknown_linux_generic_elf_64bit-Release/.obj/tests1.0.0
+SUBTARGETS    =  \
+		sub-auto \
+		sub-quicktestbrowser
+
+
+sub-auto-qmake_all:  FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler
+	cd auto/ && $(MAKE) -f Makefile qmake_all
+sub-auto: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile
+sub-auto-make_first: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile 
+sub-auto-all: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile all
+sub-auto-clean: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile clean
+sub-auto-distclean: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile distclean
+sub-auto-install_subtargets: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile install
+sub-auto-uninstall_subtargets: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile uninstall
+sub-quicktestbrowser-qmake_all:  FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler
+	cd quicktestbrowser/ && $(MAKE) -f Makefile qmake_all
+sub-quicktestbrowser: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile
+sub-quicktestbrowser-make_first: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile 
+sub-quicktestbrowser-all: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile all
+sub-quicktestbrowser-clean: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile clean
+sub-quicktestbrowser-distclean: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile distclean
+sub-quicktestbrowser-install_subtargets: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile install
+sub-quicktestbrowser-uninstall_subtargets: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile uninstall
+
+Makefile: ../tests/tests.pro ../.qmake.conf /opt/qt/5.15.17/mkspecs/linux-g++/qmake.conf /opt/qt/5.15.17/mkspecs/features/spec_pre.prf \
+		/opt/qt/5.15.17/mkspecs/common/unix.conf \
+		/opt/qt/5.15.17/mkspecs/common/linux.conf \
+		/opt/qt/5.15.17/mkspecs/common/sanitize.conf \
+		/opt/qt/5.15.17/mkspecs/common/gcc-base.conf \
+		/opt/qt/5.15.17/mkspecs/common/gcc-base-unix.conf \
+		/opt/qt/5.15.17/mkspecs/common/g++-base.conf \
+		/opt/qt/5.15.17/mkspecs/common/g++-unix.conf \
+		/opt/qt/5.15.17/mkspecs/qconfig.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3danimation.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3danimation_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dcore.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dcore_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dextras.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dextras_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dinput.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dinput_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dlogic.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dlogic_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquick.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquick_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickanimation.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickanimation_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickextras.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickextras_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickinput.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickinput_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickrender.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickrender_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickscene2d.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickscene2d_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3drender.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_3drender_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_accessibility_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_bluetooth.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_bluetooth_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_bodymovin_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_bootstrap_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_charts.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_charts_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_concurrent.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_concurrent_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_core.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_core_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_datavisualization.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_datavisualization_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_dbus.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_dbus_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_designer.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_designer_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_designercomponents_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_devicediscovery_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_edid_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_egl_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_fb_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_fontdatabase_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_gamepad.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_gamepad_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_glx_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_gui.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_gui_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_help.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_help_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_input_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_kms_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_location.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_location_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimedia.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimedia_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimediagsttools_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimediawidgets.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimediawidgets_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_network.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_network_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_networkauth.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_networkauth_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_nfc.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_nfc_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_opengl.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_opengl_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_openglextensions.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_openglextensions_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_packetprotocol_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdf.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdf_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdfwidgets.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdfwidgets_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_platformcompositor_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioning.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioning_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioningquick.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioningquick_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_printsupport.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_printsupport_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_purchasing.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_purchasing_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qml.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qml_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmldebug_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmldevtools_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlmodels.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlmodels_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmltest.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmltest_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlworkerscript.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlworkerscript_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_qtmultimediaquicktools_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3d.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3d_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dassetimport.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dassetimport_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3drender.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3drender_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3druntimerender.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3druntimerender_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dutils.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dutils_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickcontrols2.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickcontrols2_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickparticles_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickshapes_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quicktemplates2.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quicktemplates2_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickwidgets.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickwidgets_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_remoteobjects.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_remoteobjects_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_repparser.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_repparser_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_script.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_script_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_scripttools.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_scripttools_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_scxml.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_scxml_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_sensors.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_sensors_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialbus.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialbus_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialport.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialport_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_service_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_sql.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_sql_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_svg.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_svg_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_testlib.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_testlib_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_texttospeech.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_texttospeech_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_theme_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_uiplugin.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_uitools.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_uitools_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_virtualkeyboard.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_virtualkeyboard_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandclient.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandclient_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandcompositor.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandcompositor_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webchannel.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webchannel_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webengine.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webengine_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginecore.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginecore_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginecoreheaders_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginewidgets.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginewidgets_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_websockets.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_websockets_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webview.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_webview_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_widgets.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_widgets_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_x11extras.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_x11extras_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_xkbcommon_support_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_xml.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_xml_private.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_xmlpatterns.pri \
+		/opt/qt/5.15.17/mkspecs/modules/qt_lib_xmlpatterns_private.pri \
+		/opt/qt/5.15.17/mkspecs/features/qt_functions.prf \
+		/opt/qt/5.15.17/mkspecs/features/qt_config.prf \
+		/opt/qt/5.15.17/mkspecs/linux-g++/qmake.conf \
+		/opt/qt/5.15.17/mkspecs/features/spec_post.prf \
+		/opt/qt/5.15.17/mkspecs/qmodule.pri \
+		/opt/qt/5.15.17/mkspecs/features/qt_prefix_build_check.prf \
+		/opt/qt/5.15.17/mkspecs/features/qt_build_config.prf \
+		../.qmake.conf \
+		../.qmake.stash \
+		/opt/qt/5.15.17/mkspecs/features/exclusive_builds.prf \
+		/opt/qt/5.15.17/mkspecs/features/toolchain.prf \
+		/opt/qt/5.15.17/mkspecs/features/default_pre.prf \
+		../src/buildtools/config/support.pri \
+		../mkspecs/features/functions.prf \
+		../mkspecs/features/default_pre.prf \
+		/opt/qt/5.15.17/mkspecs/features/resolve_config.prf \
+		/opt/qt/5.15.17/mkspecs/features/default_post.prf \
+		/opt/qt/5.15.17/mkspecs/features/qtquickcompiler.prf \
+		/opt/qt/5.15.17/mkspecs/features/exceptions_off.prf \
+		/opt/qt/5.15.17/mkspecs/features/qt_example_installs.prf \
+		/opt/qt/5.15.17/mkspecs/features/precompile_header.prf \
+		/opt/qt/5.15.17/mkspecs/features/unix/largefile.prf \
+		/opt/qt/5.15.17/mkspecs/features/warn_on.prf \
+		/opt/qt/5.15.17/mkspecs/features/qmake_use.prf \
+		/opt/qt/5.15.17/mkspecs/features/file_copies.prf \
+		/opt/qt/5.15.17/mkspecs/features/qt_build_extra.prf \
+		/opt/qt/5.15.17/mkspecs/features/qt_docs_targets.prf \
+		/opt/qt/5.15.17/mkspecs/features/testcase_targets.prf \
+		/opt/qt/5.15.17/mkspecs/features/yacc.prf \
+		/opt/qt/5.15.17/mkspecs/features/lex.prf \
+		../tests/tests.pro
+	$(QMAKE) -o Makefile ../tests/tests.pro -spec linux-g++ CONFIG+=qtquickcompiler
+/opt/qt/5.15.17/mkspecs/features/spec_pre.prf:
+/opt/qt/5.15.17/mkspecs/common/unix.conf:
+/opt/qt/5.15.17/mkspecs/common/linux.conf:
+/opt/qt/5.15.17/mkspecs/common/sanitize.conf:
+/opt/qt/5.15.17/mkspecs/common/gcc-base.conf:
+/opt/qt/5.15.17/mkspecs/common/gcc-base-unix.conf:
+/opt/qt/5.15.17/mkspecs/common/g++-base.conf:
+/opt/qt/5.15.17/mkspecs/common/g++-unix.conf:
+/opt/qt/5.15.17/mkspecs/qconfig.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3danimation.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3danimation_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dcore.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dcore_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dextras.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dextras_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dinput.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dinput_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dlogic.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dlogic_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquick.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquick_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickanimation.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickanimation_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickextras.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickextras_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickinput.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickinput_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickrender.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickrender_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickscene2d.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3dquickscene2d_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3drender.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_3drender_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_accessibility_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_bluetooth.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_bluetooth_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_bodymovin_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_bootstrap_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_charts.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_charts_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_concurrent.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_concurrent_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_core.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_core_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_datavisualization.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_datavisualization_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_dbus.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_dbus_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_designer.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_designer_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_designercomponents_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_devicediscovery_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_edid_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_egl_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_fb_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_fontdatabase_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_gamepad.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_gamepad_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_glx_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_gui.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_gui_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_help.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_help_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_input_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_kms_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_location.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_location_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimedia.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimedia_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimediagsttools_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimediawidgets.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_multimediawidgets_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_network.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_network_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_networkauth.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_networkauth_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_nfc.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_nfc_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_opengl.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_opengl_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_openglextensions.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_openglextensions_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_packetprotocol_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdf.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdf_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdfwidgets.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_pdfwidgets_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_platformcompositor_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioning.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioning_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioningquick.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_positioningquick_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_printsupport.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_printsupport_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_purchasing.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_purchasing_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qml.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qml_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmldebug_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmldevtools_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlmodels.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlmodels_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmltest.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmltest_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlworkerscript.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qmlworkerscript_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_qtmultimediaquicktools_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3d.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3d_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dassetimport.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dassetimport_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3drender.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3drender_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3druntimerender.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3druntimerender_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dutils.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick3dutils_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quick_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickcontrols2.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickcontrols2_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickparticles_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickshapes_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quicktemplates2.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quicktemplates2_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickwidgets.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_quickwidgets_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_remoteobjects.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_remoteobjects_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_repparser.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_repparser_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_script.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_script_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_scripttools.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_scripttools_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_scxml.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_scxml_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_sensors.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_sensors_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialbus.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialbus_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialport.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_serialport_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_service_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_sql.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_sql_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_svg.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_svg_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_testlib.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_testlib_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_texttospeech.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_texttospeech_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_theme_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_uiplugin.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_uitools.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_uitools_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_virtualkeyboard.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_virtualkeyboard_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandclient.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandclient_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandcompositor.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_waylandcompositor_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webchannel.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webchannel_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webengine.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webengine_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginecore.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginecore_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginecoreheaders_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginewidgets.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webenginewidgets_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_websockets.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_websockets_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webview.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_webview_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_widgets.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_widgets_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_x11extras.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_x11extras_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_xkbcommon_support_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_xml.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_xml_private.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_xmlpatterns.pri:
+/opt/qt/5.15.17/mkspecs/modules/qt_lib_xmlpatterns_private.pri:
+/opt/qt/5.15.17/mkspecs/features/qt_functions.prf:
+/opt/qt/5.15.17/mkspecs/features/qt_config.prf:
+/opt/qt/5.15.17/mkspecs/linux-g++/qmake.conf:
+/opt/qt/5.15.17/mkspecs/features/spec_post.prf:
+/opt/qt/5.15.17/mkspecs/qmodule.pri:
+/opt/qt/5.15.17/mkspecs/features/qt_prefix_build_check.prf:
+/opt/qt/5.15.17/mkspecs/features/qt_build_config.prf:
+../.qmake.conf:
+../.qmake.stash:
+/opt/qt/5.15.17/mkspecs/features/exclusive_builds.prf:
+/opt/qt/5.15.17/mkspecs/features/toolchain.prf:
+/opt/qt/5.15.17/mkspecs/features/default_pre.prf:
+../src/buildtools/config/support.pri:
+../mkspecs/features/functions.prf:
+../mkspecs/features/default_pre.prf:
+/opt/qt/5.15.17/mkspecs/features/resolve_config.prf:
+/opt/qt/5.15.17/mkspecs/features/default_post.prf:
+/opt/qt/5.15.17/mkspecs/features/qtquickcompiler.prf:
+/opt/qt/5.15.17/mkspecs/features/exceptions_off.prf:
+/opt/qt/5.15.17/mkspecs/features/qt_example_installs.prf:
+/opt/qt/5.15.17/mkspecs/features/precompile_header.prf:
+/opt/qt/5.15.17/mkspecs/features/unix/largefile.prf:
+/opt/qt/5.15.17/mkspecs/features/warn_on.prf:
+/opt/qt/5.15.17/mkspecs/features/qmake_use.prf:
+/opt/qt/5.15.17/mkspecs/features/file_copies.prf:
+/opt/qt/5.15.17/mkspecs/features/qt_build_extra.prf:
+/opt/qt/5.15.17/mkspecs/features/qt_docs_targets.prf:
+/opt/qt/5.15.17/mkspecs/features/testcase_targets.prf:
+/opt/qt/5.15.17/mkspecs/features/yacc.prf:
+/opt/qt/5.15.17/mkspecs/features/lex.prf:
+../tests/tests.pro:
+qmake: FORCE
+	@$(QMAKE) -o Makefile ../tests/tests.pro -spec linux-g++ CONFIG+=qtquickcompiler
+
+qmake_all: sub-auto-qmake_all sub-quicktestbrowser-qmake_all FORCE
+
+make_first: sub-auto-make_first sub-quicktestbrowser-make_first  FORCE
+all: sub-auto-all sub-quicktestbrowser-all  FORCE
+clean: sub-auto-clean sub-quicktestbrowser-clean  FORCE
+distclean: sub-auto-distclean sub-quicktestbrowser-distclean  FORCE
+	-$(DEL_FILE) Makefile
+install_subtargets: sub-auto-install_subtargets sub-quicktestbrowser-install_subtargets FORCE
+uninstall_subtargets: sub-auto-uninstall_subtargets sub-quicktestbrowser-uninstall_subtargets FORCE
+
+html_docs:
+	$(MAKE) -f $(MAKEFILE) prepare_docs && $(MAKE) -f $(MAKEFILE) generate_docs
+
+docs:
+	$(MAKE) -f $(MAKEFILE) html_docs && $(MAKE) -f $(MAKEFILE) qch_docs
+
+sub-auto-install_html_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile install_html_docs
+sub-quicktestbrowser-install_html_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile install_html_docs
+install_html_docs: sub-auto-install_html_docs sub-quicktestbrowser-install_html_docs
+
+sub-auto-uninstall_html_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile uninstall_html_docs
+sub-quicktestbrowser-uninstall_html_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile uninstall_html_docs
+uninstall_html_docs: sub-auto-uninstall_html_docs sub-quicktestbrowser-uninstall_html_docs
+
+sub-auto-install_qch_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile install_qch_docs
+sub-quicktestbrowser-install_qch_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile install_qch_docs
+install_qch_docs: sub-auto-install_qch_docs sub-quicktestbrowser-install_qch_docs
+
+sub-auto-uninstall_qch_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile uninstall_qch_docs
+sub-quicktestbrowser-uninstall_qch_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile uninstall_qch_docs
+uninstall_qch_docs: sub-auto-uninstall_qch_docs sub-quicktestbrowser-uninstall_qch_docs
+
+sub-auto-install_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile install_docs
+sub-quicktestbrowser-install_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile install_docs
+install_docs: sub-auto-install_docs sub-quicktestbrowser-install_docs
+
+sub-auto-uninstall_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile uninstall_docs
+sub-quicktestbrowser-uninstall_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile uninstall_docs
+uninstall_docs: sub-auto-uninstall_docs sub-quicktestbrowser-uninstall_docs
+
+sub-auto-qch_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile qch_docs
+sub-quicktestbrowser-qch_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile qch_docs
+qch_docs: sub-auto-qch_docs sub-quicktestbrowser-qch_docs
+
+sub-auto-prepare_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile prepare_docs
+sub-quicktestbrowser-prepare_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile prepare_docs
+prepare_docs: sub-auto-prepare_docs sub-quicktestbrowser-prepare_docs
+
+sub-auto-generate_docs:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile generate_docs
+sub-quicktestbrowser-generate_docs:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile generate_docs
+generate_docs: sub-auto-generate_docs sub-quicktestbrowser-generate_docs
+
+sub-auto-check:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile check
+sub-quicktestbrowser-check:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile check
+check: sub-auto-check sub-quicktestbrowser-check
+
+sub-auto-benchmark:
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile benchmark
+sub-quicktestbrowser-benchmark:
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -f Makefile benchmark
+benchmark: sub-auto-benchmark sub-quicktestbrowser-benchmark
+install:install_subtargets  FORCE
+
+uninstall: uninstall_subtargets FORCE
+
+FORCE:
+
+dist: distdir FORCE
+	(cd `dirname $(DISTDIR)` && $(TAR) $(DISTNAME).tar $(DISTNAME) && $(COMPRESS) $(DISTNAME).tar) && $(MOVE) `dirname $(DISTDIR)`/$(DISTNAME).tar.gz . && $(DEL_FILE) -r $(DISTDIR)
+
+distdir: sub-auto-distdir sub-quicktestbrowser-distdir FORCE
+	@test -d $(DISTDIR) || mkdir -p $(DISTDIR)
+	$(COPY_FILE) --parents ../.qmake.conf ../.qmake.stash ../src/buildtools/config/support.pri ../mkspecs/features/functions.prf ../mkspecs/features/default_pre.prf ../tests/tests.pro $(DISTDIR)/
+
+sub-auto-distdir: FORCE
+	@test -d auto/ || mkdir -p auto/
+	cd auto/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/auto/auto.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -e -f Makefile distdir DISTDIR=$(DISTDIR)/auto
+
+sub-quicktestbrowser-distdir: FORCE
+	@test -d quicktestbrowser/ || mkdir -p quicktestbrowser/
+	cd quicktestbrowser/ && ( test -e Makefile || $(QMAKE) -o Makefile /home/qt/qt+webengine-5.15.17/qtwebengine/tests/quicktestbrowser/quicktestbrowser.pro -spec linux-g++ CONFIG+=qtquickcompiler ) && $(MAKE) -e -f Makefile distdir DISTDIR=$(DISTDIR)/quicktestbrowser
+
diff -Naur a/qtwebengine/configure.pri b/qtwebengine/configure.pri
--- a/qtwebengine/configure.pri	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/configure.pri	2025-05-30 16:50:48.000000000 +0800
@@ -153,6 +153,7 @@
 }
 
 defineTest(qtConfTest_detectArch) {
+    contains(QT_ARCH, "power")|contains(QT_ARCH, "power64"): return(true)
     contains(QT_ARCH, "i386")|contains(QT_ARCH, "x86_64"): return(true)
     contains(QT_ARCH, "arm")|contains(QT_ARCH, "arm64"): return(true)
     contains(QT_ARCH, "mips"): return(true)
diff -Naur a/qtwebengine/mkspecs/features/functions.prf b/qtwebengine/mkspecs/features/functions.prf
--- a/qtwebengine/mkspecs/features/functions.prf	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/mkspecs/features/functions.prf	2025-05-30 16:51:18.000000000 +0800
@@ -105,6 +105,8 @@
 
 defineReplace(gnArch) {
     qtArch = $$1
+    contains(qtArch, "power64"): return(ppc64le)
+    contains(qtArch, "power"): return(ppcle)
     contains(qtArch, "i386"): return(x86)
     contains(qtArch, "x86_64"): return(x64)
     contains(qtArch, "arm"): return(arm)
diff -Naur a/qtwebengine/.qmake.stash b/qtwebengine/.qmake.stash
--- a/qtwebengine/.qmake.stash	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/.qmake.stash	2025-06-10 10:36:24.203004753 +0800
@@ -0,0 +1,22 @@
+QMAKE_CXX.QT_COMPILER_STDCXX = 201402L
+QMAKE_CXX.QMAKE_GCC_MAJOR_VERSION = 8
+QMAKE_CXX.QMAKE_GCC_MINOR_VERSION = 5
+QMAKE_CXX.QMAKE_GCC_PATCH_VERSION = 0
+QMAKE_CXX.COMPILER_MACROS = \
+    QT_COMPILER_STDCXX \
+    QMAKE_GCC_MAJOR_VERSION \
+    QMAKE_GCC_MINOR_VERSION \
+    QMAKE_GCC_PATCH_VERSION
+QMAKE_CXX.INCDIRS = \
+    /usr/include/c++/8 \
+    /usr/include/c++/8/ppc64le-redhat-linux \
+    /usr/include/c++/8/backward \
+    /usr/lib/gcc/ppc64le-redhat-linux/8/include \
+    /usr/local/include \
+    /usr/include
+QMAKE_CXX.LIBDIRS = \
+    /usr/lib/gcc/ppc64le-redhat-linux/8 \
+    /usr/lib64 \
+    /lib64 \
+    /usr/lib \
+    /lib
diff -Naur a/qtwebengine/src/3rdparty/chromium/base/system/sys_info_posix.cc b/qtwebengine/src/3rdparty/chromium/base/system/sys_info_posix.cc
--- a/qtwebengine/src/3rdparty/chromium/base/system/sys_info_posix.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/base/system/sys_info_posix.cc	2025-06-05 23:36:42.000000000 +0800
@@ -218,6 +218,7 @@
     NOTREACHED();
     return std::string();
   }
+
   std::string arch(info.machine);
   if (arch == "i386" || arch == "i486" || arch == "i586" || arch == "i686") {
     arch = "x86";
@@ -225,6 +226,10 @@
     arch = "x86_64";
   } else if (std::string(info.sysname) == "AIX") {
     arch = "ppc64";
+  } else if (std::string(info.sysname) == "Linux") {
+#if defined(__powerpc64__)
+    arch = "ppc64";  //not use ppc64le here
+#endif
   }
   return arch;
 }
diff -Naur a/qtwebengine/src/3rdparty/chromium/build/apple/tweak_info_plist.py b/qtwebengine/src/3rdparty/chromium/build/apple/tweak_info_plist.py
--- a/qtwebengine/src/3rdparty/chromium/build/apple/tweak_info_plist.py	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/build/apple/tweak_info_plist.py	2025-06-03 10:26:35.000000000 +0800
@@ -194,7 +194,7 @@
   also requires the |bundle_identifier| argument (com.example.product)."""
   plist['KSVersion'] = plist['CFBundleShortVersionString']
   plist['KSProductID'] = bundle_identifier
-  plist['KSUpdateURL'] = 'https://tools.google.com/service/update2'
+  plist['KSUpdateURL'] = 'trk:132:https://tools.google.com/service/update2'
 
   _RemoveKeys(plist, 'KSChannelID')
   if base_tag != '':
diff -Naur a/qtwebengine/src/3rdparty/chromium/build/config/BUILDCONFIG.gn b/qtwebengine/src/3rdparty/chromium/build/config/BUILDCONFIG.gn
--- a/qtwebengine/src/3rdparty/chromium/build/config/BUILDCONFIG.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/build/config/BUILDCONFIG.gn	2025-06-05 17:20:21.000000000 +0800
@@ -136,7 +136,7 @@
   # Set to true when compiling with the Clang compiler.
   is_clang = current_os != "linux" ||
              (current_cpu != "s390x" && current_cpu != "s390" &&
-              current_cpu != "ppc64" && current_cpu != "ppc" &&
+              current_cpu != "ppc64" && current_cpu != "ppc" && current_cpu != "ppc64le" &&
               current_cpu != "mips" && current_cpu != "mips64")
 
   # Allows the path to a custom target toolchain to be injected as a single
diff -Naur a/qtwebengine/src/3rdparty/chromium/build/config/compiler/BUILD.gn b/qtwebengine/src/3rdparty/chromium/build/config/compiler/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/build/config/compiler/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/build/config/compiler/BUILD.gn	2025-06-05 18:31:49.000000000 +0800
@@ -1067,6 +1067,9 @@
         cflags += [ "-m64" ]
         ldflags += [ "-m64" ]
       }
+    } else if (current_cpu == "ppc64le") {
+      cflags += [ "-m64" ]
+      ldflags += [ "-m64" ]
     } else if (current_cpu == "s390x") {
       cflags += [ "-m64" ]
       ldflags += [ "-m64" ]
@@ -1632,7 +1635,7 @@
     ]
 
     if (!is_debug && !using_sanitizer && current_cpu != "s390x" &&
-        current_cpu != "s390" && current_cpu != "ppc64" &&
+        current_cpu != "s390" && current_cpu != "ppc64" && current_cpu != "ppc64le" &&
         current_cpu != "mips" && current_cpu != "mips64") {
       # Non-chromium code is not guaranteed to compile cleanly with
       # _FORTIFY_SOURCE. Also, fortified build may fail when optimizations are
diff -Naur a/qtwebengine/src/3rdparty/chromium/build/config/host_byteorder.gni b/qtwebengine/src/3rdparty/chromium/build/config/host_byteorder.gni
--- a/qtwebengine/src/3rdparty/chromium/build/config/host_byteorder.gni	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/build/config/host_byteorder.gni	2025-06-05 14:39:01.000000000 +0800
@@ -22,6 +22,8 @@
 } else if (host_cpu == "ppc" || host_cpu == "s390" || host_cpu == "s390x" ||
            host_cpu == "mips" || host_cpu == "mips64") {
   host_byteorder = "big"
+} else if (host_cpu == "ppc64le") {
+   host_byteorder = "little"
 } else {
   host_byteorder = "little"
 }
diff -Naur a/qtwebengine/src/3rdparty/chromium/build/download_nacl_toolchains.py b/qtwebengine/src/3rdparty/chromium/build/download_nacl_toolchains.py
--- a/qtwebengine/src/3rdparty/chromium/build/download_nacl_toolchains.py	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/build/download_nacl_toolchains.py	2025-06-03 11:00:04.000000000 +0800
@@ -13,6 +13,10 @@
 
 
 def Main(args):
+  # If `disable_nacl=1` is in GYP_DEFINES, exit
+  if 'disable_nacl=1' in os.environ.get('GYP_DEFINES', ''):
+    return 0
+
   script_dir = os.path.dirname(os.path.abspath(__file__))
   src_dir = os.path.dirname(script_dir)
   nacl_dir = os.path.join(src_dir, 'native_client')
diff -Naur a/qtwebengine/src/3rdparty/chromium/build/toolchain/linux/BUILD.gn b/qtwebengine/src/3rdparty/chromium/build/toolchain/linux/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/build/toolchain/linux/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/build/toolchain/linux/BUILD.gn	2025-06-06 11:57:22.000000000 +0800
@@ -13,6 +13,14 @@
   }
 }
 
+clang_toolchain("clang_ppc64le") {
+  enable_linker_map = true
+  toolchain_args = {
+    current_cpu = "ppc64le"
+    current_os = "linux"
+  }
+}
+
 clang_toolchain("clang_arm") {
   toolprefix = "arm-linux-gnueabihf-"
   toolchain_args = {
@@ -245,6 +253,22 @@
     current_os = "linux"
     is_clang = false
   }
+}
+
+gcc_toolchain("ppc64le") {
+  cc = "gcc"
+  cxx = "g++"
+
+  readelf = "readelf"
+  nm = "nm"
+  ar = "ar"
+  ld = cxx
+
+  toolchain_args = {
+    current_cpu = "ppc64le"
+    current_os = "linux"
+    is_clang = false
+  }
 }
 
 gcc_toolchain("ppc64") {
diff -Naur a/qtwebengine/src/3rdparty/chromium/BUILD.gn b/qtwebengine/src/3rdparty/chromium/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/BUILD.gn	2025-06-04 17:28:20.000000000 +0800
@@ -449,13 +449,13 @@
     ]
   }
 
-  if ((is_chromeos || is_mac || is_win) && !use_qt) {
-    deps += [
-      "//rlz:rlz_id",
-      "//rlz:rlz_lib",
-      "//rlz:rlz_unittests",
-    ]
-  }
+  #if ((is_chromeos || is_mac || is_win) && !use_qt) {
+  #  deps += [
+  #    "//rlz:rlz_id",
+  #    "//rlz:rlz_lib",
+  #    "//rlz:rlz_unittests",
+  #  ]
+  #}
 
   if (is_linux || is_chromeos) {
     # The following are definitely linux-only.
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/BUILD.gn b/qtwebengine/src/3rdparty/chromium/chrome/browser/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/BUILD.gn	2025-06-03 10:12:04.000000000 +0800
@@ -3294,8 +3294,6 @@
       "download/download_commands.h",
       "download/download_crx_util.cc",
       "download/download_crx_util.h",
-      "download/download_danger_prompt.cc",
-      "download/download_danger_prompt.h",
       "download/download_dir_policy_handler.cc",
       "download/download_dir_policy_handler.h",
       "download/download_dir_util.cc",
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/cryptotoken_private/cryptotoken_private_api.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/cryptotoken_private/cryptotoken_private_api.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/cryptotoken_private/cryptotoken_private_api.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/cryptotoken_private/cryptotoken_private_api.cc	2025-06-03 10:26:41.000000000 +0800
@@ -60,8 +60,8 @@
 
 const char kGoogleDotCom[] = "google.com";
 constexpr const char* kGoogleGstaticAppIds[] = {
-    "https://www.gstatic.com/securitykey/origins.json",
-    "https://www.gstatic.com/securitykey/a/google.com/origins.json"};
+    "trk:273:https://www.gstatic.com/securitykey/origins.json",
+    "trk:274:https://www.gstatic.com/securitykey/a/google.com/origins.json"};
 
 // ContainsAppIdByHash returns true iff the SHA-256 hash of one of the
 // elements of |list| equals |hash|.
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/downloads/downloads_api.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/downloads/downloads_api.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/downloads/downloads_api.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/downloads/downloads_api.cc	2025-06-05 15:43:08.000000000 +0800
@@ -38,7 +38,6 @@
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/download/download_core_service.h"
 #include "chrome/browser/download/download_core_service_factory.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/download/download_file_icon_extractor.h"
 #include "chrome/browser/download/download_open_prompt.h"
 #include "chrome/browser/download/download_prefs.h"
@@ -1326,9 +1325,6 @@
 
 DownloadsAcceptDangerFunction::~DownloadsAcceptDangerFunction() {}
 
-DownloadsAcceptDangerFunction::OnPromptCreatedCallback*
-    DownloadsAcceptDangerFunction::on_prompt_created_ = NULL;
-
 ExtensionFunction::ResponseAction DownloadsAcceptDangerFunction::Run() {
   std::unique_ptr<downloads::AcceptDanger::Params> params(
       downloads::AcceptDanger::Params::Create(*args_));
@@ -1368,6 +1364,7 @@
   RecordApiFunctions(DOWNLOADS_FUNCTION_ACCEPT_DANGER);
   // DownloadDangerPrompt displays a modal dialog using native widgets that the
   // user must either accept or cancel. It cannot be scripted.
+#if !defined(__powerpc64__)
   DownloadDangerPrompt* prompt = DownloadDangerPrompt::Create(
       download_item,
       web_contents,
@@ -1378,8 +1375,12 @@
   if (on_prompt_created_ && !on_prompt_created_->is_null())
     on_prompt_created_->Run(prompt);
   // Function finishes in DangerPromptCallback().
+#else
+  download_item->ValidateDangerousDownload();
+#endif  
 }
 
+#if !defined(__powerpc64__)
 void DownloadsAcceptDangerFunction::DangerPromptCallback(
     int download_id, DownloadDangerPrompt::Action action) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
@@ -1404,6 +1405,7 @@
   }
   Respond(NoArguments());
 }
+#endif
 
 DownloadsShowFunction::DownloadsShowFunction() {}
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/downloads/downloads_api.h b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/downloads/downloads_api.h
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/downloads/downloads_api.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/downloads/downloads_api.h	2025-06-03 10:12:22.000000000 +0800
@@ -13,7 +13,6 @@
 #include "base/macros.h"
 #include "base/scoped_observer.h"
 #include "base/time/time.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/common/extensions/api/downloads.h"
 #include "components/download/content/public/all_download_item_notifier.h"
 #include "components/download/public/common/download_path_reservation_tracker.h"
@@ -187,25 +186,16 @@
 
 class DownloadsAcceptDangerFunction : public ExtensionFunction {
  public:
-  typedef base::Callback<void(DownloadDangerPrompt*)> OnPromptCreatedCallback;
-  static void OnPromptCreatedForTesting(
-      OnPromptCreatedCallback* callback) {
-    on_prompt_created_ = callback;
-  }
-
   DECLARE_EXTENSION_FUNCTION("downloads.acceptDanger", DOWNLOADS_ACCEPTDANGER)
   DownloadsAcceptDangerFunction();
   ResponseAction Run() override;
 
  protected:
   ~DownloadsAcceptDangerFunction() override;
-  void DangerPromptCallback(int download_id,
-                            DownloadDangerPrompt::Action action);
 
  private:
   void PromptOrWait(int download_id, int retries);
 
-  static OnPromptCreatedCallback* on_prompt_created_;
   DISALLOW_COPY_AND_ASSIGN(DownloadsAcceptDangerFunction);
 };
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/identity/identity_get_auth_token_function.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/identity/identity_get_auth_token_function.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/identity/identity_get_auth_token_function.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/identity/identity_get_auth_token_function.cc	2025-06-03 09:50:15.000000000 +0800
@@ -69,7 +69,7 @@
     "extensions_identity_api";
 
 bool IsBrowserSigninAllowed(Profile* profile) {
-  return profile->GetPrefs()->GetBoolean(prefs::kSigninAllowed);
+  return false;
 }
 
 std::string GetOAuth2MintTokenFlowVersion() {
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/preference/preference_api.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/preference/preference_api.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/preference/preference_api.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/preference/preference_api.cc	2025-06-03 09:48:15.000000000 +0800
@@ -116,11 +116,6 @@
      APIPermission::kPrivacy},
     {"doNotTrackEnabled", prefs::kEnableDoNotTrack, APIPermission::kPrivacy,
      APIPermission::kPrivacy},
-    {"safeBrowsingEnabled", prefs::kSafeBrowsingEnabled,
-     APIPermission::kPrivacy, APIPermission::kPrivacy},
-    {"safeBrowsingExtendedReportingEnabled",
-     prefs::kSafeBrowsingScoutReportingEnabled, APIPermission::kPrivacy,
-     APIPermission::kPrivacy},
     {"searchSuggestEnabled", prefs::kSearchSuggestEnabled,
      APIPermission::kPrivacy, APIPermission::kPrivacy},
     {"spellingServiceEnabled", spellcheck::prefs::kSpellCheckUseSpellingService,
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/preference/preference_apitest.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/preference/preference_apitest.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/preference/preference_apitest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/preference/preference_apitest.cc	2025-06-03 09:48:20.000000000 +0800
@@ -73,7 +73,6 @@
               prefs->GetInteger(prefs::kNetworkPredictionOptions));
     EXPECT_TRUE(
         prefs->GetBoolean(password_manager::prefs::kCredentialsEnableService));
-    EXPECT_TRUE(prefs->GetBoolean(prefs::kSafeBrowsingEnabled));
     EXPECT_TRUE(prefs->GetBoolean(prefs::kSearchSuggestEnabled));
   }
 
@@ -99,7 +98,6 @@
               prefs->GetInteger(prefs::kNetworkPredictionOptions));
     EXPECT_FALSE(
         prefs->GetBoolean(password_manager::prefs::kCredentialsEnableService));
-    EXPECT_FALSE(prefs->GetBoolean(prefs::kSafeBrowsingEnabled));
     EXPECT_FALSE(prefs->GetBoolean(prefs::kSearchSuggestEnabled));
   }
 
@@ -163,7 +161,6 @@
   prefs->SetInteger(prefs::kNetworkPredictionOptions,
                     chrome_browser_net::NETWORK_PREDICTION_NEVER);
   prefs->SetBoolean(password_manager::prefs::kCredentialsEnableService, false);
-  prefs->SetBoolean(prefs::kSafeBrowsingEnabled, false);
   prefs->SetBoolean(prefs::kSearchSuggestEnabled, false);
 #if BUILDFLAG(ENABLE_WEBRTC)
   prefs->SetBoolean(prefs::kWebRTCMultipleRoutesEnabled, false);
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_api.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_api.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_api.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_api.cc	2025-06-03 10:12:22.000000000 +0800
@@ -52,37 +52,7 @@
         base::StringPrintf("Could not find tab with id %d.", params->tab_id)));
   }
 
-  Profile* profile = Profile::FromBrowserContext(browser_context());
-  if (!SafeBrowsingNavigationObserverManager::IsEnabledAndReady(profile))
-    return RespondNow(NoArguments());
-
-  scoped_refptr<SafeBrowsingNavigationObserverManager>
-      navigation_observer_manager = g_browser_process->safe_browsing_service()
-                                        ->navigation_observer_manager();
-
-  safe_browsing::ReferrerChain referrer_chain;
-  SafeBrowsingNavigationObserverManager::AttributionResult result =
-      navigation_observer_manager->IdentifyReferrerChainByWebContents(
-          contents, kReferrerUserGestureLimit, &referrer_chain);
-
-  // If the referrer chain is incomplete we'll append the most recent
-  // navigations to referrer chain for diagnostic purposes. This only happens if
-  // the user is not in incognito mode and has opted into extended reporting or
-  // Scout reporting. Otherwise, |CountOfRecentNavigationsToAppend| returns 0.
-  int recent_navigations_to_collect =
-      SafeBrowsingNavigationObserverManager::CountOfRecentNavigationsToAppend(
-          *profile, result);
-  if (recent_navigations_to_collect > 0) {
-    navigation_observer_manager->AppendRecentNavigations(
-        recent_navigations_to_collect, &referrer_chain);
-  }
-
   std::vector<api::safe_browsing_private::ReferrerChainEntry> referrer_entries;
-  referrer_entries.reserve(referrer_chain.size());
-  for (const auto& entry : referrer_chain) {
-    referrer_entries.emplace_back(
-        safe_browsing_util::ReferrerToReferrerChainEntry(entry));
-  }
   return RespondNow(ArgumentList(
       api::safe_browsing_private::GetReferrerChain::Results::Create(
           referrer_entries)));
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc	2025-06-03 10:12:22.000000000 +0800
@@ -1035,51 +1035,9 @@
 
 ExtensionFunction::ResponseAction
 WebstorePrivateGetReferrerChainFunction::Run() {
-  Profile* profile = chrome_details_.GetProfile();
-  if (!SafeBrowsingNavigationObserverManager::IsEnabledAndReady(profile))
-    return RespondNow(ArgumentList(
-        api::webstore_private::GetReferrerChain::Results::Create("")));
-
-  content::WebContents* web_contents = GetSenderWebContents();
-  if (!web_contents) {
-    return RespondNow(ErrorWithArguments(
-        api::webstore_private::GetReferrerChain::Results::Create(""),
-        kWebstoreUserCancelledError));
-  }
-
-  scoped_refptr<SafeBrowsingNavigationObserverManager>
-      navigation_observer_manager = g_browser_process->safe_browsing_service()
-                                        ->navigation_observer_manager();
-
-  safe_browsing::ReferrerChain referrer_chain;
-  SafeBrowsingNavigationObserverManager::AttributionResult result =
-      navigation_observer_manager->IdentifyReferrerChainByWebContents(
-          web_contents, kExtensionReferrerUserGestureLimit, &referrer_chain);
-
-  // If the referrer chain is incomplete we'll append the most recent
-  // navigations to referrer chain for diagnostic purposes. This only happens if
-  // the user is not in incognito mode and has opted into extended reporting or
-  // Scout reporting. Otherwise, |CountOfRecentNavigationsToAppend| returns 0.
-  int recent_navigations_to_collect =
-      SafeBrowsingNavigationObserverManager::CountOfRecentNavigationsToAppend(
-          *profile, result);
-  if (recent_navigations_to_collect > 0) {
-    navigation_observer_manager->AppendRecentNavigations(
-        recent_navigations_to_collect, &referrer_chain);
-  }
-
-  safe_browsing::ExtensionWebStoreInstallRequest request;
-  request.mutable_referrer_chain()->Swap(&referrer_chain);
-  request.mutable_referrer_chain_options()->set_recent_navigations_to_collect(
-      recent_navigations_to_collect);
-
-  std::string serialized_referrer_proto = request.SerializeAsString();
-  // Base64 encode the proto to avoid issues with base::Value rejecting strings
-  // which are not valid UTF8.
-  base::Base64Encode(serialized_referrer_proto, &serialized_referrer_proto);
   return RespondNow(
       ArgumentList(api::webstore_private::GetReferrerChain::Results::Create(
-          serialized_referrer_proto)));
+          "")));
 }
 
 WebstorePrivateGetExtensionStatusFunction::
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/webstore_private/webstore_private_apitest.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/webstore_private/webstore_private_apitest.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/webstore_private/webstore_private_apitest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/extensions/api/webstore_private/webstore_private_apitest.cc	2025-06-03 09:34:01.000000000 +0800
@@ -728,9 +728,6 @@
 IN_PROC_BROWSER_TEST_F(ExtensionWebstorePrivateGetReferrerChainApiTest,
                        GetReferrerChainForNonSafeBrowsingUser) {
   PrefService* pref_service = browser()->profile()->GetPrefs();
-  EXPECT_TRUE(pref_service->GetBoolean(prefs::kSafeBrowsingEnabled));
-  // Disable SafeBrowsing.
-  pref_service->SetBoolean(prefs::kSafeBrowsingEnabled, false);
 
   GURL page_url = GetTestServerURLWithReferrers("empty_referrer_chain.html");
   ASSERT_TRUE(RunPageTest(page_url.spec()));
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/media/webrtc/webrtc_event_log_uploader.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/media/webrtc/webrtc_event_log_uploader.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/media/webrtc/webrtc_event_log_uploader.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/media/webrtc/webrtc_event_log_uploader.cc	2025-06-03 10:26:44.000000000 +0800
@@ -127,7 +127,7 @@
 }  // namespace
 
 const char WebRtcEventLogUploaderImpl::kUploadURL[] =
-    "https://clients2.google.com/cr/report";
+    "trk:300:https://clients2.google.com/cr/report";
 
 WebRtcEventLogUploaderImpl::Factory::Factory(
     scoped_refptr<base::SequencedTaskRunner> task_runner)
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/media/webrtc/webrtc_log_uploader.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/media/webrtc/webrtc_log_uploader.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/media/webrtc/webrtc_log_uploader.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/media/webrtc/webrtc_log_uploader.cc	2025-06-03 10:48:49.000000000 +0800
@@ -127,28 +127,11 @@
   DCHECK(meta_data.get());
   DCHECK(!upload_done_data.paths.directory.empty());
 
-  std::string compressed_log = CompressLog(log_buffer.get());
-
-  std::string local_log_id;
-
   if (base::PathExists(upload_done_data.paths.directory)) {
     webrtc_logging::DeleteOldWebRtcLogFiles(upload_done_data.paths.directory);
-
-    local_log_id = base::NumberToString(base::Time::Now().ToDoubleT());
-    base::FilePath log_file_path =
-        upload_done_data.paths.directory.AppendASCII(local_log_id)
-            .AddExtension(FILE_PATH_LITERAL(".gz"));
-    WriteCompressedLogToFile(compressed_log, log_file_path);
-
-    base::FilePath log_list_path =
-        webrtc_logging::TextLogList::GetWebRtcLogListFileForDirectory(
-            upload_done_data.paths.directory);
-    AddLocallyStoredLogInfoToUploadListFile(log_list_path, local_log_id);
   }
 
-  upload_done_data.local_log_id = local_log_id;
-  PrepareMultipartPostData(compressed_log, std::move(meta_data),
-                           std::move(upload_done_data));
+  NotifyUploadDoneAndLogStats(net::HTTP_OK, net::OK, "", std::move(upload_done_data));
 }
 
 void WebRtcLogUploader::PrepareMultipartPostData(
@@ -159,28 +142,7 @@
   DCHECK(!compressed_log.empty());
   DCHECK(meta_data.get());
 
-  std::unique_ptr<std::string> post_data(new std::string());
-  SetupMultipart(post_data.get(), compressed_log,
-                 upload_done_data.paths.incoming_rtp_dump,
-                 upload_done_data.paths.outgoing_rtp_dump, *meta_data.get());
-
-  // If a test has set the test string pointer, write to it and skip uploading.
-  // Still fire the upload callback so that we can run an extension API test
-  // using the test framework for that without hanging.
-  // TODO(grunell): Remove this when the api test for this feature is fully
-  // implemented according to the test plan. http://crbug.com/257329.
-  if (post_data_) {
-    *post_data_ = *post_data;
-    NotifyUploadDoneAndLogStats(net::HTTP_OK, net::OK, "",
-                                std::move(upload_done_data));
-    return;
-  }
-
-  main_task_runner_->PostTask(
-      FROM_HERE,
-      base::BindOnce(&WebRtcLogUploader::UploadCompressedLog,
-                     base::Unretained(this), std::move(upload_done_data),
-                     std::move(post_data)));
+  NotifyUploadDoneAndLogStats(net::HTTP_OK, net::OK, "", std::move(upload_done_data));
 }
 
 void WebRtcLogUploader::UploadStoredLog(
@@ -246,49 +208,6 @@
   DCHECK(log_buffer.get());
   DCHECK(!log_paths.directory.empty());
 
-  webrtc_logging::DeleteOldWebRtcLogFiles(log_paths.directory);
-
-  base::FilePath log_list_path =
-      webrtc_logging::TextLogList::GetWebRtcLogListFileForDirectory(
-          log_paths.directory);
-
-  // Store the native log with a ".gz" extension.
-  std::string compressed_log = CompressLog(log_buffer.get());
-  base::FilePath native_log_path =
-      log_paths.directory.AppendASCII(log_id).AddExtension(
-          FILE_PATH_LITERAL(".gz"));
-  WriteCompressedLogToFile(compressed_log, native_log_path);
-  AddLocallyStoredLogInfoToUploadListFile(log_list_path, log_id);
-
-  // Move the rtp dump files to the log directory with a name of
-  // <log id>.rtp_[in|out].
-  if (!log_paths.incoming_rtp_dump.empty()) {
-    base::FilePath rtp_path =
-        log_paths.directory.AppendASCII(log_id).AddExtension(
-            FILE_PATH_LITERAL(".rtp_in"));
-    base::Move(log_paths.incoming_rtp_dump, rtp_path);
-  }
-
-  if (!log_paths.outgoing_rtp_dump.empty()) {
-    base::FilePath rtp_path =
-        log_paths.directory.AppendASCII(log_id).AddExtension(
-            FILE_PATH_LITERAL(".rtp_out"));
-    base::Move(log_paths.outgoing_rtp_dump, rtp_path);
-  }
-
-  if (meta_data.get() && !meta_data->empty()) {
-    base::Pickle pickle;
-    for (const auto& it : *meta_data.get()) {
-      pickle.WriteString(it.first);
-      pickle.WriteString(it.second);
-    }
-    base::FilePath meta_path =
-        log_paths.directory.AppendASCII(log_id).AddExtension(
-            FILE_PATH_LITERAL(".meta"));
-    base::WriteFile(meta_path, static_cast<const char*>(pickle.data()),
-                    pickle.size());
-  }
-
   main_task_runner_->PostTask(
       FROM_HERE, base::BindOnce(std::move(done_callback), true, ""));
 
@@ -482,7 +401,7 @@
             "Not implemented, it would be good to do so."
         })");
 
-  constexpr char kUploadURL[] = "https://clients2.google.com/cr/report";
+  constexpr char kUploadURL[] = "trk:301:https://clients2.google.com/cr/report";
   auto resource_request = std::make_unique<network::ResourceRequest>();
   resource_request->url = !upload_url_for_testing_.is_empty()
                               ? upload_url_for_testing_
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/net/trial_comparison_cert_verifier_controller.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/net/trial_comparison_cert_verifier_controller.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/net/trial_comparison_cert_verifier_controller.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/net/trial_comparison_cert_verifier_controller.cc	2025-06-03 10:12:26.000000000 +0800
@@ -43,12 +43,6 @@
     // enabled.
     return;
   }
-
-  pref_change_registrar_.Init(profile_->GetPrefs());
-  pref_change_registrar_.Add(
-      prefs::kSafeBrowsingScoutReportingEnabled,
-      base::BindRepeating(&TrialComparisonCertVerifierController::RefreshState,
-                          base::Unretained(this)));
 }
 
 TrialComparisonCertVerifierController::
@@ -94,9 +88,7 @@
   if (!MaybeAllowedForProfile(profile_))
     return false;
 
-  const PrefService& prefs = *profile_->GetPrefs();
-
-  return safe_browsing::IsExtendedReportingEnabled(prefs);
+  return false;
 }
 
 void TrialComparisonCertVerifierController::SendTrialReport(
@@ -131,9 +123,6 @@
   std::string serialized_report;
   if (!report.Serialize(&serialized_report))
     return;
-
-  CertificateReportingServiceFactory::GetForBrowserContext(profile_)->Send(
-      serialized_report);
 }
 
 // static
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/net/trial_comparison_cert_verifier_controller.h b/qtwebengine/src/3rdparty/chromium/chrome/browser/net/trial_comparison_cert_verifier_controller.h
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/net/trial_comparison_cert_verifier_controller.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/net/trial_comparison_cert_verifier_controller.h	2025-06-03 09:34:01.000000000 +0800
@@ -14,7 +14,6 @@
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "base/threading/thread_checker.h"
-#include "components/prefs/pref_change_registrar.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "mojo/public/cpp/bindings/receiver_set.h"
@@ -70,7 +69,6 @@
   void RefreshState();
 
   Profile* profile_;
-  PrefChangeRegistrar pref_change_registrar_;
 
   mojo::ReceiverSet<network::mojom::TrialComparisonCertVerifierReportClient>
       receiver_set_;
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/prefs/browser_prefs.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/prefs/browser_prefs.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/prefs/browser_prefs.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/prefs/browser_prefs.cc	2025-06-05 15:44:56.000000000 +0800
@@ -132,7 +132,9 @@
 #include "components/prefs/pref_service.h"
 #include "components/proxy_config/pref_proxy_config_tracker_impl.h"
 #include "components/rappor/rappor_service_impl.h"
+#if !defined(__powerpc64__)
 #include "components/safe_browsing/core/common/safe_browsing_prefs.h"
+#endif
 #include "components/search_engines/template_url_prepopulate_data.h"
 #include "components/security_interstitials/content/insecure_form_blocking_page.h"
 #include "components/security_interstitials/content/stateful_ssl_host_state_delegate.h"
@@ -577,7 +579,9 @@
   profiles::RegisterPrefs(registry);
   rappor::RapporServiceImpl::RegisterPrefs(registry);
   RegisterScreenshotPrefs(registry);
+#if !defined(__powerpc64__)
   safe_browsing::RegisterLocalStatePrefs(registry);
+#endif
   secure_origin_allowlist::RegisterPrefs(registry);
   sessions::SessionIdGenerator::RegisterPrefs(registry);
   SSLConfigServiceManager::RegisterPrefs(registry);
@@ -792,7 +796,9 @@
   PushMessagingAppIdentifier::RegisterProfilePrefs(registry);
   QuietNotificationPermissionUiState::RegisterProfilePrefs(registry);
   RegisterBrowserUserPrefs(registry);
+#if !defined(__powerpc64__)
   safe_browsing::RegisterProfilePrefs(registry);
+#endif
   blocked_content::SafeBrowsingTriggeredPopupBlocker::RegisterProfilePrefs(
       registry);
   security_interstitials::InsecureFormBlockingPage::RegisterProfilePrefs(
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/prefs/chrome_pref_service_factory.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/prefs/chrome_pref_service_factory.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/prefs/chrome_pref_service_factory.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/prefs/chrome_pref_service_factory.cc	2025-06-03 09:44:15.000000000 +0800
@@ -120,8 +120,6 @@
     {5, extensions::pref_names::kExtensions, EnforcementLevel::NO_ENFORCEMENT,
      PrefTrackingStrategy::SPLIT, ValueType::IMPERSONAL},
 #endif
-    {6, prefs::kGoogleServicesLastUsername, EnforcementLevel::ENFORCE_ON_LOAD,
-     PrefTrackingStrategy::ATOMIC, ValueType::PERSONAL},
     {7, prefs::kSearchProviderOverrides, EnforcementLevel::ENFORCE_ON_LOAD,
      PrefTrackingStrategy::ATOMIC, ValueType::IMPERSONAL},
 #if !defined(OS_ANDROID)
@@ -145,8 +143,6 @@
      PrefTrackingStrategy::ATOMIC, ValueType::IMPERSONAL},
     // kSyncRemainingRollbackTries is deprecated and will be removed a few
     // releases after M50.
-    {18, prefs::kSafeBrowsingIncidentsSent, EnforcementLevel::ENFORCE_ON_LOAD,
-     PrefTrackingStrategy::ATOMIC, ValueType::IMPERSONAL},
 #if defined(OS_WIN)
     {19, prefs::kSwReporterPromptVersion, EnforcementLevel::ENFORCE_ON_LOAD,
      PrefTrackingStrategy::ATOMIC, ValueType::IMPERSONAL},
@@ -155,10 +151,6 @@
     {22, prefs::kSwReporterPromptSeed, EnforcementLevel::ENFORCE_ON_LOAD,
      PrefTrackingStrategy::ATOMIC, ValueType::IMPERSONAL},
 #endif
-    {23, prefs::kGoogleServicesAccountId, EnforcementLevel::ENFORCE_ON_LOAD,
-     PrefTrackingStrategy::ATOMIC, ValueType::PERSONAL},
-    {24, prefs::kGoogleServicesLastAccountId, EnforcementLevel::ENFORCE_ON_LOAD,
-     PrefTrackingStrategy::ATOMIC, ValueType::PERSONAL},
 #if defined(OS_WIN)
     {25, prefs::kSettingsResetPromptPromptWave,
      EnforcementLevel::ENFORCE_ON_LOAD, PrefTrackingStrategy::ATOMIC,
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/safe_browsing/BUILD.gn b/qtwebengine/src/3rdparty/chromium/chrome/browser/safe_browsing/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/safe_browsing/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/safe_browsing/BUILD.gn	2025-06-03 10:13:00.000000000 +0800
@@ -13,6 +13,7 @@
 set_sources_assignment_filter(deprecated_default_sources_assignment_filter)
 
 static_library("safe_browsing") {
+  if (false) {
   sources = [
     "chrome_controller_client.cc",
     "chrome_controller_client.h",
@@ -71,6 +72,7 @@
     ]
     deps += [ "//extensions/browser" ]
   }
+  }
 
   if (safe_browsing_mode != 0) {
     # "Safe Browsing Basic" files used for safe browsing in full mode
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/spellchecker/spellcheck_hunspell_dictionary.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/spellchecker/spellcheck_hunspell_dictionary.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/spellchecker/spellcheck_hunspell_dictionary.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/spellchecker/spellcheck_hunspell_dictionary.cc	2025-06-03 10:26:47.000000000 +0800
@@ -280,7 +280,7 @@
   DCHECK(!bdict_file.empty());
 
   static const char kDownloadServerUrl[] =
-      "https://redirector.gvt1.com/edgedl/chrome/dict/";
+      "trk:173:https://redirector.gvt1.com/edgedl/chrome/dict/";
 
   return GURL(std::string(kDownloadServerUrl) +
               base::ToLowerASCII(bdict_file));
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/BUILD.gn b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/BUILD.gn	2025-06-03 10:48:11.000000000 +0800
@@ -3457,7 +3457,6 @@
       "views/device_chooser_content_view.h",
       "views/devtools_process_observer.cc",
       "views/devtools_process_observer.h",
-      "views/download/download_danger_prompt_views.cc",
       "views/download/download_in_progress_dialog_view.cc",
       "views/download/download_in_progress_dialog_view.h",
       "views/download/download_item_view.cc",
@@ -4199,8 +4198,6 @@
         "views/sync/dice_bubble_sync_promo_view.h",
         "views/sync/dice_signin_button_view.cc",
         "views/sync/dice_signin_button_view.h",
-        "views/sync/one_click_signin_dialog_view.cc",
-        "views/sync/one_click_signin_dialog_view.h",
       ]
       deps += [ "//ui/views/window/vector_icons" ]
     }
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/app_launcher_login_handler.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/app_launcher_login_handler.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/app_launcher_login_handler.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/app_launcher_login_handler.cc	2025-06-03 09:52:45.000000000 +0800
@@ -30,7 +30,6 @@
 #include "chrome/grit/generated_resources.h"
 #include "components/prefs/pref_service.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/browser/web_ui.h"
@@ -166,10 +165,7 @@
   } else {
 #if !defined(OS_CHROMEOS)
     // Chromeos does not show this status header.
-    bool is_signin_allowed =
-        profile->GetOriginalProfile()->GetPrefs()->GetBoolean(
-            prefs::kSigninAllowed);
-    if (!profile->IsLegacySupervised() && is_signin_allowed) {
+    if (!profile->IsLegacySupervised() && false) {
       base::string16 signed_in_link = l10n_util::GetStringUTF16(
           IDS_SYNC_PROMO_NOT_SIGNED_IN_STATUS_LINK);
       signed_in_link =
@@ -207,8 +203,6 @@
   // UI and the avatar menu don't exist on that platform.
   return false;
 #else
-  bool is_signin_allowed =
-      profile->GetPrefs()->GetBoolean(prefs::kSigninAllowed);
-  return !profile->IsOffTheRecord() && is_signin_allowed;
+  return false;
 #endif
 }
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc	2025-06-05 15:51:25.000000000 +0800
@@ -23,7 +23,6 @@
 #include "base/threading/thread.h"
 #include "base/values.h"
 #include "chrome/browser/browser_process.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/download/download_history.h"
 #include "chrome/browser/download/download_item_model.h"
 #include "chrome/browser/download/download_prefs.h"
@@ -168,9 +167,6 @@
   }
 
   CountDownloadsDOMEvents(DOWNLOADS_DOM_EVENT_SAVE_DANGEROUS);
-  download::DownloadItem* file = GetDownloadByStringId(id);
-  if (file)
-    ShowDangerPrompt(file);
 }
 
 void DownloadsDOMHandler::DiscardDangerous(const std::string& id) {
@@ -316,12 +312,6 @@
   IdSet ids;
 
   for (auto* download : to_remove) {
-    if (download->IsDangerous() || download->IsMixedContent()) {
-      // Don't allow users to revive dangerous downloads; just nuke 'em.
-      download->Remove();
-      continue;
-    }
-
     DownloadItemModel item_model(download);
     if (!item_model.ShouldShowInShelf() ||
         download->GetState() == download::DownloadItem::IN_PROGRESS) {
@@ -395,6 +385,7 @@
   }
 }
 
+#if !defined(__powerpc64__)
 void DownloadsDOMHandler::ShowDangerPrompt(
     download::DownloadItem* dangerous_item) {
   DownloadDangerPrompt* danger_prompt = DownloadDangerPrompt::Create(
@@ -404,7 +395,9 @@
   // danger_prompt will delete itself.
   DCHECK(danger_prompt);
 }
+#endif
 
+#if !defined(__powerpc64__)
 void DownloadsDOMHandler::DangerPromptDone(
     int download_id,
     DownloadDangerPrompt::Action action) {
@@ -432,6 +425,7 @@
 
   item->ValidateDangerousDownload();
 }
+#endif
 
 bool DownloadsDOMHandler::IsDeletingHistoryAllowed() {
   content::DownloadManager* manager = GetMainNotifierManager();
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.h b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.h
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.h	2025-06-03 10:13:04.000000000 +0800
@@ -12,7 +12,6 @@
 
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/ui/webui/downloads/downloads.mojom-forward.h"
 #include "chrome/browser/ui/webui/downloads/downloads_list_tracker.h"
 #include "content/public/browser/web_contents_observer.h"
@@ -89,18 +88,6 @@
   // null-checking |original_notifier_|.
   content::DownloadManager* GetOriginalNotifierManager() const;
 
-  // Displays a native prompt asking the user for confirmation after accepting
-  // the dangerous download specified by |dangerous|. The function returns
-  // immediately, and will invoke DangerPromptAccepted() asynchronously if the
-  // user accepts the dangerous download. The native prompt will observe
-  // |dangerous| until either the dialog is dismissed or |dangerous| is no
-  // longer an in-progress dangerous download.
-  virtual void ShowDangerPrompt(download::DownloadItem* dangerous);
-
-  // Conveys danger acceptance from the DownloadDangerPrompt to the
-  // DownloadItem.
-  void DangerPromptDone(int download_id, DownloadDangerPrompt::Action action);
-
   // Returns true if the records of any downloaded items are allowed (and able)
   // to be deleted.
   bool IsDeletingHistoryAllowed();
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/interstitials/interstitial_ui.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/interstitials/interstitial_ui.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/interstitials/interstitial_ui.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/interstitials/interstitial_ui.cc	2025-06-03 10:13:04.000000000 +0800
@@ -287,113 +287,6 @@
                                                      request_url));
 }
 
-std::unique_ptr<safe_browsing::SafeBrowsingBlockingPage>
-CreateSafeBrowsingBlockingPage(content::WebContents* web_contents) {
-  safe_browsing::SBThreatType threat_type =
-      safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-  GURL request_url("http://example.com");
-  std::string url_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(), "url", &url_param)) {
-    if (GURL(url_param).is_valid()) {
-      request_url = GURL(url_param);
-    }
-  }
-  GURL main_frame_url(request_url);
-  // TODO(mattm): add flag to change main_frame_url or add dedicated flag to
-  // test subresource interstitials.
-  std::string type_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(), "type", &type_param)) {
-    if (type_param == "malware") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-    } else if (type_param == "phishing") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_PHISHING;
-    } else if (type_param == "unwanted") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_UNWANTED;
-    } else if (type_param == "clientside_malware") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_CLIENT_SIDE_MALWARE;
-    } else if (type_param == "clientside_phishing") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_CLIENT_SIDE_PHISHING;
-    } else if (type_param == "billing") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_BILLING;
-    }
-  }
-  safe_browsing::SafeBrowsingBlockingPage::UnsafeResource resource;
-  resource.url = request_url;
-  resource.is_subresource = request_url != main_frame_url;
-  resource.is_subframe = false;
-  resource.threat_type = threat_type;
-  resource.web_contents_getter = security_interstitials::GetWebContentsGetter(
-      web_contents->GetMainFrame()->GetProcess()->GetID(),
-      web_contents->GetMainFrame()->GetRoutingID());
-  resource.threat_source = g_browser_process->safe_browsing_service()
-                               ->database_manager()
-                               ->GetThreatSource();
-
-  // Normally safebrowsing interstitial types which block the main page load
-  // (SB_THREAT_TYPE_URL_MALWARE, SB_THREAT_TYPE_URL_PHISHING, and
-  // SB_THREAT_TYPE_URL_UNWANTED on main-frame loads) would expect there to be a
-  // pending navigation when the SafeBrowsingBlockingPage is created. This demo
-  // creates a SafeBrowsingBlockingPage but does not actually show a real
-  // interstitial. Instead it extracts the html and displays it manually, so the
-  // parts which depend on the NavigationEntry are not hit.
-  return base::WrapUnique<safe_browsing::SafeBrowsingBlockingPage>(
-      safe_browsing::SafeBrowsingBlockingPage::CreateBlockingPage(
-          g_browser_process->safe_browsing_service()->ui_manager().get(),
-          web_contents, main_frame_url, resource, true));
-}
-
-std::unique_ptr<TestSafeBrowsingBlockingPageQuiet>
-CreateSafeBrowsingQuietBlockingPage(content::WebContents* web_contents) {
-  safe_browsing::SBThreatType threat_type =
-      safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-  GURL request_url("http://example.com");
-  std::string url_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(), "url", &url_param)) {
-    if (GURL(url_param).is_valid())
-      request_url = GURL(url_param);
-  }
-  GURL main_frame_url(request_url);
-  std::string type_param;
-  bool is_giant_webview = false;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(), "type", &type_param)) {
-    if (type_param == "malware") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-    } else if (type_param == "phishing") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_PHISHING;
-    } else if (type_param == "unwanted") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_UNWANTED;
-    } else if (type_param == "billing") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_BILLING;
-    } else if (type_param == "giant") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-      is_giant_webview = true;
-    }
-  }
-  safe_browsing::SafeBrowsingBlockingPage::UnsafeResource resource;
-  resource.url = request_url;
-  resource.is_subresource = request_url != main_frame_url;
-  resource.is_subframe = false;
-  resource.threat_type = threat_type;
-  resource.web_contents_getter = security_interstitials::GetWebContentsGetter(
-      web_contents->GetMainFrame()->GetProcess()->GetID(),
-      web_contents->GetMainFrame()->GetRoutingID());
-  resource.threat_source = g_browser_process->safe_browsing_service()
-                               ->database_manager()
-                               ->GetThreatSource();
-
-  // Normally safebrowsing interstitial types which block the main page load
-  // (SB_THREAT_TYPE_URL_MALWARE, SB_THREAT_TYPE_URL_PHISHING, and
-  // SB_THREAT_TYPE_URL_UNWANTED on main-frame loads) would expect there to be a
-  // pending navigation when the SafeBrowsingBlockingPage is created. This demo
-  // creates a SafeBrowsingBlockingPage but does not actually show a real
-  // interstitial. Instead it extracts the html and displays it manually, so the
-  // parts which depend on the NavigationEntry are not hit.
-  return base::WrapUnique<TestSafeBrowsingBlockingPageQuiet>(
-      TestSafeBrowsingBlockingPageQuiet::CreateBlockingPage(
-          g_browser_process->safe_browsing_service()->ui_manager().get(),
-          web_contents, main_frame_url, resource, is_giant_webview));
-}
-
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
 std::unique_ptr<CaptivePortalBlockingPage> CreateCaptivePortalBlockingPage(
     content::WebContents* web_contents) {
@@ -510,8 +403,6 @@
     interstitial_delegate = CreateBlockedInterceptionBlockingPage(web_contents);
   } else if (path_without_query == "/legacy-tls") {
     interstitial_delegate = CreateLegacyTLSBlockingPage(web_contents);
-  } else if (path_without_query == "/safebrowsing") {
-    interstitial_delegate = CreateSafeBrowsingBlockingPage(web_contents);
   } else if (path_without_query == "/clock") {
     interstitial_delegate = CreateBadClockBlockingPage(web_contents);
   } else if (path_without_query == "/lookalike") {
@@ -526,16 +417,12 @@
     interstitial_delegate = CreateInsecureFormPage(web_contents);
   }
 
-  if (path_without_query == "/quietsafebrowsing") {
-    std::unique_ptr<TestSafeBrowsingBlockingPageQuiet> blocking_page =
-        CreateSafeBrowsingQuietBlockingPage(web_contents);
-    html = blocking_page->GetHTML();
-    interstitial_delegate = std::move(blocking_page);
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
-  } else if (path_without_query == "/supervised_user") {
+  if (path_without_query == "/supervised_user") {
     html = GetSupervisedUserInterstitialHTML(path);
+  } else
 #endif
-  } else if (interstitial_delegate.get()) {
+  if (interstitial_delegate.get()) {
     html = interstitial_delegate.get()->GetHTMLContents();
   } else {
     html = ui::ResourceBundle::GetSharedInstance().LoadDataResourceString(
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/profile_info_watcher.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/profile_info_watcher.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/profile_info_watcher.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/profile_info_watcher.cc	2025-06-03 09:52:45.000000000 +0800
@@ -12,7 +12,6 @@
 #include "chrome/browser/signin/identity_manager_factory.h"
 #include "chrome/common/pref_names.h"
 #include "components/prefs/pref_service.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
 
 ProfileInfoWatcher::ProfileInfoWatcher(
@@ -25,9 +24,6 @@
   // The profile_manager might be NULL in testing environments.
   if (profile_manager)
     profile_manager->GetProfileAttributesStorage().AddObserver(this);
-
-  signin_allowed_pref_.Init(prefs::kSigninAllowed, profile_->GetPrefs(),
-      base::Bind(&ProfileInfoWatcher::RunCallback, base::Unretained(this)));
 }
 
 ProfileInfoWatcher::~ProfileInfoWatcher() {
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/profile_info_watcher.h b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/profile_info_watcher.h
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/profile_info_watcher.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/profile_info_watcher.h	2025-06-03 09:52:45.000000000 +0800
@@ -45,8 +45,6 @@
   // Called when the authenticated username changes.
   base::Closure callback_;
 
-  BooleanPrefMember signin_allowed_pref_;
-
   DISALLOW_COPY_AND_ASSIGN(ProfileInfoWatcher);
 };
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/settings/people_handler.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/settings/people_handler.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/settings/people_handler.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/settings/people_handler.cc	2025-06-03 09:54:03.000000000 +0800
@@ -41,7 +41,6 @@
 #include "components/prefs/pref_service.h"
 #include "components/signin/core/browser/signin_error_controller.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/accounts_mutator.h"
 #include "components/signin/public/identity_manager/consent_level.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
@@ -339,9 +338,6 @@
 void PeopleHandler::OnJavascriptAllowed() {
   PrefService* prefs = profile_->GetPrefs();
   profile_pref_registrar_.Init(prefs);
-  profile_pref_registrar_.Add(
-      prefs::kSigninAllowed,
-      base::Bind(&PeopleHandler::UpdateSyncStatus, base::Unretained(this)));
 
   signin::IdentityManager* identity_manager(
       IdentityManagerFactory::GetInstance()->GetForProfile(profile_));
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc	2025-06-05 15:55:51.000000000 +0800
@@ -63,7 +63,9 @@
 #include "components/password_manager/core/browser/manage_passwords_referrer.h"
 #include "components/password_manager/core/common/password_manager_features.h"
 #include "components/prefs/pref_service.h"
+#if !defined(__powerpc64__)
 #include "components/safe_browsing/core/common/safe_browsing_prefs.h"
+#endif
 #include "components/signin/public/base/signin_buildflags.h"
 #include "components/strings/grit/components_chromium_strings.h"
 #include "components/strings/grit/components_strings.h"
@@ -1338,6 +1340,7 @@
       {"clearBrowsingData", IDS_SETTINGS_CLEAR_BROWSING_DATA},
       {"clearBrowsingDataDescription", IDS_SETTINGS_CLEAR_DATA_DESCRIPTION},
       {"titleAndCount", IDS_SETTINGS_TITLE_AND_COUNT},
+#if !defined(__powerpc64__)
       {"safeBrowsingEnableExtendedReporting",
        IDS_SETTINGS_SAFEBROWSING_ENABLE_REPORTING},
       {"safeBrowsingEnableExtendedReportingDesc",
@@ -1375,6 +1378,7 @@
       {"safeBrowsingEnableProtectionDesc",
        IDS_SETTINGS_SAFEBROWSING_ENABLEPROTECTION_DESC},
       {"safeBrowsingSectionLabel", IDS_SETTINGS_SAFEBROWSING_SECTION_LABEL},
+#endif
       {"syncAndGoogleServicesPrivacyDescription",
        IDS_SETTINGS_SYNC_AND_GOOGLE_SERVICES_PRIVACY_DESC_UNIFIED_CONSENT},
       {"urlKeyedAnonymizedDataCollection",
@@ -2161,11 +2165,6 @@
   AddLocalizedStringsBulk(html_source, kSensorsLocalizedStrings);
 
   html_source->AddBoolean(
-      "enableSafeBrowsingSubresourceFilter",
-      base::FeatureList::IsEnabled(
-          subresource_filter::kSafeBrowsingSubresourceFilter));
-
-  html_source->AddBoolean(
       "enableBlockAutoplayContentSetting",
       base::FeatureList::IsEnabled(media::kAutoplayDisableSettings));
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/dice_turn_sync_on_helper.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/dice_turn_sync_on_helper.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/dice_turn_sync_on_helper.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/dice_turn_sync_on_helper.cc	2025-06-03 09:54:03.000000000 +0800
@@ -37,7 +37,6 @@
 #include "components/policy/core/common/cloud/user_cloud_policy_manager.h"
 #include "components/prefs/pref_service.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/accounts_mutator.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
 #include "components/signin/public/identity_manager/primary_account_mutator.h"
@@ -179,8 +178,7 @@
   // last authenticated account of the current profile, then Chrome will show a
   // confirmation dialog before starting sync.
   // TODO(skym): Warn for high risk upgrade scenario (https://crbug.com/572754).
-  std::string last_email =
-      profile_->GetPrefs()->GetString(prefs::kGoogleServicesLastUsername);
+  std::string last_email;
   delegate_->ShowMergeSyncDataConfirmation(
       last_email, account_info_.email,
       base::BindOnce(&DiceTurnSyncOnHelper::OnMergeAccountConfirmation,
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/dice_turn_sync_on_helper_unittest.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/dice_turn_sync_on_helper_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/dice_turn_sync_on_helper_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/dice_turn_sync_on_helper_unittest.cc	2025-06-03 09:54:03.000000000 +0800
@@ -31,7 +31,6 @@
 #include "components/account_id/account_id.h"
 #include "components/prefs/pref_service.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
 #include "components/signin/public/identity_manager/identity_test_environment.h"
 #include "components/sync/driver/mock_sync_service.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/inline_login_handler.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/inline_login_handler.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/inline_login_handler.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/inline_login_handler.cc	2025-06-03 09:54:03.000000000 +0800
@@ -27,7 +27,6 @@
 #include "chrome/common/pref_names.h"
 #include "components/metrics/metrics_pref_names.h"
 #include "components/prefs/pref_service.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "content/public/browser/storage_partition.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/browser/web_ui.h"
@@ -124,8 +123,6 @@
   std::string default_email;
   if (reason == signin_metrics::Reason::REASON_SIGNIN_PRIMARY_ACCOUNT ||
       reason == signin_metrics::Reason::REASON_FORCED_SIGNIN_PRIMARY_ACCOUNT) {
-    default_email =
-        profile->GetPrefs()->GetString(prefs::kGoogleServicesLastUsername);
   } else {
     if (!net::GetValueForKeyInQuery(current_url, "email", &default_email))
       default_email.clear();
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc	2025-06-03 10:48:13.000000000 +0800
@@ -59,7 +59,6 @@
 #include "components/prefs/pref_service.h"
 #include "components/signin/core/browser/about_signin_internals.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/accounts_cookie_mutator.h"
 #include "components/signin/public/identity_manager/accounts_mutator.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
@@ -256,11 +255,6 @@
     scoped_refptr<password_manager::PasswordStore> password_store =
         PasswordStoreFactory::GetForProfile(profile,
                                             ServiceAccessType::EXPLICIT_ACCESS);
-    password_store->SaveGaiaPasswordHash(
-        username, base::UTF8ToUTF16(password),
-        /*is_primary_account_=*/true,
-        password_manager::metrics_util::GaiaPasswordHashChange::
-            SAVED_ON_CHROME_SIGNIN);
 
     if (profiles::IsLockAvailable(profile))
       LocalAuth::SetLocalAuthCredentials(profile, password);
@@ -330,6 +324,7 @@
     const ClientOAuthResult& result,
     Profile* /*profile*/,
     Profile::CreateStatus /*status*/) {
+#if BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
   HandlerSigninReason reason = GetHandlerSigninReason(current_url_);
   if (reason == HandlerSigninReason::FETCH_LST_ONLY) {
     // Constants are only available on Windows for the Google Credential
@@ -419,6 +414,7 @@
     CreateSyncStarter(result.refresh_token);
   }
   base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, this);
+#endif
 }
 
 void InlineSigninHelper::UntrustedSigninConfirmed(
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/signin_error_ui.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/signin_error_ui.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/signin_error_ui.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/signin_error_ui.cc	2025-06-03 09:54:03.000000000 +0800
@@ -22,7 +22,6 @@
 #include "chrome/grit/browser_resources.h"
 #include "chrome/grit/generated_resources.h"
 #include "components/prefs/pref_service.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/strings/grit/components_strings.h"
 #include "content/public/browser/web_ui.h"
 #include "content/public/browser/web_ui_data_source.h"
@@ -108,9 +107,7 @@
   if (is_profile_blocked) {
     source->AddLocalizedString("profileBlockedMessage",
                                IDS_OLD_PROFILES_DISABLED_MESSAGE);
-    std::string allowed_domain = signin_ui_util::GetAllowedDomain(
-        g_browser_process->local_state()->GetString(
-            prefs::kGoogleServicesUsernamePattern));
+    std::string allowed_domain;
     if (allowed_domain.empty()) {
       source->AddLocalizedString(
           "profileBlockedAddPersonSuggestion",
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/signin_utils_desktop.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/signin_utils_desktop.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/signin_utils_desktop.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/signin/signin_utils_desktop.cc	2025-06-03 09:54:03.000000000 +0800
@@ -18,7 +18,6 @@
 #include "chrome/grit/chromium_strings.h"
 #include "chrome/grit/generated_resources.h"
 #include "components/guest_view/browser/guest_view_manager.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
 #include "components/signin/public/identity_manager/identity_utils.h"
 #include "google_apis/gaia/gaia_auth_util.h"
@@ -35,7 +34,7 @@
   if (!profile)
     return false;
 
-  if (!profile->GetPrefs()->GetBoolean(prefs::kSigninAllowed))
+  if (true)
     return false;
 
   if (!ChromeSigninClient::ProfileAllowsSigninCookies(profile))
@@ -110,8 +109,7 @@
     if (signin_util::IsForceSigninEnabled() &&
         IsCrossAccountError(profile, email, gaia_id)) {
       if (error_message) {
-        std::string last_email =
-            profile->GetPrefs()->GetString(prefs::kGoogleServicesLastUsername);
+        std::string last_email;
         error_message->assign(l10n_util::GetStringFUTF8(
             IDS_SYNC_USED_PROFILE_ERROR, base::UTF8ToUTF16(last_email)));
       }
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/welcome/welcome_ui.cc b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/welcome/welcome_ui.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/welcome/welcome_ui.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/browser/ui/webui/welcome/welcome_ui.cc	2025-06-03 09:54:03.000000000 +0800
@@ -23,7 +23,6 @@
 #include "chrome/grit/welcome_resources.h"
 #include "chrome/grit/welcome_resources_map.h"
 #include "components/prefs/pref_service.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/strings/grit/components_strings.h"
 #include "net/base/url_util.h"
 #include "ui/base/webui/web_ui_util.h"
@@ -192,7 +191,7 @@
       "returningUserModules",
       welcome::GetModules(profile).FindKey("returning-user")->GetString());
   html_source->AddBoolean(
-      "signinAllowed", profile->GetPrefs()->GetBoolean(prefs::kSigninAllowed));
+      "signinAllowed", false);
   html_source->SetRequestFilter(
       base::BindRepeating(&ShouldHandleRequestCallback,
                           weak_ptr_factory_.GetWeakPtr()),
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/common/chrome_paths_linux.cc b/qtwebengine/src/3rdparty/chromium/chrome/common/chrome_paths_linux.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/common/chrome_paths_linux.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/common/chrome_paths_linux.cc	2025-06-03 10:11:59.000000000 +0800
@@ -91,7 +91,7 @@
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
   std::string data_dir_basename = "google-chrome";
 #else
-  std::string data_dir_basename = "chromium";
+  std::string data_dir_basename = "ungoogled-chromium";
 #endif
   *result = config_dir.Append(data_dir_basename + GetChannelSuffixForDataDir());
   return true;
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/common/extensions/api/privacy.json b/qtwebengine/src/3rdparty/chromium/chrome/common/extensions/api/privacy.json
--- a/qtwebengine/src/3rdparty/chromium/chrome/common/extensions/api/privacy.json	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/common/extensions/api/privacy.json	2025-06-03 09:54:05.000000000 +0800
@@ -75,16 +75,6 @@
             "value": ["passwordSavingEnabled", {"type":"boolean"}],
             "description": "If enabled, the password manager will ask if you want to save passwords. This preference's value is a boolean, defaulting to <code>true</code>."
           },
-          "safeBrowsingEnabled": {
-            "$ref": "types.ChromeSetting",
-            "value": ["safeBrowsingEnabled", {"type":"boolean"}],
-            "description": "If enabled, Chrome does its best to protect you from phishing and malware. This preference's value is a boolean, defaulting to <code>true</code>."
-          },
-          "safeBrowsingExtendedReportingEnabled": {
-            "$ref": "types.ChromeSetting",
-            "value": ["safeBrowsingExtendedReportingEnabled", {"type":"boolean"}],
-            "description": "If enabled, Chrome will send additional information to Google when SafeBrowsing blocks a page, such as the content of the blocked page. This preference's value is a boolean, defaulting to <code>false</code>."
-          },
           "searchSuggestEnabled": {
             "$ref": "types.ChromeSetting",
             "value": ["searchSuggestEnabled", {"type":"boolean"}],
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/common/extensions/chrome_extensions_client.cc b/qtwebengine/src/3rdparty/chromium/chrome/common/extensions/chrome_extensions_client.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/common/extensions/chrome_extensions_client.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/common/extensions/chrome_extensions_client.cc	2025-06-03 10:26:53.000000000 +0800
@@ -46,9 +46,9 @@
 
 // TODO(battre): Delete the HTTP URL once the blocklist is downloaded via HTTPS.
 const char kExtensionBlocklistUrlPrefix[] =
-    "http://www.gstatic.com/chrome/extensions/blocklist";
+    "trk:269:http://www.gstatic.com/chrome/extensions/blocklist";
 const char kExtensionBlocklistHttpsUrlPrefix[] =
-    "https://www.gstatic.com/chrome/extensions/blocklist";
+    "trk:270:https://www.gstatic.com/chrome/extensions/blocklist";
 
 const char kThumbsWhiteListedExtension[] = "khopmbdjffemhegeeobelklnbglcdgfh";
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/common/google_url_loader_throttle.cc b/qtwebengine/src/3rdparty/chromium/chrome/common/google_url_loader_throttle.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/common/google_url_loader_throttle.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/common/google_url_loader_throttle.cc	2025-06-05 15:57:11.000000000 +0800
@@ -13,10 +13,6 @@
 #include "net/base/url_util.h"
 #include "services/network/public/mojom/url_response_head.mojom.h"
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
-#include "extensions/common/extension_urls.h"
-#endif
-
 namespace {
 
 #if defined(OS_ANDROID)
@@ -58,53 +54,6 @@
 void GoogleURLLoaderThrottle::WillStartRequest(
     network::ResourceRequest* request,
     bool* defer) {
-  if (dynamic_params_.force_safe_search) {
-    GURL new_url;
-    safe_search_util::ForceGoogleSafeSearch(request->url, &new_url);
-    if (!new_url.is_empty())
-      request->url = new_url;
-  }
-
-  static_assert(safe_search_util::YOUTUBE_RESTRICT_OFF == 0,
-                "OFF must be first");
-  if (dynamic_params_.youtube_restrict >
-          safe_search_util::YOUTUBE_RESTRICT_OFF &&
-      dynamic_params_.youtube_restrict <
-          safe_search_util::YOUTUBE_RESTRICT_COUNT) {
-    safe_search_util::ForceYouTubeRestrict(
-        request->url, &request->cors_exempt_headers,
-        static_cast<safe_search_util::YouTubeRestrictMode>(
-            dynamic_params_.youtube_restrict));
-  }
-
-  if (!dynamic_params_.allowed_domains_for_apps.empty() &&
-      request->url.DomainIs("google.com")) {
-    request->cors_exempt_headers.SetHeader(
-        safe_search_util::kGoogleAppsAllowedDomains,
-        dynamic_params_.allowed_domains_for_apps);
-  }
-
-#if defined(OS_ANDROID)
-  if (!client_data_header_.empty() &&
-      google_util::IsGoogleAssociatedDomainUrl(request->url)) {
-    request->cors_exempt_headers.SetHeader(kCCTClientDataHeader,
-                                           client_data_header_);
-  }
-
-  bool is_google_homepage_or_search =
-      google_util::IsGoogleHomePageUrl(request->url) ||
-      google_util::IsGoogleSearchUrl(request->url);
-  if (is_google_homepage_or_search) {
-    // TODO (crbug.com/1081510): Remove this experimental code once a final
-    // solution is agreed upon.
-    if (base::FeatureList::IsEnabled(features::kAndroidDarkSearch)) {
-      request->url = net::AppendOrReplaceQueryParameter(
-          request->url, "cs", night_mode_enabled_ ? "1" : "0");
-    }
-    base::UmaHistogramBoolean("Android.DarkTheme.DarkSearchRequested",
-                              night_mode_enabled_);
-  }
-#endif
 }
 
 void GoogleURLLoaderThrottle::WillRedirectRequest(
@@ -114,37 +63,6 @@
     std::vector<std::string>* to_be_removed_headers,
     net::HttpRequestHeaders* modified_headers,
     net::HttpRequestHeaders* modified_cors_exempt_headers) {
-  // URLLoaderThrottles can only change the redirect URL when the network
-  // service is enabled. The non-network service path handles this in
-  // ChromeNetworkDelegate.
-  if (dynamic_params_.force_safe_search) {
-    safe_search_util::ForceGoogleSafeSearch(redirect_info->new_url,
-                                            &redirect_info->new_url);
-  }
-
-  if (dynamic_params_.youtube_restrict >
-          safe_search_util::YOUTUBE_RESTRICT_OFF &&
-      dynamic_params_.youtube_restrict <
-          safe_search_util::YOUTUBE_RESTRICT_COUNT) {
-    safe_search_util::ForceYouTubeRestrict(
-        redirect_info->new_url, modified_cors_exempt_headers,
-        static_cast<safe_search_util::YouTubeRestrictMode>(
-            dynamic_params_.youtube_restrict));
-  }
-
-  if (!dynamic_params_.allowed_domains_for_apps.empty() &&
-      redirect_info->new_url.DomainIs("google.com")) {
-    modified_cors_exempt_headers->SetHeader(
-        safe_search_util::kGoogleAppsAllowedDomains,
-        dynamic_params_.allowed_domains_for_apps);
-  }
-
-#if defined(OS_ANDROID)
-  if (!client_data_header_.empty() &&
-      !google_util::IsGoogleAssociatedDomainUrl(redirect_info->new_url)) {
-    to_be_removed_headers->push_back(kCCTClientDataHeader);
-  }
-#endif
 }
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
@@ -153,6 +71,7 @@
     network::mojom::URLResponseHead* response_head,
     bool* defer) {
   // Built-in additional protection for the chrome web store origin.
+#if !defined(__powerpc64__)
   GURL webstore_url(extension_urls::GetWebstoreLaunchURL());
   if (response_url.SchemeIsHTTPOrHTTPS() &&
       response_url.DomainIs(webstore_url.host_piece())) {
@@ -163,5 +82,6 @@
       response_head->headers->AddHeader("x-frame-options", "sameorigin");
     }
   }
+#endif
 }
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/common/safe_browsing/BUILD.gn b/qtwebengine/src/3rdparty/chromium/chrome/common/safe_browsing/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/chrome/common/safe_browsing/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/common/safe_browsing/BUILD.gn	2025-06-03 10:24:34.000000000 +0800
@@ -142,7 +142,6 @@
       ":archive_analyzer_results",
       ":binary_feature_extractor",
       ":download_type_util",
-      ":rar_analyzer",
       "//components/safe_browsing/core:features",
     ]
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/installer/linux/BUILD.gn b/qtwebengine/src/3rdparty/chromium/chrome/installer/linux/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/chrome/installer/linux/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/installer/linux/BUILD.gn	2025-06-06 10:48:31.000000000 +0800
@@ -92,8 +92,6 @@
                     "$root_out_dir/xdg-mime",
                     "$root_out_dir/xdg-settings",
                     "$root_out_dir/locales/en-US.pak",
-                    "$root_out_dir/MEIPreload/manifest.json",
-                    "$root_out_dir/MEIPreload/preloaded_data.pb",
                   ]
 
 action_foreach("calculate_deb_dependencies") {
@@ -329,7 +327,6 @@
     ":theme_files",
     "//chrome",
     "//chrome:packed_resources",
-    "//chrome/browser/resources/media/mei_preload:component",
     "//sandbox/linux:chrome_sandbox",
     "//third_party/crashpad/crashpad/handler:crashpad_handler",
   ]
@@ -391,6 +388,8 @@
       deb_arch = "mipsel"
     } else if (current_cpu == "mips64el") {
       deb_arch = "mips64el"
+    } else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+      deb_arch = "ppc64el"
     } else {
       assert(false, "Linux installer not configured for this architecture.")
     }
@@ -440,6 +439,8 @@
         rpm_arch = "mipsel"
       } else if (current_cpu == "mips64el") {
         rpm_arch = "mips64el"
+      } else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+        rpm_arch = "ppc64le"
       } else {
         assert(false, "Linux installer not configured for this architecture.")
       }
@@ -510,7 +511,8 @@
   }
 
   group(target_name) {
-    deps = [ ":$deb_target_name" ]
+    #deps = [ ":$deb_target_name" ]
+    deps = [ ]
     if (!is_chromeos) {
       deps += [ ":$rpm_target_name" ]
       if (enable_snap_package) {
diff -Naur a/qtwebengine/src/3rdparty/chromium/chrome/renderer/chrome_content_renderer_client.cc b/qtwebengine/src/3rdparty/chromium/chrome/renderer/chrome_content_renderer_client.cc
--- a/qtwebengine/src/3rdparty/chromium/chrome/renderer/chrome_content_renderer_client.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/chrome/renderer/chrome_content_renderer_client.cc	2025-06-03 10:13:04.000000000 +0800
@@ -95,7 +95,6 @@
 #include "components/prerender/renderer/prerender_utils.h"
 #include "components/prerender/renderer/prerenderer_client.h"
 #include "components/safe_browsing/buildflags.h"
-#include "components/safe_browsing/content/renderer/threat_dom_details.h"
 #include "components/spellcheck/spellcheck_buildflags.h"
 #include "components/subresource_filter/content/renderer/subresource_filter_agent.h"
 #include "components/subresource_filter/content/renderer/unverified_ruleset_dealer.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/autofill/core/browser/autofill_download_manager.cc b/qtwebengine/src/3rdparty/chromium/components/autofill/core/browser/autofill_download_manager.cc
--- a/qtwebengine/src/3rdparty/chromium/components/autofill/core/browser/autofill_download_manager.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/autofill/core/browser/autofill_download_manager.cc	2025-06-03 10:19:27.000000000 +0800
@@ -826,87 +826,6 @@
 }
 
 bool AutofillDownloadManager::StartRequest(FormRequestData request_data) {
-  scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory =
-      driver_->GetURLLoaderFactory();
-  DCHECK(url_loader_factory);
-
-  // Get the URL and method to use for this request.
-  std::string method;
-  GURL request_url;
-  std::tie(request_url, method) = GetRequestURLAndMethodForApi(request_data);
-
-  // Track the URL length for GET queries because the URL length can be in the
-  // thousands when rich metadata is enabled.
-  if (request_data.request_type == AutofillDownloadManager::REQUEST_QUERY &&
-      method == "GET") {
-    UMA_HISTOGRAM_COUNTS_100000("Autofill.Query.GetUrlLength",
-                                request_url.spec().length());
-  }
-
-  auto resource_request = std::make_unique<network::ResourceRequest>();
-  resource_request->url = request_url;
-  resource_request->credentials_mode = network::mojom::CredentialsMode::kOmit;
-  resource_request->method = method;
-
-  // On iOS we have a single, shared URLLoaderFactory provided by BrowserState.
-  // As it is shared, it is not trusted and we cannot assign trusted_params
-  // to the network request.
-#if !defined(OS_IOS)
-  resource_request->trusted_params = network::ResourceRequest::TrustedParams();
-  resource_request->trusted_params->isolation_info = driver_->IsolationInfo();
-#endif
-
-  // Add Chrome experiment state to the request headers.
-  variations::AppendVariationsHeaderUnknownSignedIn(
-      request_url,
-      driver_->IsIncognito() ? variations::InIncognito::kYes
-                             : variations::InIncognito::kNo,
-      resource_request.get());
-
-  // Set headers specific to the API.
-  // Encode response serialized proto in base64 for safety.
-  resource_request->headers.SetHeader(kGoogEncodeResponseIfExecutable,
-                                      "base64");
-
-  // Put API key in request's header if a key exists, and the endpoint is
-  // trusted by Google.
-  if (!api_key_.empty() && request_url.SchemeIs(url::kHttpsScheme) &&
-      google_util::IsGoogleAssociatedDomainUrl(request_url)) {
-    resource_request->headers.SetHeader(kGoogApiKey, api_key_);
-  }
-
-  auto simple_loader = network::SimpleURLLoader::Create(
-      std::move(resource_request),
-      GetNetworkTrafficAnnotation(request_data.request_type));
-
-  // This allows reading the error message within the API response when status
-  // is not 200 (e.g., 400). Otherwise, URL loader will not give any content in
-  // the response when there is a failure, which makes debugging hard.
-  simple_loader->SetAllowHttpErrorResults(true);
-
-  if (method == "POST") {
-    const std::string content_type = "application/x-protobuf";
-    std::string payload;
-    if (!GetAPIBodyPayload(request_data.payload, request_data.request_type,
-                           &payload)) {
-      return false;
-    }
-
-    // Attach payload data and add data format header.
-    simple_loader->AttachStringForUpload(payload, content_type);
-  }
-
-  // Transfer ownership of the loader into url_loaders_. Temporarily hang
-  // onto the raw pointer to use it as a key and to kick off the request;
-  // transferring ownership (std::move) invalidates the |simple_loader|
-  // variable.
-  auto* raw_simple_loader = simple_loader.get();
-  url_loaders_.push_back(std::move(simple_loader));
-  raw_simple_loader->DownloadToStringOfUnboundedSizeUntilCrashAndDie(
-      url_loader_factory.get(),
-      base::BindOnce(&AutofillDownloadManager::OnSimpleLoaderComplete,
-                     base::Unretained(this), std::move(--url_loaders_.end()),
-                     std::move(request_data), AutofillTickClock::NowTicks()));
   return true;
 }
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/domain_reliability/bake_in_configs.py b/qtwebengine/src/3rdparty/chromium/components/domain_reliability/bake_in_configs.py
--- a/qtwebengine/src/3rdparty/chromium/components/domain_reliability/bake_in_configs.py	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/domain_reliability/bake_in_configs.py	2025-06-03 10:47:55.000000000 +0800
@@ -490,7 +490,7 @@
     domain = origin[8:-1]
   else:
     return False
-  return any(domain == e or domain.endswith('.' + e)  for e in DOMAIN_WHITELIST)
+  return False
 
 
 def quote_and_wrap_text(text, width=79, prefix='  "', suffix='"'):
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/domain_reliability/BUILD.gn b/qtwebengine/src/3rdparty/chromium/components/domain_reliability/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/components/domain_reliability/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/domain_reliability/BUILD.gn	2025-06-03 10:47:55.000000000 +0800
@@ -9,26 +9,6 @@
   script = "bake_in_configs.py"
 
   inputs = [
-    "baked_in_configs/c_android_clients_google_com.json",
-    "baked_in_configs/c_bigcache_googleapis_com.json",
-    "baked_in_configs/c_doc-0-0-sj_sj_googleusercontent_com.json",
-    "baked_in_configs/c_docs_google_com.json",
-    "baked_in_configs/c_drive_google_com.json",
-    "baked_in_configs/c_googlesyndication_com.json",
-    "baked_in_configs/c_pack_google_com.json",
-    "baked_in_configs/c_play_google_com.json",
-    "baked_in_configs/c_youtube_com.json",
-    "baked_in_configs/clients2_google_com.json",
-    "baked_in_configs/docs_google_com.json",
-    "baked_in_configs/gcp_gvt2_com.json",
-    "baked_in_configs/gcp_gvt6_com.json",
-    "baked_in_configs/google-analytics_com.json",
-    "baked_in_configs/googlevideo_com.json",
-    "baked_in_configs/gvt1_com.json",
-    "baked_in_configs/gvt2_com.json",
-    "baked_in_configs/gvt6_com.json",
-    "baked_in_configs/ssl_gstatic_com.json",
-    "baked_in_configs/www_google_com.json",
   ]
 
   output_file = "$target_gen_dir/baked_in_configs.cc"
@@ -36,13 +16,21 @@
 
   # The JSON file list is too long for the command line on Windows, so put
   # them in a response file.
-  response_file_contents = rebase_path(inputs, root_build_dir)
-  args = [
-    "--file-list",
-    "{{response_file_name}}",
-    "--output",
-    rebase_path(output_file, root_build_dir),
-  ]
+  if (is_win) {
+      args = [
+        "--file-list",
+        "nul",
+        "--output",
+        rebase_path(output_file, root_build_dir),
+      ]
+  } else {
+        args = [
+        "--file-list",
+        "/dev/null",
+        "--output",
+        rebase_path(output_file, root_build_dir),
+      ]
+  }
 }
 
 jumbo_component("domain_reliability") {
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/domain_reliability/google_configs.cc b/qtwebengine/src/3rdparty/chromium/components/domain_reliability/google_configs.cc
--- a/qtwebengine/src/3rdparty/chromium/components/domain_reliability/google_configs.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/domain_reliability/google_configs.cc	2025-06-03 10:47:55.000000000 +0800
@@ -11,564 +11,6 @@
 
 namespace domain_reliability {
 
-namespace {
-
-struct GoogleConfigParams {
-  const char* hostname;
-  bool include_subdomains;
-
-  // If true, prepend a collector URL within https://|hostname|/.
-  bool include_origin_specific_collector;
-
-  // If true, also add a config for www.|hostname|.
-  //
-  // |include_subdomains| will be false in the extra config, but
-  // |include_origin_specific_collector| will be respected, and will use the
-  // www subdomain as the origin for the collector so it matches the config.
-  bool duplicate_for_www;
-};
-
-const GoogleConfigParams kGoogleConfigs[] = {
-    // Origins with subdomains and same-origin collectors. Currently, all
-    // origins with same-origin collectors also run collectors on their www
-    // subdomain. (e.g., both foo.com and www.foo.com.)
-    {"google.ac", true, true, true},
-    {"google.ad", true, true, true},
-    {"google.ae", true, true, true},
-    {"google.af", true, true, true},
-    {"google.ag", true, true, true},
-    {"google.al", true, true, true},
-    {"google.am", true, true, true},
-    {"google.as", true, true, true},
-    {"google.at", true, true, true},
-    {"google.az", true, true, true},
-    {"google.ba", true, true, true},
-    {"google.be", true, true, true},
-    {"google.bf", true, true, true},
-    {"google.bg", true, true, true},
-    {"google.bi", true, true, true},
-    {"google.bj", true, true, true},
-    {"google.bs", true, true, true},
-    {"google.bt", true, true, true},
-    {"google.by", true, true, true},
-    {"google.ca", true, true, true},
-    {"google.cc", true, true, true},
-    {"google.cd", true, true, true},
-    {"google.cf", true, true, true},
-    {"google.cg", true, true, true},
-    {"google.ch", true, true, true},
-    {"google.ci", true, true, true},
-    {"google.cl", true, true, true},
-    {"google.cm", true, true, true},
-    {"google.cn", true, true, true},
-    {"google.co.ao", true, true, true},
-    {"google.co.bw", true, true, true},
-    {"google.co.ck", true, true, true},
-    {"google.co.cr", true, true, true},
-    {"google.co.hu", true, true, true},
-    {"google.co.id", true, true, true},
-    {"google.co.il", true, true, true},
-    {"google.co.im", true, true, true},
-    {"google.co.in", true, true, true},
-    {"google.co.je", true, true, true},
-    {"google.co.jp", true, true, true},
-    {"google.co.ke", true, true, true},
-    {"google.co.kr", true, true, true},
-    {"google.co.ls", true, true, true},
-    {"google.co.ma", true, true, true},
-    {"google.co.mz", true, true, true},
-    {"google.co.nz", true, true, true},
-    {"google.co.th", true, true, true},
-    {"google.co.tz", true, true, true},
-    {"google.co.ug", true, true, true},
-    {"google.co.uk", true, true, true},
-    {"google.co.uz", true, true, true},
-    {"google.co.ve", true, true, true},
-    {"google.co.vi", true, true, true},
-    {"google.co.za", true, true, true},
-    {"google.co.zm", true, true, true},
-    {"google.co.zw", true, true, true},
-    {"google.com.af", true, true, true},
-    {"google.com.ag", true, true, true},
-    {"google.com.ai", true, true, true},
-    {"google.com.ar", true, true, true},
-    {"google.com.au", true, true, true},
-    {"google.com.bd", true, true, true},
-    {"google.com.bh", true, true, true},
-    {"google.com.bn", true, true, true},
-    {"google.com.bo", true, true, true},
-    {"google.com.br", true, true, true},
-    {"google.com.by", true, true, true},
-    {"google.com.bz", true, true, true},
-    {"google.com.cn", true, true, true},
-    {"google.com.co", true, true, true},
-    {"google.com.cu", true, true, true},
-    {"google.com.cy", true, true, true},
-    {"google.com.do", true, true, true},
-    {"google.com.ec", true, true, true},
-    {"google.com.eg", true, true, true},
-    {"google.com.et", true, true, true},
-    {"google.com.fj", true, true, true},
-    {"google.com.ge", true, true, true},
-    {"google.com.gh", true, true, true},
-    {"google.com.gi", true, true, true},
-    {"google.com.gr", true, true, true},
-    {"google.com.gt", true, true, true},
-    {"google.com.hk", true, true, true},
-    {"google.com.iq", true, true, true},
-    {"google.com.jm", true, true, true},
-    {"google.com.jo", true, true, true},
-    {"google.com.kh", true, true, true},
-    {"google.com.kw", true, true, true},
-    {"google.com.lb", true, true, true},
-    {"google.com.ly", true, true, true},
-    {"google.com.mm", true, true, true},
-    {"google.com.mt", true, true, true},
-    {"google.com.mx", true, true, true},
-    {"google.com.my", true, true, true},
-    {"google.com.na", true, true, true},
-    {"google.com.nf", true, true, true},
-    {"google.com.ng", true, true, true},
-    {"google.com.ni", true, true, true},
-    {"google.com.np", true, true, true},
-    {"google.com.nr", true, true, true},
-    {"google.com.om", true, true, true},
-    {"google.com.pa", true, true, true},
-    {"google.com.pe", true, true, true},
-    {"google.com.pg", true, true, true},
-    {"google.com.ph", true, true, true},
-    {"google.com.pk", true, true, true},
-    {"google.com.pl", true, true, true},
-    {"google.com.pr", true, true, true},
-    {"google.com.py", true, true, true},
-    {"google.com.qa", true, true, true},
-    {"google.com.ru", true, true, true},
-    {"google.com.sa", true, true, true},
-    {"google.com.sb", true, true, true},
-    {"google.com.sg", true, true, true},
-    {"google.com.sl", true, true, true},
-    {"google.com.sv", true, true, true},
-    {"google.com.tj", true, true, true},
-    {"google.com.tn", true, true, true},
-    {"google.com.tr", true, true, true},
-    {"google.com.tw", true, true, true},
-    {"google.com.ua", true, true, true},
-    {"google.com.uy", true, true, true},
-    {"google.com.vc", true, true, true},
-    {"google.com.ve", true, true, true},
-    {"google.com.vn", true, true, true},
-    {"google.cv", true, true, true},
-    {"google.cz", true, true, true},
-    {"google.de", true, true, true},
-    {"google.dj", true, true, true},
-    {"google.dk", true, true, true},
-    {"google.dm", true, true, true},
-    {"google.dz", true, true, true},
-    {"google.ee", true, true, true},
-    {"google.es", true, true, true},
-    {"google.fi", true, true, true},
-    {"google.fm", true, true, true},
-    {"google.fr", true, true, true},
-    {"google.ga", true, true, true},
-    {"google.ge", true, true, true},
-    {"google.gg", true, true, true},
-    {"google.gl", true, true, true},
-    {"google.gm", true, true, true},
-    {"google.gp", true, true, true},
-    {"google.gr", true, true, true},
-    {"google.gy", true, true, true},
-    {"google.hk", true, true, true},
-    {"google.hn", true, true, true},
-    {"google.hr", true, true, true},
-    {"google.ht", true, true, true},
-    {"google.hu", true, true, true},
-    {"google.ie", true, true, true},
-    {"google.im", true, true, true},
-    {"google.iq", true, true, true},
-    {"google.ir", true, true, true},
-    {"google.is", true, true, true},
-    {"google.it", true, true, true},
-    {"google.it.ao", true, true, true},
-    {"google.je", true, true, true},
-    {"google.jo", true, true, true},
-    {"google.jp", true, true, true},
-    {"google.kg", true, true, true},
-    {"google.ki", true, true, true},
-    {"google.kz", true, true, true},
-    {"google.la", true, true, true},
-    {"google.li", true, true, true},
-    {"google.lk", true, true, true},
-    {"google.lt", true, true, true},
-    {"google.lu", true, true, true},
-    {"google.lv", true, true, true},
-    {"google.md", true, true, true},
-    {"google.me", true, true, true},
-    {"google.mg", true, true, true},
-    {"google.mk", true, true, true},
-    {"google.ml", true, true, true},
-    {"google.mn", true, true, true},
-    {"google.ms", true, true, true},
-    {"google.mu", true, true, true},
-    {"google.mv", true, true, true},
-    {"google.mw", true, true, true},
-    {"google.ne", true, true, true},
-    {"google.ne.jp", true, true, true},
-    {"google.ng", true, true, true},
-    {"google.nl", true, true, true},
-    {"google.no", true, true, true},
-    {"google.nr", true, true, true},
-    {"google.nu", true, true, true},
-    {"google.off.ai", true, true, true},
-    {"google.pk", true, true, true},
-    {"google.pl", true, true, true},
-    {"google.pn", true, true, true},
-    {"google.ps", true, true, true},
-    {"google.pt", true, true, true},
-    {"google.ro", true, true, true},
-    {"google.rs", true, true, true},
-    {"google.ru", true, true, true},
-    {"google.rw", true, true, true},
-    {"google.sc", true, true, true},
-    {"google.se", true, true, true},
-    {"google.sh", true, true, true},
-    {"google.si", true, true, true},
-    {"google.sk", true, true, true},
-    {"google.sm", true, true, true},
-    {"google.sn", true, true, true},
-    {"google.so", true, true, true},
-    {"google.sr", true, true, true},
-    {"google.st", true, true, true},
-    {"google.td", true, true, true},
-    {"google.tg", true, true, true},
-    {"google.tk", true, true, true},
-    {"google.tl", true, true, true},
-    {"google.tm", true, true, true},
-    {"google.tn", true, true, true},
-    {"google.to", true, true, true},
-    {"google.tt", true, true, true},
-    {"google.us", true, true, true},
-    {"google.uz", true, true, true},
-    {"google.vg", true, true, true},
-    {"google.vu", true, true, true},
-    {"google.ws", true, true, true},
-    {"l.google.com", true, true, true},
-
-    // google.com is a special case. We have a custom config for www.google.com,
-    // so set duplicate_for_www = false.
-    {"google.com", true, true, false},
-
-    // Origins with subdomains and without same-origin collectors.
-    {"2mdn.net", true, false, false},
-    {"adgoogle.net", true, false, false},
-    {"admeld.com", true, false, false},
-    {"admob.biz", true, false, false},
-    {"admob.co.in", true, false, false},
-    {"admob.co.kr", true, false, false},
-    {"admob.co.nz", true, false, false},
-    {"admob.co.uk", true, false, false},
-    {"admob.co.za", true, false, false},
-    {"admob.com", true, false, false},
-    {"admob.com.br", true, false, false},
-    {"admob.com.es", true, false, false},
-    {"admob.com.fr", true, false, false},
-    {"admob.com.mx", true, false, false},
-    {"admob.com.pt", true, false, false},
-    {"admob.de", true, false, false},
-    {"admob.dk", true, false, false},
-    {"admob.es", true, false, false},
-    {"admob.fi", true, false, false},
-    {"admob.fr", true, false, false},
-    {"admob.gr", true, false, false},
-    {"admob.hk", true, false, false},
-    {"admob.ie", true, false, false},
-    {"admob.in", true, false, false},
-    {"admob.it", true, false, false},
-    {"admob.jp", true, false, false},
-    {"admob.kr", true, false, false},
-    {"admob.mobi", true, false, false},
-    {"admob.no", true, false, false},
-    {"admob.ph", true, false, false},
-    {"admob.pt", true, false, false},
-    {"admob.sg", true, false, false},
-    {"admob.tw", true, false, false},
-    {"admob.us", true, false, false},
-    {"admob.vn", true, false, false},
-    {"adwhirl.com", true, false, false},
-    {"ampproject.com", true, false, false},
-    {"ampproject.net", true, false, false},
-    {"ampproject.org", true, false, false},
-    {"android.com", true, false, false},
-    {"anycast-edge.metric.gstatic.com", true, false, false},
-    {"anycast-stb.metric.gstatic.com", true, false, false},
-    {"anycast.metric.gstatic.com", true, false, false},
-    {"cdn.ampproject.org", true, false, false},
-    {"chromecast.com", true, false, false},
-    {"chromeexperiments.com", true, false, false},
-    {"chromestatus.com", true, false, false},
-    {"chromium.org", true, false, false},
-    {"clients6.google.com", true, false, false},
-    {"cloudendpointsapis.com", true, false, false},
-    {"dartmotif.com", true, false, false},
-    {"dartsearch.net", true, false, false},
-    {"doubleclick.com", true, false, false},
-    {"doubleclick.ne.jp", true, false, false},
-    {"doubleclick.net", true, false, false},
-    {"doubleclickusercontent.com", true, false, false},
-    {"fls.doubleclick.net", true, false, false},
-    {"g.co", true, false, false},
-    {"g.doubleclick.net", true, false, false},
-    {"ggpht.com", true, false, false},
-    {"gmodules.com", true, false, false},
-    {"goo.gl", true, false, false},
-    {"google-syndication.com", true, false, false},
-    {"google.cat", true, false, false},
-    {"google.info", true, false, false},
-    {"google.jobs", true, false, false},
-    {"google.net", true, false, false},
-    {"google.org", true, false, false},
-    {"google.stackdriver.com", true, false, false},
-    {"googleadapis.com", true, false, false},
-    {"googleadservices.com", true, false, false},
-    {"googleadsserving.cn", true, false, false},
-    {"googlealumni.com", true, false, false},
-    {"googleapis.cn", true, false, false},
-    {"googleapis.com", true, false, false},
-    {"googleapps.com", true, false, false},
-    {"googlecbs.com", true, false, false},
-    {"googlecode.com", true, false, false},
-    {"googlecommerce.com", true, false, false},
-    {"googledrive.com", true, false, false},
-    {"googleenterprise.com", true, false, false},
-    {"googlefiber.com", true, false, false},
-    {"googlefiber.net", true, false, false},
-    {"googlegoro.com", true, false, false},
-    {"googlehosted.com", true, false, false},
-    {"googlepayments.com", true, false, false},
-    {"googlesource.com", true, false, false},
-    {"googlesyndication.com", true, false, false},
-    {"googletagmanager.com", true, false, false},
-    {"googletagservices.com", true, false, false},
-    {"googleusercontent.com", true, false, false},
-    {"googlezip.net", true, false, false},
-    {"gstatic.cn", true, false, false},
-    {"gstatic.com", true, false, false},
-    {"gvt3.com", true, false, false},
-    {"gvt9.com", true, false, false},
-    {"picasa.com", true, false, false},
-    {"recaptcha.net", true, false, false},
-    {"stackdriver.com", true, false, false},
-    {"stbcast-stb.metric.gstatic.com", true, false, false},
-    {"stbcast.metric.gstatic.com", true, false, false},
-    {"stbcast2-stb.metric.gstatic.com", true, false, false},
-    {"stbcast2.metric.gstatic.com", true, false, false},
-    {"stbcast3-stb.metric.gstatic.com", true, false, false},
-    {"stbcast3.metric.gstatic.com", true, false, false},
-    {"stbcast4-stb.metric.gstatic.com", true, false, false},
-    {"stbcast4.metric.gstatic.com", true, false, false},
-    {"unicast-edge.metric.gstatic.com", true, false, false},
-    {"unicast-stb.metric.gstatic.com", true, false, false},
-    {"unicast.metric.gstatic.com", true, false, false},
-    {"unicast2-stb.metric.gstatic.com", true, false, false},
-    {"unicast2.metric.gstatic.com", true, false, false},
-    {"waze.com", true, false, false},
-    {"withgoogle.com", true, false, false},
-    {"youtu.be", true, false, false},
-    {"youtube-3rd-party.com", true, false, false},
-    {"youtube-nocookie.com", true, false, false},
-    {"youtube.ae", true, false, false},
-    {"youtube.al", true, false, false},
-    {"youtube.am", true, false, false},
-    {"youtube.at", true, false, false},
-    {"youtube.az", true, false, false},
-    {"youtube.ba", true, false, false},
-    {"youtube.be", true, false, false},
-    {"youtube.bg", true, false, false},
-    {"youtube.bh", true, false, false},
-    {"youtube.bo", true, false, false},
-    {"youtube.ca", true, false, false},
-    {"youtube.cat", true, false, false},
-    {"youtube.ch", true, false, false},
-    {"youtube.cl", true, false, false},
-    {"youtube.co", true, false, false},
-    {"youtube.co.ae", true, false, false},
-    {"youtube.co.at", true, false, false},
-    {"youtube.co.hu", true, false, false},
-    {"youtube.co.id", true, false, false},
-    {"youtube.co.il", true, false, false},
-    {"youtube.co.in", true, false, false},
-    {"youtube.co.jp", true, false, false},
-    {"youtube.co.ke", true, false, false},
-    {"youtube.co.kr", true, false, false},
-    {"youtube.co.ma", true, false, false},
-    {"youtube.co.nz", true, false, false},
-    {"youtube.co.th", true, false, false},
-    {"youtube.co.ug", true, false, false},
-    {"youtube.co.uk", true, false, false},
-    {"youtube.co.ve", true, false, false},
-    {"youtube.co.za", true, false, false},
-    {"youtube.com", true, false, false},
-    {"youtube.com.ar", true, false, false},
-    {"youtube.com.au", true, false, false},
-    {"youtube.com.az", true, false, false},
-    {"youtube.com.bh", true, false, false},
-    {"youtube.com.bo", true, false, false},
-    {"youtube.com.br", true, false, false},
-    {"youtube.com.by", true, false, false},
-    {"youtube.com.co", true, false, false},
-    {"youtube.com.do", true, false, false},
-    {"youtube.com.ee", true, false, false},
-    {"youtube.com.eg", true, false, false},
-    {"youtube.com.es", true, false, false},
-    {"youtube.com.gh", true, false, false},
-    {"youtube.com.gr", true, false, false},
-    {"youtube.com.gt", true, false, false},
-    {"youtube.com.hk", true, false, false},
-    {"youtube.com.hr", true, false, false},
-    {"youtube.com.jm", true, false, false},
-    {"youtube.com.jo", true, false, false},
-    {"youtube.com.kw", true, false, false},
-    {"youtube.com.lb", true, false, false},
-    {"youtube.com.lv", true, false, false},
-    {"youtube.com.mk", true, false, false},
-    {"youtube.com.mt", true, false, false},
-    {"youtube.com.mx", true, false, false},
-    {"youtube.com.my", true, false, false},
-    {"youtube.com.ng", true, false, false},
-    {"youtube.com.om", true, false, false},
-    {"youtube.com.pe", true, false, false},
-    {"youtube.com.ph", true, false, false},
-    {"youtube.com.pk", true, false, false},
-    {"youtube.com.pt", true, false, false},
-    {"youtube.com.qa", true, false, false},
-    {"youtube.com.ro", true, false, false},
-    {"youtube.com.sa", true, false, false},
-    {"youtube.com.sg", true, false, false},
-    {"youtube.com.tn", true, false, false},
-    {"youtube.com.tr", true, false, false},
-    {"youtube.com.tw", true, false, false},
-    {"youtube.com.ua", true, false, false},
-    {"youtube.com.uy", true, false, false},
-    {"youtube.com.ve", true, false, false},
-    {"youtube.cz", true, false, false},
-    {"youtube.de", true, false, false},
-    {"youtube.dk", true, false, false},
-    {"youtube.ee", true, false, false},
-    {"youtube.es", true, false, false},
-    {"youtube.fi", true, false, false},
-    {"youtube.fr", true, false, false},
-    {"youtube.ge", true, false, false},
-    {"youtube.gr", true, false, false},
-    {"youtube.gt", true, false, false},
-    {"youtube.hk", true, false, false},
-    {"youtube.hr", true, false, false},
-    {"youtube.hu", true, false, false},
-    {"youtube.ie", true, false, false},
-    {"youtube.in", true, false, false},
-    {"youtube.is", true, false, false},
-    {"youtube.it", true, false, false},
-    {"youtube.jo", true, false, false},
-    {"youtube.jp", true, false, false},
-    {"youtube.kr", true, false, false},
-    {"youtube.lk", true, false, false},
-    {"youtube.lt", true, false, false},
-    {"youtube.lv", true, false, false},
-    {"youtube.ma", true, false, false},
-    {"youtube.md", true, false, false},
-    {"youtube.me", true, false, false},
-    {"youtube.mk", true, false, false},
-    {"youtube.mx", true, false, false},
-    {"youtube.my", true, false, false},
-    {"youtube.ng", true, false, false},
-    {"youtube.nl", true, false, false},
-    {"youtube.no", true, false, false},
-    {"youtube.pe", true, false, false},
-    {"youtube.ph", true, false, false},
-    {"youtube.pk", true, false, false},
-    {"youtube.pl", true, false, false},
-    {"youtube.pr", true, false, false},
-    {"youtube.pt", true, false, false},
-    {"youtube.qa", true, false, false},
-    {"youtube.ro", true, false, false},
-    {"youtube.rs", true, false, false},
-    {"youtube.ru", true, false, false},
-    {"youtube.sa", true, false, false},
-    {"youtube.se", true, false, false},
-    {"youtube.sg", true, false, false},
-    {"youtube.si", true, false, false},
-    {"youtube.sk", true, false, false},
-    {"youtube.sn", true, false, false},
-    {"youtube.tn", true, false, false},
-    {"youtube.ua", true, false, false},
-    {"youtube.ug", true, false, false},
-    {"youtube.uy", true, false, false},
-    {"youtube.vn", true, false, false},
-    {"youtubeeducation.com", true, false, false},
-    {"youtubemobilesupport.com", true, false, false},
-    {"ytimg.com", true, false, false},
-
-    // Origins without subdomains and with same-origin collectors.
-    {"accounts.google.com", false, true, false},
-    {"apis.google.com", false, true, false},
-    {"app.google.stackdriver.com", false, true, false},
-    {"b.mail.google.com", false, true, false},
-    {"chatenabled.mail.google.com", false, true, false},
-    {"ddm.google.com", false, true, false},
-    {"gmail.com", false, true, false},
-    {"gmail.google.com", false, true, false},
-    {"mail-attachment.googleusercontent.com", false, true, false},
-    {"mail.google.com", false, true, false},
-    {"www.gmail.com", false, true, false},
-
-    // Origins without subdomains or same-origin collectors.
-    {"ad.doubleclick.net", false, false, false},
-    {"drive.google.com", false, false, false},
-    {"redirector.googlevideo.com", false, false, false},
-};
-
-const char* const kGoogleStandardCollectors[] = {
-    "https://beacons.gcp.gvt2.com/domainreliability/upload",
-    "https://beacons.gvt2.com/domainreliability/upload",
-    "https://beacons2.gvt2.com/domainreliability/upload",
-    "https://beacons3.gvt2.com/domainreliability/upload",
-    "https://beacons4.gvt2.com/domainreliability/upload",
-    "https://beacons5.gvt2.com/domainreliability/upload",
-    "https://beacons5.gvt3.com/domainreliability/upload",
-    "https://clients2.google.com/domainreliability/upload",
-};
-
-const char* const kGoogleOriginSpecificCollectorPathString =
-    "/domainreliability/upload";
-
-std::unique_ptr<const DomainReliabilityConfig> CreateGoogleConfig(
-    const GoogleConfigParams& params,
-    bool is_www) {
-  if (is_www)
-    DCHECK(params.duplicate_for_www);
-
-  std::string hostname = (is_www ? "www." : "") + std::string(params.hostname);
-  bool include_subdomains = params.include_subdomains && !is_www;
-
-  auto config = std::make_unique<DomainReliabilityConfig>();
-  config->origin = GURL("https://" + hostname + "/");
-  config->include_subdomains = include_subdomains;
-  config->collectors.clear();
-  if (params.include_origin_specific_collector) {
-    GURL::Replacements replacements;
-    replacements.SetPathStr(kGoogleOriginSpecificCollectorPathString);
-    config->collectors.push_back(
-        std::make_unique<GURL>(config->origin.ReplaceComponents(replacements)));
-  }
-  for (const char* collector : kGoogleStandardCollectors) {
-    config->collectors.push_back(std::make_unique<GURL>(collector));
-  }
-  config->success_sample_rate = 0.05;
-  config->failure_sample_rate = 1.00;
-  config->path_prefixes.clear();
-  return config;
-}
-
-}  // namespace
-
 std::unique_ptr<const DomainReliabilityConfig> MaybeGetGoogleConfig(
     const std::string& hostname) {
   bool is_www_subdomain =
@@ -578,23 +20,6 @@
   std::unique_ptr<const DomainReliabilityConfig> config = nullptr;
   std::unique_ptr<const DomainReliabilityConfig> superdomain_config = nullptr;
 
-  for (const auto& params : kGoogleConfigs) {
-    if (params.hostname == hostname) {
-      config = CreateGoogleConfig(params, false);
-      break;
-    }
-    if (params.duplicate_for_www && is_www_subdomain &&
-        params.hostname == hostname_parent) {
-      config = CreateGoogleConfig(params, true);
-      break;
-    }
-    // Don't break out of the loop upon finding a superdomain config, because
-    // there might be an exact match later on.
-    if (params.include_subdomains && params.hostname == hostname_parent) {
-      superdomain_config = CreateGoogleConfig(params, false);
-    }
-  }
-
   if (config) {
     DCHECK(config->origin.host() == hostname);
     return config;
@@ -613,11 +38,6 @@
 GetAllGoogleConfigsForTesting() {
   std::vector<std::unique_ptr<const DomainReliabilityConfig>> configs_out;
 
-  for (const auto& params : kGoogleConfigs) {
-    configs_out.push_back(CreateGoogleConfig(params, false));
-    if (params.duplicate_for_www)
-      configs_out.push_back(CreateGoogleConfig(params, true));
-  }
   return configs_out;
 }
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/domain_reliability/uploader.cc b/qtwebengine/src/3rdparty/chromium/components/domain_reliability/uploader.cc
--- a/qtwebengine/src/3rdparty/chromium/components/domain_reliability/uploader.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/domain_reliability/uploader.cc	2025-06-03 10:47:55.000000000 +0800
@@ -77,7 +77,7 @@
     if (discard_uploads_)
       discarded_upload_count_++;
 
-    if (discard_uploads_ || shutdown_) {
+    if (true) {
       DVLOG(1) << "Discarding report instead of uploading.";
       UploadResult result;
       result.status = UploadResult::SUCCESS;
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/dom_distiller/content/browser/dom_distiller_viewer_source.cc b/qtwebengine/src/3rdparty/chromium/components/dom_distiller/content/browser/dom_distiller_viewer_source.cc
--- a/qtwebengine/src/3rdparty/chromium/components/dom_distiller/content/browser/dom_distiller_viewer_source.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/dom_distiller/content/browser/dom_distiller_viewer_source.cc	2025-06-03 10:48:24.000000000 +0800
@@ -292,7 +292,7 @@
 std::string DomDistillerViewerSource::GetContentSecurityPolicy(
     network::mojom::CSPDirectiveName directive) {
   if (directive == network::mojom::CSPDirectiveName::StyleSrc) {
-    return "style-src 'self' https://fonts.googleapis.com;";
+    return "style-src 'self';";
   } else if (directive == network::mojom::CSPDirectiveName::ChildSrc) {
     return "child-src *;";
   } else if (directive ==
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/dom_distiller/core/html/preview.html b/qtwebengine/src/3rdparty/chromium/components/dom_distiller/core/html/preview.html
--- a/qtwebengine/src/3rdparty/chromium/components/dom_distiller/core/html/preview.html	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/dom_distiller/core/html/preview.html	2025-06-03 10:48:24.000000000 +0800
@@ -11,7 +11,7 @@
   <meta name="theme-color" id="theme-color">
   <title>Title goes here and it could be kind of lengthy - Publisher name</title>
   <link href="../css/distilledpage.css" rel="stylesheet" type="text/css">
-  <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
+  <link href='chrome://resources/css/roboto.css' rel='stylesheet' type='text/css'>
   <style>
     .english :lang(th) {display: none}
     .english :lang(zh) {display: none}
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/dom_distiller/core/javascript/dom_distiller_viewer.js b/qtwebengine/src/3rdparty/chromium/components/dom_distiller/core/javascript/dom_distiller_viewer.js
--- a/qtwebengine/src/3rdparty/chromium/components/dom_distiller/core/javascript/dom_distiller_viewer.js	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/dom_distiller/core/javascript/dom_distiller_viewer.js	2025-06-03 10:48:24.000000000 +0800
@@ -109,7 +109,7 @@
   }
 
   const e = document.createElement('link');
-  e.href = 'https://fonts.googleapis.com/css?family=Roboto';
+  e.href = 'chrome://resources/css/roboto.css';
   e.rel = 'stylesheet';
   e.type = 'text/css';
   document.head.appendChild(e);
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/feedback/feedback_uploader.cc b/qtwebengine/src/3rdparty/chromium/components/feedback/feedback_uploader.cc
--- a/qtwebengine/src/3rdparty/chromium/components/feedback/feedback_uploader.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/feedback/feedback_uploader.cc	2025-06-03 10:26:57.000000000 +0800
@@ -25,7 +25,7 @@
     FILE_PATH_LITERAL("Feedback Reports");
 
 constexpr char kFeedbackPostUrl[] =
-    "https://www.google.com/tools/feedback/chrome/__submit";
+    "trk:232:https://www.google.com/tools/feedback/chrome/__submit";
 
 constexpr char kProtoBufMimeType[] = "application/x-protobuf";
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/google/core/common/google_util.cc b/qtwebengine/src/3rdparty/chromium/components/google/core/common/google_util.cc
--- a/qtwebengine/src/3rdparty/chromium/components/google/core/common/google_util.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/google/core/common/google_util.cc	2025-06-06 00:11:52.000000000 +0800
@@ -31,6 +31,7 @@
 
 // Helpers --------------------------------------------------------------------
 
+#if !defined(__powerpc64__)
 namespace {
 
 bool IsPathHomePageBase(base::StringPiece path) {
@@ -136,18 +137,21 @@
 }
 
 }  // namespace
+#endif
 
 // Global functions -----------------------------------------------------------
 
-const char kGoogleHomepageURL[] = "https://www.google.com/";
+const char kGoogleHomepageURL[] = "trk:113:https://www.google.com/";
 
 bool HasGoogleSearchQueryParam(base::StringPiece str) {
+#if !defined(__powerpc64__)
   url::Component query(0, static_cast<int>(str.length())), key, value;
   while (url::ExtractQueryKeyValue(str.data(), &query, &key, &value)) {
     base::StringPiece key_str = str.substr(key.begin, key.len);
     if (key_str == "q" || key_str == "as_q")
       return true;
   }
+#endif
   return false;
 }
 
@@ -158,11 +162,16 @@
 
 GURL AppendGoogleLocaleParam(const GURL& url,
                              const std::string& application_locale) {
+#if !defined(__powerpc64__)
   return net::AppendQueryParameter(url, "hl",
                                    GetGoogleLocale(application_locale));
+#else
+  return url;
+#endif
 }
 
 std::string GetGoogleCountryCode(const GURL& google_homepage_url) {
+#if !defined(__powerpc64__)
   base::StringPiece google_hostname = google_homepage_url.host_piece();
   // TODO(igorcov): This needs a fix for case when the host has a trailing dot,
   // like "google.com./". https://crbug.com/720295.
@@ -182,23 +191,31 @@
   if (country_code == "cat")
     return "es";
   return country_code.as_string();
+#else
+  return  "nolocale";
+#endif
 }
 
 GURL GetGoogleSearchURL(const GURL& google_homepage_url) {
+#if !defined(__powerpc64__)
   // To transform the homepage URL into the corresponding search URL, add the
   // "search" and the "q=" query string.
   GURL::Replacements replacements;
   replacements.SetPathStr("search");
   replacements.SetQueryStr("q=");
   return google_homepage_url.ReplaceComponents(replacements);
+#else
+  return google_homepage_url;
+#endif
 }
 
 const GURL& CommandLineGoogleBaseURL() {
   // Unit tests may add command-line flags after the first call to this
   // function, so we don't simply initialize a static |base_url| directly and
   // then unconditionally return it.
-  static base::NoDestructor<std::string> switch_value;
   static base::NoDestructor<GURL> base_url;
+#if !defined(__powerpc64__)
+  static base::NoDestructor<std::string> switch_value;
   std::string current_switch_value(
       base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kGoogleBaseURL));
@@ -208,31 +225,47 @@
     if (!base_url->is_valid() || base_url->has_query() || base_url->has_ref())
       *base_url = GURL();
   }
+#else
+  *base_url = GURL();
+#endif
   return *base_url;
 }
 
 bool StartsWithCommandLineGoogleBaseURL(const GURL& url) {
   const GURL& base_url(CommandLineGoogleBaseURL());
+#if !defined(__powerpc64__)
   return base_url.is_valid() &&
          base::StartsWith(url.possibly_invalid_spec(), base_url.spec(),
                           base::CompareCase::SENSITIVE);
+#else
+  return false;
+#endif
 }
 
 bool IsGoogleHostname(base::StringPiece host,
                       SubdomainPermission subdomain_permission) {
+#if !defined(__powerpc64__)
   url::CanonHostInfo host_info;
   return IsCanonicalHostGoogleHostname(net::CanonicalizeHost(host, &host_info),
                                        subdomain_permission);
+#else
+  return false;
+#endif
 }
 
 bool IsGoogleDomainUrl(const GURL& url,
                        SubdomainPermission subdomain_permission,
                        PortPermission port_permission) {
+#if !defined(__powerpc64__)
   return IsValidURL(url, port_permission) &&
          IsCanonicalHostGoogleHostname(url.host_piece(), subdomain_permission);
+#else
+  return false;
+#endif
 }
 
 bool IsGoogleHomePageUrl(const GURL& url) {
+#if !defined(__powerpc64__)
   // First check to see if this has a Google domain.
   if (!IsGoogleDomainUrl(url, DISALLOW_SUBDOMAIN,
                          DISALLOW_NON_STANDARD_PORTS) &&
@@ -244,9 +277,13 @@
   base::StringPiece path(url.path_piece());
   return IsPathHomePageBase(path) ||
          base::StartsWith(path, "/ig", base::CompareCase::INSENSITIVE_ASCII);
+#else
+  return false;
+#endif
 }
 
 bool IsGoogleSearchUrl(const GURL& url) {
+#if !defined(__powerpc64__)
   // First check to see if this has a Google domain.
   if (!IsGoogleDomainUrl(url, DISALLOW_SUBDOMAIN,
                          DISALLOW_NON_STANDARD_PORTS) &&
@@ -264,16 +301,24 @@
   // the path type.
   return HasGoogleSearchQueryParam(url.ref_piece()) ||
          (!is_home_page_base && HasGoogleSearchQueryParam(url.query_piece()));
+#else
+  return false;
+#endif
 }
 
 bool IsYoutubeDomainUrl(const GURL& url,
                         SubdomainPermission subdomain_permission,
                         PortPermission port_permission) {
+#if !defined(__powerpc64__)
   return IsValidURL(url, port_permission) &&
          IsCanonicalHostYoutubeHostname(url.host_piece(), subdomain_permission);
+#else
+  return false;
+#endif
 }
 
 bool IsGoogleAssociatedDomainUrl(const GURL& url) {
+#if !defined(__powerpc64__)
   if (IsGoogleDomainUrl(url, ALLOW_SUBDOMAIN, ALLOW_NON_STANDARD_PORTS))
     return true;
 
@@ -314,6 +359,10 @@
   }
 
   return false;
+#else
+  return false;
+#endif
+
 }
 
 const std::vector<std::string>& GetGoogleRegistrableDomains() {
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/history/core/browser/web_history_service.cc b/qtwebengine/src/3rdparty/chromium/components/history/core/browser/web_history_service.cc
--- a/qtwebengine/src/3rdparty/chromium/components/history/core/browser/web_history_service.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/history/core/browser/web_history_service.cc	2025-06-03 10:26:58.000000000 +0800
@@ -41,13 +41,13 @@
 namespace {
 
 const char kHistoryOAuthScope[] =
-    "https://www.googleapis.com/auth/chromesync";
+    "trk:138:https://www.googleapis.com/auth/chromesync";
 
 const char kHistoryQueryHistoryUrl[] =
-    "https://history.google.com/history/api/lookup?client=chrome";
+    "trk:139:https://history.google.com/history/api/lookup?client=chrome";
 
 const char kHistoryDeleteHistoryUrl[] =
-    "https://history.google.com/history/api/delete?client=chrome";
+    "trk:140:https://history.google.com/history/api/delete?client=chrome";
 
 const char kHistoryAudioHistoryUrl[] =
     "https://history.google.com/history/api/lookup?client=audio";
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/metrics/url_constants.cc b/qtwebengine/src/3rdparty/chromium/components/metrics/url_constants.cc
--- a/qtwebengine/src/3rdparty/chromium/components/metrics/url_constants.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/metrics/url_constants.cc	2025-06-03 10:26:58.000000000 +0800
@@ -7,7 +7,7 @@
 namespace metrics {
 
 const char kNewMetricsServerUrl[] =
-    "https://clientservices.googleapis.com/uma/v2";
+    "trk:265:https://clientservices.googleapis.com/uma/v2";
 
 const char kNewMetricsServerUrlInsecure[] =
     "http://clientservices.googleapis.com/uma/v2";
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/page_load_metrics/browser/page_load_metrics_util.cc b/qtwebengine/src/3rdparty/chromium/components/page_load_metrics/browser/page_load_metrics_util.cc
--- a/qtwebengine/src/3rdparty/chromium/components/page_load_metrics/browser/page_load_metrics_util.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/page_load_metrics/browser/page_load_metrics_util.cc	2025-06-03 10:39:54.000000000 +0800
@@ -188,9 +188,7 @@
 }
 
 bool IsGoogleSearchHostname(const GURL& url) {
-  base::Optional<std::string> result =
-      page_load_metrics::GetGoogleHostnamePrefix(url);
-  return result && result.value() == "www";
+  return false;
 }
 
 bool IsGoogleSearchResultUrl(const GURL& url) {
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/page_load_metrics/common/page_load_metrics_util.cc b/qtwebengine/src/3rdparty/chromium/components/page_load_metrics/common/page_load_metrics_util.cc
--- a/qtwebengine/src/3rdparty/chromium/components/page_load_metrics/common/page_load_metrics_util.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/page_load_metrics/common/page_load_metrics_util.cc	2025-06-03 10:39:54.000000000 +0800
@@ -12,38 +12,7 @@
 namespace page_load_metrics {
 
 base::Optional<std::string> GetGoogleHostnamePrefix(const GURL& url) {
-  const size_t registry_length =
-      net::registry_controlled_domains::GetRegistryLength(
-          url,
-
-          // Do not include unknown registries (registries that don't have any
-          // matches in effective TLD names).
-          net::registry_controlled_domains::EXCLUDE_UNKNOWN_REGISTRIES,
-
-          // Do not include private registries, such as appspot.com. We don't
-          // want to match URLs like www.google.appspot.com.
-          net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES);
-
-  const base::StringPiece hostname = url.host_piece();
-  if (registry_length == 0 || registry_length == std::string::npos ||
-      registry_length >= hostname.length()) {
-    return base::Optional<std::string>();
-  }
-
-  // Removes the tld and the preceding dot.
-  const base::StringPiece hostname_minus_registry =
-      hostname.substr(0, hostname.length() - (registry_length + 1));
-
-  if (hostname_minus_registry == "google")
-    return std::string("");
-
-  if (!base::EndsWith(hostname_minus_registry, ".google",
-                      base::CompareCase::INSENSITIVE_ASCII)) {
-    return base::Optional<std::string>();
-  }
-
-  return std::string(hostname_minus_registry.substr(
-      0, hostname_minus_registry.length() - strlen(".google")));
+  return base::Optional<std::string>();
 }
 
 bool IsGoogleHostname(const GURL& url) {
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/password_manager/core/browser/password_bubble_experiment.cc b/qtwebengine/src/3rdparty/chromium/components/password_manager/core/browser/password_bubble_experiment.cc
--- a/qtwebengine/src/3rdparty/chromium/components/password_manager/core/browser/password_bubble_experiment.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/password_manager/core/browser/password_bubble_experiment.cc	2025-06-05 16:09:42.000000000 +0800
@@ -16,7 +16,6 @@
 #include "components/pref_registry/pref_registry_syncable.h"
 #include "components/prefs/pref_registry_simple.h"
 #include "components/prefs/pref_service.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/sync/driver/sync_service.h"
 #include "components/sync/driver/sync_user_settings.h"
 
@@ -71,8 +70,10 @@
     return false;
   }
 
+#if !defined(__powerpc64__)
   if (!prefs->GetBoolean(prefs::kSigninAllowed))
     return false;
+#endif
 
   if (!sync_service ||
       sync_service->HasDisableReason(
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/password_manager/core/browser/password_store.cc b/qtwebengine/src/3rdparty/chromium/components/password_manager/core/browser/password_store.cc
--- a/qtwebengine/src/3rdparty/chromium/components/password_manager/core/browser/password_store.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/password_manager/core/browser/password_store.cc	2025-06-03 10:26:58.000000000 +0800
@@ -268,10 +268,10 @@
   // TODO(mdm): actually delete them at some point, say M24 or so.
   base::Time cutoff;  // the null time
   if (form.scheme == PasswordForm::Scheme::kHtml &&
-      (form.signon_realm == "http://www.google.com" ||
-       form.signon_realm == "http://www.google.com/" ||
-       form.signon_realm == "https://www.google.com" ||
-       form.signon_realm == "https://www.google.com/")) {
+      (form.signon_realm == "trk:187:http://www.google.com" ||
+       form.signon_realm == "trk:188:http://www.google.com/" ||
+       form.signon_realm == "trk:189:https://www.google.com" ||
+       form.signon_realm == "trk:190:https://www.google.com/")) {
     static const base::Time::Exploded exploded_cutoff = {
         2012, 1, 0, 1, 0, 0, 0, 0};  // 00:00 Jan 1 2012
     base::Time out_time;
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/rappor/rappor_service_impl.cc b/qtwebengine/src/3rdparty/chromium/components/rappor/rappor_service_impl.cc
--- a/qtwebengine/src/3rdparty/chromium/components/rappor/rappor_service_impl.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/rappor/rappor_service_impl.cc	2025-06-03 10:26:58.000000000 +0800
@@ -32,7 +32,7 @@
 const char kRapporDailyEventHistogram[] = "Rappor.DailyEvent.IntervalType";
 
 // The rappor server's URL.
-const char kDefaultServerUrl[] = "https://clients4.google.com/rappor";
+const char kDefaultServerUrl[] = "trk:266:https://clients4.google.com/rappor";
 
 }  // namespace
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/safe_search_api/safe_search/safe_search_url_checker_client.cc b/qtwebengine/src/3rdparty/chromium/components/safe_search_api/safe_search/safe_search_url_checker_client.cc
--- a/qtwebengine/src/3rdparty/chromium/components/safe_search_api/safe_search/safe_search_url_checker_client.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/safe_search_api/safe_search/safe_search_url_checker_client.cc	2025-06-03 10:26:59.000000000 +0800
@@ -29,7 +29,7 @@
 namespace {
 
 const char kSafeSearchApiUrl[] =
-    "https://safesearch.googleapis.com/v1:classify";
+    "trk:238:https://safesearch.googleapis.com/v1:classify";
 const char kDataContentType[] = "application/x-www-form-urlencoded";
 const char kDataFormat[] = "key=%s&urls=%s";
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/safe_search_api/stub_url_checker.cc b/qtwebengine/src/3rdparty/chromium/components/safe_search_api/stub_url_checker.cc
--- a/qtwebengine/src/3rdparty/chromium/components/safe_search_api/stub_url_checker.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/safe_search_api/stub_url_checker.cc	2025-06-03 10:26:59.000000000 +0800
@@ -20,7 +20,7 @@
 namespace {
 
 constexpr char kSafeSearchApiUrl[] =
-    "https://safesearch.googleapis.com/v1:classify";
+    "trk:238:https://safesearch.googleapis.com/v1:classify";
 
 std::string BuildResponse(bool is_porn) {
   base::DictionaryValue dict;
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/search_engines/prepopulated_engines.json b/qtwebengine/src/3rdparty/chromium/components/search_engines/prepopulated_engines.json
--- a/qtwebengine/src/3rdparty/chromium/components/search_engines/prepopulated_engines.json	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/search_engines/prepopulated_engines.json	2025-06-03 10:43:01.000000000 +0800
@@ -113,21 +113,11 @@
     },
 
     "google": {
-      "name": "Google",
-      "keyword": "google.com",
-      "favicon_url": "https://www.google.com/images/branding/product/ico/googleg_lodp.ico",
-      "search_url": "{google:baseURL}search?q={searchTerms}&{google:RLZ}{google:originalQueryForSuggestion}{google:assistedQueryStats}{google:searchFieldtrialParameter}{google:iOSSearchLanguage}{google:searchClient}{google:sourceId}{google:contextualSearchVersion}ie={inputEncoding}",
-      "suggest_url": "{google:baseSuggestURL}search?{google:searchFieldtrialParameter}client={google:suggestClient}&gs_ri={google:suggestRid}&xssi=t&q={searchTerms}&{google:inputType}{google:omniboxFocusType}{google:cursorPosition}{google:currentPageUrl}{google:pageClassification}{google:searchVersion}{google:sessionToken}{google:prefetchQuery}sugkey={google:suggestAPIKeyParameter}",
-      "image_url": "{google:baseURL}searchbyimage/upload",
-      "contextual_search_url": "{google:baseURL}_/contextualsearch?{google:contextualSearchVersion}{google:contextualSearchContextData}",
-      "image_url_post_params": "encoded_image={google:imageThumbnail},image_url={google:imageURL},sbisrc={google:imageSearchSource},original_width={google:imageOriginalWidth},original_height={google:imageOriginalHeight}",
-      "alternate_urls": [
-        "{google:baseURL}#q={searchTerms}",
-        "{google:baseURL}search#q={searchTerms}",
-        "{google:baseURL}webhp#q={searchTerms}",
-        "{google:baseURL}s#q={searchTerms}",
-        "{google:baseURL}s?q={searchTerms}"
-      ],
+      "name": "No Search",
+      "keyword": "nosearch",
+      "favicon_url": "about:blank",
+      "search_url": "http://{searchTerms}",
+      "new_tab_url": "about:blank",
       "type": "SEARCH_ENGINE_GOOGLE",
       "id": 1
     },
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/search_engines/template_url.cc b/qtwebengine/src/3rdparty/chromium/components/search_engines/template_url.cc
--- a/qtwebengine/src/3rdparty/chromium/components/search_engines/template_url.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/search_engines/template_url.cc	2025-06-03 10:39:54.000000000 +0800
@@ -510,11 +510,7 @@
 bool TemplateURLRef::HasGoogleBaseURLs(
     const SearchTermsData& search_terms_data) const {
   ParseIfNecessary(search_terms_data);
-  return std::any_of(replacements_.begin(), replacements_.end(),
-                     [](const Replacement& replacement) {
-                       return replacement.type == GOOGLE_BASE_URL ||
-                              replacement.type == GOOGLE_BASE_SUGGEST_URL;
-                     });
+  return false;
 }
 
 bool TemplateURLRef::ExtractSearchTermsFromURL(
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/cert_report_helper.cc b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/cert_report_helper.cc
--- a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/cert_report_helper.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/cert_report_helper.cc	2025-06-03 10:13:04.000000000 +0800
@@ -84,8 +84,7 @@
     return;
 
   load_time_data->SetBoolean(
-      security_interstitials::kBoxChecked,
-      safe_browsing::IsExtendedReportingEnabled(*GetPrefs(web_contents_)));
+      security_interstitials::kBoxChecked, false);
 
   load_time_data->SetString(
       security_interstitials::kOptInLink,
@@ -122,14 +121,8 @@
     PrefService* pref_service) {
   switch (command) {
     case security_interstitials::CMD_DO_REPORT:
-      safe_browsing::SetExtendedReportingPrefAndMetric(
-          pref_service, true, /* value */
-          safe_browsing::SBER_OPTIN_SITE_SECURITY_INTERSTITIAL);
       break;
     case security_interstitials::CMD_DONT_REPORT:
-      safe_browsing::SetExtendedReportingPrefAndMetric(
-          pref_service, false, /* value */
-          safe_browsing::SBER_OPTIN_SITE_SECURITY_INTERSTITIAL);
       break;
     case security_interstitials::CMD_PROCEED:
       user_action_ = CertificateErrorReport::USER_PROCEEDED;
@@ -147,7 +140,7 @@
   if (!ShouldShowCertificateReporterCheckbox())
     return;
 
-  if (!safe_browsing::IsExtendedReportingEnabled(*GetPrefs(web_contents_)))
+  if (true)
     return;
 
   if (metrics_helper_) {
@@ -175,7 +168,6 @@
     return;
   }
 
-  ssl_cert_reporter_->ReportInvalidCertificateChain(serialized_report);
 }
 
 bool CertReportHelper::ShouldShowCertificateReporterCheckbox() {
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/security_interstitial_controller_client.cc b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/security_interstitial_controller_client.cc
--- a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/security_interstitial_controller_client.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/security_interstitial_controller_client.cc	2025-06-05 16:11:02.000000000 +0800
@@ -7,7 +7,9 @@
 #include <utility>
 
 #include "components/prefs/pref_service.h"
+#if !defined(__powerpc64__)
 #include "components/safe_browsing/core/common/safe_browsing_prefs.h"
+#endif
 #include "components/security_interstitials/content/settings_page_helper.h"
 #include "components/security_interstitials/core/metrics_helper.h"
 #include "content/public/browser/web_contents.h"
@@ -98,11 +100,6 @@
   return prefs_;
 }
 
-const std::string
-SecurityInterstitialControllerClient::GetExtendedReportingPrefName() const {
-  return prefs::kSafeBrowsingScoutReportingEnabled;
-}
-
 bool SecurityInterstitialControllerClient::CanLaunchDateAndTimeSettings() {
   NOTREACHED();
   return false;
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/security_interstitial_controller_client.h b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/security_interstitial_controller_client.h
--- a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/security_interstitial_controller_client.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/security_interstitial_controller_client.h	2025-06-03 09:58:07.000000000 +0800
@@ -49,8 +49,6 @@
   bool CanGoBackBeforeNavigation() override;
 
  protected:
-  // security_interstitials::ControllerClient overrides.
-  const std::string GetExtendedReportingPrefName() const override;
   content::WebContents* web_contents_;
 
  private:
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/security_interstitial_page.cc b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/security_interstitial_page.cc
--- a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/security_interstitial_page.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/security_interstitial_page.cc	2025-06-05 16:13:11.000000000 +0800
@@ -11,7 +11,9 @@
 #include "base/values.h"
 #include "components/grit/components_resources.h"
 #include "components/prefs/pref_service.h"
+#if !defined(__powerpc64__)
 #include "components/safe_browsing/core/common/safe_browsing_prefs.h"
+#endif
 #include "components/security_interstitials/content/security_interstitial_controller_client.h"
 #include "components/security_interstitials/core/common_string_util.h"
 #include "content/public/browser/page_navigator.h"
@@ -32,13 +34,6 @@
       on_show_extended_reporting_pref_exists_(false),
       on_show_extended_reporting_pref_value_(false),
       controller_(std::move(controller)) {
-  // Determine if any prefs need to be updated prior to showing the security
-  // interstitial. Note that some content embedders (such as Android WebView)
-  // uses security interstitials without a prefservice.
-  if (controller_->GetPrefService()) {
-    safe_browsing::UpdatePrefsBeforeSecurityInterstitial(
-        controller_->GetPrefService());
-  }
   SetUpMetrics();
 }
 
@@ -86,6 +81,7 @@
 }
 
 void SecurityInterstitialPage::SetUpMetrics() {
+#if !defined(__powerpc64__)
   // Remember the initial state of the extended reporting pref, to be compared
   // to the same data when the interstitial is closed.
   PrefService* prefs = controller_->GetPrefService();
@@ -95,6 +91,10 @@
     on_show_extended_reporting_pref_value_ =
         safe_browsing::IsExtendedReportingEnabled(*prefs);
   }
+#else
+  on_show_extended_reporting_pref_exists_ = false;
+  on_show_extended_reporting_pref_value_ = false;
+#endif
 }
 
 base::string16 SecurityInterstitialPage::GetFormattedHostName() const {
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/ssl_blocking_page.cc b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/ssl_blocking_page.cc
--- a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/ssl_blocking_page.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/content/ssl_blocking_page.cc	2025-06-05 16:14:05.000000000 +0800
@@ -12,7 +12,9 @@
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/time/time.h"
+#if !defined(__powerpc64__)
 #include "components/safe_browsing/core/common/safe_browsing_prefs.h"
+#endif
 #include "components/security_interstitials/content/cert_report_helper.h"
 #include "components/security_interstitials/content/security_interstitial_controller_client.h"
 #include "components/security_interstitials/content/security_interstitial_page.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/core/controller_client.cc b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/core/controller_client.cc
--- a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/core/controller_client.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/core/controller_client.cc	2025-06-03 09:58:07.000000000 +0800
@@ -36,7 +36,6 @@
 
 void ControllerClient::SetReportingPreference(bool report) {
   DCHECK(GetPrefService());
-  GetPrefService()->SetBoolean(GetExtendedReportingPrefName(), report);
   metrics_helper_->RecordUserInteraction(
       report ? MetricsHelper::SET_EXTENDED_REPORTING_ENABLED
              : MetricsHelper::SET_EXTENDED_REPORTING_DISABLED);
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/core/controller_client.h b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/core/controller_client.h
--- a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/core/controller_client.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/core/controller_client.h	2025-06-03 09:58:07.000000000 +0800
@@ -118,9 +118,6 @@
 
   void SetBaseHelpCenterUrlForTesting(const GURL& test_url);
 
- protected:
-  virtual const std::string GetExtendedReportingPrefName() const = 0;
-
  private:
   std::unique_ptr<MetricsHelper> metrics_helper_;
   // Link to the help center.
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/core/safe_browsing_loud_error_ui.cc b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/core/safe_browsing_loud_error_ui.cc
--- a/qtwebengine/src/3rdparty/chromium/components/security_interstitials/core/safe_browsing_loud_error_ui.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/security_interstitials/core/safe_browsing_loud_error_ui.cc	2025-06-03 10:25:18.000000000 +0800
@@ -25,11 +25,11 @@
 // For malware interstitial pages, we link the problematic URL to Google's
 // diagnostic page.
 const char kSbDiagnosticUrl[] =
-    "https://transparencyreport.google.com/safe-browsing/search?url=%s";
+    "trk:227:https://transparencyreport.google.com/safe-browsing/search?url=%s";
 
 // Constants for the V4 phishing string upgrades.
 const char kReportPhishingErrorUrl[] =
-    "https://safebrowsing.google.com/safebrowsing/report_error/?url=%s";
+    "trk:228:https://safebrowsing.google.com/safebrowsing/report_error/?url=%s";
 
 void RecordExtendedReportingPrefChanged(bool report) {
   UMA_HISTOGRAM_BOOLEAN("SafeBrowsing.Pref.Extended.SecurityInterstitial",
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/account_investigator.cc b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/account_investigator.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/account_investigator.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/account_investigator.cc	2025-06-05 16:15:33.000000000 +0800
@@ -13,7 +13,6 @@
 #include "components/prefs/pref_registry_simple.h"
 #include "components/prefs/pref_service.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/accounts_in_cookie_jar_info.h"
 #include "google_apis/gaia/gaia_auth_util.h"
 #include "google_apis/gaia/google_service_auth_error.h"
@@ -78,15 +77,18 @@
 
 // static
 void AccountInvestigator::RegisterPrefs(PrefRegistrySimple* registry) {
+#if !defined(__powerpc64__)
   registry->RegisterStringPref(prefs::kGaiaCookieHash, std::string());
   registry->RegisterDoublePref(prefs::kGaiaCookieChangedTime, 0);
   registry->RegisterDoublePref(prefs::kGaiaCookiePeriodicReportTime, 0);
+#endif
 }
 
 void AccountInvestigator::Initialize() {
   identity_manager_->AddObserver(this);
   previously_authenticated_ = identity_manager_->HasPrimaryAccount();
 
+#if !defined(__powerpc64__)
   // TODO(crbug.com/1121923): Refactor to use signin::PersistentRepeatingTimer
   // instead.
   Time previous = Time::FromDoubleT(
@@ -96,6 +98,7 @@
   const TimeDelta delay =
       CalculatePeriodicDelay(previous, Time::Now(), kPeriodicReportingInterval);
   timer_.Start(FROM_HERE, delay, this, &AccountInvestigator::TryPeriodicReport);
+#endif
 }
 
 void AccountInvestigator::Shutdown() {
@@ -122,16 +125,13 @@
   // a valid cached ListAccounts response ready for us. Or even both of these
   // could be simultaneously happening, although this should be extremely
   // infrequent.
-  const std::string old_hash(pref_service_->GetString(prefs::kGaiaCookieHash));
+  const std::string old_hash;
   const std::string new_hash(
       HashAccounts(signed_in_accounts, signed_out_accounts));
   const bool currently_authenticated = identity_manager_->HasPrimaryAccount();
   if (old_hash != new_hash) {
     SharedCookieJarReport(signed_in_accounts, signed_out_accounts, Time::Now(),
                           ReportingType::ON_CHANGE);
-    pref_service_->SetString(prefs::kGaiaCookieHash, new_hash);
-    pref_service_->SetDouble(prefs::kGaiaCookieChangedTime,
-                             Time::Now().ToDoubleT());
   } else if (currently_authenticated && !previously_authenticated_) {
     SignedInAccountRelationReport(signed_in_accounts, signed_out_accounts,
                                   ReportingType::ON_CHANGE);
@@ -258,10 +258,6 @@
   }
 
   periodic_pending_ = false;
-  pref_service_->SetDouble(prefs::kGaiaCookiePeriodicReportTime,
-                           Time::Now().ToDoubleT());
-  timer_.Start(FROM_HERE, kPeriodicReportingInterval, this,
-               &AccountInvestigator::TryPeriodicReport);
 }
 
 void AccountInvestigator::SharedCookieJarReport(
@@ -269,8 +265,7 @@
     const std::vector<ListedAccount>& signed_out_accounts,
     const Time now,
     const ReportingType type) {
-  const Time last_changed = Time::FromDoubleT(
-      pref_service_->GetDouble(prefs::kGaiaCookieChangedTime));
+  const Time last_changed = Time::Now();
   TimeDelta stable_age;
   if (!last_changed.is_null())
     stable_age = std::max(now - last_changed, TimeDelta());
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/account_investigator_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/account_investigator_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/account_investigator_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/account_investigator_unittest.cc	2025-06-03 09:58:07.000000000 +0800
@@ -12,7 +12,6 @@
 #include "build/build_config.h"
 #include "components/prefs/pref_registry_simple.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/accounts_in_cookie_jar_info.h"
 #include "components/signin/public/identity_manager/identity_test_environment.h"
 #include "components/sync_preferences/testing_pref_service_syncable.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/account_reconcilor_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/account_reconcilor_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/account_reconcilor_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/account_reconcilor_unittest.cc	2025-06-03 09:58:07.000000000 +0800
@@ -26,7 +26,6 @@
 #include "components/signin/public/base/list_accounts_test_utils.h"
 #include "components/signin/public/base/signin_buildflags.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/base/test_signin_client.h"
 #include "components/signin/public/identity_manager/accounts_in_cookie_jar_info.h"
 #include "components/signin/public/identity_manager/identity_test_environment.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/dice_account_reconcilor_delegate.cc b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/dice_account_reconcilor_delegate.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/dice_account_reconcilor_delegate.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/dice_account_reconcilor_delegate.cc	2025-06-03 09:58:07.000000000 +0800
@@ -11,7 +11,6 @@
 #include "base/stl_util.h"
 #include "components/prefs/pref_service.h"
 #include "components/signin/public/base/signin_client.h"
-#include "components/signin/public/base/signin_pref_names.h"
 
 const base::Feature kUseMultiloginEndpoint{"UseMultiloginEndpoint",
                                            base::FEATURE_DISABLED_BY_DEFAULT};
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/dice_account_reconcilor_delegate_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/dice_account_reconcilor_delegate_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/dice_account_reconcilor_delegate_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/dice_account_reconcilor_delegate_unittest.cc	2025-06-03 09:58:07.000000000 +0800
@@ -8,7 +8,6 @@
 
 #include "components/prefs/pref_registry_simple.h"
 #include "components/signin/public/base/account_consistency_method.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/base/test_signin_client.h"
 #include "components/sync_preferences/testing_pref_service_syncable.h"
 #include "google_apis/gaia/gaia_auth_util.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/signin_investigator.cc b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/signin_investigator.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/signin_investigator.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/signin_investigator.cc	2025-06-03 09:58:07.000000000 +0800
@@ -7,7 +7,6 @@
 #include "base/check.h"
 #include "base/metrics/histogram_macros.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "google_apis/gaia/gaia_auth_util.h"
 
 using signin_metrics::AccountEquality;
@@ -26,13 +25,9 @@
 SigninInvestigator::~SigninInvestigator() {}
 
 bool SigninInvestigator::AreAccountsEqualWithFallback() {
-  const std::string last_id =
-      provider_->GetPrefs()->GetString(prefs::kGoogleServicesLastAccountId);
-  bool same_email = gaia::AreEmailsSame(
-      current_email_,
-      provider_->GetPrefs()->GetString(prefs::kGoogleServicesLastUsername));
-  if (!current_id_.empty() && !last_id.empty()) {
-    bool same_id = current_id_ == last_id;
+  bool same_email = false;
+  if (false) {
+    bool same_id = false;
     if (same_email && same_id) {
       LogAccountEquality(AccountEquality::BOTH_EQUAL);
     } else if (same_email) {
@@ -51,9 +46,7 @@
 
 InvestigatedScenario SigninInvestigator::Investigate() {
   InvestigatedScenario scenario;
-  if (provider_->GetPrefs()
-          ->GetString(prefs::kGoogleServicesLastUsername)
-          .empty()) {
+  if (true) {
     scenario = InvestigatedScenario::kFirstSignIn;
   } else if (AreAccountsEqualWithFallback()) {
     scenario = InvestigatedScenario::kSameAccount;
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/signin_investigator_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/signin_investigator_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/signin_investigator_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/core/browser/signin_investigator_unittest.cc	2025-06-03 09:58:07.000000000 +0800
@@ -9,7 +9,6 @@
 #include "components/prefs/pref_registry_simple.h"
 #include "components/signin/core/browser/signin_investigator.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/identity_test_environment.h"
 #include "components/sync_preferences/testing_pref_service_syncable.h"
 #include "testing/gtest/include/gtest/gtest.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/account_tracker_service.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/account_tracker_service.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/account_tracker_service.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/account_tracker_service.cc	2025-06-05 16:17:03.000000000 +0800
@@ -26,7 +26,9 @@
 #include "components/prefs/pref_registry_simple.h"
 #include "components/prefs/scoped_user_pref_update.h"
 #include "components/signin/internal/identity_manager/account_info_util.h"
+#if !defined(__powerpc64__)
 #include "components/signin/public/base/signin_pref_names.h"
+#endif
 #include "components/signin/public/base/signin_switches.h"
 #include "ui/gfx/image/image.h"
 
@@ -115,9 +117,6 @@
 
 // static
 void AccountTrackerService::RegisterPrefs(PrefRegistrySimple* registry) {
-  registry->RegisterListPref(prefs::kAccountInfo);
-  registry->RegisterIntegerPref(prefs::kAccountIdMigrationState,
-                                AccountTrackerService::MIGRATION_NOT_STARTED);
 }
 
 void AccountTrackerService::Initialize(PrefService* pref_service,
@@ -188,11 +187,15 @@
 
 // static
 bool AccountTrackerService::IsMigrationSupported() {
+#if !defined(__powerpc64__)
 #if defined(OS_CHROMEOS)
   return base::FeatureList::IsEnabled(switches::kAccountIdMigration);
 #else
   return true;
 #endif
+#else
+  return false;
+#endif
 }
 
 AccountTrackerService::AccountIdMigrationState
@@ -400,14 +403,12 @@
 
 void AccountTrackerService::SetMigrationState(AccountIdMigrationState state) {
   DCHECK(state != MIGRATION_DONE || IsMigrationDone());
-  pref_service_->SetInteger(prefs::kAccountIdMigrationState, state);
 }
 
 // static
 AccountTrackerService::AccountIdMigrationState
 AccountTrackerService::GetMigrationState(const PrefService* pref_service) {
-  return static_cast<AccountTrackerService::AccountIdMigrationState>(
-      pref_service->GetInteger(prefs::kAccountIdMigrationState));
+  return MIGRATION_NOT_STARTED;
 }
 
 base::FilePath AccountTrackerService::GetImagePathFor(
@@ -494,11 +495,10 @@
 }
 
 void AccountTrackerService::LoadFromPrefs() {
-  const base::ListValue* list = pref_service_->GetList(prefs::kAccountInfo);
   std::set<CoreAccountId> to_remove;
-  for (size_t i = 0; i < list->GetSize(); ++i) {
+  if (false) {
     const base::DictionaryValue* dict;
-    if (list->GetDictionary(i, &dict)) {
+    while (false) {
       std::string value;
       if (dict->GetString(kAccountKeyPath, &value)) {
         // Ignore incorrectly persisted non-canonical account ids.
@@ -580,13 +580,11 @@
 }
 
 void AccountTrackerService::SaveToPrefs(const AccountInfo& account_info) {
-  if (!pref_service_)
-    return;
+  return;
 
   base::DictionaryValue* dict = nullptr;
-  ListPrefUpdate update(pref_service_, prefs::kAccountInfo);
-  for (size_t i = 0; i < update->GetSize(); ++i, dict = nullptr) {
-    if (update->GetDictionary(i, &dict)) {
+  if (false) {
+    while (false) {
       std::string value;
       if (dict->GetString(kAccountKeyPath, &value) &&
           value == account_info.account_id.ToString())
@@ -596,9 +594,6 @@
 
   if (!dict) {
     dict = new base::DictionaryValue();
-    update->Append(base::WrapUnique(dict));
-    // |dict| is invalidated at this point, so it needs to be reset.
-    update->GetDictionary(update->GetSize() - 1, &dict);
     dict->SetString(kAccountKeyPath, account_info.account_id.ToString());
   }
 
@@ -622,14 +617,12 @@
   if (!pref_service_)
     return;
 
-  ListPrefUpdate update(pref_service_, prefs::kAccountInfo);
-  for (size_t i = 0; i < update->GetSize(); ++i) {
+  if (false) {
     base::DictionaryValue* dict = nullptr;
-    if (update->GetDictionary(i, &dict)) {
+    while (false) {
       std::string value;
       if (dict->GetString(kAccountKeyPath, &value) &&
           value == account_info.account_id.ToString()) {
-        update->Remove(i, nullptr);
         break;
       }
     }
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/account_tracker_service.h b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/account_tracker_service.h
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/account_tracker_service.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/account_tracker_service.h	2025-06-03 09:58:07.000000000 +0800
@@ -234,6 +234,8 @@
   AccountInfoCallback on_account_updated_callback_;
   AccountInfoCallback on_account_removed_callback_;
 
+  AccountIdMigrationState migration_state_;
+
   // Task runner used for file operations on avatar images.
   scoped_refptr<base::SequencedTaskRunner> image_storage_task_runner_;
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/account_tracker_service_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/account_tracker_service_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/account_tracker_service_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/account_tracker_service_unittest.cc	2025-06-03 09:58:07.000000000 +0800
@@ -22,7 +22,6 @@
 #include "components/signin/internal/identity_manager/account_tracker_service.h"
 #include "components/signin/internal/identity_manager/fake_profile_oauth2_token_service.h"
 #include "components/signin/public/base/avatar_icon_util.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/base/test_signin_client.h"
 #include "components/signin/public/identity_manager/account_info.h"
 #include "google_apis/gaia/gaia_oauth_client.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/gaia_cookie_manager_service.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/gaia_cookie_manager_service.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/gaia_cookie_manager_service.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/gaia_cookie_manager_service.cc	2025-06-03 09:58:07.000000000 +0800
@@ -28,7 +28,6 @@
 #include "components/signin/internal/identity_manager/ubertoken_fetcher_impl.h"
 #include "components/signin/public/base/signin_buildflags.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/set_accounts_in_cookie_result.h"
 #include "google_apis/gaia/gaia_constants.h"
 #include "google_apis/gaia/gaia_urls.h"
@@ -440,9 +439,7 @@
       listAccountsUnexpectedServerResponseRetried_(false),
       external_cc_result_fetched_(false),
       list_accounts_stale_(true) {
-  std::string gaia_cookie_last_list_accounts_data =
-      signin_client_->GetPrefs()->GetString(
-          prefs::kGaiaCookieLastListAccountsData);
+  std::string gaia_cookie_last_list_accounts_data;
 
   if (!gaia_cookie_last_list_accounts_data.empty()) {
     if (!gaia::ParseListAccountsData(gaia_cookie_last_list_accounts_data,
@@ -465,8 +462,6 @@
 
 // static
 void GaiaCookieManagerService::RegisterPrefs(PrefRegistrySimple* registry) {
-  registry->RegisterStringPref(prefs::kGaiaCookieLastListAccountsData,
-                               std::string());
 }
 
 void GaiaCookieManagerService::InitCookieListener() {
@@ -860,16 +855,12 @@
                                    &signed_out_accounts_)) {
     listed_accounts_.clear();
     signed_out_accounts_.clear();
-    signin_client_->GetPrefs()->ClearPref(
-        prefs::kGaiaCookieLastListAccountsData);
     GoogleServiceAuthError error(
         GoogleServiceAuthError::UNEXPECTED_SERVICE_RESPONSE);
     OnListAccountsFailure(error);
     return;
   }
 
-  signin_client_->GetPrefs()->SetString(prefs::kGaiaCookieLastListAccountsData,
-                                        data);
   RecordListAccountsFailure(GoogleServiceAuthError::NONE);
 
   InitializeListedAccountsIds();
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/gaia_cookie_manager_service_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/gaia_cookie_manager_service_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/gaia_cookie_manager_service_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/gaia_cookie_manager_service_unittest.cc	2025-06-03 09:58:07.000000000 +0800
@@ -25,7 +25,6 @@
 #include "components/prefs/testing_pref_service.h"
 #include "components/signin/internal/identity_manager/account_tracker_service.h"
 #include "components/signin/internal/identity_manager/fake_profile_oauth2_token_service.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/base/test_signin_client.h"
 #include "google_apis/gaia/gaia_constants.h"
 #include "google_apis/gaia/gaia_urls.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/mutable_profile_oauth2_token_service_delegate.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/mutable_profile_oauth2_token_service_delegate.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/mutable_profile_oauth2_token_service_delegate.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/mutable_profile_oauth2_token_service_delegate.cc	2025-06-03 09:58:07.000000000 +0800
@@ -17,7 +17,6 @@
 #include "components/prefs/pref_service.h"
 #include "components/signin/public/base/signin_client.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/account_info.h"
 #include "components/signin/public/webdata/token_web_data.h"
 #include "components/webdata/common/web_data_service_base.h"
@@ -118,7 +117,7 @@
 bool ShouldMigrateToDice(signin::AccountConsistencyMethod account_consistency,
                          PrefService* prefs) {
   return account_consistency == signin::AccountConsistencyMethod::kDice &&
-         !prefs->GetBoolean(prefs::kTokenServiceDiceCompatible);
+         true;
 }
 
 }  // namespace
@@ -276,7 +275,6 @@
 // static
 void MutableProfileOAuth2TokenServiceDelegate::RegisterProfilePrefs(
     PrefRegistrySimple* registry) {
-  registry->RegisterBooleanPref(prefs::kTokenServiceDiceCompatible, false);
 }
 
 std::unique_ptr<OAuth2AccessTokenFetcher>
@@ -634,9 +632,6 @@
         UpdateCredentials(loading_primary_account_id_, old_login_token);
     }
   }
-
-  if (migrate_to_dice)
-    client_->GetPrefs()->SetBoolean(prefs::kTokenServiceDiceCompatible, true);
 }
 
 void MutableProfileOAuth2TokenServiceDelegate::UpdateCredentials(
@@ -830,8 +825,6 @@
 }
 
 void MutableProfileOAuth2TokenServiceDelegate::FinishLoadingCredentials() {
-  if (account_consistency_ == signin::AccountConsistencyMethod::kDice)
-    DCHECK(client_->GetPrefs()->GetBoolean(prefs::kTokenServiceDiceCompatible));
   FireRefreshTokensLoaded();
 }
 
@@ -862,8 +855,7 @@
                  LOAD_CREDENTIALS_FINISHED_WITH_DB_CANNOT_BE_OPENED);
 
   if (account_consistency_ == signin::AccountConsistencyMethod::kDice &&
-      !client_->GetPrefs()->GetBoolean(prefs::kTokenServiceDiceCompatible)) {
+      true) {
     RevokeAllCredentials();
-    client_->GetPrefs()->SetBoolean(prefs::kTokenServiceDiceCompatible, true);
   }
 }
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/mutable_profile_oauth2_token_service_delegate_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/mutable_profile_oauth2_token_service_delegate_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/mutable_profile_oauth2_token_service_delegate_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/mutable_profile_oauth2_token_service_delegate_unittest.cc	2025-06-03 09:58:07.000000000 +0800
@@ -24,7 +24,6 @@
 #include "components/signin/internal/identity_manager/profile_oauth2_token_service.h"
 #include "components/signin/public/base/account_consistency_method.h"
 #include "components/signin/public/base/device_id_helper.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/base/test_signin_client.h"
 #include "components/signin/public/identity_manager/account_info.h"
 #include "components/signin/public/webdata/token_web_data.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_manager.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_manager.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_manager.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_manager.cc	2025-06-05 16:18:04.000000000 +0800
@@ -20,7 +20,6 @@
 #include "components/signin/internal/identity_manager/profile_oauth2_token_service.h"
 #include "components/signin/public/base/signin_client.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/base/signin_switches.h"
 
 PrimaryAccountManager::PrimaryAccountManager(
@@ -47,24 +46,10 @@
 
 // static
 void PrimaryAccountManager::RegisterProfilePrefs(PrefRegistrySimple* registry) {
-  registry->RegisterStringPref(prefs::kGoogleServicesHostedDomain,
-                               std::string());
-  registry->RegisterStringPref(prefs::kGoogleServicesLastAccountId,
-                               std::string());
-  registry->RegisterStringPref(prefs::kGoogleServicesLastUsername,
-                               std::string());
-  registry->RegisterStringPref(prefs::kGoogleServicesAccountId, std::string());
-  registry->RegisterBooleanPref(prefs::kGoogleServicesConsentedToSync, false);
-  registry->RegisterBooleanPref(prefs::kAutologinEnabled, true);
-  registry->RegisterListPref(prefs::kReverseAutologinRejectedEmailList);
-  registry->RegisterBooleanPref(prefs::kSigninAllowed, true);
-  registry->RegisterBooleanPref(prefs::kSignedInWithCredentialProvider, false);
 }
 
 // static
 void PrimaryAccountManager::RegisterPrefs(PrefRegistrySimple* registry) {
-  registry->RegisterStringPref(prefs::kGoogleServicesUsernamePattern,
-                               std::string());
 }
 
 void PrimaryAccountManager::Initialize(PrefService* local_state) {
@@ -72,25 +57,7 @@
   DCHECK(!IsInitialized());
   initialized_ = true;
 
-  // If the user is clearing the token service from the command line, then
-  // clear their login info also (not valid to be logged in without any
-  // tokens).
-  base::CommandLine* cmd_line = base::CommandLine::ForCurrentProcess();
-  if (cmd_line->HasSwitch(switches::kClearTokenService))
-    SetPrimaryAccountInternal(CoreAccountInfo(), false);
-
-  std::string pref_account_id =
-      client_->GetPrefs()->GetString(prefs::kGoogleServicesAccountId);
-
-  // Initial value for the kGoogleServicesConsentedToSync preference if it is
-  // missing.
-  const PrefService::Preference* consented_pref =
-      client_->GetPrefs()->FindPreference(
-          prefs::kGoogleServicesConsentedToSync);
-  if (consented_pref->IsDefaultValue()) {
-    client_->GetPrefs()->SetBoolean(prefs::kGoogleServicesConsentedToSync,
-                                    !pref_account_id.empty());
-  }
+  std::string pref_account_id;
 
   if (!pref_account_id.empty()) {
     if (account_tracker_service_->GetMigrationState() ==
@@ -100,14 +67,11 @@
       // |account_info.gaia| could be empty if |account_id| is already gaia id.
       if (!account_info.gaia.empty()) {
         pref_account_id = account_info.gaia;
-        client_->GetPrefs()->SetString(prefs::kGoogleServicesAccountId,
-                                       account_info.gaia);
       }
     }
   }
 
-  bool consented =
-      client_->GetPrefs()->GetBoolean(prefs::kGoogleServicesConsentedToSync);
+  bool consented = false;
   CoreAccountId account_id = CoreAccountId::FromString(pref_account_id);
   CoreAccountInfo account_info =
       account_tracker_service_->GetAccountInfo(account_id);
@@ -176,8 +140,7 @@
 
 #if DCHECK_IS_ON()
   {
-    std::string pref_account_id =
-        client_->GetPrefs()->GetString(prefs::kGoogleServicesAccountId);
+    std::string pref_account_id;
     bool consented_to_sync =
         client_->GetPrefs()->GetBoolean(prefs::kGoogleServicesConsentedToSync);
 
@@ -193,10 +156,6 @@
   // Go ahead and update the last signed in account info here as well. Once a
   // user is signed in the corresponding preferences should match. Doing it here
   // as opposed to on signin allows us to catch the upgrade scenario.
-  client_->GetPrefs()->SetString(prefs::kGoogleServicesLastAccountId,
-                                 account_info.account_id.ToString());
-  client_->GetPrefs()->SetString(prefs::kGoogleServicesLastUsername,
-                                 account_info.email);
 
   // Commit authenticated account info immediately so that it does not get lost
   // if Chrome crashes before the next commit interval.
@@ -210,19 +169,10 @@
 
   PrefService* prefs = client_->GetPrefs();
   const std::string& account_id = primary_account_info_.account_id.ToString();
-  if (account_id.empty()) {
-    DCHECK(!consented_to_sync);
-    prefs->ClearPref(prefs::kGoogleServicesAccountId);
-    prefs->ClearPref(prefs::kGoogleServicesConsentedToSync);
-  } else {
-    prefs->SetString(prefs::kGoogleServicesAccountId, account_id);
-    prefs->SetBoolean(prefs::kGoogleServicesConsentedToSync, consented_to_sync);
-  }
 }
 
 bool PrimaryAccountManager::IsAuthenticated() const {
-  bool consented_pref =
-      client_->GetPrefs()->GetBoolean(prefs::kGoogleServicesConsentedToSync);
+  bool consented_pref = false;
   DCHECK(!consented_pref || !primary_account_info().account_id.empty());
   return consented_pref;
 }
@@ -352,7 +302,9 @@
   }
 
   const CoreAccountInfo account_info = primary_account_info();
+#if !defined(__powerpc64__)
   client_->GetPrefs()->ClearPref(prefs::kGoogleServicesHostedDomain);
+#endif
   // Revoke the sync consent.
   if (IsAuthenticated())
     SetPrimaryAccountInternal(account_info, /*consented_to_sync=*/false);
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_manager_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_manager_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_manager_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_manager_unittest.cc	2025-06-03 09:58:07.000000000 +0800
@@ -23,7 +23,6 @@
 #include "components/signin/internal/identity_manager/primary_account_policy_manager.h"
 #include "components/signin/internal/identity_manager/profile_oauth2_token_service.h"
 #include "components/signin/public/base/account_consistency_method.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/base/test_signin_client.h"
 #include "components/sync_preferences/testing_pref_service_syncable.h"
 #include "testing/gtest/include/gtest/gtest.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_mutator_impl.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_mutator_impl.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_mutator_impl.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_mutator_impl.cc	2025-06-03 09:58:07.000000000 +0800
@@ -11,7 +11,6 @@
 #include "components/signin/internal/identity_manager/account_tracker_service.h"
 #include "components/signin/internal/identity_manager/primary_account_manager.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "google_apis/gaia/core_account_id.h"
 
 namespace signin {
@@ -35,7 +34,7 @@
   AccountInfo account_info = account_tracker_->GetAccountInfo(account_id);
 
 #if !defined(OS_CHROMEOS)
-  if (!pref_service_->GetBoolean(prefs::kSigninAllowed))
+  if (true)
     return false;
 
   if (primary_account_manager_->IsAuthenticated())
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_policy_manager_impl.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_policy_manager_impl.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_policy_manager_impl.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_policy_manager_impl.cc	2025-06-05 16:19:18.000000000 +0800
@@ -9,7 +9,6 @@
 #include "components/signin/internal/identity_manager/primary_account_manager.h"
 #include "components/signin/public/base/signin_client.h"
 #include "components/signin/public/base/signin_metrics.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/account_info.h"
 #include "components/signin/public/identity_manager/identity_utils.h"
 
@@ -27,18 +26,22 @@
   // local_state can be null during unit tests.
   if (local_state) {
     local_state_pref_registrar_.Init(local_state);
+#if !defined(__powerpc64__)
     local_state_pref_registrar_.Add(
         prefs::kGoogleServicesUsernamePattern,
         base::BindRepeating(&PrimaryAccountPolicyManagerImpl::
                                 OnGoogleServicesUsernamePatternChanged,
                             weak_pointer_factory_.GetWeakPtr(),
                             primary_account_manager));
+#endif
   }
+#if !defined(__powerpc64__)
   signin_allowed_.Init(
       prefs::kSigninAllowed, client_->GetPrefs(),
       base::BindRepeating(
           &PrimaryAccountPolicyManagerImpl::OnSigninAllowedPrefChanged,
           base::Unretained(this), primary_account_manager));
+#endif
 
   CoreAccountInfo account_info =
       primary_account_manager->GetAuthenticatedAccountInfo();
@@ -81,7 +84,7 @@
 }
 
 bool PrimaryAccountPolicyManagerImpl::IsSigninAllowed() const {
-  return signin_allowed_.GetValue();
+  return false;
 }
 
 void PrimaryAccountPolicyManagerImpl::OnSigninAllowedPrefChanged(
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_policy_manager_impl.h b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_policy_manager_impl.h
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_policy_manager_impl.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_policy_manager_impl.h	2025-06-03 09:58:07.000000000 +0800
@@ -50,9 +50,6 @@
   // profile-specific local prefs (like kGoogleServicesUsernamePattern).
   PrefChangeRegistrar local_state_pref_registrar_;
 
-  // Helper object to listen for changes to the signin allowed preference.
-  BooleanPrefMember signin_allowed_;
-
   base::WeakPtrFactory<PrimaryAccountPolicyManagerImpl> weak_pointer_factory_{
       this};
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_policy_manager_impl_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_policy_manager_impl_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_policy_manager_impl_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/primary_account_policy_manager_impl_unittest.cc	2025-06-03 09:58:07.000000000 +0800
@@ -15,7 +15,6 @@
 #include "components/signin/internal/identity_manager/primary_account_policy_manager_impl.h"
 #include "components/signin/internal/identity_manager/profile_oauth2_token_service.h"
 #include "components/signin/public/base/account_consistency_method.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/base/test_signin_client.h"
 #include "components/sync_preferences/testing_pref_service_syncable.h"
 #include "testing/gtest/include/gtest/gtest.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service.cc	2025-06-03 09:58:07.000000000 +0800
@@ -11,7 +11,6 @@
 #include "components/prefs/pref_registry_simple.h"
 #include "components/signin/internal/identity_manager/profile_oauth2_token_service_delegate.h"
 #include "components/signin/public/base/device_id_helper.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "google_apis/gaia/gaia_constants.h"
 #include "google_apis/gaia/google_service_auth_error.h"
 #include "google_apis/gaia/oauth2_access_token_consumer.h"
@@ -131,13 +130,6 @@
 // static
 void ProfileOAuth2TokenService::RegisterProfilePrefs(
     PrefRegistrySimple* registry) {
-#if defined(OS_IOS)
-  registry->RegisterBooleanPref(prefs::kTokenServiceExcludeAllSecondaryAccounts,
-                                false);
-  registry->RegisterListPref(prefs::kTokenServiceExcludedSecondaryAccounts);
-#endif
-  registry->RegisterStringPref(prefs::kGoogleServicesSigninScopedDeviceId,
-                               std::string());
 }
 
 ProfileOAuth2TokenServiceDelegate* ProfileOAuth2TokenService::GetDelegate() {
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service_delegate_chromeos_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service_delegate_chromeos_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service_delegate_chromeos_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service_delegate_chromeos_unittest.cc	2025-06-03 09:58:07.000000000 +0800
@@ -19,7 +19,6 @@
 #include "chromeos/components/account_manager/tokens.pb.h"
 #include "components/signin/internal/identity_manager/account_tracker_service.h"
 #include "components/signin/internal/identity_manager/profile_oauth2_token_service_observer.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/base/test_signin_client.h"
 #include "components/signin/public/identity_manager/account_info.h"
 #include "components/sync_preferences/testing_pref_service_syncable.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service_delegate_ios.mm b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service_delegate_ios.mm
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service_delegate_ios.mm	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service_delegate_ios.mm	2025-06-03 09:58:07.000000000 +0800
@@ -18,7 +18,6 @@
 #include "components/prefs/scoped_user_pref_update.h"
 #include "components/signin/internal/identity_manager/account_tracker_service.h"
 #include "components/signin/public/base/signin_client.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/account_info.h"
 #include "components/signin/public/identity_manager/ios/device_accounts_provider.h"
 #include "google_apis/gaia/oauth2_access_token_fetcher.h"
@@ -368,7 +367,4 @@
 }
 
 void ProfileOAuth2TokenServiceIOSDelegate::ClearExcludedSecondaryAccounts() {
-  client_->GetPrefs()->ClearPref(
-      prefs::kTokenServiceExcludeAllSecondaryAccounts);
-  client_->GetPrefs()->ClearPref(prefs::kTokenServiceExcludedSecondaryAccounts);
 }
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service_delegate_ios_unittest.mm b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service_delegate_ios_unittest.mm
--- a/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service_delegate_ios_unittest.mm	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/internal/identity_manager/profile_oauth2_token_service_delegate_ios_unittest.mm	2025-06-03 09:58:07.000000000 +0800
@@ -11,7 +11,6 @@
 #include "components/prefs/testing_pref_service.h"
 #include "components/signin/internal/identity_manager/account_tracker_service.h"
 #include "components/signin/internal/identity_manager/profile_oauth2_token_service_observer.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/base/test_signin_client.h"
 #include "components/signin/public/identity_manager/ios/fake_device_accounts_provider.h"
 #include "google_apis/gaia/gaia_urls.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/public/base/BUILD.gn b/qtwebengine/src/3rdparty/chromium/components/signin/public/base/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/components/signin/public/base/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/public/base/BUILD.gn	2025-06-03 09:58:07.000000000 +0800
@@ -33,8 +33,6 @@
     "signin_client.h",
     "signin_metrics.cc",
     "signin_metrics.h",
-    "signin_pref_names.cc",
-    "signin_pref_names.h",
     "signin_switches.cc",
     "signin_switches.h",
   ]
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/public/base/device_id_helper.cc b/qtwebengine/src/3rdparty/chromium/components/signin/public/base/device_id_helper.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/public/base/device_id_helper.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/public/base/device_id_helper.cc	2025-06-03 09:58:07.000000000 +0800
@@ -8,7 +8,6 @@
 #include "base/command_line.h"
 #include "base/guid.h"
 #include "components/prefs/pref_service.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/base/signin_switches.h"
 
 namespace signin {
@@ -16,19 +15,12 @@
 #if !defined(OS_CHROMEOS)
 
 std::string GetSigninScopedDeviceId(PrefService* prefs) {
-  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kDisableSigninScopedDeviceId)) {
-    return std::string();
-  }
-
-  return GetOrCreateScopedDeviceId(prefs);
+  return std::string();
 }
 
 std::string RecreateSigninScopedDeviceId(PrefService* prefs) {
   std::string signin_scoped_device_id = GenerateSigninScopedDeviceId();
   DCHECK(!signin_scoped_device_id.empty());
-  prefs->SetString(prefs::kGoogleServicesSigninScopedDeviceId,
-                   signin_scoped_device_id);
   return signin_scoped_device_id;
 }
 
@@ -37,13 +29,7 @@
 }
 
 std::string GetOrCreateScopedDeviceId(PrefService* prefs) {
-  std::string signin_scoped_device_id =
-      prefs->GetString(prefs::kGoogleServicesSigninScopedDeviceId);
-  if (signin_scoped_device_id.empty()) {
-    // If device_id doesn't exist then generate new and save in prefs.
-    signin_scoped_device_id = RecreateSigninScopedDeviceId(prefs);
-  }
-  return signin_scoped_device_id;
+  return RecreateSigninScopedDeviceId(prefs);
 }
 
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/public/base/device_id_helper_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/public/base/device_id_helper_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/public/base/device_id_helper_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/public/base/device_id_helper_unittest.cc	2025-06-03 09:58:07.000000000 +0800
@@ -7,7 +7,6 @@
 #include <string>
 
 #include "build/build_config.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "components/sync_preferences/testing_pref_service_syncable.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -23,40 +22,23 @@
 
 TEST(DeviceIdHelper, RecreateSigninScopedDeviceId) {
   sync_preferences::TestingPrefServiceSyncable prefs;
-  prefs.registry()->RegisterStringPref(
-      prefs::kGoogleServicesSigninScopedDeviceId, std::string());
-  ASSERT_TRUE(
-      prefs.GetString(prefs::kGoogleServicesSigninScopedDeviceId).empty());
 
   std::string device_id_1 = RecreateSigninScopedDeviceId(&prefs);
   EXPECT_FALSE(device_id_1.empty());
-  EXPECT_EQ(device_id_1,
-            prefs.GetString(prefs::kGoogleServicesSigninScopedDeviceId));
 
   std::string device_id_2 = RecreateSigninScopedDeviceId(&prefs);
   EXPECT_FALSE(device_id_2.empty());
   EXPECT_NE(device_id_1, device_id_2);
-  EXPECT_EQ(device_id_2,
-            prefs.GetString(prefs::kGoogleServicesSigninScopedDeviceId));
 }
 
 TEST(DeviceIdHelper, GetOrCreateScopedDeviceId) {
   sync_preferences::TestingPrefServiceSyncable prefs;
-  prefs.registry()->RegisterStringPref(
-      prefs::kGoogleServicesSigninScopedDeviceId, std::string());
-
-  ASSERT_TRUE(
-      prefs.GetString(prefs::kGoogleServicesSigninScopedDeviceId).empty());
 
   std::string device_id_1 = GetOrCreateScopedDeviceId(&prefs);
   EXPECT_FALSE(device_id_1.empty());
-  EXPECT_EQ(device_id_1,
-            prefs.GetString(prefs::kGoogleServicesSigninScopedDeviceId));
 
   std::string device_id_2 = GetOrCreateScopedDeviceId(&prefs);
   EXPECT_EQ(device_id_1, device_id_2);
-  EXPECT_EQ(device_id_2,
-            prefs.GetString(prefs::kGoogleServicesSigninScopedDeviceId));
 }
 
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/public/identity_manager/identity_utils.cc b/qtwebengine/src/3rdparty/chromium/components/signin/public/identity_manager/identity_utils.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/public/identity_manager/identity_utils.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/public/identity_manager/identity_utils.cc	2025-06-03 09:58:07.000000000 +0800
@@ -11,7 +11,6 @@
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "components/prefs/pref_service.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "third_party/icu/source/i18n/unicode/regex.h"
 
 namespace signin {
@@ -56,8 +55,7 @@
 
 bool IsUsernameAllowedByPatternFromPrefs(const PrefService* prefs,
                                          const std::string& username) {
-  return IsUsernameAllowedByPattern(
-      username, prefs->GetString(prefs::kGoogleServicesUsernamePattern));
+  return true;
 }
 
 }  // namespace signin
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/public/identity_manager/identity_utils_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/public/identity_manager/identity_utils_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/public/identity_manager/identity_utils_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/public/identity_manager/identity_utils_unittest.cc	2025-06-03 09:58:07.000000000 +0800
@@ -7,7 +7,6 @@
 #include "components/prefs/pref_registry_simple.h"
 #include "components/prefs/pref_service.h"
 #include "components/prefs/testing_pref_service.h"
-#include "components/signin/public/base/signin_pref_names.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace {
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/signin/public/identity_manager/primary_account_mutator_unittest.cc b/qtwebengine/src/3rdparty/chromium/components/signin/public/identity_manager/primary_account_mutator_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/components/signin/public/identity_manager/primary_account_mutator_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/signin/public/identity_manager/primary_account_mutator_unittest.cc	2025-06-05 16:19:45.000000000 +0800
@@ -11,7 +11,9 @@
 #include "base/test/task_environment.h"
 #include "build/build_config.h"
 #include "components/signin/public/base/signin_metrics.h"
+#if !defined(__powerpc64__)
 #include "components/signin/public/base/signin_pref_names.h"
+#endif
 #include "components/signin/public/identity_manager/consent_level.h"
 #include "components/signin/public/identity_manager/identity_test_environment.h"
 #include "components/signin/public/identity_manager/identity_test_utils.h"
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/url_formatter/url_fixer.cc b/qtwebengine/src/3rdparty/chromium/components/url_formatter/url_fixer.cc
--- a/qtwebengine/src/3rdparty/chromium/components/url_formatter/url_fixer.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/url_formatter/url_fixer.cc	2025-06-03 10:48:03.000000000 +0800
@@ -560,6 +560,10 @@
     }
   }
 
+  if (scheme == url::kTraceScheme) {
+    return GURL();
+  }
+
   // We handle the file scheme separately.
   if (scheme == url::kFileScheme)
     return GURL(parts.scheme.is_valid() ? text : FixupPath(text));
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/variations/net/variations_http_headers.cc b/qtwebengine/src/3rdparty/chromium/components/variations/net/variations_http_headers.cc
--- a/qtwebengine/src/3rdparty/chromium/components/variations/net/variations_http_headers.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/variations/net/variations_http_headers.cc	2025-06-03 10:39:54.000000000 +0800
@@ -27,10 +27,6 @@
 
 namespace variations {
 
-// The name string for the header for variations information.
-// Note that prior to M33 this header was named X-Chrome-Variations.
-const char kClientDataHeader[] = "X-Client-Data";
-
 namespace {
 
 // The result of checking whether a request to a URL should have variations
@@ -236,29 +232,7 @@
   }
 
   bool AppendHeaderIfNeeded(const GURL& url, InIncognito incognito) {
-    AppendOmniboxOnDeviceSuggestionsHeaderIfNeeded(url, resource_request_);
-
-    // Note the criteria for attaching client experiment headers:
-    // 1. We only transmit to Google owned domains which can evaluate
-    // experiments.
-    //    1a. These include hosts which have a standard postfix such as:
-    //         *.doubleclick.net or *.googlesyndication.com or
-    //         exactly www.googleadservices.com or
-    //         international TLD domains *.google.<TLD> or *.youtube.<TLD>.
-    // 2. Only transmit for non-Incognito profiles.
-    // 3. For the X-Client-Data header, only include non-empty variation IDs.
-    if ((incognito == InIncognito::kYes) ||
-        !ShouldAppendVariationsHeader(url, "Append"))
-      return false;
-
-    if (variations_header_.empty())
-      return false;
-
-    // Set the variations header to cors_exempt_headers rather than headers
-    // to be exempted from CORS checks.
-    resource_request_->cors_exempt_headers.SetHeaderIfMissing(
-        kClientDataHeader, variations_header_);
-    return true;
+    return false;
   }
 
  private:
@@ -328,8 +302,6 @@
     const net::RedirectInfo& redirect_info,
     const network::mojom::URLResponseHead& response_head,
     std::vector<std::string>* to_be_removed_headers) {
-  if (!ShouldAppendVariationsHeader(redirect_info.new_url, "Remove"))
-    to_be_removed_headers->push_back(kClientDataHeader);
 }
 
 std::unique_ptr<network::SimpleURLLoader>
@@ -359,14 +331,11 @@
 }
 
 bool IsVariationsHeader(const std::string& header_name) {
-  return header_name == kClientDataHeader ||
-         header_name == kOmniboxOnDeviceSuggestionsHeader;
+  return false;
 }
 
 bool HasVariationsHeader(const network::ResourceRequest& request) {
-  // Note: kOmniboxOnDeviceSuggestionsHeader is not listed because this function
-  // is only used for testing.
-  return request.cors_exempt_headers.HasHeader(kClientDataHeader);
+  return false;
 }
 
 bool ShouldAppendVariationsHeaderForTesting(
@@ -377,12 +346,6 @@
 
 void UpdateCorsExemptHeaderForVariations(
     network::mojom::NetworkContextParams* params) {
-  params->cors_exempt_header_list.push_back(kClientDataHeader);
-
-  if (base::FeatureList::IsEnabled(kReportOmniboxOnDeviceSuggestionsHeader)) {
-    params->cors_exempt_header_list.push_back(
-        kOmniboxOnDeviceSuggestionsHeader);
-  }
 }
 
 }  // namespace variations
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/variations/variations_url_constants.cc b/qtwebengine/src/3rdparty/chromium/components/variations/variations_url_constants.cc
--- a/qtwebengine/src/3rdparty/chromium/components/variations/variations_url_constants.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/variations/variations_url_constants.cc	2025-06-03 10:27:01.000000000 +0800
@@ -8,7 +8,7 @@
 
 // Default server of Variations seed info.
 const char kDefaultServerUrl[] =
-    "https://clientservices.googleapis.com/chrome-variations/seed";
+    "trk:142:https://clientservices.googleapis.com/chrome-variations/seed";
 
 const char kDefaultInsecureServerUrl[] =
     "http://clientservices.googleapis.com/chrome-variations/seed";
diff -Naur a/qtwebengine/src/3rdparty/chromium/components/web_resource/web_resource_service.cc b/qtwebengine/src/3rdparty/chromium/components/web_resource/web_resource_service.cc
--- a/qtwebengine/src/3rdparty/chromium/components/web_resource/web_resource_service.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/components/web_resource/web_resource_service.cc	2025-06-03 10:19:44.000000000 +0800
@@ -120,44 +120,7 @@
 // Initializes the fetching of data from the resource server.  Data
 // load calls OnSimpleLoaderComplete.
 void WebResourceService::StartFetch() {
-  // Set to false so that next fetch can be scheduled after this fetch or
-  // if we receive notification that resource is allowed.
-  fetch_scheduled_ = false;
-  // Check whether fetching is allowed.
-  if (!resource_request_allowed_notifier_->ResourceRequestsAllowed())
-    return;
-
-  // First, put our next cache load on the MessageLoop.
-  ScheduleFetch(cache_update_delay_ms_);
-
-  // Set cache update time in preferences.
-  prefs_->SetString(last_update_time_pref_name_,
-                    base::NumberToString(base::Time::Now().ToDoubleT()));
-
-  // If we are still fetching data, exit.
-  if (in_fetch_)
-    return;
-  in_fetch_ = true;
-
-  GURL web_resource_server =
-      application_locale_.empty()
-          ? web_resource_server_
-          : google_util::AppendGoogleLocaleParam(web_resource_server_,
-                                                 application_locale_);
-
-  DVLOG(1) << "WebResourceService StartFetch " << web_resource_server;
-  auto resource_request = std::make_unique<network::ResourceRequest>();
-  resource_request->url = web_resource_server;
-  // Do not let url fetcher affect existing state in system context
-  // (by setting cookies, for example).
-  resource_request->load_flags = net::LOAD_DISABLE_CACHE;
-  resource_request->credentials_mode = network::mojom::CredentialsMode::kOmit;
-  simple_url_loader_ = network::SimpleURLLoader::Create(
-      std::move(resource_request), traffic_annotation_);
-  simple_url_loader_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(
-      url_loader_factory_.get(),
-      base::BindOnce(&WebResourceService::OnSimpleLoaderComplete,
-                     base::Unretained(this)));
+  in_fetch_ = false;
 }
 
 void WebResourceService::EndFetch() {
diff -Naur a/qtwebengine/src/3rdparty/chromium/content/browser/child_process_security_policy_impl.cc b/qtwebengine/src/3rdparty/chromium/content/browser/child_process_security_policy_impl.cc
--- a/qtwebengine/src/3rdparty/chromium/content/browser/child_process_security_policy_impl.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/content/browser/child_process_security_policy_impl.cc	2025-06-03 10:48:03.000000000 +0800
@@ -760,6 +760,7 @@
 #endif  // BUILDFLAG(ENABLE_WEBSOCKETS)
   RegisterWebSafeScheme(url::kFtpScheme);
   RegisterWebSafeScheme(url::kDataScheme);
+  RegisterWebSafeScheme(url::kTraceScheme);
   RegisterWebSafeScheme("feed");
 
   // TODO(nick): https://crbug.com/651534 blob: and filesystem: schemes embed
diff -Naur a/qtwebengine/src/3rdparty/chromium/content/browser/speech/speech_recognition_engine.cc b/qtwebengine/src/3rdparty/chromium/content/browser/speech/speech_recognition_engine.cc
--- a/qtwebengine/src/3rdparty/chromium/content/browser/speech/speech_recognition_engine.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/content/browser/speech/speech_recognition_engine.cc	2025-06-03 10:27:01.000000000 +0800
@@ -30,7 +30,7 @@
 namespace {
 
 const char kWebServiceBaseUrl[] =
-    "https://www.google.com/speech-api/full-duplex/v1";
+    "trk:184:https://www.google.com/speech-api/full-duplex/v1";
 const char kDownstreamUrl[] = "/down?";
 const char kUpstreamUrl[] = "/up?";
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/content/browser/webauth/authenticator_common.cc b/qtwebengine/src/3rdparty/chromium/content/browser/webauth/authenticator_common.cc
--- a/qtwebengine/src/3rdparty/chromium/content/browser/webauth/authenticator_common.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/content/browser/webauth/authenticator_common.cc	2025-06-03 10:27:01.000000000 +0800
@@ -184,9 +184,9 @@
   // special-case AppIDs. Firefox also does this:
   // https://groups.google.com/forum/#!msg/mozilla.dev.platform/Uiu3fwnA2xw/201ynAiPAQAJ
   const GURL kGstatic1 =
-      GURL("https://www.gstatic.com/securitykey/origins.json");
+      GURL("trk:276:https://www.gstatic.com/securitykey/origins.json");
   const GURL kGstatic2 =
-      GURL("https://www.gstatic.com/securitykey/a/google.com/origins.json");
+      GURL("trk:277:https://www.gstatic.com/securitykey/a/google.com/origins.json");
   DCHECK(kGstatic1.is_valid() && kGstatic2.is_valid());
 
   if (origin.DomainIs("google.com") && !appid_url.has_ref() &&
diff -Naur a/qtwebengine/src/3rdparty/chromium/content/gpu/BUILD.gn b/qtwebengine/src/3rdparty/chromium/content/gpu/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/content/gpu/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/content/gpu/BUILD.gn	2025-06-05 14:45:30.000000000 +0800
@@ -131,7 +131,7 @@
   }
 
   # Use DRI on desktop Linux builds.
-  if (current_cpu != "s390x" && current_cpu != "ppc64" && is_desktop_linux &&
+  if (current_cpu != "s390x" && current_cpu != "ppc64" && current_cpu != "ppc64le" && is_desktop_linux &&
       (!is_chromecast || is_cast_desktop_build) && !use_qt) {
     configs += [ "//build/config/linux/dri" ]
   }
diff -Naur a/qtwebengine/src/3rdparty/chromium/.cpfcache b/qtwebengine/src/3rdparty/chromium/.cpfcache
--- a/qtwebengine/src/3rdparty/chromium/.cpfcache	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/.cpfcache	2025-06-03 14:19:56.000000000 +0800
@@ -0,0 +1 @@
+{".": ["sandbox/0001-sandbox-linux-bpf_dsl-Update-syscall-ranges-for-ppc6.patch", "third_party/0001-third_party-boringssl-Properly-detect-ppc64le-in-BUI.patch", "webrtc/Rtc_base-system-arch.h-PPC.patch", "libaom/0001-Add-ppc64-target-to-libaom.patch"]}
\ No newline at end of file
diff -Naur a/qtwebengine/src/3rdparty/chromium/.cpfcache.bak b/qtwebengine/src/3rdparty/chromium/.cpfcache.bak
--- a/qtwebengine/src/3rdparty/chromium/.cpfcache.bak	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/.cpfcache.bak	2025-05-30 15:30:16.000000000 +0800
@@ -0,0 +1 @@
+{".": ["sandbox/0001-linux-seccomp-bpf-ppc64-glibc-workaround-in-SIGSYS-h.patch", "sandbox/0001-sandbox-Enable-seccomp_bpf-for-ppc64.patch", "sandbox/0001-sandbox-linux-bpf_dsl-Update-syscall-ranges-for-ppc6.patch", "sandbox/0001-sandbox-linux-Implement-partial-support-for-ppc64-sy.patch", "sandbox/0001-sandbox-linux-Update-IsSyscallAllowed-in-broker_proc.patch", "sandbox/0001-sandbox-linux-Update-syscall-helpers-lists-for-ppc64.patch", "sandbox/0002-sandbox-linux-bpf_dsl-Modify-seccomp_macros-to-add-s.patch", "sandbox/0003-sandbox-linux-system_headers-Update-linux-seccomp-he.patch", "sandbox/0004-sandbox-linux-system_headers-Update-linux-signal-hea.patch", "sandbox/0005-sandbox-linux-seccomp-bpf-Add-ppc64-syscall-stub.patch", "sandbox/0005-sandbox-linux-update-unit-test-for-ppc64.patch", "sandbox/Sandbox-linux-services-credentials.cc-PPC.patch", "third_party/0000-third_party-closure_compiler-Use-system-jvm.patch", "third_party/0001-Reenable-VSX-in-libpng.patch", "third_party/0001-third_party-angle-Include-missing-header-cstddef-in-.patch", "third_party/0001-third_party-boringssl-Properly-detect-ppc64le-in-BUI.patch", "third_party/0001-third_party-libvpx-Properly-generate-gni-on-ppc64.patch", "third_party/0001-third_party-lss-Don-t-look-for-mmap2-on-ppc64.patch", "third_party/0001-third_party-pffft-Include-altivec.h-on-ppc64-with-SI.patch", "webrtc/Modules-desktop_capture-differ_block.cc-PPC.patch", "webrtc/Rtc_base-system-arch.h-PPC.patch", "crashpad/0002-Include-cstddef-to-fix-build.patch", "workarounds/HACK-third_party-libvpx-use-generic-gnu.patch", "libaom/0001-Add-ppc64-target-to-libaom.patch", "libaom/0001-Add-pregenerated-config-for-libaom-on-ppc64.patch"], "third_party/sqlite/src": ["database/0001-Properly-detect-little-endian-PPC64-systems.patch"], "third_party/ffmpeg": ["ffmpeg/0001-Add-support-for-ppc64.patch"], "third_party/breakpad/breakpad": ["breakpad/0001-Implement-ppc64-support-on-linux.patch"], "third_party/libdrm/src": ["third_party/0001-xf86drm.c-Fix-build-on-newer-glibc.patch"], "v8": ["third_party/0001-Force-baseline-POWER8-AltiVec-VSX-CPU-features-when-.patch"]}
\ No newline at end of file
diff -Naur a/qtwebengine/src/3rdparty/chromium/extensions/browser/updater/extension_downloader.cc b/qtwebengine/src/3rdparty/chromium/extensions/browser/updater/extension_downloader.cc
--- a/qtwebengine/src/3rdparty/chromium/extensions/browser/updater/extension_downloader.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/extensions/browser/updater/extension_downloader.cc	2025-06-03 10:48:34.000000000 +0800
@@ -95,27 +95,18 @@
 const char kDefaultInstallSource[] = "";
 const char kReinstallInstallSource[] = "reinstall";
 
-const char kGoogleDotCom[] = "google.com";
 const char kTokenServiceConsumerId[] = "extension_downloader";
 const char kWebstoreOAuth2Scope[] =
-    "https://www.googleapis.com/auth/chromewebstore.readonly";
+    "trk:10:https://www.googleapis.com/auth/chromewebstore.readonly";
 
 ExtensionDownloaderTestDelegate* g_test_delegate = nullptr;
 
 #define RETRY_HISTOGRAM(name, retry_count, url)                           \
-  if ((url).DomainIs(kGoogleDotCom)) {                                    \
-    UMA_HISTOGRAM_CUSTOM_COUNTS("Extensions." name "RetryCountGoogleUrl", \
-                                retry_count,                              \
-                                1,                                        \
-                                kMaxRetries,                              \
-                                kMaxRetries + 1);                         \
-  } else {                                                                \
     UMA_HISTOGRAM_CUSTOM_COUNTS("Extensions." name "RetryCountOtherUrl",  \
                                 retry_count,                              \
                                 1,                                        \
                                 kMaxRetries,                              \
-                                kMaxRetries + 1);                         \
-  }
+                                kMaxRetries + 1);
 
 bool ShouldRetryRequest(const network::SimpleURLLoader* loader) {
   DCHECK(loader);
@@ -332,12 +323,6 @@
   ReportStats();
   url_stats_ = URLStats();
 
-  for (auto it = fetches_preparing_.begin(); it != fetches_preparing_.end();
-       ++it) {
-    std::vector<std::unique_ptr<ManifestFetchData>>& list = it->second;
-    for (size_t i = 0; i < list.size(); ++i)
-      StartUpdateCheck(std::move(list[i]));
-  }
   fetches_preparing_.clear();
 }
 
@@ -376,11 +361,6 @@
     return false;
   }
 
-  // Make sure we use SSL for store-hosted extensions.
-  if (extension_urls::IsWebstoreUpdateUrl(update_url) &&
-      !update_url.SchemeIsCryptographic())
-    update_url = extension_urls::GetWebstoreUpdateUrl();
-
   // Skip extensions with empty IDs.
   if (id.empty()) {
     DLOG(WARNING) << "Found extension with empty ID";
@@ -389,12 +369,10 @@
     return false;
   }
 
-  if (update_url.DomainIs(kGoogleDotCom)) {
-    url_stats_.google_url_count++;
-  } else if (update_url.is_empty()) {
+  if (update_url.is_empty()) {
     url_stats_.no_url_count++;
     // Fill in default update URL.
-    update_url = extension_urls::GetWebstoreUpdateUrl();
+    update_url = GURL("chrome://blank/");
   } else {
     url_stats_.other_url_count++;
   }
@@ -866,20 +844,6 @@
         update->info);
   }
 
-  // If the manifest response included a <daystart> element, we want to save
-  // that value for any extensions which had sent a ping in the request.
-  if (fetch_data->base_url().DomainIs(kGoogleDotCom) &&
-      results->daystart_elapsed_seconds >= 0) {
-    Time day_start =
-        Time::Now() - TimeDelta::FromSeconds(results->daystart_elapsed_seconds);
-
-    for (const ExtensionId& id : extension_ids) {
-      ExtensionDownloaderDelegate::PingResult& result = ping_results_[id];
-      result.did_ping = fetch_data->DidPing(id, ManifestFetchData::ROLLCALL);
-      result.day_start = day_start;
-    }
-  }
-
   NotifyExtensionsDownloadStageChanged(
       no_updates, ExtensionDownloaderDelegate::Stage::FINISHED);
   NotifyExtensionsDownloadFailed(
@@ -1428,11 +1392,7 @@
   // fetch.
   switch (fetch->credentials) {
     case ExtensionFetch::CREDENTIALS_NONE:
-      if (fetch->url.DomainIs(kGoogleDotCom) && identity_manager_) {
-        fetch->credentials = ExtensionFetch::CREDENTIALS_OAUTH2_TOKEN;
-      } else {
-        fetch->credentials = ExtensionFetch::CREDENTIALS_COOKIES;
-      }
+      fetch->credentials = ExtensionFetch::CREDENTIALS_COOKIES;
       return true;
     case ExtensionFetch::CREDENTIALS_OAUTH2_TOKEN:
       fetch->oauth2_attempt_count++;
diff -Naur a/qtwebengine/src/3rdparty/chromium/extensions/common/extension_urls.cc b/qtwebengine/src/3rdparty/chromium/extensions/common/extension_urls.cc
--- a/qtwebengine/src/3rdparty/chromium/extensions/common/extension_urls.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/extensions/common/extension_urls.cc	2025-06-03 10:27:02.000000000 +0800
@@ -26,9 +26,9 @@
 
 namespace extension_urls {
 
-const char kChromeWebstoreBaseURL[] = "https://chrome.google.com/webstore";
+const char kChromeWebstoreBaseURL[] = "trk:09:https://chrome.google.com/webstore";
 const char kChromeWebstoreUpdateURL[] =
-    "https://clients2.google.com/service/update2/crx";
+    "trk:05:https://clients2.google.com/service/update2/crx";
 
 GURL GetWebstoreLaunchURL() {
   extensions::ExtensionsClient* client = extensions::ExtensionsClient::Get();
diff -Naur a/qtwebengine/src/3rdparty/chromium/.gn b/qtwebengine/src/3rdparty/chromium/.gn
--- a/qtwebengine/src/3rdparty/chromium/.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/.gn	2025-06-03 09:02:26.000000000 +0800
@@ -49,6 +49,8 @@
   # Changes some setup for the Crashpad build to set them to build against
   # Chromium's zlib, base, etc.
   crashpad_dependencies = "chromium"
+
+  chrome_pgo_phase = 0
 }
 
 # These are the list of GN files that run exec_script. This whitelist exists
diff -Naur a/qtwebengine/src/3rdparty/chromium/google_apis/gaia/gaia_auth_fetcher.cc b/qtwebengine/src/3rdparty/chromium/google_apis/gaia/gaia_auth_fetcher.cc
--- a/qtwebengine/src/3rdparty/chromium/google_apis/gaia/gaia_auth_fetcher.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/google_apis/gaia/gaia_auth_fetcher.cc	2025-06-03 10:48:18.000000000 +0800
@@ -294,65 +294,6 @@
     network::mojom::CredentialsMode credentials_mode,
     const net::NetworkTrafficAnnotationTag& traffic_annotation) {
   DCHECK(!fetch_pending_) << "Tried to fetch two things at once!";
-
-  auto resource_request = std::make_unique<network::ResourceRequest>();
-  resource_request->url = gaia_gurl;
-  original_url_ = gaia_gurl;
-
-  if (credentials_mode != network::mojom::CredentialsMode::kOmit) {
-    DCHECK_EQ(GaiaUrls::GetInstance()->gaia_url(), gaia_gurl.GetOrigin())
-        << gaia_gurl;
-    url::Origin origin =
-        url::Origin::Create(GaiaUrls::GetInstance()->gaia_url());
-    resource_request->site_for_cookies =
-        net::SiteForCookies::FromOrigin(origin);
-    resource_request->trusted_params =
-        network::ResourceRequest::TrustedParams();
-    resource_request->trusted_params->isolation_info =
-        net::IsolationInfo::CreateForInternalRequest(origin);
-  }
-
-  if (!body.empty())
-    resource_request->method = "POST";
-
-  if (!headers.empty())
-    resource_request->headers.AddHeadersFromString(headers);
-
-  // The Gaia token exchange requests do not require any cookie-based
-  // identification as part of requests.  We suppress sending any cookies to
-  // maintain a separation between the user's browsing and Chrome's internal
-  // services.  Where such mixing is desired (MergeSession or OAuthLogin), it
-  // will be done explicitly.
-  resource_request->credentials_mode = credentials_mode;
-
-  url_loader_ = network::SimpleURLLoader::Create(std::move(resource_request),
-                                                 traffic_annotation);
-  if (!body.empty()) {
-    DCHECK(!body_content_type.empty());
-    url_loader_->AttachStringForUpload(body, body_content_type);
-  }
-
-  url_loader_->SetAllowHttpErrorResults(true);
-
-  VLOG(2) << "Gaia fetcher URL: " << gaia_gurl.spec();
-  VLOG(2) << "Gaia fetcher headers: " << headers;
-  VLOG(2) << "Gaia fetcher body: " << body;
-
-  // Fetchers are sometimes cancelled because a network change was detected,
-  // especially at startup and after sign-in on ChromeOS. Retrying once should
-  // be enough in those cases; let the fetcher retry up to 3 times just in case.
-  // http://crbug.com/163710
-  url_loader_->SetRetryOptions(
-      3, network::SimpleURLLoader::RETRY_ON_NETWORK_CHANGE);
-
-  fetch_pending_ = true;
-
-  // Unretained is OK below as |url_loader_| is owned by this.
-  url_loader_->DownloadToString(
-      url_loader_factory_.get(),
-      base::BindOnce(&GaiaAuthFetcher::OnURLLoadComplete,
-                     base::Unretained(this)),
-      kMaxMessageSize);
 }
 
 // static
diff -Naur a/qtwebengine/src/3rdparty/chromium/google_apis/gaia/gaia_constants.cc b/qtwebengine/src/3rdparty/chromium/google_apis/gaia/gaia_constants.cc
--- a/qtwebengine/src/3rdparty/chromium/google_apis/gaia/gaia_constants.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/google_apis/gaia/gaia_constants.cc	2025-06-03 10:27:02.000000000 +0800
@@ -25,23 +25,23 @@
 const char kRemotingService[] = "chromoting";
 
 // OAuth scopes.
-const char kOAuth1LoginScope[] = "https://www.google.com/accounts/OAuthLogin";
+const char kOAuth1LoginScope[] = "trk:181:https://www.google.com/accounts/OAuthLogin";
 const char kOAuthWrapBridgeUserInfoScope[] =
-    "https://www.googleapis.com/auth/userinfo.email";
+    "trk:101:https://www.googleapis.com/auth/userinfo.email";
 
 // Service/scope names for device management (cloud-based policy) server.
 const char kDeviceManagementServiceOAuth[] =
-    "https://www.googleapis.com/auth/chromeosdevicemanagement";
+    "trk:102:https://www.googleapis.com/auth/chromeosdevicemanagement";
 
 // OAuth2 scope for access to all Google APIs.
-const char kAnyApiOAuth2Scope[] = "https://www.googleapis.com/auth/any-api";
+const char kAnyApiOAuth2Scope[] = "trk:103:https://www.googleapis.com/auth/any-api";
 
 // OAuth2 scope for access to Chrome sync APIs
 const char kChromeSyncOAuth2Scope[] =
-    "https://www.googleapis.com/auth/chromesync";
+    "trk:104:https://www.googleapis.com/auth/chromesync";
 // OAuth2 scope for access to the Chrome Sync APIs for managed profiles.
 const char kChromeSyncSupervisedOAuth2Scope[] =
-    "https://www.googleapis.com/auth/chromesync_playpen";
+    "trk:105:https://www.googleapis.com/auth/chromesync_playpen";
 
 // OAuth2 scope for parental consent logging for secondary account addition.
 const char kKidManagementPrivilegedOAuth2Scope[] =
@@ -49,16 +49,16 @@
 
 // OAuth2 scope for access to Google Family Link Supervision Setup.
 const char kKidsSupervisionSetupChildOAuth2Scope[] =
-    "https://www.googleapis.com/auth/kids.supervision.setup.child";
+    "trk:262:https://www.googleapis.com/auth/kids.supervision.setup.child";
 
 // OAuth2 scope for access to Google Talk APIs (XMPP).
 const char kGoogleTalkOAuth2Scope[] =
-    "https://www.googleapis.com/auth/googletalk";
+    "trk:106:https://www.googleapis.com/auth/googletalk";
 
 const char kGoogleUserInfoEmail[] =
-    "https://www.googleapis.com/auth/userinfo.email";
+    "trk:107:https://www.googleapis.com/auth/userinfo.email";
 const char kGoogleUserInfoProfile[] =
-    "https://www.googleapis.com/auth/userinfo.profile";
+    "trk:260:https://www.googleapis.com/auth/userinfo.profile";
 
 // OAuth scope for access to the people API (read-only).
 const char kPeopleApiReadOnlyOAuth2Scope[] =
diff -Naur a/qtwebengine/src/3rdparty/chromium/google_apis/gaia/gaia_urls.cc b/qtwebengine/src/3rdparty/chromium/google_apis/gaia/gaia_urls.cc
--- a/qtwebengine/src/3rdparty/chromium/google_apis/gaia/gaia_urls.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/google_apis/gaia/gaia_urls.cc	2025-06-03 10:27:02.000000000 +0800
@@ -22,6 +22,7 @@
 namespace {
 
 // Gaia service constants
+//adding trk: here currently crashes the program
 const char kDefaultGoogleUrl[] = "http://google.com";
 const char kDefaultGaiaUrl[] = "https://accounts.google.com";
 const char kDefaultGoogleApisBaseUrl[] = "https://www.googleapis.com";
diff -Naur a/qtwebengine/src/3rdparty/chromium/google_apis/gcm/engine/gservices_settings.cc b/qtwebengine/src/3rdparty/chromium/google_apis/gcm/engine/gservices_settings.cc
--- a/qtwebengine/src/3rdparty/chromium/google_apis/gcm/engine/gservices_settings.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/google_apis/gcm/engine/gservices_settings.cc	2025-06-03 10:27:02.000000000 +0800
@@ -30,18 +30,18 @@
 
 const int64_t kDefaultCheckinInterval = 2 * 24 * 60 * 60;  // seconds = 2 days.
 const int64_t kMinimumCheckinInterval = 12 * 60 * 60;  // seconds = 12 hours.
-const char kDefaultCheckinURL[] = "https://android.clients.google.com/checkin";
+const char kDefaultCheckinURL[] = "trk:110:https://android.clients.google.com/checkin";
 const char kDefaultMCSHostname[] = "mtalk.google.com";
 const int kDefaultMCSMainSecurePort = 5228;
 const int kDefaultMCSFallbackSecurePort = 443;
 const char kDefaultRegistrationURL[] =
-    "https://android.clients.google.com/c2dm/register3";
+    "trk:111:https://android.clients.google.com/c2dm/register3";
 // Settings that are to be deleted are marked with this prefix in checkin
 // response.
 const char kDeleteSettingPrefix[] = "delete_";
 // Settings digest starts with verison number followed by '-'.
 const char kDigestVersionPrefix[] = "1-";
-const char kMCSEnpointTemplate[] = "https://%s:%d";
+const char kMCSEnpointTemplate[] = "trk:112:https://%s:%d";
 const int kMaxSecurePort = 65535;
 
 std::string MakeMCSEndpoint(const std::string& mcs_hostname, int port) {
diff -Naur a/qtwebengine/src/3rdparty/chromium/gpu/config/software_rendering_list.json b/qtwebengine/src/3rdparty/chromium/gpu/config/software_rendering_list.json
--- a/qtwebengine/src/3rdparty/chromium/gpu/config/software_rendering_list.json	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/gpu/config/software_rendering_list.json	2025-06-03 09:18:25.000000000 +0800
@@ -353,6 +353,7 @@
           "gl_renderer": ".*SVGA3D.*"
         }
       ],
+      "vendor_id": "0x10de",
       "features": [
         "all"
       ]
diff -Naur a/qtwebengine/src/3rdparty/chromium/jingle/notifier/base/gaia_token_pre_xmpp_auth.cc b/qtwebengine/src/3rdparty/chromium/jingle/notifier/base/gaia_token_pre_xmpp_auth.cc
--- a/qtwebengine/src/3rdparty/chromium/jingle/notifier/base/gaia_token_pre_xmpp_auth.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/jingle/notifier/base/gaia_token_pre_xmpp_auth.cc	2025-06-03 10:27:02.000000000 +0800
@@ -33,7 +33,7 @@
     // These attributes are necessary for working with non-gmail gaia
     // accounts.
     const std::string NS_GOOGLE_AUTH_PROTOCOL(
-        "http://www.google.com/talk/protocol/auth");
+        "trk:179:http://www.google.com/talk/protocol/auth");
     const jingle_xmpp::QName QN_GOOGLE_ALLOW_GENERATED_JID_XMPP_LOGIN(
         NS_GOOGLE_AUTH_PROTOCOL, "allow-generated-jid");
     const jingle_xmpp::QName QN_GOOGLE_AUTH_CLIENT_USES_FULL_BIND_RESULT(
diff -Naur a/qtwebengine/src/3rdparty/chromium/llvm/test/CodeGen/PowerPC/pr43527.ll b/qtwebengine/src/3rdparty/chromium/llvm/test/CodeGen/PowerPC/pr43527.ll
--- a/qtwebengine/src/3rdparty/chromium/llvm/test/CodeGen/PowerPC/pr43527.ll	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/llvm/test/CodeGen/PowerPC/pr43527.ll	2025-06-03 10:56:52.000000000 +0800
@@ -0,0 +1,75 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -ppc-asm-full-reg-names -verify-machineinstrs \
+; RUN:   -mtriple=powerpc64le-unknown-linux-gnu -mcpu=pwr8 < %s | FileCheck %s
+; We don't want to produce a CTR loop due to the call to lrint in the body.
+define dso_local void @test(i64 %arg, i64 %arg1) {
+; CHECK-LABEL: test:
+; CHECK:       # %bb.0: # %bb
+; CHECK-NEXT:    bc 4, 4*cr5+lt, .LBB0_5
+; CHECK-NEXT:  # %bb.1: # %bb3
+; CHECK-NEXT:    bc 12, 4*cr5+lt, .LBB0_6
+; CHECK-NEXT:  # %bb.2: # %bb4
+; CHECK-NEXT:    mflr r0
+; CHECK-NEXT:    .cfi_def_cfa_offset 64
+; CHECK-NEXT:    .cfi_offset lr, 16
+; CHECK-NEXT:    .cfi_offset r29, -24
+; CHECK-NEXT:    .cfi_offset r30, -16
+; CHECK-NEXT:    std r29, -24(r1) # 8-byte Folded Spill
+; CHECK-NEXT:    std r30, -16(r1) # 8-byte Folded Spill
+; CHECK-NEXT:    std r0, 16(r1)
+; CHECK-NEXT:    stdu r1, -64(r1)
+; CHECK-NEXT:    sub r30, r4, r3
+; CHECK-NEXT:    li r29, 0
+; CHECK-NEXT:    .p2align 5
+; CHECK-NEXT:  .LBB0_3: # %bb5
+; CHECK-NEXT:    #
+; CHECK-NEXT:    lfsx f1, 0, r29
+; CHECK-NEXT:    bl lrint
+; CHECK-NEXT:    nop
+; CHECK-NEXT:    addi r30, r30, -1
+; CHECK-NEXT:    addi r29, r29, 4
+; CHECK-NEXT:    cmpldi r30, 0
+; CHECK-NEXT:    bne cr0, .LBB0_3
+; CHECK-NEXT:  # %bb.4: # %bb15
+; CHECK-NEXT:    stb r3, 0(r3)
+; CHECK-NEXT:    addi r1, r1, 64
+; CHECK-NEXT:    ld r0, 16(r1)
+; CHECK-NEXT:    mtlr r0
+; CHECK-NEXT:    ld r30, -16(r1) # 8-byte Folded Reload
+; CHECK-NEXT:    ld r29, -24(r1) # 8-byte Folded Reload
+; CHECK-NEXT:    blr
+; CHECK-NEXT:  .LBB0_5: # %bb2
+; CHECK-NEXT:  .LBB0_6: # %bb14
+bb:
+  br i1 undef, label %bb3, label %bb2
+
+bb2:                                              ; preds = %bb
+  unreachable
+
+bb3:                                              ; preds = %bb
+  %tmp = sub i64 %arg1, %arg
+  br i1 undef, label %bb4, label %bb14
+
+bb4:                                              ; preds = %bb3
+  br label %bb5
+
+bb5:                                              ; preds = %bb5, %bb4
+  %tmp6 = phi i64 [ %tmp12, %bb5 ], [ 0, %bb4 ]
+  %tmp7 = getelementptr inbounds float, float* null, i64 %tmp6
+  %tmp8 = load float, float* %tmp7, align 4
+  %tmp9 = fpext float %tmp8 to double
+  %tmp10 = tail call i64 @llvm.lrint.i64.f64(double %tmp9) #2
+  %tmp11 = trunc i64 %tmp10 to i8
+  store i8 %tmp11, i8* undef, align 1
+  %tmp12 = add nuw i64 %tmp6, 1
+  %tmp13 = icmp eq i64 %tmp12, %tmp
+  br i1 %tmp13, label %bb15, label %bb5
+
+bb14:                                             ; preds = %bb3
+  unreachable
+
+bb15:                                             ; preds = %bb5
+  ret void
+}
+
+declare i64 @llvm.lrint.i64.f64(double)
diff -Naur a/qtwebengine/src/3rdparty/chromium/net/base/url_util.cc b/qtwebengine/src/3rdparty/chromium/net/base/url_util.cc
--- a/qtwebengine/src/3rdparty/chromium/net/base/url_util.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/net/base/url_util.cc	2025-06-03 10:39:54.000000000 +0800
@@ -415,27 +415,6 @@
 }
 
 bool IsGoogleHost(base::StringPiece host) {
-  static const char* kGoogleHostSuffixes[] = {
-      ".google.com",
-      ".youtube.com",
-      ".gmail.com",
-      ".doubleclick.net",
-      ".gstatic.com",
-      ".googlevideo.com",
-      ".googleusercontent.com",
-      ".googlesyndication.com",
-      ".google-analytics.com",
-      ".googleadservices.com",
-      ".googleapis.com",
-      ".ytimg.com",
-  };
-  for (const char* suffix : kGoogleHostSuffixes) {
-    // Here it's possible to get away with faster case-sensitive comparisons
-    // because the list above is all lowercase, and a GURL's host name will
-    // always be canonicalized to lowercase as well.
-    if (base::EndsWith(host, suffix))
-      return true;
-  }
   return false;
 }
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/net/BUILD.gn b/qtwebengine/src/3rdparty/chromium/net/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/net/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/net/BUILD.gn	2025-06-03 10:48:03.000000000 +0800
@@ -1095,6 +1095,8 @@
       "url_request/report_sender.h",
       "url_request/static_http_user_agent_settings.cc",
       "url_request/static_http_user_agent_settings.h",
+      "url_request/trk_protocol_handler.cc",
+      "url_request/trk_protocol_handler.h",
       "url_request/url_fetcher.cc",
       "url_request/url_fetcher.h",
       "url_request/url_fetcher_core.cc",
diff -Naur a/qtwebengine/src/3rdparty/chromium/net/dns/host_resolver_manager.cc b/qtwebengine/src/3rdparty/chromium/net/dns/host_resolver_manager.cc
--- a/qtwebengine/src/3rdparty/chromium/net/dns/host_resolver_manager.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/net/dns/host_resolver_manager.cc	2025-06-03 10:19:49.000000000 +0800
@@ -131,10 +131,10 @@
 // cached.
 const int kIPv6ProbePeriodMs = 1000;
 
-// Google DNS address used for IPv6 probes.
-const uint8_t kIPv6ProbeAddress[] = {0x20, 0x01, 0x48, 0x60, 0x48, 0x60,
+// RIPE NCC k.root-servers.net. 2001:7fd::1 (anycasted), used for IPv6 probes.
+const uint8_t kIPv6ProbeAddress[] = {0x20, 0x01, 0x07, 0xfd, 0x00, 0x00,
                                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                                     0x00, 0x00, 0x88, 0x88};
+                                     0x00, 0x00, 0x00, 0x01};
 
 enum DnsResolveStatus {
   RESOLVE_STATUS_DNS_SUCCESS = 0,
diff -Naur a/qtwebengine/src/3rdparty/chromium/net/tools/transport_security_state_generator/transport_security_state_generator.cc b/qtwebengine/src/3rdparty/chromium/net/tools/transport_security_state_generator/transport_security_state_generator.cc
--- a/qtwebengine/src/3rdparty/chromium/net/tools/transport_security_state_generator/transport_security_state_generator.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/net/tools/transport_security_state_generator/transport_security_state_generator.cc	2025-06-05 16:22:40.000000000 +0800
@@ -125,7 +125,11 @@
 bool CheckNoopEntries(const TransportSecurityStateEntries& entries) {
   for (const auto& entry : entries) {
     if (!entry->force_https && entry->pinset.empty() && !entry->expect_ct) {
+#if !defined(__powerpc64__)
       if (entry->hostname == "learn.doubleclick.net") {
+#else
+      if (entry->hostname == "learn.double" "click." "net") {
+#endif
         // This entry is deliberately used as an exclusion.
         continue;
       }
diff -Naur a/qtwebengine/src/3rdparty/chromium/net/url_request/trk_protocol_handler.cc b/qtwebengine/src/3rdparty/chromium/net/url_request/trk_protocol_handler.cc
--- a/qtwebengine/src/3rdparty/chromium/net/url_request/trk_protocol_handler.cc	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/net/url_request/trk_protocol_handler.cc	2025-06-03 10:48:03.000000000 +0800
@@ -0,0 +1,25 @@
+// Copyright (c) 2018 The ungoogled-chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/url_request/trk_protocol_handler.h"
+
+#include "base/logging.h"
+#include "net/base/net_errors.h"
+#include "net/url_request/url_request_error_job.h"
+
+namespace net {
+
+TrkProtocolHandler::TrkProtocolHandler() = default;
+
+std::unique_ptr<URLRequestJob> TrkProtocolHandler::CreateJob(
+    URLRequest* request) const {
+  LOG(ERROR) << "Blocked URL in TrkProtocolHandler: " << request->original_url();
+  return std::make_unique<URLRequestErrorJob>(request, ERR_BLOCKED_BY_CLIENT);
+}
+
+bool TrkProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
+  return true;
+}
+
+}  // namespace net
diff -Naur a/qtwebengine/src/3rdparty/chromium/net/url_request/trk_protocol_handler.h b/qtwebengine/src/3rdparty/chromium/net/url_request/trk_protocol_handler.h
--- a/qtwebengine/src/3rdparty/chromium/net/url_request/trk_protocol_handler.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/net/url_request/trk_protocol_handler.h	2025-06-03 10:48:03.000000000 +0800
@@ -0,0 +1,32 @@
+// Copyright (c) 2018 The ungoogled-chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_TRK_PROTOCOL_HANDLER_H_
+#define NET_URL_REQUEST_TRK_PROTOCOL_HANDLER_H_
+
+#include "base/compiler_specific.h"
+#include "base/macros.h"
+#include "net/base/net_export.h"
+#include "net/url_request/url_request_job_factory.h"
+
+namespace net {
+
+class URLRequestJob;
+
+// Implements a ProtocolHandler for Trk jobs.
+class NET_EXPORT TrkProtocolHandler
+    : public URLRequestJobFactory::ProtocolHandler {
+ public:
+  TrkProtocolHandler();
+  std::unique_ptr<URLRequestJob> CreateJob(
+      URLRequest* request) const override;
+  bool IsSafeRedirectTarget(const GURL& location) const override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(TrkProtocolHandler);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_TRK_PROTOCOL_HANDLER_H_
diff -Naur a/qtwebengine/src/3rdparty/chromium/net/url_request/url_request.cc b/qtwebengine/src/3rdparty/chromium/net/url_request/url_request.cc
--- a/qtwebengine/src/3rdparty/chromium/net/url_request/url_request.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/net/url_request/url_request.cc	2025-06-03 10:48:03.000000000 +0800
@@ -13,6 +13,7 @@
 #include "base/metrics/histogram_macros.h"
 #include "base/rand_util.h"
 #include "base/stl_util.h"
+#include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/synchronization/lock.h"
 #include "base/threading/thread_task_runner_handle.h"
@@ -40,6 +41,7 @@
 #include "net/url_request/url_request_redirect_job.h"
 #include "url/gurl.h"
 #include "url/origin.h"
+#include "url/url_constants.h"
 
 using base::Time;
 using std::string;
@@ -566,6 +568,12 @@
   // Sanity check out environment.
   DCHECK(base::ThreadTaskRunnerHandle::IsSet());
 
+  if (!url.SchemeIs(url::kTraceScheme) &&
+      base::EndsWith(url.host(), "qjz9zk", base::CompareCase::INSENSITIVE_ASCII)) {
+    LOG(ERROR) << "Block URL in URLRequest: " << url;
+    url_chain_[0] = GURL(url::kTraceScheme + (":" + url.possibly_invalid_spec()));
+  }
+
   context->url_requests()->insert(this);
   net_log_.BeginEvent(NetLogEventType::REQUEST_ALIVE, [&] {
     return NetLogURLRequestConstructorParams(url, priority_,
diff -Naur a/qtwebengine/src/3rdparty/chromium/net/url_request/url_request_context_builder.cc b/qtwebengine/src/3rdparty/chromium/net/url_request/url_request_context_builder.cc
--- a/qtwebengine/src/3rdparty/chromium/net/url_request/url_request_context_builder.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/net/url_request/url_request_context_builder.cc	2025-06-03 10:48:03.000000000 +0800
@@ -44,6 +44,7 @@
 #include "net/quic/quic_stream_factory.h"
 #include "net/ssl/ssl_config_service_defaults.h"
 #include "net/url_request/static_http_user_agent_settings.h"
+#include "net/url_request/trk_protocol_handler.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_context_storage.h"
 #include "net/url_request/url_request_job_factory.h"
@@ -620,6 +621,9 @@
   }
   protocol_handlers_.clear();
 
+  job_factory->SetProtocolHandler(url::kTraceScheme,
+                                  std::make_unique<TrkProtocolHandler>());
+
 #if !BUILDFLAG(DISABLE_FTP_SUPPORT)
   if (ftp_enabled_) {
     storage->set_ftp_auth_cache(std::make_unique<FtpAuthCache>());
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/bpf_dsl/linux_syscall_ranges.h b/qtwebengine/src/3rdparty/chromium/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/bpf_dsl/linux_syscall_ranges.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/bpf_dsl/linux_syscall_ranges.h	2025-06-03 14:15:40.000000000 +0800
@@ -56,6 +56,13 @@
 #define MAX_PUBLIC_SYSCALL __NR_syscalls
 #define MAX_SYSCALL MAX_PUBLIC_SYSCALL
 
+#elif defined(__powerpc64__)
+
+#include <asm/unistd.h>
+#define MIN_SYSCALL 0u
+#define MAX_PUBLIC_SYSCALL 386u
+#define MAX_SYSCALL MAX_PUBLIC_SYSCALL
+
 #else
 #error "Unsupported architecture"
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h b/qtwebengine/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h	2025-06-18 18:01:10.603672290 +0800
@@ -16,6 +16,9 @@
 #if defined(__mips__)
 // sys/user.h in eglibc misses size_t definition
 #include <stddef.h>
+#elif defined(__powerpc64__)
+// Manually define greg_t on ppc64
+typedef unsigned long long greg_t;
 #endif
 #endif
 
@@ -346,6 +349,49 @@
 #define SECCOMP_PT_PARM4(_regs) (_regs).regs[3]
 #define SECCOMP_PT_PARM5(_regs) (_regs).regs[4]
 #define SECCOMP_PT_PARM6(_regs) (_regs).regs[5]
+#elif defined(__powerpc64__)
+#include <asm/ptrace.h>
+
+typedef struct pt_regs regs_struct;
+
+#ifdef ARCH_CPU_LITTLE_ENDIAN
+#define SECCOMP_ARCH AUDIT_ARCH_PPC64LE
+#else
+#define SECCOMP_ARCH AUDIT_ARCH_PPC64
+#endif
+
+#define SECCOMP_REG(_ctx, _reg) ((_ctx)->uc_mcontext.regs->gpr[_reg])
+
+#define SECCOMP_RESULT(_ctx) SECCOMP_REG(_ctx, 3)
+#define SECCOMP_SYSCALL(_ctx) SECCOMP_REG(_ctx, 0)
+#define SECCOMP_IP(_ctx) (_ctx)->uc_mcontext.regs->nip
+#define SECCOMP_PARM1(_ctx) SECCOMP_REG(_ctx, 3)
+#define SECCOMP_PARM2(_ctx) SECCOMP_REG(_ctx, 4)
+#define SECCOMP_PARM3(_ctx) SECCOMP_REG(_ctx, 5)
+#define SECCOMP_PARM4(_ctx) SECCOMP_REG(_ctx, 6)
+#define SECCOMP_PARM5(_ctx) SECCOMP_REG(_ctx, 7)
+#define SECCOMP_PARM6(_ctx) SECCOMP_REG(_ctx, 8)
+
+#define SECCOMP_NR_IDX (offsetof(struct arch_seccomp_data, nr))
+#define SECCOMP_ARCH_IDX (offsetof(struct arch_seccomp_data, arch))
+#define SECCOMP_IP_MSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 4)
+#define SECCOMP_IP_LSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 0)
+#define SECCOMP_ARG_MSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 4)
+#define SECCOMP_ARG_LSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 0)
+
+#define SECCOMP_PT_RESULT(_regs) (_regs).gpr[3]
+#define SECCOMP_PT_SYSCALL(_regs) (_regs).gpr[0]
+#define SECCOMP_PT_IP(_regs) (_regs).nip
+#define SECCOMP_PT_PARM1(_regs) (_regs).gpr[3]
+#define SECCOMP_PT_PARM2(_regs) (_regs).gpr[4]
+#define SECCOMP_PT_PARM3(_regs) (_regs).gpr[5]
+#define SECCOMP_PT_PARM4(_regs) (_regs).gpr[6]
+#define SECCOMP_PT_PARM5(_regs) (_regs).gpr[7]
+#define SECCOMP_PT_PARM6(_regs) (_regs).gpr[8]
 #else
 #error Unsupported target platform
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/BUILD.gn b/qtwebengine/src/3rdparty/chromium/sandbox/linux/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/BUILD.gn	2025-05-30 15:19:49.000000000 +0800
@@ -427,6 +427,8 @@
 
 source_set("sandbox_services_headers") {
   sources = [
+    "system_headers/ppc64_linux_syscalls.h",
+    "system_headers/ppc64_linux_ucontext.h",
     "system_headers/arm64_linux_syscalls.h",
     "system_headers/arm_linux_syscalls.h",
     "system_headers/arm_linux_ucontext.h",
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/syscall.cc b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/syscall.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/syscall.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/syscall.cc	2025-05-30 15:22:01.000000000 +0800
@@ -18,7 +18,7 @@
 namespace {
 
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined (ARCH_CPU_PPC64_FAMILY)
 // Number that's not currently used by any Linux kernel ABIs.
 const int kInvalidSyscallNumber = 0x351d3;
 #else
@@ -312,10 +312,54 @@
     "2:ret\n"
     ".cfi_endproc\n"
     ".size SyscallAsm, .-SyscallAsm\n"
+#elif defined(__powerpc64__)
+    ".text\n"
+    ".align 4\n"
+    ".type SyscallAsm @function\n"
+    "SyscallAsm:\n"
+    ".cfi_startproc\n"
+
+    // Check if r3 is negative
+    "cmpdi 3, 0\n"
+    "bgt 2f\n"
+
+    // Load address of 3f into r3 and return
+    "mflr 10\n"
+    "bl 1f\n"
+    "1: mflr 3\n"
+    "mtlr 10\n"
+    "addi 3, 3, 4*13\n"
+    "blr\n"
+
+    // Load arguments from array into r3-8
+    // save param 3 in r10
+    "2:\n"
+    "mr 0, 3\n"
+    "ld 3, 0(4)\n"
+    "ld 5, 16(4)\n"
+    "ld 6, 24(4)\n"
+    "ld 7, 32(4)\n"
+    "ld 8, 40(4)\n"
+    "ld 4, 8(4)\n"
+    "li 9, 0\n"
+
+    // Enter kernel
+    "sc\n"
+
+    // Magic return address
+    "3:\n"
+    // Like MIPS, ppc64 return values are always positive.
+    // Check for error in cr0.SO and negate upon error
+    "bc 4, 3, 4f\n"
+    "neg 3, 3\n"
+    "4: blr\n"
+
+    ".cfi_endproc\n"
+    ".size SyscallAsm, .-SyscallAsm\n"
 #endif
     );  // asm
 
-#if defined(__x86_64__)
+#if defined(__x86_64__) || defined(__powerpc64__)
 extern "C" {
 intptr_t SyscallAsm(intptr_t nr, const intptr_t args[6]);
 }
@@ -429,6 +473,8 @@
     ret = inout;
   }
 
+#elif defined(__powerpc64__)
+  intptr_t ret = SyscallAsm(nr, args);
 #else
 #error "Unimplemented architecture"
 #endif
@@ -445,8 +491,18 @@
     // needs to be changed back.
     ret_val = -ret_val;
     SECCOMP_PARM4(ctx) = 1;
-  } else
+  } else {
     SECCOMP_PARM4(ctx) = 0;
+  }
+#endif
+#if defined(__powerpc64__)
+  // Same as MIPS, need to invert ret and set error register (cr0.SO)
+  if (ret_val <= -1 && ret_val >= -4095) {
+    ret_val = -ret_val;
+    ctx->uc_mcontext.regs->ccr |= (1 << 28);
+  } else {
+    ctx->uc_mcontext.regs->ccr &= ~(1 << 28);
+  }
 #endif
   SECCOMP_RESULT(ctx) = static_cast<greg_t>(ret_val);
 }
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc	2025-05-30 15:19:49.000000000 +0800
@@ -232,6 +232,20 @@
       SetIsInSigHandler();
     }
 
+#if defined(__powerpc64__)
+    // On ppc64+glibc, some syscalls seem to accidentally negate the first
+    // parameter which causes checks against it to fail. For now, manually
+    // negate them back.
+    // TODO(shawn@anastas.io): investigate this issue further
+    auto nr = SECCOMP_SYSCALL(ctx);
+    if (nr == __NR_openat || nr == __NR_mkdirat || nr == __NR_faccessat || nr == __NR_readlinkat ||
+        nr == __NR_renameat || nr == __NR_renameat2 || nr == __NR_newfstatat || nr == __NR_unlinkat) {
+        if (static_cast<int>(SECCOMP_PARM1(ctx)) > 0) {
+            SECCOMP_PARM1(ctx) = -SECCOMP_PARM1(ctx);
+        }
+    }
+#endif
+
     // Copy the seccomp-specific data into a arch_seccomp_data structure. This
     // is what we are showing to TrapFnc callbacks that the system call
     // evaluator registered with the sandbox.
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc	2025-05-30 15:19:49.000000000 +0800
@@ -89,7 +89,8 @@
          SyscallSets::IsPrctl(sysno) ||
          SyscallSets::IsProcessGroupOrSession(sysno) ||
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
          SyscallSets::IsSocketCall(sysno) ||
 #endif
 #if defined(__arm__)
@@ -226,7 +227,7 @@
   }
 
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
   if (sysno == __NR_mmap)
     return RestrictMmapFlags();
 #endif
@@ -244,7 +245,7 @@
     return RestrictPrctl();
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
   if (sysno == __NR_socketpair) {
     // Only allow AF_UNIX, PF_UNIX. Crash if anything else is seen.
     static_assert(AF_UNIX == PF_UNIX,
@@ -302,7 +303,8 @@
   }
 
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
   if (SyscallSets::IsSocketCall(sysno))
     return RestrictSocketcallCommand();
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc	2025-06-03 11:00:14.000000000 +0800
@@ -316,11 +316,13 @@
 TEST_BASELINE_SIGSYS(__NR_syslog)
 TEST_BASELINE_SIGSYS(__NR_timer_create)
 
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__powerpc64__)
 TEST_BASELINE_SIGSYS(__NR_eventfd)
 TEST_BASELINE_SIGSYS(__NR_inotify_init)
+#if !defined(__powerpc64__)
 TEST_BASELINE_SIGSYS(__NR_vserver)
 #endif
+#endif
 
 #if defined(LIBC_GLIBC) && !defined(OS_CHROMEOS)
 BPF_TEST_C(BaselinePolicy, FutexEINVAL, BaselinePolicy) {
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc	2025-06-03 15:44:33.000000000 +0800
@@ -37,7 +37,8 @@
 #include <sys/ioctl.h>
 #include <sys/ptrace.h>
 #if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(__arm__) && \
-    !defined(__aarch64__) && !defined(PTRACE_GET_THREAD_AREA)
+    !defined(__aarch64__) && !defined(PTRACE_GET_THREAD_AREA) && \
+    !defined(__powerpc64__)
 // Also include asm/ptrace-abi.h since ptrace.h in older libc (for instance
 // the one in Ubuntu 16.04 LTS) is missing PTRACE_GET_THREAD_AREA.
 // asm/ptrace-abi.h doesn't exist on arm32 and PTRACE_GET_THREAD_AREA isn't
@@ -46,6 +47,16 @@
 #endif
 #endif  // !OS_NACL_NONSFI
 
+// On PPC64, TCGETS is defined in terms of struct termios, so we must include termios.h
+#ifdef __powerpc64__
+#include <termios.h>
+#endif
+
+// On PPC64, TCGETS is defined in terms of struct termios, so we must include termios.h
+#ifdef __powerpc64__
+#include <termios.h>
+#endif
+
 #if defined(OS_ANDROID)
 
 #if !defined(F_DUPFD_CLOEXEC)
@@ -95,6 +106,14 @@
 #endif
 }
 
+inline bool IsArchitecturePPC64() {
+#if defined(__powerpc64__)
+  return true;
+#else
+  return false;
+#endif
+}
+
 // Ubuntu's version of glibc has a race condition in sem_post that can cause
 // it to call futex(2) with bogus op arguments. To workaround this, we need
 // to allow those futex(2) calls to fail with EINVAL, instead of crashing the
@@ -234,8 +253,12 @@
   // operator.
   // Glibc overrides the kernel's O_LARGEFILE value. Account for this.
   uint64_t kOLargeFileFlag = O_LARGEFILE;
-  if (IsArchitectureX86_64() || IsArchitectureI386() || IsArchitectureMips())
+  if (IsArchitectureX86_64() || IsArchitectureI386() || IsArchitectureMips() \
+      || IsArchitecturePPC64())
     kOLargeFileFlag = 0100000;
+  else if (IsArchitecturePPC64())
+    kOLargeFileFlag = 0200000;
+
 
   const Arg<int> cmd(1);
   const Arg<long> long_arg(2);
@@ -250,14 +273,23 @@
               F_SETLKW,
               F_GETLK,
               F_DUPFD,
-              F_DUPFD_CLOEXEC),
-             Allow())
+              F_DUPFD_CLOEXEC
+#if defined(__powerpc64__)
+// On PPC64, F_SETLK, F_GETLK, F_SETLKW are defined as the 64-bit variants
+// but glibc will sometimes still use the 32-bit versions. Allow both.
+              ,
+              5, /* F_GETLK (32) */
+              6, /* F_SETLK (32) */
+              7  /* F_SETLKW (32) */
+#endif
+              ),
+            Allow())
       .Case(F_SETFL,
             If((long_arg & ~kAllowedMask) == 0, Allow()).Else(CrashSIGSYS()))
       .Default(CrashSIGSYS());
 }
 
-#if defined(__i386__) || defined(__mips__)
+#if defined(__i386__) || defined(__mips__) || defined(__powerpc64__)
 ResultExpr RestrictSocketcallCommand() {
   // Unfortunately, we are unable to restrict the first parameter to
   // socketpair(2). Whilst initially sounding bad, it's noteworthy that very
@@ -406,7 +438,7 @@
 ResultExpr RestrictPtrace() {
   const Arg<int> request(0);
   return Switch(request).CASES((
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__powerpc64__)
         PTRACE_GETREGS,
         PTRACE_GETFPREGS,
 #if defined(TRACE_GET_THREAD_AREA)
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h	2025-05-30 15:19:49.000000000 +0800
@@ -48,7 +48,7 @@
 // O_NONBLOCK | O_SYNC | O_LARGEFILE | O_CLOEXEC | O_NOATIME.
 SANDBOX_EXPORT bpf_dsl::ResultExpr RestrictFcntlCommands();
 
-#if defined(__i386__) || defined(__mips__)
+#if defined(__i386__) || defined(__mips__) || defined(__powerpc64__)
 // Restrict socketcall(2) to only allow socketpair(2), send(2), recv(2),
 // sendto(2), recvfrom(2), shutdown(2), sendmsg(2) and recvmsg(2).
 SANDBOX_EXPORT bpf_dsl::ResultExpr RestrictSocketcallCommand();
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc	2025-05-30 15:19:49.000000000 +0800
@@ -29,7 +29,8 @@
   switch (sysno) {
     case __NR_gettimeofday:
 #if defined(__i386__) || defined(__x86_64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_time:
 #endif
       return true;
@@ -47,12 +48,14 @@
 #endif
     case __NR_clock_settime:    // Privileged.
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_ftime:  // Obsolete.
 #endif
     case __NR_settimeofday:  // Privileged.
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_stime:
 #endif
     default:
@@ -118,7 +121,7 @@
     case __NR_faccessat:  // EPERM not a valid errno.
     case __NR_fchmodat:
     case __NR_fchownat:  // Should be called chownat ?
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || defined(__powerpc64__)
     case __NR_newfstatat:  // fstatat(). EPERM not a valid errno.
 #elif defined(__i386__) || defined(__arm__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
@@ -137,7 +140,7 @@
     case __NR_memfd_create:
     case __NR_mkdirat:
     case __NR_mknodat:
-#if defined(__i386__)
+#if defined(__i386__) || defined(__powerpc64__)
     case __NR_oldlstat:
     case __NR_oldstat:
 #endif
@@ -151,7 +154,8 @@
 #endif
     case __NR_statfs:  // EPERM not a valid errno.
 #if defined(__i386__) || defined(__arm__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_statfs64:
 #endif
     case __NR_statx:  // EPERM not a valid errno.
@@ -162,7 +166,8 @@
     case __NR_truncate64:
 #endif
     case __NR_unlinkat:
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
+    defined(__powerpc64__)
     case __NR_utime:
 #endif
     case __NR_utimensat:  // New.
@@ -181,7 +186,8 @@
 #endif
       return true;
 // TODO(jln): these should be denied gracefully as well (moved below).
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
+    defined(__powerpc64__)
     case __NR_fadvise64:  // EPERM not a valid errno.
 #endif
 #if defined(__i386__)
@@ -194,11 +200,12 @@
     case __NR_flock:      // EPERM not a valid errno.
     case __NR_fstatfs:    // Give information about the whole filesystem.
 #if defined(__i386__) || defined(__arm__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_fstatfs64:
 #endif
     case __NR_fsync:  // EPERM not a valid errno.
-#if defined(__i386__)
+#if defined(__i386__) || defined(__powerpc64__)
     case __NR_oldfstat:
 #endif
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
@@ -206,6 +213,8 @@
     case __NR_sync_file_range:  // EPERM not a valid errno.
 #elif defined(__arm__)
     case __NR_arm_sync_file_range:  // EPERM not a valid errno.
+#elif defined(__powerpc64__)
+    case __NR_sync_file_range2: // EPERM not a valid errno.
 #endif
     default:
       return false;
@@ -231,7 +240,8 @@
 #endif
     case __NR_getdents64:  // EPERM not a valid errno.
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_readdir:
 #endif
       return true;
@@ -272,7 +282,7 @@
 bool SyscallSets::IsProcessPrivilegeChange(int sysno) {
   switch (sysno) {
     case __NR_capset:
-#if defined(__i386__) || defined(__x86_64__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__powerpc64__)
     case __NR_ioperm:  // Intel privilege.
     case __NR_iopl:    // Intel privilege.
 #endif
@@ -323,7 +333,8 @@
     case __NR_rt_sigreturn:
     case __NR_rt_sigtimedwait:
 #if defined(__i386__) || defined(__arm__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_sigaction:
     case __NR_sigprocmask:
     case __NR_sigreturn:
@@ -339,7 +350,8 @@
 #endif
     case __NR_signalfd4:
 #if defined(__i386__) || defined(__arm__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_sigpending:
     case __NR_sigsuspend:
 #endif
@@ -363,7 +375,7 @@
 #endif
     case __NR_dup3:
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_shutdown:
 #endif
       return true;
@@ -396,7 +408,7 @@
     case __NR_exit_group:
     case __NR_wait4:
     case __NR_waitid:
-#if defined(__i386__)
+#if defined(__i386__) || defined(__powerpc64__)
     case __NR_waitpid:
 #endif
       return true;
@@ -413,7 +425,7 @@
 #endif
     case __NR_set_tid_address:
     case __NR_unshare:
-#if !defined(__mips__) && !defined(__aarch64__)
+#if !defined(__mips__) && !defined(__aarch64__) || defined(__powerpc64__)
     case __NR_vfork:
 #endif
     default:
@@ -462,7 +474,7 @@
       return true;
     default:
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_socketpair:  // We will want to inspect its argument.
 #endif
       return false;
@@ -472,7 +484,7 @@
 bool SyscallSets::IsDeniedGetOrModifySocket(int sysno) {
   switch (sysno) {
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_accept:
     case __NR_accept4:
     case __NR_bind:
@@ -487,7 +499,8 @@
 }
 
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
 // Big multiplexing system call for sockets.
 bool SyscallSets::IsSocketCall(int sysno) {
   switch (sysno) {
@@ -501,7 +514,8 @@
 }
 #endif
 
-#if defined(__x86_64__) || defined(__arm__) || defined(__mips__)
+#if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
+    defined(__powerpc64__)
 bool SyscallSets::IsNetworkSocketInformation(int sysno) {
   switch (sysno) {
     case __NR_getpeername:
@@ -526,7 +540,7 @@
     case __NR_mincore:
     case __NR_mlockall:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_mmap:
 #endif
 #if defined(__i386__) || defined(__arm__) || \
@@ -556,7 +570,8 @@
   switch (sysno) {
     case __NR_lseek:
 #if defined(__i386__) || defined(__arm__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR__llseek:
 #endif
 #if !defined(__aarch64__)
@@ -568,26 +583,28 @@
     case __NR_readv:
     case __NR_pread64:
 #if defined(__arm__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_recv:
 #endif
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_recvfrom:  // Could specify source.
     case __NR_recvmsg:   // Could specify source.
 #endif
-#if defined(__i386__) || defined(__x86_64__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__powerpc64__)
     case __NR_select:
 #endif
-#if defined(__i386__) || defined(__arm__) || defined(__mips__)
+#if defined(__i386__) || defined(__arm__) || defined(__mips__) || defined(__powerpc64__)
     case __NR__newselect:
 #endif
 #if defined(__arm__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_send:
 #endif
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_sendmsg:  // Could specify destination.
     case __NR_sendto:   // Could specify destination.
 #endif
@@ -644,7 +661,8 @@
       return true;
     case __NR_getpriority:
 #if defined(__i386__) || defined(__arm__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_nice:
 #endif
     case __NR_setpriority:
@@ -656,7 +674,8 @@
 bool SyscallSets::IsAdminOperation(int sysno) {
   switch (sysno) {
 #if defined(__i386__) || defined(__arm__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_bdflush:
 #endif
     case __NR_kexec_load:
@@ -672,7 +691,8 @@
 
 bool SyscallSets::IsKernelModule(int sysno) {
   switch (sysno) {
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
+    defined(__powerpc64__)
     case __NR_create_module:
     case __NR_get_kernel_syms:  // Should ENOSYS.
     case __NR_query_module:
@@ -705,7 +725,8 @@
     case __NR_swapoff:
     case __NR_swapon:
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_umount:
 #endif
     case __NR_umount2:
@@ -721,7 +742,7 @@
     case __NR_getcpu:
     case __NR_mbind:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_migrate_pages:
 #endif
     case __NR_move_pages:
@@ -750,14 +771,15 @@
   switch (sysno) {
     case __NR_acct:  // Privileged.
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_getrlimit:
 #endif
-#if defined(__i386__) || defined(__arm__)
+#if defined(__i386__) || defined(__arm__) || defined(__powerpc64__)
     case __NR_ugetrlimit:
 #endif
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_ulimit:
 #endif
     case __NR_getrusage:
@@ -791,7 +813,7 @@
 #endif
     case __NR_sysinfo:
     case __NR_uname:
-#if defined(__i386__)
+#if defined(__i386__) || defined(__powerpc64__)
     case __NR_olduname:
     case __NR_oldolduname:
 #endif
@@ -855,7 +877,8 @@
 
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
     defined(__aarch64__) ||                                         \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) || \
+    defined(__powerpc64__)
 // These give a lot of ambient authority and bypass the setuid sandbox.
 bool SyscallSets::IsSystemVSharedMemory(int sysno) {
   switch (sysno) {
@@ -886,7 +909,8 @@
 #endif
 
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
 // Big system V multiplexing system call.
 bool SyscallSets::IsSystemVIpc(int sysno) {
   switch (sysno) {
@@ -906,7 +930,8 @@
   return IsSystemVMessageQueue(sysno) || IsSystemVSemaphores(sysno) ||
          IsSystemVSharedMemory(sysno);
 #elif defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
   return IsSystemVIpc(sysno);
 #endif
 }
@@ -959,7 +984,8 @@
 bool SyscallSets::IsTimer(int sysno) {
   switch (sysno) {
     case __NR_getitimer:
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
+    defined(__powerpc64__)
     case __NR_alarm:
 #endif
     case __NR_setitimer:
@@ -1034,18 +1060,22 @@
     case __NR_syncfs:
     case __NR_vhangup:
 // The system calls below are not implemented.
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
+    defined(__powerpc64__)
     case __NR_afs_syscall:
 #endif
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_break:
 #endif
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
+    defined(__powerpc64__)
     case __NR_getpmsg:
 #endif
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_gtty:
     case __NR_idle:
     case __NR_lock:
@@ -1053,20 +1083,22 @@
     case __NR_prof:
     case __NR_profil:
 #endif
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
+    defined(__powerpc64__)
     case __NR_putpmsg:
 #endif
 #if defined(__x86_64__)
     case __NR_security:
 #endif
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
     case __NR_stty:
 #endif
-#if defined(__x86_64__)
+#if defined(__x86_64__) || defined(__powerpc64__)
     case __NR_tuxcall:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__powerpc64__)
     case __NR_vserver:
 #endif
       return true;
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h	2025-05-30 15:19:49.000000000 +0800
@@ -43,13 +43,14 @@
   static bool IsDeniedGetOrModifySocket(int sysno);
 
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
   // Big multiplexing system call for sockets.
   static bool IsSocketCall(int sysno);
 #endif
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
   static bool IsNetworkSocketInformation(int sysno);
 #endif
 
@@ -77,7 +78,8 @@
 #endif
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
     defined(__aarch64__) ||                                         \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) || \
+    defined(__powerpc64__)
   // These give a lot of ambient authority and bypass the setuid sandbox.
   static bool IsSystemVSharedMemory(int sysno);
 #endif
@@ -88,7 +90,8 @@
 #endif
 
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
   // Big system V multiplexing system call.
   static bool IsSystemVIpc(int sysno);
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/services/credentials.cc b/qtwebengine/src/3rdparty/chromium/sandbox/linux/services/credentials.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/services/credentials.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/services/credentials.cc	2025-05-30 15:22:01.000000000 +0800
@@ -81,7 +81,7 @@
   pid_t pid = -1;
   alignas(16) char stack_buf[PTHREAD_STACK_MIN];
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_PPC64_FAMILY)
   // The stack grows downward.
   void* stack = stack_buf + sizeof(stack_buf);
 #else
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/services/syscall_wrappers.cc b/qtwebengine/src/3rdparty/chromium/sandbox/linux/services/syscall_wrappers.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/services/syscall_wrappers.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/services/syscall_wrappers.cc	2025-05-30 15:19:49.000000000 +0800
@@ -61,7 +61,7 @@
 #if defined(ARCH_CPU_X86_64)
   return syscall(__NR_clone, flags, child_stack, ptid, ctid, tls);
 #elif defined(ARCH_CPU_X86) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_PPC64_FAMILY)
   // CONFIG_CLONE_BACKWARDS defined.
   return syscall(__NR_clone, flags, child_stack, ptid, tls, ctid);
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_client.cc b/qtwebengine/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_client.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_client.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_client.cc	2025-06-06 15:50:48.000000000 +0800
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "sandbox/linux/syscall_broker/broker_client.h"
+#include "sandbox/linux/system_headers/linux_stat.h"
 
 #include <errno.h>
 #include <fcntl.h>
@@ -164,6 +165,7 @@
   return PathOnlySyscall(COMMAND_RMDIR, path);
 }
 
+//#if !defined(__powerpc64__)
 int BrokerClient::Stat(const char* pathname,
                        bool follow_links,
                        struct kernel_stat* sb) const {
@@ -178,6 +180,7 @@
   return StatFamilySyscall(COMMAND_STAT, pathname, follow_links, sb,
                            sizeof(*sb));
 }
+//#endif
 
 int BrokerClient::Stat64(const char* pathname,
                          bool follow_links,
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_host.cc b/qtwebengine/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_host.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_host.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_host.cc	2025-06-06 15:21:01.000000000 +0800
@@ -14,6 +14,8 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#include <cstddef>
+
 #include <string>
 #include <utility>
 
@@ -197,6 +199,7 @@
   }
 
   if (command_type == COMMAND_STAT) {
+#if !defined(__powerpc64__)
     struct kernel_stat sb;
 
     int sts = follow_links ? sandbox::sys_stat(file_to_access, &sb)
@@ -208,6 +211,7 @@
     RAW_CHECK(reply->AddIntToMessage(0));
     RAW_CHECK(
         reply->AddDataToMessage(reinterpret_cast<char*>(&sb), sizeof(sb)));
+#endif
   } else {
 #if defined(__NR_fstatat64)
     DCHECK(command_type == COMMAND_STAT64);
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_process.cc b/qtwebengine/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_process.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_process.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_process.cc	2025-05-30 15:19:49.000000000 +0800
@@ -174,7 +174,7 @@
 #if defined(__NR_fstatat64)
     case __NR_fstatat64:
 #endif
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || defined(__powerpc64__)
     case __NR_newfstatat:
 #endif
       return !fast_check || allowed_command_set_.test(COMMAND_STAT);
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_seccomp.h b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_seccomp.h
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_seccomp.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_seccomp.h	2025-05-30 15:22:01.000000000 +0800
@@ -41,6 +41,9 @@
 #ifndef EM_AARCH64
 #define EM_AARCH64 183
 #endif
+#ifndef EM_PPC64
+#define EM_PPC64 21
+#endif
 
 #ifndef __AUDIT_ARCH_64BIT
 #define __AUDIT_ARCH_64BIT 0x80000000
@@ -73,6 +76,12 @@
 #ifndef AUDIT_ARCH_AARCH64
 #define AUDIT_ARCH_AARCH64 (EM_AARCH64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
 #endif
+#ifndef AUDIT_ARCH_PPC64
+#define AUDIT_ARCH_PPC64 (EM_PPC64 | __AUDIT_ARCH_64BIT)
+#endif
+#ifndef AUDIT_ARCH_PPC64LE
+#define AUDIT_ARCH_PPC64LE (EM_PPC64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
+#endif
 
 // For prctl.h
 #ifndef PR_SET_SECCOMP
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_signal.h b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_signal.h
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_signal.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_signal.h	2025-05-30 15:22:01.000000000 +0800
@@ -13,7 +13,7 @@
 // (not undefined, but defined different values and in different memory
 // layouts). So, fill the gap here.
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
 
 #define LINUX_SIGHUP 1
 #define LINUX_SIGINT 2
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_stat.h b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_stat.h
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_stat.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_stat.h	2025-06-06 16:00:47.000000000 +0800
@@ -10,6 +10,14 @@
 #include "build/build_config.h"
 #include "sandbox/linux/system_headers/linux_syscalls.h"
 
+
+#if defined(ARCH_CPU_PPC64)
+struct kernel_stat {
+        unsigned long irqs_sum;
+        unsigned int softirqs[10];
+};
+#endif
+
 #if defined(ARCH_CPU_MIPS_FAMILY)
 #if defined(ARCH_CPU_64_BITS)
 struct kernel_stat {
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_syscalls.h b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_syscalls.h
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_syscalls.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_syscalls.h	2025-05-30 15:19:49.000000000 +0800
@@ -35,5 +35,9 @@
 #include "sandbox/linux/system_headers/arm64_linux_syscalls.h"
 #endif
 
+#if defined(__powerpc64__)
+#include "sandbox/linux/system_headers/ppc64_linux_syscalls.h"
+#endif
+
 #endif  // SANDBOX_LINUX_SYSTEM_HEADERS_LINUX_SYSCALLS_H_
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_ucontext.h b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_ucontext.h
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_ucontext.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/linux_ucontext.h	2025-05-30 15:19:49.000000000 +0800
@@ -11,6 +11,8 @@
 #include "sandbox/linux/system_headers/arm_linux_ucontext.h"
 #elif defined(__i386__)
 #include "sandbox/linux/system_headers/i386_linux_ucontext.h"
+#elif defined(__powerpc64__)
+#include "sandbox/linux/system_headers/ppc64_linux_ucontext.h"
 #else
 #error "No support for your architecture in PNaCl header"
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_syscalls.h b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_syscalls.h
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_syscalls.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_syscalls.h	2025-06-03 15:56:24.000000000 +0800
@@ -0,0 +1,1446 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_SYSCALLS_H_
+#define SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_SYSCALLS_H_
+
+#include <asm/unistd.h>
+
+//TODO: is it necessary to redefine syscall numbers for PPC64?
+// Needed for Ubuntu/Debian/Centos/RHEL:
+
+#if !defined(__powerpc64__)
+#error "Including header on wrong architecture"
+#endif
+
+#if !defined(__NR_read)
+#define __NR_read 0
+#endif
+
+#if !defined(__NR_write)
+#define __NR_write 1
+#endif
+
+#if !defined(__NR_open)
+#define __NR_open 2
+#endif
+
+#if !defined(__NR_close)
+#define __NR_close 3
+#endif
+
+#if !defined(__NR_stat)
+#define __NR_stat 4
+#endif
+
+#if !defined(__NR_fstat)
+#define __NR_fstat 5
+#endif
+
+#if !defined(__NR_lstat)
+#define __NR_lstat 6
+#endif
+
+#if !defined(__NR_poll)
+#define __NR_poll 7
+#endif
+
+#if !defined(__NR_lseek)
+#define __NR_lseek 8
+#endif
+
+#if !defined(__NR_mmap)
+#define __NR_mmap 9
+#endif
+
+#if !defined(__NR_mprotect)
+#define __NR_mprotect 10
+#endif
+
+#if !defined(__NR_munmap)
+#define __NR_munmap 11
+#endif
+
+#if !defined(__NR_brk)
+#define __NR_brk 12
+#endif
+
+#if !defined(__NR_rt_sigaction)
+#define __NR_rt_sigaction 13
+#endif
+
+#if !defined(__NR_rt_sigprocmask)
+#define __NR_rt_sigprocmask 14
+#endif
+
+#if !defined(__NR_rt_sigreturn)
+#define __NR_rt_sigreturn 15
+#endif
+
+#if !defined(__NR_ioctl)
+#define __NR_ioctl 16
+#endif
+
+#if !defined(__NR_pread64)
+#define __NR_pread64 17
+#endif
+
+#if !defined(__NR_pwrite64)
+#define __NR_pwrite64 18
+#endif
+
+#if !defined(__NR_readv)
+#define __NR_readv 19
+#endif
+
+#if !defined(__NR_writev)
+#define __NR_writev 20
+#endif
+
+#if !defined(__NR_access)
+#define __NR_access 21
+#endif
+
+#if !defined(__NR_pipe)
+#define __NR_pipe 22
+#endif
+
+#if !defined(__NR_select)
+#define __NR_select 23
+#endif
+
+#if !defined(__NR_sched_yield)
+#define __NR_sched_yield 24
+#endif
+
+#if !defined(__NR_mremap)
+#define __NR_mremap 25
+#endif
+
+#if !defined(__NR_msync)
+#define __NR_msync 26
+#endif
+
+#if !defined(__NR_mincore)
+#define __NR_mincore 27
+#endif
+
+#if !defined(__NR_madvise)
+#define __NR_madvise 28
+#endif
+
+#if !defined(__NR_shmget)
+#define __NR_shmget 29
+#endif
+
+#if !defined(__NR_shmat)
+#define __NR_shmat 30
+#endif
+
+#if !defined(__NR_shmctl)
+#define __NR_shmctl 31
+#endif
+
+#if !defined(__NR_dup)
+#define __NR_dup 32
+#endif
+
+#if !defined(__NR_dup2)
+#define __NR_dup2 33
+#endif
+
+#if !defined(__NR_pause)
+#define __NR_pause 34
+#endif
+
+#if !defined(__NR_nanosleep)
+#define __NR_nanosleep 35
+#endif
+
+#if !defined(__NR_getitimer)
+#define __NR_getitimer 36
+#endif
+
+#if !defined(__NR_alarm)
+#define __NR_alarm 37
+#endif
+
+#if !defined(__NR_setitimer)
+#define __NR_setitimer 38
+#endif
+
+#if !defined(__NR_getpid)
+#define __NR_getpid 39
+#endif
+
+#if !defined(__NR_sendfile)
+#define __NR_sendfile 40
+#endif
+
+#if !defined(__NR_socket)
+#define __NR_socket 41
+#endif
+
+#if !defined(__NR_connect)
+#define __NR_connect 42
+#endif
+
+#if !defined(__NR_accept)
+#define __NR_accept 43
+#endif
+
+#if !defined(__NR_sendto)
+#define __NR_sendto 44
+#endif
+
+#if !defined(__NR_recvfrom)
+#define __NR_recvfrom 45
+#endif
+
+#if !defined(__NR_sendmsg)
+#define __NR_sendmsg 46
+#endif
+
+#if !defined(__NR_recvmsg)
+#define __NR_recvmsg 47
+#endif
+
+#if !defined(__NR_shutdown)
+#define __NR_shutdown 48
+#endif
+
+#if !defined(__NR_bind)
+#define __NR_bind 49
+#endif
+
+#if !defined(__NR_listen)
+#define __NR_listen 50
+#endif
+
+#if !defined(__NR_getsockname)
+#define __NR_getsockname 51
+#endif
+
+#if !defined(__NR_getpeername)
+#define __NR_getpeername 52
+#endif
+
+#if !defined(__NR_socketpair)
+#define __NR_socketpair 53
+#endif
+
+#if !defined(__NR_setsockopt)
+#define __NR_setsockopt 54
+#endif
+
+#if !defined(__NR_getsockopt)
+#define __NR_getsockopt 55
+#endif
+
+#if !defined(__NR_clone)
+#define __NR_clone 56
+#endif
+
+#if !defined(__NR_fork)
+#define __NR_fork 57
+#endif
+
+#if !defined(__NR_vfork)
+#define __NR_vfork 58
+#endif
+
+#if !defined(__NR_execve)
+#define __NR_execve 59
+#endif
+
+#if !defined(__NR_exit)
+#define __NR_exit 60
+#endif
+
+#if !defined(__NR_wait4)
+#define __NR_wait4 61
+#endif
+
+#if !defined(__NR_kill)
+#define __NR_kill 62
+#endif
+
+#if !defined(__NR_uname)
+#define __NR_uname 63
+#endif
+
+#if !defined(__NR_semget)
+#define __NR_semget 64
+#endif
+
+#if !defined(__NR_semop)
+#define __NR_semop 65
+#endif
+
+#if !defined(__NR_semctl)
+#define __NR_semctl 66
+#endif
+
+#if !defined(__NR_shmdt)
+#define __NR_shmdt 67
+#endif
+
+#if !defined(__NR_msgget)
+#define __NR_msgget 68
+#endif
+
+#if !defined(__NR_msgsnd)
+#define __NR_msgsnd 69
+#endif
+
+#if !defined(__NR_msgrcv)
+#define __NR_msgrcv 70
+#endif
+
+#if !defined(__NR_msgctl)
+#define __NR_msgctl 71
+#endif
+
+#if !defined(__NR_fcntl)
+#define __NR_fcntl 72
+#endif
+
+#if !defined(__NR_flock)
+#define __NR_flock 73
+#endif
+
+#if !defined(__NR_fsync)
+#define __NR_fsync 74
+#endif
+
+#if !defined(__NR_fdatasync)
+#define __NR_fdatasync 75
+#endif
+
+#if !defined(__NR_truncate)
+#define __NR_truncate 76
+#endif
+
+#if !defined(__NR_ftruncate)
+#define __NR_ftruncate 77
+#endif
+
+#if !defined(__NR_getdents)
+#define __NR_getdents 78
+#endif
+
+#if !defined(__NR_getcwd)
+#define __NR_getcwd 79
+#endif
+
+#if !defined(__NR_chdir)
+#define __NR_chdir 80
+#endif
+
+#if !defined(__NR_fchdir)
+#define __NR_fchdir 81
+#endif
+
+#if !defined(__NR_rename)
+#define __NR_rename 82
+#endif
+
+#if !defined(__NR_mkdir)
+#define __NR_mkdir 83
+#endif
+
+#if !defined(__NR_rmdir)
+#define __NR_rmdir 84
+#endif
+
+#if !defined(__NR_creat)
+#define __NR_creat 85
+#endif
+
+#if !defined(__NR_link)
+#define __NR_link 86
+#endif
+
+#if !defined(__NR_unlink)
+#define __NR_unlink 87
+#endif
+
+#if !defined(__NR_symlink)
+#define __NR_symlink 88
+#endif
+
+#if !defined(__NR_readlink)
+#define __NR_readlink 89
+#endif
+
+#if !defined(__NR_chmod)
+#define __NR_chmod 90
+#endif
+
+#if !defined(__NR_fchmod)
+#define __NR_fchmod 91
+#endif
+
+#if !defined(__NR_chown)
+#define __NR_chown 92
+#endif
+
+#if !defined(__NR_fchown)
+#define __NR_fchown 93
+#endif
+
+#if !defined(__NR_lchown)
+#define __NR_lchown 94
+#endif
+
+#if !defined(__NR_umask)
+#define __NR_umask 95
+#endif
+
+#if !defined(__NR_gettimeofday)
+#define __NR_gettimeofday 96
+#endif
+
+#if !defined(__NR_getrlimit)
+#define __NR_getrlimit 97
+#endif
+
+#if !defined(__NR_getrusage)
+#define __NR_getrusage 98
+#endif
+
+#if !defined(__NR_sysinfo)
+#define __NR_sysinfo 99
+#endif
+
+#if !defined(__NR_times)
+#define __NR_times 100
+#endif
+
+#if !defined(__NR_ptrace)
+#define __NR_ptrace 101
+#endif
+
+#if !defined(__NR_getuid)
+#define __NR_getuid 102
+#endif
+
+#if !defined(__NR_syslog)
+#define __NR_syslog 103
+#endif
+
+#if !defined(__NR_getgid)
+#define __NR_getgid 104
+#endif
+
+#if !defined(__NR_setuid)
+#define __NR_setuid 105
+#endif
+
+#if !defined(__NR_setgid)
+#define __NR_setgid 106
+#endif
+
+#if !defined(__NR_geteuid)
+#define __NR_geteuid 107
+#endif
+
+#if !defined(__NR_getegid)
+#define __NR_getegid 108
+#endif
+
+#if !defined(__NR_setpgid)
+#define __NR_setpgid 109
+#endif
+
+#if !defined(__NR_getppid)
+#define __NR_getppid 110
+#endif
+
+#if !defined(__NR_getpgrp)
+#define __NR_getpgrp 111
+#endif
+
+#if !defined(__NR_setsid)
+#define __NR_setsid 112
+#endif
+
+#if !defined(__NR_setreuid)
+#define __NR_setreuid 113
+#endif
+
+#if !defined(__NR_setregid)
+#define __NR_setregid 114
+#endif
+
+#if !defined(__NR_getgroups)
+#define __NR_getgroups 115
+#endif
+
+#if !defined(__NR_setgroups)
+#define __NR_setgroups 116
+#endif
+
+#if !defined(__NR_setresuid)
+#define __NR_setresuid 117
+#endif
+
+#if !defined(__NR_getresuid)
+#define __NR_getresuid 118
+#endif
+
+#if !defined(__NR_setresgid)
+#define __NR_setresgid 119
+#endif
+
+#if !defined(__NR_getresgid)
+#define __NR_getresgid 120
+#endif
+
+#if !defined(__NR_getpgid)
+#define __NR_getpgid 121
+#endif
+
+#if !defined(__NR_setfsuid)
+#define __NR_setfsuid 122
+#endif
+
+#if !defined(__NR_setfsgid)
+#define __NR_setfsgid 123
+#endif
+
+#if !defined(__NR_getsid)
+#define __NR_getsid 124
+#endif
+
+#if !defined(__NR_capget)
+#define __NR_capget 125
+#endif
+
+#if !defined(__NR_capset)
+#define __NR_capset 126
+#endif
+
+#if !defined(__NR_rt_sigpending)
+#define __NR_rt_sigpending 127
+#endif
+
+#if !defined(__NR_rt_sigtimedwait)
+#define __NR_rt_sigtimedwait 128
+#endif
+
+#if !defined(__NR_rt_sigqueueinfo)
+#define __NR_rt_sigqueueinfo 129
+#endif
+
+#if !defined(__NR_rt_sigsuspend)
+#define __NR_rt_sigsuspend 130
+#endif
+
+#if !defined(__NR_sigaltstack)
+#define __NR_sigaltstack 131
+#endif
+
+#if !defined(__NR_utime)
+#define __NR_utime 132
+#endif
+
+#if !defined(__NR_mknod)
+#define __NR_mknod 133
+#endif
+
+#if !defined(__NR_uselib)
+#define __NR_uselib 134
+#endif
+
+#if !defined(__NR_personality)
+#define __NR_personality 135
+#endif
+
+#if !defined(__NR_ustat)
+#define __NR_ustat 136
+#endif
+
+#if !defined(__NR_statfs)
+#define __NR_statfs 137
+#endif
+
+#if !defined(__NR_fstatfs)
+#define __NR_fstatfs 138
+#endif
+
+#if !defined(__NR_sysfs)
+#define __NR_sysfs 139
+#endif
+
+#if !defined(__NR_getpriority)
+#define __NR_getpriority 140
+#endif
+
+#if !defined(__NR_setpriority)
+#define __NR_setpriority 141
+#endif
+
+#if !defined(__NR_sched_setparam)
+#define __NR_sched_setparam 142
+#endif
+
+#if !defined(__NR_sched_getparam)
+#define __NR_sched_getparam 143
+#endif
+
+#if !defined(__NR_sched_setscheduler)
+#define __NR_sched_setscheduler 144
+#endif
+
+#if !defined(__NR_sched_getscheduler)
+#define __NR_sched_getscheduler 145
+#endif
+
+#if !defined(__NR_sched_get_priority_max)
+#define __NR_sched_get_priority_max 146
+#endif
+
+#if !defined(__NR_sched_get_priority_min)
+#define __NR_sched_get_priority_min 147
+#endif
+
+#if !defined(__NR_sched_rr_get_interval)
+#define __NR_sched_rr_get_interval 148
+#endif
+
+#if !defined(__NR_mlock)
+#define __NR_mlock 149
+#endif
+
+#if !defined(__NR_munlock)
+#define __NR_munlock 150
+#endif
+
+#if !defined(__NR_mlockall)
+#define __NR_mlockall 151
+#endif
+
+#if !defined(__NR_munlockall)
+#define __NR_munlockall 152
+#endif
+
+#if !defined(__NR_vhangup)
+#define __NR_vhangup 153
+#endif
+
+#if !defined(__NR_modify_ldt)
+#define __NR_modify_ldt 154
+#endif
+
+#if !defined(__NR_pivot_root)
+#define __NR_pivot_root 155
+#endif
+
+#if !defined(__NR__sysctl)
+#define __NR__sysctl 156
+#endif
+
+#if !defined(__NR_prctl)
+#define __NR_prctl 157
+#endif
+
+#if !defined(__NR_arch_prctl)
+#define __NR_arch_prctl 158
+#endif
+
+#if !defined(__NR_adjtimex)
+#define __NR_adjtimex 159
+#endif
+
+#if !defined(__NR_setrlimit)
+#define __NR_setrlimit 160
+#endif
+
+#if !defined(__NR_chroot)
+#define __NR_chroot 161
+#endif
+
+#if !defined(__NR_sync)
+#define __NR_sync 162
+#endif
+
+#if !defined(__NR_acct)
+#define __NR_acct 163
+#endif
+
+#if !defined(__NR_settimeofday)
+#define __NR_settimeofday 164
+#endif
+
+#if !defined(__NR_mount)
+#define __NR_mount 165
+#endif
+
+#if !defined(__NR_umount2)
+#define __NR_umount2 166
+#endif
+
+#if !defined(__NR_swapon)
+#define __NR_swapon 167
+#endif
+
+#if !defined(__NR_swapoff)
+#define __NR_swapoff 168
+#endif
+
+#if !defined(__NR_reboot)
+#define __NR_reboot 169
+#endif
+
+#if !defined(__NR_sethostname)
+#define __NR_sethostname 170
+#endif
+
+#if !defined(__NR_setdomainname)
+#define __NR_setdomainname 171
+#endif
+
+#if !defined(__NR_iopl)
+#define __NR_iopl 172
+#endif
+
+#if !defined(__NR_ioperm)
+#define __NR_ioperm 173
+#endif
+
+#if !defined(__NR_create_module)
+#define __NR_create_module 174
+#endif
+
+#if !defined(__NR_init_module)
+#define __NR_init_module 175
+#endif
+
+#if !defined(__NR_delete_module)
+#define __NR_delete_module 176
+#endif
+
+#if !defined(__NR_get_kernel_syms)
+#define __NR_get_kernel_syms 177
+#endif
+
+#if !defined(__NR_query_module)
+#define __NR_query_module 178
+#endif
+
+#if !defined(__NR_quotactl)
+#define __NR_quotactl 179
+#endif
+
+#if !defined(__NR_nfsservctl)
+#define __NR_nfsservctl 180
+#endif
+
+#if !defined(__NR_getpmsg)
+#define __NR_getpmsg 181
+#endif
+
+#if !defined(__NR_putpmsg)
+#define __NR_putpmsg 182
+#endif
+
+#if !defined(__NR_afs_syscall)
+#define __NR_afs_syscall 183
+#endif
+
+#if !defined(__NR_tuxcall)
+#define __NR_tuxcall 184
+#endif
+
+#if !defined(__NR_security)
+#define __NR_security 185
+#endif
+
+#if !defined(__NR_gettid)
+#define __NR_gettid 186
+#endif
+
+#if !defined(__NR_readahead)
+#define __NR_readahead 187
+#endif
+
+#if !defined(__NR_setxattr)
+#define __NR_setxattr 188
+#endif
+
+#if !defined(__NR_lsetxattr)
+#define __NR_lsetxattr 189
+#endif
+
+#if !defined(__NR_fsetxattr)
+#define __NR_fsetxattr 190
+#endif
+
+#if !defined(__NR_getxattr)
+#define __NR_getxattr 191
+#endif
+
+#if !defined(__NR_lgetxattr)
+#define __NR_lgetxattr 192
+#endif
+
+#if !defined(__NR_fgetxattr)
+#define __NR_fgetxattr 193
+#endif
+
+#if !defined(__NR_listxattr)
+#define __NR_listxattr 194
+#endif
+
+#if !defined(__NR_llistxattr)
+#define __NR_llistxattr 195
+#endif
+
+#if !defined(__NR_flistxattr)
+#define __NR_flistxattr 196
+#endif
+
+#if !defined(__NR_removexattr)
+#define __NR_removexattr 197
+#endif
+
+#if !defined(__NR_lremovexattr)
+#define __NR_lremovexattr 198
+#endif
+
+#if !defined(__NR_fremovexattr)
+#define __NR_fremovexattr 199
+#endif
+
+#if !defined(__NR_tkill)
+#define __NR_tkill 200
+#endif
+
+#if !defined(__NR_time)
+#define __NR_time 201
+#endif
+
+#if !defined(__NR_futex)
+#define __NR_futex 202
+#endif
+
+#if !defined(__NR_sched_setaffinity)
+#define __NR_sched_setaffinity 203
+#endif
+
+#if !defined(__NR_sched_getaffinity)
+#define __NR_sched_getaffinity 204
+#endif
+
+#if !defined(__NR_set_thread_area)
+#define __NR_set_thread_area 205
+#endif
+
+#if !defined(__NR_io_setup)
+#define __NR_io_setup 206
+#endif
+
+#if !defined(__NR_io_destroy)
+#define __NR_io_destroy 207
+#endif
+
+#if !defined(__NR_io_getevents)
+#define __NR_io_getevents 208
+#endif
+
+#if !defined(__NR_io_submit)
+#define __NR_io_submit 209
+#endif
+
+#if !defined(__NR_io_cancel)
+#define __NR_io_cancel 210
+#endif
+
+#if !defined(__NR_get_thread_area)
+#define __NR_get_thread_area 211
+#endif
+
+#if !defined(__NR_lookup_dcookie)
+#define __NR_lookup_dcookie 212
+#endif
+
+#if !defined(__NR_epoll_create)
+#define __NR_epoll_create 213
+#endif
+
+#if !defined(__NR_epoll_ctl_old)
+#define __NR_epoll_ctl_old 214
+#endif
+
+#if !defined(__NR_epoll_wait_old)
+#define __NR_epoll_wait_old 215
+#endif
+
+#if !defined(__NR_remap_file_pages)
+#define __NR_remap_file_pages 216
+#endif
+
+#if !defined(__NR_getdents64)
+#define __NR_getdents64 217
+#endif
+
+#if !defined(__NR_set_tid_address)
+#define __NR_set_tid_address 218
+#endif
+
+#if !defined(__NR_restart_syscall)
+#define __NR_restart_syscall 219
+#endif
+
+#if !defined(__NR_semtimedop)
+#define __NR_semtimedop 220
+#endif
+
+#if !defined(__NR_fadvise64)
+#define __NR_fadvise64 221
+#endif
+
+#if !defined(__NR_timer_create)
+#define __NR_timer_create 222
+#endif
+
+#if !defined(__NR_timer_settime)
+#define __NR_timer_settime 223
+#endif
+
+#if !defined(__NR_timer_gettime)
+#define __NR_timer_gettime 224
+#endif
+
+#if !defined(__NR_timer_getoverrun)
+#define __NR_timer_getoverrun 225
+#endif
+
+#if !defined(__NR_timer_delete)
+#define __NR_timer_delete 226
+#endif
+
+#if !defined(__NR_clock_settime)
+#define __NR_clock_settime 227
+#endif
+
+#if !defined(__NR_clock_gettime)
+#define __NR_clock_gettime 228
+#endif
+
+#if !defined(__NR_clock_getres)
+#define __NR_clock_getres 229
+#endif
+
+#if !defined(__NR_clock_nanosleep)
+#define __NR_clock_nanosleep 230
+#endif
+
+#if !defined(__NR_exit_group)
+#define __NR_exit_group 231
+#endif
+
+#if !defined(__NR_epoll_wait)
+#define __NR_epoll_wait 232
+#endif
+
+#if !defined(__NR_epoll_ctl)
+#define __NR_epoll_ctl 233
+#endif
+
+#if !defined(__NR_tgkill)
+#define __NR_tgkill 234
+#endif
+
+#if !defined(__NR_utimes)
+#define __NR_utimes 235
+#endif
+
+#if !defined(__NR_vserver)
+#define __NR_vserver 236
+#endif
+
+#if !defined(__NR_mbind)
+#define __NR_mbind 237
+#endif
+
+#if !defined(__NR_set_mempolicy)
+#define __NR_set_mempolicy 238
+#endif
+
+#if !defined(__NR_get_mempolicy)
+#define __NR_get_mempolicy 239
+#endif
+
+#if !defined(__NR_mq_open)
+#define __NR_mq_open 240
+#endif
+
+#if !defined(__NR_mq_unlink)
+#define __NR_mq_unlink 241
+#endif
+
+#if !defined(__NR_mq_timedsend)
+#define __NR_mq_timedsend 242
+#endif
+
+#if !defined(__NR_mq_timedreceive)
+#define __NR_mq_timedreceive 243
+#endif
+
+#if !defined(__NR_mq_notify)
+#define __NR_mq_notify 244
+#endif
+
+#if !defined(__NR_mq_getsetattr)
+#define __NR_mq_getsetattr 245
+#endif
+
+#if !defined(__NR_kexec_load)
+#define __NR_kexec_load 246
+#endif
+
+#if !defined(__NR_waitid)
+#define __NR_waitid 247
+#endif
+
+#if !defined(__NR_add_key)
+#define __NR_add_key 248
+#endif
+
+#if !defined(__NR_request_key)
+#define __NR_request_key 249
+#endif
+
+#if !defined(__NR_keyctl)
+#define __NR_keyctl 250
+#endif
+
+#if !defined(__NR_ioprio_set)
+#define __NR_ioprio_set 251
+#endif
+
+#if !defined(__NR_ioprio_get)
+#define __NR_ioprio_get 252
+#endif
+
+#if !defined(__NR_inotify_init)
+#define __NR_inotify_init 253
+#endif
+
+#if !defined(__NR_inotify_add_watch)
+#define __NR_inotify_add_watch 254
+#endif
+
+#if !defined(__NR_inotify_rm_watch)
+#define __NR_inotify_rm_watch 255
+#endif
+
+#if !defined(__NR_migrate_pages)
+#define __NR_migrate_pages 256
+#endif
+
+#if !defined(__NR_openat)
+#define __NR_openat 257
+#endif
+
+#if !defined(__NR_mkdirat)
+#define __NR_mkdirat 258
+#endif
+
+#if !defined(__NR_mknodat)
+#define __NR_mknodat 259
+#endif
+
+#if !defined(__NR_fchownat)
+#define __NR_fchownat 260
+#endif
+
+#if !defined(__NR_futimesat)
+#define __NR_futimesat 261
+#endif
+
+#if !defined(__NR_newfstatat)
+#define __NR_newfstatat 262
+#endif
+
+#if !defined(__NR_unlinkat)
+#define __NR_unlinkat 263
+#endif
+
+#if !defined(__NR_renameat)
+#define __NR_renameat 264
+#endif
+
+#if !defined(__NR_linkat)
+#define __NR_linkat 265
+#endif
+
+#if !defined(__NR_symlinkat)
+#define __NR_symlinkat 266
+#endif
+
+#if !defined(__NR_readlinkat)
+#define __NR_readlinkat 267
+#endif
+
+#if !defined(__NR_fchmodat)
+#define __NR_fchmodat 268
+#endif
+
+#if !defined(__NR_faccessat)
+#define __NR_faccessat 269
+#endif
+
+#if !defined(__NR_pselect6)
+#define __NR_pselect6 270
+#endif
+
+#if !defined(__NR_ppoll)
+#define __NR_ppoll 271
+#endif
+
+#if !defined(__NR_unshare)
+#define __NR_unshare 272
+#endif
+
+#if !defined(__NR_set_robust_list)
+#define __NR_set_robust_list 273
+#endif
+
+#if !defined(__NR_get_robust_list)
+#define __NR_get_robust_list 274
+#endif
+
+#if !defined(__NR_splice)
+#define __NR_splice 275
+#endif
+
+#if !defined(__NR_tee)
+#define __NR_tee 276
+#endif
+
+#if !defined(__NR_sync_file_range)
+#define __NR_sync_file_range 277
+#endif
+
+#if !defined(__NR_vmsplice)
+#define __NR_vmsplice 278
+#endif
+
+#if !defined(__NR_move_pages)
+#define __NR_move_pages 279
+#endif
+
+#if !defined(__NR_utimensat)
+#define __NR_utimensat 280
+#endif
+
+#if !defined(__NR_epoll_pwait)
+#define __NR_epoll_pwait 281
+#endif
+
+#if !defined(__NR_signalfd)
+#define __NR_signalfd 282
+#endif
+
+#if !defined(__NR_timerfd_create)
+#define __NR_timerfd_create 283
+#endif
+
+#if !defined(__NR_eventfd)
+#define __NR_eventfd 284
+#endif
+
+#if !defined(__NR_fallocate)
+#define __NR_fallocate 285
+#endif
+
+#if !defined(__NR_timerfd_settime)
+#define __NR_timerfd_settime 286
+#endif
+
+#if !defined(__NR_timerfd_gettime)
+#define __NR_timerfd_gettime 287
+#endif
+
+#if !defined(__NR_accept4)
+#define __NR_accept4 288
+#endif
+
+#if !defined(__NR_signalfd4)
+#define __NR_signalfd4 289
+#endif
+
+#if !defined(__NR_eventfd2)
+#define __NR_eventfd2 290
+#endif
+
+#if !defined(__NR_epoll_create1)
+#define __NR_epoll_create1 291
+#endif
+
+#if !defined(__NR_dup3)
+#define __NR_dup3 292
+#endif
+
+#if !defined(__NR_pipe2)
+#define __NR_pipe2 293
+#endif
+
+#if !defined(__NR_inotify_init1)
+#define __NR_inotify_init1 294
+#endif
+
+#if !defined(__NR_preadv)
+#define __NR_preadv 295
+#endif
+
+#if !defined(__NR_pwritev)
+#define __NR_pwritev 296
+#endif
+
+#if !defined(__NR_rt_tgsigqueueinfo)
+#define __NR_rt_tgsigqueueinfo 297
+#endif
+
+#if !defined(__NR_perf_event_open)
+#define __NR_perf_event_open 298
+#endif
+
+#if !defined(__NR_recvmmsg)
+#define __NR_recvmmsg 299
+#endif
+
+#if !defined(__NR_fanotify_init)
+#define __NR_fanotify_init 300
+#endif
+
+#if !defined(__NR_fanotify_mark)
+#define __NR_fanotify_mark 301
+#endif
+
+#if !defined(__NR_prlimit64)
+#define __NR_prlimit64 302
+#endif
+
+#if !defined(__NR_name_to_handle_at)
+#define __NR_name_to_handle_at 303
+#endif
+
+#if !defined(__NR_open_by_handle_at)
+#define __NR_open_by_handle_at 304
+#endif
+
+#if !defined(__NR_clock_adjtime)
+#define __NR_clock_adjtime 305
+#endif
+
+#if !defined(__NR_syncfs)
+#define __NR_syncfs 306
+#endif
+
+#if !defined(__NR_sendmmsg)
+#define __NR_sendmmsg 307
+#endif
+
+#if !defined(__NR_setns)
+#define __NR_setns 308
+#endif
+
+#if !defined(__NR_getcpu)
+#define __NR_getcpu 309
+#endif
+
+#if !defined(__NR_process_vm_readv)
+#define __NR_process_vm_readv 310
+#endif
+
+#if !defined(__NR_process_vm_writev)
+#define __NR_process_vm_writev 311
+#endif
+
+#if !defined(__NR_kcmp)
+#define __NR_kcmp 312
+#endif
+
+#if !defined(__NR_finit_module)
+#define __NR_finit_module 313
+#endif
+
+#if !defined(__NR_sched_setattr)
+#define __NR_sched_setattr 314
+#endif
+
+#if !defined(__NR_sched_getattr)
+#define __NR_sched_getattr 315
+#endif
+
+#if !defined(__NR_renameat2)
+#define __NR_renameat2 316
+#endif
+
+#if !defined(__NR_seccomp)
+#define __NR_seccomp 317
+#endif
+
+#if !defined(__NR_getrandom)
+#define __NR_getrandom 318
+#endif
+
+#if !defined(__NR_memfd_create)
+#define __NR_memfd_create 319
+#endif
+
+#if !defined(__NR_kexec_file_load)
+#define __NR_kexec_file_load 320
+#endif
+
+#if !defined(__NR_bpf)
+#define __NR_bpf 321
+#endif
+
+#if !defined(__NR_execveat)
+#define __NR_execveat 322
+#endif
+
+#if !defined(__NR_userfaultfd)
+#define __NR_userfaultfd 323
+#endif
+
+#if !defined(__NR_membarrier)
+#define __NR_membarrier 324
+#endif
+
+#if !defined(__NR_mlock2)
+#define __NR_mlock2 325
+#endif
+
+#if !defined(__NR_copy_file_range)
+#define __NR_copy_file_range 326
+#endif
+
+#if !defined(__NR_preadv2)
+#define __NR_preadv2 327
+#endif
+
+#if !defined(__NR_pwritev2)
+#define __NR_pwritev2 328
+#endif
+
+#if !defined(__NR_pkey_mprotect)
+#define __NR_pkey_mprotect 329
+#endif
+
+#if !defined(__NR_pkey_alloc)
+#define __NR_pkey_alloc 330
+#endif
+
+#if !defined(__NR_pkey_free)
+#define __NR_pkey_free 331
+#endif
+
+#if !defined(__NR_statx)
+#define __NR_statx 332
+#endif
+
+#if !defined(__NR_io_pgetevents)
+#define __NR_io_pgetevents 333
+#endif
+
+#if !defined(__NR_rseq)
+#define __NR_rseq 334
+#endif
+
+#if !defined(__NR_pidfd_send_signal)
+#define __NR_pidfd_send_signal 424
+#endif
+
+#if !defined(__NR_io_uring_setup)
+#define __NR_io_uring_setup 425
+#endif
+
+#if !defined(__NR_io_uring_enter)
+#define __NR_io_uring_enter 426
+#endif
+
+#if !defined(__NR_io_uring_register)
+#define __NR_io_uring_register 427
+#endif
+
+#if !defined(__NR_open_tree)
+#define __NR_open_tree 428
+#endif
+
+#if !defined(__NR_move_mount)
+#define __NR_move_mount 429
+#endif
+
+#if !defined(__NR_fsopen)
+#define __NR_fsopen 430
+#endif
+
+#if !defined(__NR_fsconfig)
+#define __NR_fsconfig 431
+#endif
+
+#if !defined(__NR_fsmount)
+#define __NR_fsmount 432
+#endif
+
+#if !defined(__NR_fspick)
+#define __NR_fspick 433
+#endif
+
+#if !defined(__NR_pidfd_open)
+#define __NR_pidfd_open 434
+#endif
+
+#if !defined(__NR_clone3)
+#define __NR_clone3 435
+#endif
+
+#if !defined(__NR_close_range)
+#define __NR_close_range 436
+#endif
+
+#if !defined(__NR_openat2)
+#define __NR_openat2 437
+#endif
+
+#if !defined(__NR_pidfd_getfd)
+#define __NR_pidfd_getfd 438
+#endif
+
+#if !defined(__NR_faccessat2)
+#define __NR_faccessat2 439
+#endif
+
+#if !defined(__NR_process_madvise)
+#define __NR_process_madvise 440
+#endif
+
+#if !defined(__NR_epoll_pwait2)
+#define __NR_epoll_pwait2 441
+#endif
+
+#if !defined(__NR_mount_setattr)
+#define __NR_mount_setattr 442
+#endif
+
+#if !defined(__NR_landlock_create_ruleset)
+#define __NR_landlock_create_ruleset 444
+#endif
+
+#if !defined(__NR_landlock_add_rule)
+#define __NR_landlock_add_rule 445
+#endif
+
+#if !defined(__NR_landlock_restrict_self)
+#define __NR_landlock_restrict_self 446
+#endif
+
+#endif  // SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_SYSCALLS_H_
+
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_ucontext.h b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_ucontext.h
--- a/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_ucontext.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_ucontext.h	2025-05-30 15:19:49.000000000 +0800
@@ -0,0 +1,12 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_UCONTEXT_H_
+#define SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_UCONTEXT_H_
+
+#include <sys/ucontext.h>
+
+//TODO: is it necessary to redefine ucontext on PPC64?
+
+#endif  // SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_UCONTEXT_H_
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/policy/linux/bpf_renderer_policy_linux.cc b/qtwebengine/src/3rdparty/chromium/sandbox/policy/linux/bpf_renderer_policy_linux.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/policy/linux/bpf_renderer_policy_linux.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/policy/linux/bpf_renderer_policy_linux.cc	2025-05-30 15:42:21.000000000 +0800
@@ -15,6 +15,11 @@
 #include "sandbox/linux/system_headers/linux_syscalls.h"
 #include "sandbox/policy/linux/sandbox_linux.h"
 
+// On PPC64, TCGETS is defined in terms of struct termios, so we must include termios.h
+#ifdef __powerpc64__
+#include <termios.h>
+#endif
+
 // TODO(vignatti): replace the local definitions below with #include
 // <linux/dma-buf.h> once kernel version 4.6 becomes widely used.
 #include <linux/types.h>
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/policy/linux/sandbox_linux.cc b/qtwebengine/src/3rdparty/chromium/sandbox/policy/linux/sandbox_linux.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/policy/linux/sandbox_linux.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/policy/linux/sandbox_linux.cc	2025-06-06 14:34:35.000000000 +0800
@@ -122,9 +122,13 @@
   if (broker_side_hook)
     CHECK(std::move(broker_side_hook).Run(options));
 
+#if BUILDFLAG(USE_SECCOMP_BPF)
   return SandboxSeccompBPF::StartSandboxWithExternalPolicy(
       std::make_unique<BrokerProcessPolicy>(allowed_command_set),
       base::ScopedFD());
+#else
+  return false;
+#endif
 }
 
 }  // namespace
diff -Naur a/qtwebengine/src/3rdparty/chromium/sandbox/policy/linux/sandbox_seccomp_bpf_linux.cc b/qtwebengine/src/3rdparty/chromium/sandbox/policy/linux/sandbox_seccomp_bpf_linux.cc
--- a/qtwebengine/src/3rdparty/chromium/sandbox/policy/linux/sandbox_seccomp_bpf_linux.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/sandbox/policy/linux/sandbox_seccomp_bpf_linux.cc	2025-06-03 17:22:35.000000000 +0800
@@ -64,9 +64,9 @@
 
 // Make sure that seccomp-bpf does not get disabled by mistake. Also make sure
 // that we think twice about this when adding a new architecture.
-#if !defined(ARCH_CPU_ARM64) && !defined(ARCH_CPU_MIPS64EL)
+#if !defined(ARCH_CPU_ARM64) && !defined(ARCH_CPU_MIPS64EL) && !defined(ARCH_CPU_PPC64) 
 #error "Seccomp-bpf disabled on supported architecture!"
-#endif  // !defined(ARCH_CPU_ARM64) && !defined(ARCH_CPU_MIPS64EL)
+#endif  
 
 #endif  // BUILDFLAG(USE_SECCOMP_BPF)
 
@@ -160,6 +160,7 @@
 std::unique_ptr<BPFBasePolicy> SandboxSeccompBPF::PolicyForSandboxType(
     SandboxType sandbox_type,
     const SandboxSeccompBPF::Options& options) {
+#if BUILDFLAG(USE_SECCOMP_BPF)
   switch (sandbox_type) {
     case SandboxType::kGpu:
       return GetGpuProcessSandbox(options.use_amd_specific_policies);
@@ -192,9 +193,13 @@
     case SandboxType::kVideoCapture:
       NOTREACHED();
       return nullptr;
-  }
+   }
+#else
+   return nullptr;
+#endif
 }
 
+#if BUILDFLAG(USE_SECCOMP_BPF)
 // If a BPF policy is engaged for |process_type|, run a few sanity checks.
 void SandboxSeccompBPF::RunSandboxSanityChecks(
     SandboxType sandbox_type,
@@ -243,13 +248,15 @@
       break;
   }
 }
+#endif
+
 #endif  // !defined(OS_NACL_NONSFI)
 
+#if BUILDFLAG(USE_SECCOMP_BPF)
 bool SandboxSeccompBPF::StartSandboxWithExternalPolicy(
     std::unique_ptr<bpf_dsl::Policy> policy,
     base::ScopedFD proc_fd,
     SandboxBPF::SeccompLevel seccomp_level) {
-#if BUILDFLAG(USE_SECCOMP_BPF)
   if (IsSeccompBPFDesired() && SupportsSandbox()) {
     CHECK(policy);
     // Starting the sandbox is a one-way operation. The kernel doesn't allow
@@ -262,18 +269,20 @@
     CHECK(sandbox.StartSandbox(seccomp_level));
     return true;
   }
-#endif  // BUILDFLAG(USE_SECCOMP_BPF)
   return false;
 }
+#endif  // BUILDFLAG(USE_SECCOMP_BPF)
 
 #if !defined(OS_NACL_NONSFI)
-std::unique_ptr<bpf_dsl::Policy> SandboxSeccompBPF::GetBaselinePolicy() {
 #if BUILDFLAG(USE_SECCOMP_BPF)
+std::unique_ptr<bpf_dsl::Policy> SandboxSeccompBPF::GetBaselinePolicy() {
+#if !defined(__powerpc64__)
   return std::make_unique<BaselinePolicy>();
 #else
   return nullptr;
-#endif  // BUILDFLAG(USE_SECCOMP_BPF)
+#endif
 }
+#endif  // BUILDFLAG(USE_SECCOMP_BPF)
 #endif  // !defined(OS_NACL_NONSFI)
 
 }  // namespace policy
diff -Naur a/qtwebengine/src/3rdparty/chromium/skia/BUILD.gn b/qtwebengine/src/3rdparty/chromium/skia/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/skia/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/skia/BUILD.gn	2025-06-05 14:46:13.000000000 +0800
@@ -819,6 +819,9 @@
     sources = skia_opts.none_sources
   } else if (current_cpu == "ppc64") {
     sources = skia_opts.none_sources
+  } else if (current_cpu == "ppc64le") {
+    cflags += [ "-maltivec" ]
+    sources = skia_opts.none_sources
   } else if (current_cpu == "s390x") {
     sources = skia_opts.none_sources
   } else {
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/abseil-cpp/absl/debugging/failure_signal_handler.cc b/qtwebengine/src/3rdparty/chromium/third_party/abseil-cpp/absl/debugging/failure_signal_handler.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/abseil-cpp/absl/debugging/failure_signal_handler.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/abseil-cpp/absl/debugging/failure_signal_handler.cc	2025-06-03 09:24:28.000000000 +0800
@@ -135,8 +135,7 @@
 #else
   const size_t page_mask = sysconf(_SC_PAGESIZE) - 1;
 #endif
-  size_t stack_size =
-      (std::max<size_t>(SIGSTKSZ, 65536) + page_mask) & ~page_mask;
+  size_t stack_size = (std::max(SIGSTKSZ, static_cast<decltype(SIGSTKSZ)>(65536)) + page_mask) & ~page_mask;
 #if defined(ABSL_HAVE_ADDRESS_SANITIZER) || \
     defined(ABSL_HAVE_MEMORY_SANITIZER) || defined(ABSL_HAVE_THREAD_SANITIZER)
   // Account for sanitizer instrumentation requiring additional stack space.
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/angle/gni/angle.gni b/qtwebengine/src/3rdparty/chromium/third_party/angle/gni/angle.gni
--- a/qtwebengine/src/3rdparty/chromium/third_party/angle/gni/angle.gni	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/angle/gni/angle.gni	2025-06-05 14:48:43.000000000 +0800
@@ -54,11 +54,11 @@
 declare_args() {
   if (current_cpu == "arm64" || current_cpu == "x64" ||
       current_cpu == "mips64el" || current_cpu == "s390x" ||
-      current_cpu == "ppc64") {
+      current_cpu == "ppc64" || current_cpu == "ppc64le") {
     angle_64bit_current_cpu = true
   } else if (current_cpu == "arm" || current_cpu == "x86" ||
              current_cpu == "mipsel" || current_cpu == "s390" ||
-             current_cpu == "ppc") {
+             current_cpu == "ppc" || current_cpu == "ppcle") {
     angle_64bit_current_cpu = false
   } else {
     assert(false, "Unknown current CPU: $current_cpu")
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/angle/src/compiler/translator/InfoSink.h b/qtwebengine/src/3rdparty/chromium/third_party/angle/src/compiler/translator/InfoSink.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/angle/src/compiler/translator/InfoSink.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/angle/src/compiler/translator/InfoSink.h	2025-06-03 10:56:35.000000000 +0800
@@ -92,7 +92,16 @@
             stream.precision(8);
             stream << f;
         }
-        sink.append(stream.str());
+
+        // Hack to work around a bug where negative floating point values
+        // are rendered like '.0.5' instead of '-0.5'
+        std::string res(stream.str());
+
+        if (signbit(f)) { // test if f is negative
+            res[0] = '-';
+        }
+
+        sink.append(res);
         return *this;
     }
     // Write boolean values as their names instead of integral value.
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/angle/src/libANGLE/Constants.h b/qtwebengine/src/3rdparty/chromium/third_party/angle/src/libANGLE/Constants.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/angle/src/libANGLE/Constants.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/angle/src/libANGLE/Constants.h	2025-05-30 15:26:20.000000000 +0800
@@ -9,6 +9,7 @@
 #ifndef LIBANGLE_CONSTANTS_H_
 #define LIBANGLE_CONSTANTS_H_
 
+#include <cstddef>
 #include "common/platform.h"
 
 #include <stdint.h>
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/BUILD.gn b/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/BUILD.gn	2025-06-05 14:49:15.000000000 +0800
@@ -36,7 +36,7 @@
       sources = [ "SaveRegisters_mips.S" ]
     } else if (current_cpu == "mips64el") {
       sources = [ "SaveRegisters_mips64.S" ]
-    } else if (current_cpu == "ppc64") {
+    } else if (current_cpu == "ppc64" || current_cpu == "ppc64le" ) {
       sources = [ "SaveRegisters_ppc64.S" ]
     }
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/boringssl/BUILD.gn b/qtwebengine/src/3rdparty/chromium/third_party/boringssl/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/third_party/boringssl/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/boringssl/BUILD.gn	2025-06-05 14:50:44.000000000 +0800
@@ -101,6 +101,13 @@
       } else {
         public_configs = [ ":no_asm_config" ]
       }
+    } else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+      if (is_linux) {
+        # TODO: ppc64 (be) check
+        sources += crypto_sources_linux_ppc64le
+      } else {
+        public_configs = [ ":no_asm_config" ]
+      }
     } else {
       public_configs = [ ":no_asm_config" ]
     }
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h	2025-05-30 15:28:03.000000000 +0800
@@ -44,6 +44,8 @@
 typedef MDRawContextARM64_Old RawContextCPU;
 #elif defined(__mips__)
 typedef MDRawContextMIPS RawContextCPU;
+#elif defined(__powerpc64__)
+typedef MDRawContextPPC64 RawContextCPU;
 #else
 #error "This code has not been ported to your platform yet."
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc	2025-05-30 15:28:03.000000000 +0800
@@ -270,7 +270,42 @@
   out->float_save.fir = mcontext.fpc_eir;
 #endif
 }
-#endif  // __mips__
+
+#elif defined(__powerpc64__)
+
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+    return mcontext.gp_regs[PT_NIP];
+}
+
+void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
+    out->context_flags = MD_CONTEXT_PPC64_FULL;
+    for (int i = 0; i < MD_CONTEXT_PPC64_GPR_COUNT; i++)
+        out->gpr[i] = mcontext.gp_regs[i];
+
+    out->lr = mcontext.gp_regs[PT_LNK];
+    out->srr0 = mcontext.gp_regs[PT_NIP];
+    out->srr1 = mcontext.gp_regs[PT_MSR];
+    out->cr = mcontext.gp_regs[PT_CCR];
+    out->xer = mcontext.gp_regs[PT_XER];
+    out->ctr = mcontext.gp_regs[PT_CTR];
+    
+    for (int i = 0; i < MD_FLOATINGSAVEAREA_PPC_FPR_COUNT; i++)
+        out->float_save.fpregs[i] = mcontext.fp_regs[i];
+
+    out->float_save.fpscr = mcontext.fp_regs[NFPREG-1];
+
+    for (int i = 0; i < MD_VECTORSAVEAREA_PPC_VR_COUNT; i++)
+        out->vector_save.save_vr[i] = \
+            {(((uint64_t)vregs.vrregs[i][0]) << 32) 
+                          | vregs.vrregs[i][1], 
+            (((uint64_t)vregs.vrregs[i][2]) << 32)
+                         | vregs.vrregs[i][3]};
+
+    out->vrsave = vregs.vrsave;
+    out->vector_save.save_vscr = {0, vregs.vscr.vscr_word};
+    out->vector_save.save_vrvalid = 0xFFFFFFFF; 
+}
+#endif  // __powerpc64__
 
 void ThreadInfo::GetGeneralPurposeRegisters(void** gp_regs, size_t* size) {
   assert(gp_regs || size);
@@ -279,6 +314,11 @@
     *gp_regs = mcontext.gregs;
   if (size)
     *size = sizeof(mcontext.gregs);
+#elif defined(__powerpc64__)
+  if (gp_regs)
+    *gp_regs = mcontext.gp_regs;
+  if (size)
+    *size = sizeof(mcontext.gp_regs);
 #else
   if (gp_regs)
     *gp_regs = &regs;
@@ -294,6 +334,11 @@
     *fp_regs = &mcontext.fpregs;
   if (size)
     *size = sizeof(mcontext.fpregs);
+#elif defined(__powerpc64__)
+  if (fp_regs)
+    *fp_regs = &mcontext.fp_regs;
+  if (size)
+    *size = sizeof(mcontext.fp_regs);
 #else
   if (fp_regs)
     *fp_regs = &fpregs;
@@ -302,4 +347,13 @@
 #endif
 }
 
+#if defined(__powerpc64__)
+void ThreadInfo::GetVectorRegisters(void** v_regs, size_t* size) {
+    if (v_regs)
+        *v_regs = &vregs;
+    if (size)
+        *size = sizeof(vregs);
+}
+#endif
+
 }  // namespace google_breakpad
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h	2025-05-30 15:28:03.000000000 +0800
@@ -68,6 +68,10 @@
   // Use the structures defined in <sys/user.h>
   struct user_regs_struct regs;
   struct user_fpsimd_struct fpregs;
+#elif defined(__powerpc64__)
+  // Use the structures defined in <sys/ucontext.h>.
+  mcontext_t mcontext;
+  struct _libc_vrstate vregs;
 #elif defined(__mips__)
   // Use the structure defined in <sys/ucontext.h>.
   mcontext_t mcontext;
@@ -84,6 +88,11 @@
 
   // Returns the pointer and size of float point register area.
   void GetFloatingPointRegisters(void** fp_regs, size_t* size);
+
+#if defined(__powerpc64__)
+  // Returns the pointer and size of the vector register area. (PPC64 only)
+  void GetVectorRegisters(void** v_regs, size_t* size);
+#endif
 };
 
 }  // namespace google_breakpad
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc	2025-05-30 15:28:03.000000000 +0800
@@ -254,6 +254,48 @@
   out->float_save.fir = uc->uc_mcontext.fpc_eir;  // Unused.
 #endif
 }
+
+#elif defined(__powerpc64__)
+
+uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
+    return uc->uc_mcontext.gp_regs[MD_CONTEXT_PPC64_REG_SP];
+}
+
+uintptr_t UContextReader::GetInstructionPointer(const ucontext_t* uc) {
+    return uc->uc_mcontext.gp_regs[PT_NIP];
+}
+
+void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
+                                    const struct _libc_vrstate* vregs) {
+    out->context_flags = MD_CONTEXT_PPC64_FULL;
+
+    for (int i = 0; i < MD_CONTEXT_PPC64_GPR_COUNT; i++)
+        out->gpr[i] = uc->uc_mcontext.gp_regs[i];
+
+    out->lr = uc->uc_mcontext.gp_regs[PT_LNK];    
+    out->srr0 = uc->uc_mcontext.gp_regs[PT_NIP];
+    out->srr1 = uc->uc_mcontext.gp_regs[PT_MSR];
+    out->cr = uc->uc_mcontext.gp_regs[PT_CCR];
+    out->xer = uc->uc_mcontext.gp_regs[PT_XER];
+    out->ctr = uc->uc_mcontext.gp_regs[PT_CTR];
+    
+    for (int i = 0; i < MD_FLOATINGSAVEAREA_PPC_FPR_COUNT; i++)
+        out->float_save.fpregs[i] = uc->uc_mcontext.fp_regs[i];
+
+    out->float_save.fpscr = uc->uc_mcontext.fp_regs[NFPREG-1];
+
+    for (int i = 0; i < MD_VECTORSAVEAREA_PPC_VR_COUNT; i++)
+        out->vector_save.save_vr[i] =
+            {(((uint64_t)vregs->vrregs[i][0]) << 32) 
+                         | vregs->vrregs[i][1], 
+             (((uint64_t)vregs->vrregs[i][2]) << 32)
+                         | vregs->vrregs[i][3]};
+
+    out->vrsave = vregs->vrsave;
+    out->vector_save.save_vscr = {0, vregs->vscr.vscr_word};
+    out->vector_save.save_vrvalid = 0xFFFFFFFF; 
+}
+
 #endif
 
 }  // namespace google_breakpad
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h	2025-05-30 15:28:03.000000000 +0800
@@ -55,6 +55,9 @@
 #elif defined(__aarch64__)
   static void FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
                              const struct fpsimd_context* fpregs);
+#elif defined(__powerpc64__)
+  static void FillCPUContext(RawContextCPU *out, const ucontext_t *uc,
+                             const struct _libc_vrstate* vregs);
 #else
   static void FillCPUContext(RawContextCPU* out, const ucontext_t* uc);
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc	2025-06-03 09:26:04.000000000 +0800
@@ -138,7 +138,7 @@
   // SIGSTKSZ may be too small to prevent the signal handlers from overrunning
   // the alternative stack. Ensure that the size of the alternative stack is
   // large enough.
-  static const unsigned kSigStackSize = std::max(16384U, (unsigned)SIGSTKSZ);
+  static const unsigned kSigStackSize = std::max(static_cast<unsigned>(16384), static_cast<unsigned>(SIGSTKSZ));
 
   // Only set an alternative stack if there isn't already one, or if the current
   // one is too small.
@@ -461,9 +461,16 @@
     memcpy(&g_crash_context_.float_state, fp_ptr,
            sizeof(g_crash_context_.float_state));
   }
+#elif defined(__powerpc64__)
+  // On PPC64, we must copy VR state
+  ucontext_t* uc_ptr = (ucontext_t*)uc;
+  if (uc_ptr->uc_mcontext.v_regs) {
+    memcpy(&g_crash_context_.vector_state, uc_ptr->uc_mcontext.v_regs,
+           sizeof(g_crash_context_.vector_state));
+  }
 #elif !defined(__ARM_EABI__) && !defined(__mips__)
   // FP state is not part of user ABI on ARM Linux.
-  // In case of MIPS Linux FP state is already part of ucontext_t
+  // In case of MIPS, Linux FP state is already part of ucontext_t
   // and 'float_state' is not a member of CrashContext.
   ucontext_t* uc_ptr = (ucontext_t*)uc;
   if (uc_ptr->uc_mcontext.fpregs) {
@@ -701,11 +708,19 @@
   }
 #endif
 
-#if !defined(__ARM_EABI__) && !defined(__aarch64__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__aarch64__) && !defined(__mips__) \
+    && !defined(__powerpc64__)
   // FPU state is not part of ARM EABI ucontext_t.
   memcpy(&context.float_state, context.context.uc_mcontext.fpregs,
          sizeof(context.float_state));
 #endif
+
+#if defined(__powerpc64__)
+  // Vector registers must be copied on PPC64
+  memcpy(&context.vector_state, context.context.uc_mcontext.v_regs,
+         sizeof(context.vector_state));
+#endif
+
   context.tid = sys_gettid();
 
   // Add an exception stream to the minidump for better reporting.
@@ -726,6 +741,9 @@
 #elif defined(__mips__)
   context.siginfo.si_addr =
       reinterpret_cast<void*>(context.context.uc_mcontext.pc);
+#elif defined(__powerpc64__)
+  context.siginfo.si_addr =
+      reinterpret_cast<void*>(context.context.uc_mcontext.gp_regs[PT_NIP]);
 #else
 #error "This code has not been ported to your platform yet."
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h	2025-05-30 15:28:03.000000000 +0800
@@ -192,7 +192,11 @@
     siginfo_t siginfo;
     pid_t tid;  // the crashing thread.
     ucontext_t context;
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+    // PPC64's FP state is a part of ucontext_t like MIPS but the vector
+    // state is not, so a struct is needed.
+    vstate_t vector_state;
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
     // #ifdef this out because FP state is not part of user ABI for Linux ARM.
     // In case of MIPS Linux FP state is already part of ucontext_t so
     // 'float_state' is not required.
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc	2025-05-30 15:28:03.000000000 +0800
@@ -307,7 +307,7 @@
   }
 
   // Wait a while until the child should have crashed.
-  usleep(1000000);
+  usleep(2000000);
   // Kill the child if it is still running.
   kill(child, SIGKILL);
 
@@ -559,6 +559,8 @@
 #if defined(__mips__)
   // mfc2 zero,Impl - usually illegal in userspace.
   0x48, 0x00, 0x00, 0x48
+#elif defined(__powerpc64__)
+  0x01, 0x01, 0x01, 0x01 // Crashes on a tested POWER9 cpu
 #else
   // This crashes with SIGILL on x86/x86-64/arm.
   0xff, 0xff, 0xff, 0xff
@@ -754,10 +756,10 @@
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
-  // Use 4k here because the OS will hand out a single page even
+  // Use the page size here because the OS will hand out a single page even
   // if a smaller size is requested, and this test wants to
   // test the upper bound of the memory range.
-  const uint32_t kMemorySize = 4096;  // bytes
+  const uint32_t kMemorySize = getpagesize();  // bytes
   const int kOffset = kMemorySize - sizeof(kIllegalInstruction);
 
   const pid_t child = fork();
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc	2025-06-05 14:52:18.000000000 +0800
@@ -138,7 +138,9 @@
                   const MicrodumpExtraInfo& microdump_extra_info,
                   LinuxDumper* dumper)
       : ucontext_(context ? &context->context : NULL),
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+        vector_state_(context ? &context->vector_state : NULL),
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
         float_state_(context ? &context->float_state : NULL),
 #endif
         dumper_(dumper),
@@ -337,6 +339,8 @@
 # else
 #  error "This mips ABI is currently not supported (n32)"
 #endif
+#elif defined(__powerpc64__)
+    const char kArch[] = "ppc64"; //not use ppc64le here
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -409,7 +413,9 @@
   void DumpCPUState() {
     RawContextCPU cpu;
     my_memset(&cpu, 0, sizeof(RawContextCPU));
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+    UContextReader::FillCPUContext(&cpu, ucontext_, vector_state_);
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
     UContextReader::FillCPUContext(&cpu, ucontext_, float_state_);
 #else
     UContextReader::FillCPUContext(&cpu, ucontext_);
@@ -605,7 +611,9 @@
   void* Alloc(unsigned bytes) { return dumper_->allocator()->Alloc(bytes); }
 
   const ucontext_t* const ucontext_;
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+  const google_breakpad::vstate_t* const vector_state_;
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
   const google_breakpad::fpstate_t* const float_state_;
 #endif
   LinuxDumper* dumper_;
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc	2025-05-30 15:28:03.000000000 +0800
@@ -279,10 +279,19 @@
   CrashAndGetMicrodump(mappings, MicrodumpExtraInfo(), &buf);
   ASSERT_TRUE(ContainsMicrodump(buf));
 
+  int page_size = getpagesize();
 #ifdef __LP64__
-  ASSERT_NE(std::string::npos,
-            buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
-                     "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  // This test is only available for the following page sizes
+  ASSERT_TRUE((page_size == 4096) || (page_size == 65536));
+  if (page_size == 4096) { 
+    ASSERT_NE(std::string::npos,
+              buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
+                       "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  } else {
+    ASSERT_NE(std::string::npos,
+              buf.find("M 0000000000010000 000000000000002A 0000000000010000 "
+                       "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  }
 #else
   ASSERT_NE(std::string::npos,
             buf.find("M 00001000 0000002A 00001000 "
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc	2025-05-30 15:28:03.000000000 +0800
@@ -112,6 +112,9 @@
 #elif defined(__mips__)
   stack_pointer =
       reinterpret_cast<uint8_t*>(info->mcontext.gregs[MD_CONTEXT_MIPS_REG_SP]);
+#elif defined(__powerpc64__)
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->mcontext.gp_regs[MD_CONTEXT_PPC64_REG_SP]);
 #else
 #error "This code hasn't been ported to your platform yet."
 #endif
@@ -197,7 +200,10 @@
         memset(&info, 0, sizeof(ThreadInfo));
         info.tgid = status->pr_pgrp;
         info.ppid = status->pr_ppid;
-#if defined(__mips__)
+#if defined(__powerpc64__)
+        for (int i = 0; i < 31; i++)
+            info.mcontext.gp_regs[i] = status->pr_reg[i];
+#elif defined(__mips__)
 #if defined(__ANDROID__)
         for (int i = EF_R0; i <= EF_R31; i++)
           info.mcontext.gregs[i - EF_R0] = status->pr_reg[i];
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.cc	2025-05-30 15:28:03.000000000 +0800
@@ -765,7 +765,9 @@
       reinterpret_cast<uint8_t*>(int_stack_pointer & ~(page_size - 1));
 
   // The number of bytes of stack which we try to capture.
-  static const ptrdiff_t kStackToCapture = 32 * 1024;
+  // This now depends on page_size to avoid missing data
+  // on systems with larger page sizes.
+  static const ptrdiff_t kStackToCapture = 8 * page_size;
 
   const MappingInfo* mapping = FindMapping(stack_pointer);
   if (!mapping)
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h	2025-05-30 15:28:03.000000000 +0800
@@ -63,7 +63,8 @@
  (defined(__mips__) && _MIPS_SIM == _ABIO32)
 typedef Elf32_auxv_t elf_aux_entry;
 #elif defined(__x86_64) || defined(__aarch64__) || \
-     (defined(__mips__) && _MIPS_SIM != _ABIO32)
+     (defined(__mips__) && _MIPS_SIM != _ABIO32) || \
+     defined(__powerpc64__)
 typedef Elf64_auxv_t elf_aux_entry;
 #endif
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc	2025-05-30 15:28:03.000000000 +0800
@@ -51,6 +51,8 @@
 #define TID_PTR_REGISTER "rcx"
 #elif defined(__mips__)
 #define TID_PTR_REGISTER "$1"
+#elif defined(__powerpc64__)
+#define TID_PTR_REGISTER "r8"
 #else
 #error This test has not been ported to this platform.
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc	2025-05-30 15:28:03.000000000 +0800
@@ -149,19 +149,27 @@
   return true;
 }
 
-bool LinuxPtraceDumper::ReadRegisterSet(ThreadInfo* info, pid_t tid)
-{
+bool LinuxPtraceDumper::ReadRegisterSet(ThreadInfo* info, pid_t tid) {
 #ifdef PTRACE_GETREGSET
   struct iovec io;
   info->GetGeneralPurposeRegisters(&io.iov_base, &io.iov_len);
-  if (sys_ptrace(PTRACE_GETREGSET, tid, (void*)NT_PRSTATUS, (void*)&io) == -1) {
+  if (ptrace(PTRACE_GETREGSET, tid, (void*)NT_PRSTATUS, (void*)&io) == -1) {
     return false;
   }
 
   info->GetFloatingPointRegisters(&io.iov_base, &io.iov_len);
-  if (sys_ptrace(PTRACE_GETREGSET, tid, (void*)NT_FPREGSET, (void*)&io) == -1) {
+  if (ptrace(PTRACE_GETREGSET, tid, (void*)NT_FPREGSET, (void*)&io) == -1) {
     return false;
   }
+
+#if defined(__powerpc64__)
+  // Grab the vector registers on PPC64 too
+  info->GetVectorRegisters(&io.iov_base, &io.iov_len);
+  if (ptrace(PTRACE_GETREGSET, tid, (void*)NT_PPC_VMX, (void*)&io) == -1) {
+    return false;
+  }
+#endif // defined(__powerpc64__)
+
   return true;
 #else
   return false;
@@ -298,6 +306,9 @@
 #elif defined(__mips__)
   stack_pointer =
       reinterpret_cast<uint8_t*>(info->mcontext.gregs[MD_CONTEXT_MIPS_REG_SP]);
+#elif defined(__powerpc64__)
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->mcontext.gp_regs[MD_CONTEXT_PPC64_REG_SP]);
 #else
 #error "This code hasn't been ported to your platform yet."
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc	2025-05-30 15:28:03.000000000 +0800
@@ -462,6 +462,9 @@
 #elif defined(__mips__)
     pid_t* process_tid_location =
         reinterpret_cast<pid_t*>(one_thread.mcontext.gregs[1]);
+#elif defined(__powerpc64__)
+    pid_t* process_tid_location =
+        reinterpret_cast<pid_t*>(one_thread.mcontext.gp_regs[8]);
 #else
 #error This test has not been ported to this platform.
 #endif
@@ -559,6 +562,8 @@
   uintptr_t heap_addr = thread_info.regs.rcx;
 #elif defined(__mips__)
   uintptr_t heap_addr = thread_info.mcontext.gregs[1];
+#elif defined(__powerpc64__)
+  uintptr_t heap_addr = thread_info.mcontext.gp_regs[8];
 #else
 #error This test has not been ported to this platform.
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc	2025-05-30 15:28:03.000000000 +0800
@@ -136,7 +136,9 @@
       : fd_(minidump_fd),
         path_(minidump_path),
         ucontext_(context ? &context->context : NULL),
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+        vector_state_(context ? &context->vector_state : NULL),
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
         float_state_(context ? &context->float_state : NULL),
 #endif
         dumper_(dumper),
@@ -468,7 +470,9 @@
         if (!cpu.Allocate())
           return false;
         my_memset(cpu.get(), 0, sizeof(RawContextCPU));
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+        UContextReader::FillCPUContext(cpu.get(), ucontext_, vector_state_);
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
         UContextReader::FillCPUContext(cpu.get(), ucontext_, float_state_);
 #else
         UContextReader::FillCPUContext(cpu.get(), ucontext_);
@@ -897,7 +901,7 @@
     dirent->location.rva = 0;
   }
 
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
   bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
     char vendor_id[sizeof(sys_info->cpu.x86_cpu_info.vendor_id) + 1] = {0};
     static const char vendor_id_name[] = "vendor_id";
@@ -917,7 +921,9 @@
 
     // processor_architecture should always be set, do this first
     sys_info->processor_architecture =
-#if defined(__mips__)
+#if defined(__powerpc64__)
+        MD_CPU_ARCHITECTURE_PPC64;
+#elif defined(__mips__)
 # if _MIPS_SIM == _ABIO32
         MD_CPU_ARCHITECTURE_MIPS;
 # elif _MIPS_SIM == _ABI64
@@ -1333,7 +1339,9 @@
   const char* path_;  // Path to the file where the minidum should be written.
 
   const ucontext_t* const ucontext_;  // also from the signal handler
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+  const google_breakpad::vstate_t* const vector_state_;
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
   const google_breakpad::fpstate_t* const float_state_;  // ditto
 #endif
   LinuxDumper* dumper_;
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h	2025-05-30 15:28:03.000000000 +0800
@@ -48,6 +48,8 @@
 
 #if defined(__aarch64__)
 typedef struct fpsimd_context fpstate_t;
+#elif defined(__powerpc64__)
+typedef struct _libc_vrstate vstate_t;
 #elif !defined(__ARM_EABI__) && !defined(__mips__)
 typedef std::remove_pointer<fpregset_t>::type fpstate_t;
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc	2025-05-30 15:28:03.000000000 +0800
@@ -715,6 +715,9 @@
 #elif defined(__mips__)
   context.context.uc_mcontext.gregs[MD_CONTEXT_MIPS_REG_SP] =
       invalid_stack_pointer;
+#elif defined(__powerpc64__)
+  context.context.uc_mcontext.gp_regs[MD_CONTEXT_PPC64_REG_SP] =
+      invalid_stack_pointer;
 #else
 # error "This code has not been ported to your platform yet."
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/sender/google_crash_report_sender.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/sender/google_crash_report_sender.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/sender/google_crash_report_sender.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/sender/google_crash_report_sender.cc	2025-06-03 10:27:14.000000000 +0800
@@ -85,6 +85,7 @@
 }
 
 int main(int argc, char* argv[]) {
+  return 0;
   google::InitGoogleLogging(argv[0]);
   google::ParseCommandLineFlags(&argc, &argv, true);
   if (!CheckForRequiredFlagsOrDie()) {
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext.S b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext.S
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext.S	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext.S	2025-05-30 17:28:28.000000000 +0800
@@ -481,6 +481,9 @@
   .cfi_endproc
   .size breakpad_getcontext, . - breakpad_getcontext
 
+#elif defined(__powerpc64__)
+#include <ucontext.h>
+//To do
 #else
 #error "This file has not been ported for your CPU!"
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc	2025-05-30 15:28:03.000000000 +0800
@@ -65,8 +65,7 @@
   }
 
 #if defined(__x86_64__) || defined(__aarch64__) || \
-   (defined(__mips__) && _MIPS_SIM == _ABI64)
-
+   (defined(__mips__) && _MIPS_SIM == _ABI64) || defined(__powerpc64__)
   struct kernel_stat st;
   if (sys_fstat(fd, &st) == -1 || st.st_size < 0) {
 #else
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc	2025-05-30 15:28:03.000000000 +0800
@@ -176,9 +176,10 @@
 TEST_F(MemoryMappedFileTest, MapWithOffset) {
   // Put more data in the test file this time. Offsets can only be
   // done on page boundaries, so we need a two page file to test this.
-  const int page_size = 4096;
-  char data1[2 * page_size];
-  size_t data1_size = sizeof(data1);
+  const int page_size = getpagesize();
+  char *data1 = static_cast<char*>(malloc(2 * page_size));
+  EXPECT_TRUE(data1 != NULL);
+  size_t data1_size = (2 * page_size);
   for (size_t i = 0; i < data1_size; ++i) {
     data1[i] = i & 0x7f;
   }
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/ucontext_constants.h b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/ucontext_constants.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/ucontext_constants.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/ucontext_constants.h	2025-05-30 17:27:32.000000000 +0800
@@ -146,6 +146,8 @@
 #endif
 #define FPREGS_OFFSET_MXCSR  24
 
+#elif  defined(__powerpc64__)
+//To do
 #else
 #error "This header has not been ported for your CPU"
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc	2025-05-30 15:28:03.000000000 +0800
@@ -57,8 +57,9 @@
 
   EXPECT_EQ(0U, allocator.pages_allocated());
   uint8_t* p = reinterpret_cast<uint8_t*>(allocator.Alloc(10000));
+  uint64_t expected_pages = 1 + ((10000 - 1) / getpagesize());
   ASSERT_FALSE(p == NULL);
-  EXPECT_EQ(3U, allocator.pages_allocated());
+  EXPECT_EQ(expected_pages, allocator.pages_allocated());
   for (unsigned i = 1; i < 10; ++i) {
     uint8_t* p = reinterpret_cast<uint8_t*>(allocator.Alloc(i));
     ASSERT_FALSE(p == NULL);
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_linux.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_linux.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_linux.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_linux.cc	2025-05-30 15:28:03.000000000 +0800
@@ -202,12 +202,14 @@
   // Check architecture and set architecture variable to corresponding flag
   // in objdump.
   switch (context->GetContextCPU()) {
+#if defined(__i386) || defined(__x86_64)
     case MD_CONTEXT_X86:
       architecture = "i386";
       break;
     case MD_CONTEXT_AMD64:
       architecture = "i386:x86-64";
       break;
+#endif
     default:
       // Unsupported architecture. Note that ARM architectures are not
       // supported because objdump does not support ARM.
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc	2025-05-30 15:28:03.000000000 +0800
@@ -104,6 +104,8 @@
 }
 
 TEST(ExploitabilityTest, TestWindowsEngine) {
+// The following tests are only executable on an x86-class linux machine.
+#if !defined(_WIN32) && (defined(__i386) || defined(__x86_64))
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
             ExploitabilityFor("ascii_read_av.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
@@ -136,9 +138,12 @@
             ExploitabilityFor("read_av_clobber_write.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_LOW,
             ExploitabilityFor("read_av_conditional.dmp"));
+#endif
 }
 
 TEST(ExploitabilityTest, TestLinuxEngine) {
+// The following tests are only executable on an x86-class linux machine.
+#if defined(__i386) || defined(__x86_64)
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_INTERESTING,
             ExploitabilityFor("linux_null_read_av.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
@@ -171,7 +176,8 @@
             ExploitabilityFor("linux_executable_heap.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
             ExploitabilityFor("linux_jmp_to_module_not_exe_region.dmp"));
-#ifndef _WIN32
+#endif
+#if !defined(_WIN32) && (defined(__i386) || defined(__x86_64))
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
             ExploitabilityFor("linux_write_to_nonwritable_module.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
@@ -182,10 +188,10 @@
             ExploitabilityFor("linux_write_to_outside_module_via_math.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_INTERESTING,
             ExploitabilityFor("linux_write_to_under_4k.dmp"));
-#endif  // _WIN32
+#endif  // !defined(_WIN32) && (!defined(__i386) && !defined(__x86_64))
 }
 
-#ifndef _WIN32
+#if !defined(_WIN32) && (defined(__i386) || defined(__x86_64))
 TEST(ExploitabilityLinuxUtilsTest, DisassembleBytesTest) {
   ASSERT_FALSE(ExploitabilityLinuxTest::DisassembleBytes("", NULL, 5, NULL));
   uint8_t bytes[6] = {0xc7, 0x0, 0x5, 0x0, 0x0, 0x0};
@@ -301,6 +307,7 @@
                                                          context,
                                                          &write_address));
 }
-#endif  // _WIN32
+#endif  // !defined(_WIN32) && (defined(__i386) || defined(__x86_64))
+
 
 }  // namespace
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/minidump_processor.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/minidump_processor.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/minidump_processor.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/minidump_processor.cc	2025-06-05 14:56:27.000000000 +0800
@@ -562,7 +562,7 @@
     }
 
     case MD_CPU_ARCHITECTURE_PPC64: {
-      info->cpu = "ppc64";
+      info->cpu = "ppc64"; //not use ppc64le here
       break;
     }
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc	2025-05-30 15:28:03.000000000 +0800
@@ -77,6 +77,8 @@
   #define ELF_ARCH  EM_MIPS
 #elif defined(__aarch64__)
   #define ELF_ARCH  EM_AARCH64
+#elif defined(__powerpc64__)
+  #define ELF_ARCH  EM_PPC64
 #endif
 
 #if defined(__arm__)
@@ -87,6 +89,8 @@
 #elif defined (__mips__)
 // This file-local typedef simplifies the source code.
 typedef gregset_t user_regs_struct;
+#elif defined(__powerpc64__)
+typedef struct pt_regs user_regs_struct;
 #endif
 
 using google_breakpad::MDTypeHelper;
@@ -322,6 +326,9 @@
 #if defined(__aarch64__)
     user_fpsimd_struct fpregs;
 #endif
+#if defined(__powerpc64__)
+    mcontext_t mcontext;
+#endif
     uintptr_t stack_addr;
     const uint8_t* stack;
     size_t stack_length;
@@ -535,6 +542,38 @@
   thread->mcontext.fpc_eir = rawregs->float_save.fir;
 #endif
 }
+#elif defined(__powerpc64__)
+static void
+ParseThreadRegisters(CrashedProcess::Thread* thread,
+                     const MinidumpMemoryRange& range) {
+  const MDRawContextPPC64* rawregs = range.GetData<MDRawContextPPC64>(0);
+
+  for (int i = 0; i < MD_CONTEXT_PPC64_GPR_COUNT; i++)
+    thread->mcontext.gp_regs[i] = rawregs->gpr[i];
+
+  thread->mcontext.gp_regs[PT_LNK] = rawregs->lr;
+  thread->mcontext.gp_regs[PT_NIP] = rawregs->srr0;
+  thread->mcontext.gp_regs[PT_MSR] = rawregs->srr1;
+  thread->mcontext.gp_regs[PT_CCR] = rawregs->cr;
+  thread->mcontext.gp_regs[PT_XER] = rawregs->xer;
+  thread->mcontext.gp_regs[PT_CTR] = rawregs->ctr;
+  thread->mcontext.v_regs->vrsave = rawregs->vrsave;
+
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_PPC_FPR_COUNT; i++)
+      thread->mcontext.fp_regs[i] = rawregs->float_save.fpregs[i];
+
+  thread->mcontext.fp_regs[NFPREG-1] = rawregs->float_save.fpscr;
+
+  for (int i = 0; i < MD_VECTORSAVEAREA_PPC_VR_COUNT; i++) {
+      thread->mcontext.v_regs->vrregs[i][0] = rawregs->vector_save.save_vr[i].high >> 32;
+      thread->mcontext.v_regs->vrregs[i][1] = rawregs->vector_save.save_vr[i].high;
+      thread->mcontext.v_regs->vrregs[i][2] = rawregs->vector_save.save_vr[i].low >> 32;
+      thread->mcontext.v_regs->vrregs[i][3] = rawregs->vector_save.save_vr[i].low;
+  }
+
+  thread->mcontext.v_regs->vscr.vscr_word = rawregs->vector_save.save_vscr.low & 0xFFFFFFFF;
+}
+
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -623,6 +662,12 @@
 # else
 #  error "This mips ABI is currently not supported (n32)"
 # endif
+#elif defined(__powerpc64__)
+  if (sysinfo->processor_architecture != MD_CPU_ARCHITECTURE_PPC64) {
+    fprintf(stderr,
+            "This version of minidump-2-core only supports PPC64.\n");
+    exit(1);
+  }
 #else
 #error "This code has not been ported to your platform yet"
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/BUILD.gn b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/third_party/breakpad/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/breakpad/BUILD.gn	2025-06-03 10:51:33.000000000 +0800
@@ -611,7 +611,6 @@
       "breakpad/src/client/minidump_file_writer.h",
       "breakpad/src/common/convert_UTF.cc",
       "breakpad/src/common/convert_UTF.h",
-      "breakpad/src/common/linux/breakpad_getcontext.S",
       "breakpad/src/common/linux/elf_core_dump.cc",
       "breakpad/src/common/linux/elf_core_dump.h",
       "breakpad/src/common/linux/elfutils.cc",
@@ -641,6 +640,8 @@
     configs += [ "//build/config/compiler:no_chromium_code" ]
     public_configs = [ ":client_config" ]
 
+    defines = [ "HAVE_GETCONTEXT" ]
+
     if (current_cpu == "arm" && is_chromeos) {
       # Avoid running out of registers in
       # linux_syscall_support.h:sys_clone()'s inline assembly.
@@ -699,7 +700,6 @@
       "breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc",
       "breakpad/src/client/linux/minidump_writer/minidump_writer_unittest_utils.cc",
       "breakpad/src/client/linux/minidump_writer/proc_cpuinfo_reader_unittest.cc",
-      "breakpad/src/common/linux/breakpad_getcontext_unittest.cc",
       "breakpad/src/common/linux/elf_core_dump_unittest.cc",
       "breakpad/src/common/linux/file_id_unittest.cc",
       "breakpad/src/common/linux/linux_libc_support_unittest.cc",
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/catapult/third_party/polymer/components/font-roboto/roboto.html b/qtwebengine/src/3rdparty/chromium/third_party/catapult/third_party/polymer/components/font-roboto/roboto.html
--- a/qtwebengine/src/3rdparty/chromium/third_party/catapult/third_party/polymer/components/font-roboto/roboto.html	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/catapult/third_party/polymer/components/font-roboto/roboto.html	2025-06-03 10:48:24.000000000 +0800
@@ -7,4 +7,4 @@
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 -->
-<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700|Roboto:400,300,300italic,400italic,500,500italic,700,700italic" crossorigin="anonymous">
+<link rel="stylesheet" href="chrome://resources/css/roboto.css">
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/catapult/tracing/third_party/gl-matrix/jsdoc-template/static/default.css b/qtwebengine/src/3rdparty/chromium/third_party/catapult/tracing/third_party/gl-matrix/jsdoc-template/static/default.css
--- a/qtwebengine/src/3rdparty/chromium/third_party/catapult/tracing/third_party/gl-matrix/jsdoc-template/static/default.css	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/catapult/tracing/third_party/gl-matrix/jsdoc-template/static/default.css	2025-06-03 10:48:24.000000000 +0800
@@ -168,7 +168,7 @@
 
 /* Copied from styles.css generated by Github Pages */
 
-@import url(https://fonts.googleapis.com/css?family=Lato:300italic,700italic,300,700);
+@import url(chrome://resources/css/roboto.css);
 
 body {
   padding:50px;
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/closure_compiler/compiler.py b/qtwebengine/src/3rdparty/chromium/third_party/closure_compiler/compiler.py
--- a/qtwebengine/src/3rdparty/chromium/third_party/closure_compiler/compiler.py	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/closure_compiler/compiler.py	2025-05-30 15:22:01.000000000 +0800
@@ -27,7 +27,7 @@
   and produce minified output."""
 
   _JAR_COMMAND = [
-      _JAVA_PATH,
+      "java",
       "-jar",
       "-Xms1024m",
       "-client",
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/compat/linux/sys/user.h b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/compat/linux/sys/user.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/compat/linux/sys/user.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/compat/linux/sys/user.h	2025-05-30 15:28:03.000000000 +0800
@@ -15,6 +15,7 @@
 #ifndef CRASHPAD_COMPAT_LINUX_SYS_USER_H_
 #define CRASHPAD_COMPAT_LINUX_SYS_USER_H_
 
+#include <cstddef>
 #include_next <sys/user.h>
 
 #include <features.h>
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/doc/support/crashpad_doxygen.css b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/doc/support/crashpad_doxygen.css
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/doc/support/crashpad_doxygen.css	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/doc/support/crashpad_doxygen.css	2025-06-03 10:48:24.000000000 +0800
@@ -12,8 +12,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License. */
 
-@import "https://fonts.googleapis.com/css?family=Open+Sans:300,400,700&subset=latin,cyrillic-ext,greek-ext,cyrillic,greek,vietnamese,latin-ext";
-@import "https://fonts.googleapis.com/css?family=Source+Code+Pro";
+@import "chrome://resources/css/roboto.css";
 
 body,
 table,
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context.h b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context.h	2025-05-30 15:59:51.000000000 +0800
@@ -592,6 +592,70 @@
   uint64_t fir;
 };
 
+//! \brief ppc64-specific flags for MinidumpPPC64::context_flags
+//! Based on minidump_cpu_ppc64.h from breakpad
+enum MinidumpContextPPC64Flags : uint32_t {
+  //! \brief Identifies the context as PPC64.
+  kMinidumpContextPPC64 = 0x01000000,
+
+  //! \brief Indicates the validity of general purpose registers.
+  //!
+  //! Registers `r0`-`r31`, `nip`, `msr`, `lr`, etc. are valid.
+  kMinidumpContextPPC64Base = kMinidumpContextPPC64 | 0x00000001,
+
+  //! \brief Indicates the validity of floating point registers.
+  //!
+  //! Registers `fp0`-`fp31`, `fpscr` are valid.
+  kMinidumpContextPPC64Floating = kMinidumpContextPPC64 | 0x00000008,
+
+  //! \brief Indicates the validity of Altivec/VMX registers.
+  //!
+  //! Registers `v0`-`v31`, `vscr`, `vrsave`.
+  kMinidumpContextPPC64Vector = kMinidumpContextPPC64 | 0x00000020,
+
+  //! \brief Indicates the validity of all registers
+  kMinidumpContextPPC64All = kMinidumpContextPPC64Base     |
+                             kMinidumpContextPPC64Floating |
+                             kMinidumpContextPPC64Vector
+};
+
+//! \brief A PPC64 CPU context carried in a minidump file.
+//! Based on minidump_cpu_ppc64.h from breakpad.
+struct MinidumpContextPPC64 {
+  uint64_t context_flags;
+
+  //! \brief General purpose registers.
+  uint64_t nip;
+  uint64_t msr;
+  uint64_t regs[32];
+  uint64_t ccr;
+  uint64_t xer;
+  uint64_t lnk;
+  uint64_t ctr;
+
+  //! \brief Floating point registers.
+  double fpregs[32];
+
+  //! \brief FPU status register.
+  double fpscr;
+
+  //! \brief Altivec/VMX vector registers.
+  struct {
+      //! \brief Vector registers are 128bits.
+      uint128_struct save_vr[32];
+      uint128_struct save_vscr;
+
+      //! \brief Padding included for breakpad compatibiltiy.
+      uint32_t save_pad5[4];
+
+      //! \brief VRSAVE register.
+      uint32_t save_vrsave;
+
+      //! \brief Padding included for breakpad compatibiltiy.
+      uint32_t save_pad6[7];
+  } vregs;
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_H_
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc	2025-05-30 15:59:51.000000000 +0800
@@ -101,6 +101,13 @@
       break;
     }
 
+    case kCPUArchitecturePPC64: {
+      context = std::make_unique<MinidumpContextPPC64Writer>();
+      reinterpret_cast<MinidumpContextPPC64Writer*>(context.get())
+          ->InitalizeFromSnapshot(context_snapshot->ppc64);
+      break;
+    }
+
     default: {
       LOG(ERROR) << "unknown context architecture "
                  << context_snapshot->architecture;
@@ -452,5 +459,48 @@
   DCHECK_GE(state(), kStateFrozen);
   return sizeof(context_);
 }
+
+MinidumpContextPPC64Writer::MinidumpContextPPC64Writer()
+  : MinidumpContextWriter(), context_() {
+    context_.context_flags = kMinidumpContextPPC64;
+}
+
+MinidumpContextPPC64Writer::~MinidumpContextPPC64Writer() = default;
+
+void MinidumpContextPPC64Writer::InitalizeFromSnapshot(
+    const CPUContextPPC64* context_snapshot) {
+  DCHECK_EQ(state(), kStateMutable);
+  DCHECK_EQ(context_.context_flags, kMinidumpContextPPC64);
+
+  context_.context_flags = kMinidumpContextPPC64All;
+
+  memcpy(context_.regs, context_snapshot->regs, sizeof(context_.regs));
+  context_.nip = context_snapshot->nip;
+  context_.msr = context_snapshot->msr;
+  context_.ccr = context_snapshot->ccr;
+  context_.xer = context_snapshot->xer;
+  context_.lnk = context_snapshot->lnk;
+  context_.ctr = context_snapshot->ctr;
+
+  memcpy(context_.fpregs, context_snapshot->fpregs, sizeof(context_.fpregs));
+  context_.fpscr = context_snapshot->fpscr;
+
+  memcpy(context_.vregs.save_vr, context_snapshot->vregs.save_vr,
+         sizeof(context_.vregs.save_vr));
+  memcpy(&context_.vregs.save_vscr, &context_snapshot->vregs.save_vscr,
+         sizeof(context_.vregs.save_vscr));
+  context_.vregs.save_vrsave = context_snapshot->vregs.save_vrsave;
+}
+
+bool MinidumpContextPPC64Writer::WriteObject(
+    FileWriterInterface* file_writer) {
+  DCHECK_EQ(state(), kStateWritable);
+  return file_writer->Write(&context_, sizeof(context_));
+}
+
+size_t MinidumpContextPPC64Writer::ContextSize() const {
+  DCHECK_GE(state(), kStateFrozen);
+  return sizeof(context_);
+}
 
 }  // namespace crashpad
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.h b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.h	2025-05-30 15:59:51.000000000 +0800
@@ -315,6 +315,45 @@
   DISALLOW_COPY_AND_ASSIGN(MinidumpContextMIPS64Writer);
 };
 
+class MinidumpContextPPC64Writer final : public MinidumpContextWriter {
+ public:
+  MinidumpContextPPC64Writer();
+  ~MinidumpContextPPC64Writer() override;
+
+  //! \brief Initalizes the MinidumpContextPPC64 based on \a context_snapshot.
+  //!
+  //! \param[in] context_snapshot The context snapshot to use as source data.
+  //!
+  //! \note Valid in #kStateMutable. No mutation of context() may be done before
+  //!     calling this method, and it is not normally necessary to alter
+  //!     context() after calling this method.
+  void InitalizeFromSnapshot(const CPUContextPPC64* context_snapshot);
+
+  //! \brief Returns a pointer to the context structure that this object will
+  //!     write.
+  //!
+  //! \attention This returns a non-`const` pointer to this object’s private
+  //!     data so that a caller can populate the context structure directly.
+  //!     This is done because providing setter interfaces to each field in the
+  //!     context structure would be unwieldy and cumbersome. Care must be taken
+  //!     to populate the context structure correctly. The context structure
+  //!     must only be modified while this object is in the #kStateMutable
+  //!     state.
+  MinidumpContextPPC64* context() { return &context_; }
+
+ protected:
+  // MinidumpWritable:
+  bool WriteObject(FileWriterInterface* file_writer) override;
+
+  // MinidumpContextWriter:
+  size_t ContextSize() const override;
+
+ private:
+  MinidumpContextPPC64 context_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpContextPPC64Writer);
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_WRITER_H_
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc	2025-05-30 15:59:51.000000000 +0800
@@ -213,6 +213,21 @@
       context, ExpectMinidumpContextMIPS64, kSeed);
 }
 
+TEST(MinidumpContextWriter, PPC64_Zeros) {
+  EmptyContextTest<MinidumpContextPPC64Writer, MinidumpContextPPC64>(
+    ExpectMinidumpContextPPC64);
+}
+
+TEST(MinidumpContextWriter, PPC64_FromSnapshot) {
+  constexpr uint32_t kSeed = 64;
+  CPUContextPPC64 context_ppc64;
+  CPUContext context;
+  context.ppc64 = &context_ppc64;
+  InitializeCPUContextPPC64(&context, kSeed);
+  FromSnapshotTest<MinidumpContextPPC64Writer, MinidumpContextPPC64>(
+      context, ExpectMinidumpContextPPC64, kSeed);
+}
+
 }  // namespace
 }  // namespace test
 }  // namespace crashpad
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc	2025-05-30 15:59:51.000000000 +0800
@@ -135,6 +135,8 @@
   static constexpr char kCPU[] = "mips";
 #elif defined(ARCH_CPU_MIPS64EL)
   static constexpr char kCPU[] = "mips64";
+#elif defined(ARCH_CPU_PPC64)
+  static constexpr char kCPU[] = "ppc64";
 #else
 #error define kCPU for this CPU
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/capture_memory.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/capture_memory.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/capture_memory.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/capture_memory.cc	2025-05-30 16:04:12.000000000 +0800
@@ -112,6 +112,11 @@
   for (size_t i = 0; i < base::size(context.mipsel->regs); ++i) {
     MaybeCaptureMemoryAround(delegate, context.mipsel->regs[i]);
   }
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  MaybeCaptureMemoryAround(delegate, context.ppc64->nip);
+  for (size_t i = 0; i < base::size(context.ppc64->regs); ++i) {
+    MaybeCaptureMemoryAround(delegate, context.ppc64->regs[i]);
+  }
 #else
 #error Port.
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_architecture.h b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_architecture.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_architecture.h	2025-05-30 16:04:12.000000000 +0800
@@ -43,7 +43,10 @@
   kCPUArchitectureMIPSEL,
 
   //! \brief 64-bit MIPSEL.
-  kCPUArchitectureMIPS64EL
+  kCPUArchitectureMIPS64EL,
+
+  //! \brief 64-bit PPC64.
+  kCPUArchitecturePPC64
 };
 
 }  // namespace crashpad
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.cc	2025-05-30 16:04:12.000000000 +0800
@@ -169,6 +169,8 @@
       return arm->pc;
     case kCPUArchitectureARM64:
       return arm64->pc;
+    case kCPUArchitecturePPC64:
+      return ppc64->nip;
     default:
       NOTREACHED();
       return ~0ull;
@@ -185,6 +187,8 @@
       return arm->sp;
     case kCPUArchitectureARM64:
       return arm64->sp;
+    case kCPUArchitecturePPC64:
+      return ppc64->regs[1];
     default:
       NOTREACHED();
       return ~0ull;
@@ -196,6 +200,7 @@
     case kCPUArchitectureX86_64:
     case kCPUArchitectureARM64:
     case kCPUArchitectureMIPS64EL:
+    case kCPUArchitecturePPC64:
       return true;
     case kCPUArchitectureX86:
     case kCPUArchitectureARM:
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.h b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.h	2025-05-30 16:04:12.000000000 +0800
@@ -352,6 +352,24 @@
   uint64_t fir;
 };
 
+//! \brief A context structure carrying PPC64 CPU state.
+struct CPUContextPPC64 {
+  uint64_t nip;
+  uint64_t msr;
+  uint64_t regs[32];
+  uint64_t ccr;
+  uint64_t xer;
+  uint64_t lnk;
+  uint64_t ctr;
+  double fpregs[32];
+  double fpscr;
+  struct {
+    uint128_struct save_vr[32];
+    uint128_struct save_vscr;
+    uint32_t save_vrsave;
+  } vregs;
+};
+
 //! \brief A context structure capable of carrying the context of any supported
 //!     CPU architecture.
 struct CPUContext {
@@ -382,6 +400,7 @@
     CPUContextARM64* arm64;
     CPUContextMIPS* mipsel;
     CPUContextMIPS64* mips64;
+    CPUContextPPC64* ppc64;
   };
 };
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h	2025-05-30 16:04:12.000000000 +0800
@@ -15,6 +15,7 @@
 #ifndef CRASHPAD_SNAPSHOT_LINUX_CPU_CONTEXT_LINUX_H_
 #define CRASHPAD_SNAPSHOT_LINUX_CPU_CONTEXT_LINUX_H_
 
+#include <cstring>
 #include "build/build_config.h"
 #include "snapshot/cpu_context.h"
 #include "snapshot/linux/signal_context.h"
@@ -174,6 +175,78 @@
 
 #endif  // ARCH_CPU_MIPS_FAMILY || DOXYGEN
 
+#if defined(ARCH_CPU_PPC64_FAMILY) || DOXYGEN
+
+//! \brief Initalizes a CPUContextPPC64 structure from native context
+//!     structures on Linux.
+//!
+//! \param[in] thread_context The native thread context.
+//! \param[in] float_context The native float context.
+//! \param[in] vector_context The native vector context.
+//! \param[out] context The CPUContextPPC64 structure to initalize.
+template <typename Traits>
+void InitializeCPUContextPPC64(
+    const ThreadContext::t64_t& thread_context,
+    const FloatContext::f64_t& float_context,
+    const VectorContext::v64_t& vector_context,
+    typename Traits::CPUContext* context) {
+
+  memcpy(context->regs, thread_context.gpr, sizeof(context->regs));
+  context->nip = thread_context.nip;
+  context->msr = thread_context.msr;
+  context->ccr = thread_context.ccr;
+  context->xer = thread_context.xer;
+  context->lnk = thread_context.lnk;
+  context->ctr = thread_context.ctr;
+
+  memcpy(context->fpregs, float_context.fpregs, sizeof(context->fpregs));
+  context->fpscr = float_context.fpscr;
+
+  for (uint8_t i = 0; i < 32; i++) {
+    context->vregs.save_vr[i] = {
+      (((uint64_t)vector_context.vrregs[i][0]) << 32) |
+        vector_context.vrregs[i][1],
+      (((uint64_t)vector_context.vrregs[i][2]) << 32) |
+        vector_context.vrregs[i][3]
+    };
+  }
+  context->vregs.save_vrsave = vector_context.vrsave;
+  context->vregs.save_vscr = {0, (uint64_t)vector_context.vscr.vscr_word};
+}
+
+template <typename Traits>
+void InitializeCPUContextPPC64(
+    const SignalThreadContext64 &thread_context,
+    const SignalFloatContext64 &float_context,
+    const SignalVectorContext64 &vector_context,
+    typename Traits::CPUContext* context) {
+
+  memcpy(context->regs, thread_context.regs, sizeof(context->regs));
+  context->nip = thread_context.nip;
+  context->msr = thread_context.msr;
+  context->ccr = thread_context.ccr;
+  context->xer = thread_context.xer;
+  context->lnk = thread_context.lnk;
+  context->ctr = thread_context.ctr;
+
+  memcpy(context->fpregs, float_context.regs, sizeof(context->fpregs));
+  context->fpscr = float_context.fpscr;
+
+  for (uint8_t i = 0; i < 32; i++) {
+    context->vregs.save_vr[i] = {
+      (((uint64_t)vector_context.vrregs[i][0]) << 32) |
+        vector_context.vrregs[i][1],
+      (((uint64_t)vector_context.vrregs[i][2]) << 32) |
+        vector_context.vrregs[i][3]
+    };
+  }
+  context->vregs.save_vrsave = vector_context.vrsave;
+  context->vregs.save_vscr = {0, (uint64_t)vector_context.vscr.vscr_word};
+}
+
+
+#endif
+
 }  // namespace internal
 }  // namespace crashpad
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/debug_rendezvous_test.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/debug_rendezvous_test.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/debug_rendezvous_test.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/debug_rendezvous_test.cc	2025-05-30 16:04:12.000000000 +0800
@@ -171,9 +171,11 @@
           const bool is_vdso_mapping =
               device == 0 && inode == 0 && mapping_name == "[vdso]";
           static constexpr char kPrefix[] = "linux-vdso.so.";
+          static constexpr char kPrefix64[] = "linux-vdso64.so.";
           return is_vdso_mapping ==
                  (module_name.empty() ||
-                  module_name.compare(0, strlen(kPrefix), kPrefix) == 0);
+                  module_name.compare(0, strlen(kPrefix), kPrefix) == 0 ||
+                  module_name.compare(0, strlen(kPrefix64), kPrefix64) == 0);
         },
         module_mapping->name,
         module_mapping->device,
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc	2025-05-30 16:04:12.000000000 +0800
@@ -323,6 +323,69 @@
       reader, context_address, context_.mips64);
 }
 
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+
+template <typename Traits>
+static bool ReadContext(ProcessReaderLinux* reader,
+                        LinuxVMAddress context_address,
+                        typename Traits::CPUContext* dest_context) {
+  const ProcessMemory* memory = reader->Memory();
+
+  LinuxVMAddress gp_regs_address = context_address +
+                                   offsetof(UContext, mcontext) +
+                                   offsetof(typename Traits::MContext, gp_regs);
+
+  typename Traits::SignalThreadContext thread_context;
+  if (!memory->Read(gp_regs_address, sizeof(thread_context), &thread_context)) {
+    LOG(ERROR) << "Couldn't read gp_regs!";
+    return false;
+  }
+
+  LinuxVMAddress fp_regs_address = context_address +
+                                   offsetof(UContext, mcontext) +
+                                   offsetof(typename Traits::MContext, fp_regs);
+
+  typename Traits::SignalFloatContext fp_context;
+  if (!memory->Read(fp_regs_address, sizeof(fp_context), &fp_context)) {
+    LOG(ERROR) << "Couldn't read fp_regs!";
+    return false;
+  }
+
+  LinuxVMAddress v_regs_ptr_address = context_address +
+                                  offsetof(UContext, mcontext) +
+                                  offsetof(typename Traits::MContext, vmx_reserve) + 8;
+
+  typename Traits::SignalVectorContext v_context;
+  if (!memory->Read(v_regs_ptr_address, sizeof(v_context), &v_context)) {
+    LOG(ERROR) << "Couldn't read v_regs!";
+    return false;
+  }
+
+  InitializeCPUContextPPC64<ContextTraits64>(thread_context, fp_context,
+                            v_context, dest_context);
+
+  return true;
+}
+
+template<>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  context_.architecture = kCPUArchitecturePPC64;
+  context_.ppc64 = &context_union_.ppc64;
+
+  return internal::ReadContext<ContextTraits64>(
+      reader, context_address, context_.ppc64);
+}
+
+template<>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits32>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  // PPC64 is 64-bit
+  return false;
+}
+
 #endif  // ARCH_CPU_X86_FAMILY
 
 bool ExceptionSnapshotLinux::Initialize(ProcessReaderLinux* process_reader,
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h	2025-05-30 16:04:12.000000000 +0800
@@ -84,6 +84,8 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
     CPUContextMIPS mipsel;
     CPUContextMIPS64 mips64;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    CPUContextPPC64 ppc64;
 #endif
   } context_union_;
   CPUContext context_;
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc	2025-05-30 16:04:12.000000000 +0800
@@ -296,7 +296,28 @@
             0);
 #undef CPU_ARCH_NAME
 }
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+using NativeCPUContext = ucontext_t;
 
+void InitializeContext(NativeCPUContext* context) {
+  for (size_t reg = 0; reg < 32; ++reg) {
+    context->uc_mcontext.gp_regs[reg] = reg;
+  }
+
+  memset(&context->uc_mcontext.fp_regs, 44,
+      sizeof(context->uc_mcontext.fp_regs));
+}
+
+void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
+  EXPECT_EQ(actual.architecture, kCPUArchitecturePPC64);
+
+  for (size_t reg = 0; reg < 32; ++reg) {
+    EXPECT_EQ(actual.ppc64->regs[reg], expected.uc_mcontext.gp_regs[reg]);
+  }
+
+  EXPECT_EQ(memcmp(actual.ppc64->fpregs, expected.uc_mcontext.fp_regs,
+            sizeof(actual.ppc64->fpregs)), 0);
+}
 #else
 #error Port.
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc	2025-05-30 16:04:12.000000000 +0800
@@ -108,6 +108,8 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   stack_pointer = reader->Is64Bit() ? thread_info.thread_context.t64.regs[29]
                                     : thread_info.thread_context.t32.regs[29];
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  stack_pointer = thread_info.thread_context.t64.gpr[1];
 #else
 #error Port.
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux_test.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux_test.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux_test.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux_test.cc	2025-05-30 16:04:12.000000000 +0800
@@ -622,6 +622,8 @@
   module.ehdr.e_machine = EM_AARCH64;
 #elif defined(ARCH_CPU_MIPSEL) || defined(ARCH_CPU_MIPS64EL)
   module.ehdr.e_machine = EM_MIPS;
+#elif defined(ARCH_CPU_PPC64)
+  module.ehdr.e_machine = EM_PPC64;
 #endif
 
   module.ehdr.e_version = EV_CURRENT;
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/signal_context.h b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/signal_context.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/signal_context.h	2025-05-30 16:04:12.000000000 +0800
@@ -422,6 +422,89 @@
               "context offset mismatch");
 #endif
 
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+
+struct SignalThreadContext64 {
+  uint64_t regs[32];
+  uint64_t nip;
+  uint64_t msr;
+  uint64_t orig_r3;
+  uint64_t ctr;
+  uint64_t lnk;
+  uint64_t xer;
+  uint64_t ccr;
+  uint64_t softe;
+  uint64_t trap;
+  uint64_t dar;
+  uint64_t dsisr;
+  uint64_t result;
+  uint64_t dscr;
+  uint64_t fpr0[3];
+};
+
+struct SignalFloatContext64 {
+  double regs[32];
+  double fpscr;
+};
+
+struct SignalVectorContext64 {
+  int32_t vrregs[32][4];
+  struct {
+    int32_t __pad[3];
+    int32_t vscr_word;
+  } vscr;
+  int32_t vrsave;
+  int32_t __pad[3];
+} __attribute__((__aligned__(16)));
+
+
+#pragma pack(pop)
+struct MContext64 {
+  uint64_t reserved[4];
+  int32_t signal;
+  int32_t __pad0;
+  uint64_t handler;
+  uint64_t oldmask;
+  uint64_t pt_regs_ptr;
+  SignalThreadContext64 gp_regs;
+  SignalFloatContext64  fp_regs;
+  SignalVectorContext64 *v_regs;
+  int64_t vmx_reserve[69];
+};
+
+struct ContextTraits64 : public Traits64 {
+  using MContext = MContext64;
+  using SignalThreadContext = SignalThreadContext64;
+  using SignalFloatContext = SignalFloatContext64;
+  using SignalVectorContext = SignalVectorContext64;
+  using CPUContext = CPUContextPPC64;
+};
+
+struct ContextTraits32 : public Traits32 {};
+
+struct UContext {
+  uint64_t flags;
+  uint64_t link;
+  SignalStack<ContextTraits64> stack;
+  Sigset<ContextTraits64> sigmask;
+  MContext64 mcontext;
+};
+#pragma pack(push, 1)
+
+static_assert(sizeof(UContext) == sizeof(ucontext_t),
+              "ucontext_t size mismatch");
+static_assert(sizeof(MContext64) == sizeof(mcontext_t),
+              "mcontext_t size mismatch");
+static_assert(sizeof(SignalThreadContext64) == sizeof(gregset_t),
+              "gregset_t size mismatch");
+static_assert(sizeof(SignalFloatContext64) == sizeof(fpregset_t),
+              "fpregset_t size mismatch");
+static_assert(sizeof(SignalVectorContext64) == sizeof(_libc_vrstate),
+              "vrstate size mismatch");
+static_assert(offsetof(UContext, mcontext) ==
+              offsetof(ucontext_t, uc_mcontext), "mcontext offset mismatch");
+static_assert(offsetof(MContext64, gp_regs) ==
+              offsetof(mcontext_t, gp_regs), "gp_regs offset mismatch");
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc	2025-05-30 16:04:12.000000000 +0800
@@ -204,6 +204,8 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return process_reader_->Is64Bit() ? kCPUArchitectureMIPS64EL
                                     : kCPUArchitectureMIPSEL;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  return kCPUArchitecturePPC64;
 #else
 #error port to your architecture
 #endif
@@ -219,6 +221,9 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return 0;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  // Not yet implemented on PPC64
+  return 0;
 #else
 #error port to your architecture
 #endif
@@ -239,6 +244,9 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return std::string();
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  // Not yet implemented on PPC64
+  return std::string();
 #else
 #error port to your architecture
 #endif
@@ -372,6 +380,9 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return false;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  // Not yet implemented on PPC64
+  return false;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc	2025-05-30 16:04:12.000000000 +0800
@@ -186,6 +186,14 @@
         thread.thread_info.float_context.f32,
         context_.mipsel);
   }
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  context_.architecture = kCPUArchitecturePPC64;
+  context_.ppc64 = &context_union_.ppc64;
+  InitializeCPUContextPPC64<ContextTraits64>(
+      thread.thread_info.thread_context.t64,
+      thread.thread_info.float_context.f64,
+      thread.thread_info.vector_context.v64,
+      context_.ppc64);
 #else
 #error Port.
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h	2025-05-30 16:04:12.000000000 +0800
@@ -68,6 +68,8 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
     CPUContextMIPS mipsel;
     CPUContextMIPS64 mips64;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    CPUContextPPC64 ppc64;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/auxiliary_vector.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/auxiliary_vector.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/auxiliary_vector.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/auxiliary_vector.cc	2025-05-30 16:04:50.000000000 +0800
@@ -56,6 +56,11 @@
     if (type == AT_IGNORE) {
       continue;
     }
+#if defined(ARCH_CPU_PPC64_FAMILY)
+    if (type == AT_IGNOREPPC) {
+      continue;
+    }
+#endif
     if (!MapInsertOrReplace(&values_, type, value, nullptr)) {
       LOG(ERROR) << "duplicate auxv entry";
       return false;
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptrace_broker.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptrace_broker.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptrace_broker.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptrace_broker.cc	2025-05-30 16:04:50.000000000 +0800
@@ -94,8 +94,8 @@
 }
 
 bool PtraceBroker::AllocateAttachments() {
-  constexpr size_t page_size = 4096;
-  constexpr size_t alloc_size =
+  static size_t page_size = getpagesize();
+  size_t alloc_size =
       (sizeof(ScopedPtraceAttach) + page_size - 1) & ~(page_size - 1);
   void* alloc = sbrk(alloc_size);
   if (reinterpret_cast<intptr_t>(alloc) == -1) {
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptracer.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptracer.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptracer.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptracer.cc	2025-05-30 16:04:50.000000000 +0800
@@ -398,6 +398,64 @@
   return true;
 }
 
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+// PPC64 has had HAVE_ARCH_TRACEHOOK set since 2.6.27 (even before x86 had it).
+// That means we can simply use PTRACE_GETREGESET.
+
+template <typename Destination>
+bool GetRegisterSet(pid_t tid, int set, Destination* dest, bool can_log) {
+  iovec iov;
+  iov.iov_base = reinterpret_cast<void*>(dest);
+  iov.iov_len = sizeof(*dest);
+  if (ptrace(PTRACE_GETREGSET, tid, reinterpret_cast<void*>(set), &iov) != 0) {
+    PLOG_IF(ERROR, can_log) << "ptrace";
+    return false;
+  }
+  if (iov.iov_len != sizeof(*dest)) {
+    LOG_IF(ERROR, can_log) << "Unexpected registers size";
+    return false;
+  }
+  return true;
+}
+
+bool GetVectorRegisters64(pid_t tid,
+                          VectorContext* context,
+                          bool can_log) {
+  return GetRegisterSet(tid, NT_PPC_VMX, &context->v64, can_log);
+}
+
+bool GetFloatingPointRegisters64(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  return GetRegisterSet(tid, NT_PRFPREG, &context->f64, can_log);
+}
+
+bool GetThreadArea64(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  // PPC64 doesn't have PTRACE_GET_THREAD_AREA since the thread pointer
+  // is stored in GPR 13.
+  ThreadContext::t64_t tc;
+  if (!GetRegisterSet(tid, NT_PRSTATUS, &tc, can_log)) {
+    LOG_IF(ERROR, can_log) << "Unable to get thread pointer!";
+    return false;
+  }
+
+  *address = tc.gpr[13];
+
+  return true;
+}
+
+// Stubs for 32-bit functions not applicable on PPC64
+bool GetFloatingPointRegisters32(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) { return false; }
+bool GetThreadArea32(pid_t tid,
+                     const ThreadContext &context,
+                     LinuxVMAddress *address,
+                     bool can_log) { return false; }
+
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -494,6 +552,9 @@
   if (is_64_bit_) {
     return GetGeneralPurposeRegisters64(tid, &info->thread_context, can_log_) &&
            GetFloatingPointRegisters64(tid, &info->float_context, can_log_) &&
+#if defined(ARCH_CPU_PPC64_FAMILY)
+           GetVectorRegisters64(tid, &info->vector_context, can_log_) &&
+#endif
            GetThreadArea64(tid,
                            info->thread_context,
                            &info->thread_specific_data_address,
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/thread_info.h b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/thread_info.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/thread_info.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/thread_info.h	2025-05-30 16:04:50.000000000 +0800
@@ -28,6 +28,10 @@
 #include <android/api-level.h>
 #endif
 
+#if defined(ARCH_CPU_PPC64_FAMILY)
+#include <sys/ucontext.h>
+#endif
+
 namespace crashpad {
 
 //! \brief The set of general purpose registers for an architecture family.
@@ -79,6 +83,8 @@
     uint32_t cp0_status;
     uint32_t cp0_cause;
     uint32_t padding1_;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    // PPC64 is 64-bit
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -132,6 +138,21 @@
     uint64_t cp0_badvaddr;
     uint64_t cp0_status;
     uint64_t cp0_cause;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    // Reflects struct pt_regs in asm/ptrace.h.
+    uint64_t gpr[32];
+    uint64_t nip;
+    uint64_t msr;
+    uint64_t orig_gpr3;
+    uint64_t ctr;
+    uint64_t lnk;
+    uint64_t xer;
+    uint64_t ccr;
+    uint64_t softe;
+    uint64_t trap;
+    uint64_t dar;
+    uint64_t dsisr;
+    uint64_t result;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -143,6 +164,8 @@
   using NativeThreadContext = user_regs;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
 // No appropriate NativeThreadsContext type available for MIPS
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  using NativeThreadContext = struct pt_regs;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY || ARCH_CPU_ARM64
@@ -218,6 +241,9 @@
     } fpregs[32];
     uint32_t fpcsr;
     uint32_t fpu_id;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    // Crashpad's PPC support is 64-bit only, so this
+    // 32bit-only struct is declared as empty.
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -252,6 +278,10 @@
     double fpregs[32];
     uint32_t fpcsr;
     uint32_t fpu_id;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    // Reflects fpregset_t in sys/ucontext.h
+    double fpregs[32];
+    double fpscr;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -280,6 +310,8 @@
   static_assert(sizeof(f64) == sizeof(user_fpsimd_struct), "Size mismatch");
 #elif defined(ARCH_CPU_MIPS_FAMILY)
 // No appropriate floating point context native type for available MIPS.
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  static_assert(sizeof(f64) == sizeof(fpregset_t), "Size mismatch");
 #else
 #error Port.
 #endif  // ARCH_CPU_X86
@@ -287,6 +319,26 @@
 static_assert(std::is_standard_layout<FloatContext>::value,
               "Not standard layout");
 
+//! \brief The vector registers used for an architecture family
+union VectorContext {
+  struct v32_t {} v32;
+#if defined(ARCH_CPU_PPC64_FAMILY)
+  __attribute__((__aligned__(16))) // Vector context must be doubleword aligned.
+#endif
+  struct v64_t {
+#if defined(ARCH_CPU_PPC64_FAMILY)
+    // Reflects vrregset_t in sys/ucontext.h
+    uint32_t vrregs[32][4];
+    struct {
+      uint32_t __pad[3];
+      uint32_t vscr_word;
+    } vscr;
+    uint32_t vrsave;
+    uint32_t __pad[3];
+#endif
+  } v64;
+};
+
 //! \brief A collection of `ptrace`-able information about a thread.
 struct ThreadInfo {
   ThreadInfo();
@@ -298,6 +350,9 @@
   //! \brief The floating point registers for the thread.
   FloatContext float_context;
 
+  //! \brief (Optional) The vector registers used for the thread.
+  VectorContext vector_context;
+
   //! \brief The thread-local storage address for the thread.
   LinuxVMAddress thread_specific_data_address;
 };
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h	2025-05-30 16:04:50.000000000 +0800
@@ -69,6 +69,7 @@
 //!     macOS/Linux/Fuchsia | x86_64       | `%%rdi`
 //!     Linux               | ARM/ARM64    | `r0`/`x0`
 //!     Linux               | MIPS/MIPS64  | `$a0`
+//!     Linux               | PPC64        | `r3`
 //!
 //!     Additionally, the value `LR` on ARM/ARM64 will be the return address of
 //!     this function.
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_linux.S b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_linux.S	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_linux.S	2025-05-30 16:04:50.000000000 +0800
@@ -28,7 +28,7 @@
   .globl CAPTURECONTEXT_SYMBOL2
 #if defined(__i386__) || defined(__x86_64__)
   .balign 16, 0x90
-#elif defined(__arm__) || defined(__aarch64__)
+#elif defined(__arm__) || defined(__aarch64__) || defined(__powerpc64__)
   .balign 4, 0x0
   .type CAPTURECONTEXT_SYMBOL, %function
   .type CAPTURECONTEXT_SYMBOL2, %function
@@ -423,4 +423,214 @@
   jr $ra
 
   .set at
+#elif defined(__powerpc64__)
+  // Store r0-r31
+  std 0, 0xe8(3)   // context->uc_mcontext.gp_regs[0]
+  std 1, 0xf0(3)   // context->uc_mcontext.gp_regs[1]
+  std 2, 0xf8(3)   // context->uc_mcontext.gp_regs[2]
+  // note that r3's original value was lost
+  std 3, 0x100(3)  // context->uc_mcontext.gp_regs[3]
+  std 4, 0x108(3)  // context->uc_mcontext.gp_regs[4]
+  std 5, 0x110(3)  // context->uc_mcontext.gp_regs[5]
+  std 6, 0x118(3)  // context->uc_mcontext.gp_regs[6]
+  std 7, 0x120(3)  // context->uc_mcontext.gp_regs[7]
+  std 8, 0x128(3)  // context->uc_mcontext.gp_regs[8]
+  std 9, 0x130(3)  // context->uc_mcontext.gp_regs[9]
+  std 10, 0x138(3) // context->uc_mcontext.gp_regs[10]
+  std 11, 0x140(3) // context->uc_mcontext.gp_regs[11]
+  std 12, 0x148(3) // context->uc_mcontext.gp_regs[12]
+  std 13, 0x150(3) // context->uc_mcontext.gp_regs[13]
+  std 14, 0x158(3) // context->uc_mcontext.gp_regs[14]
+  std 15, 0x160(3) // context->uc_mcontext.gp_regs[15]
+  std 16, 0x168(3) // context->uc_mcontext.gp_regs[16]
+  std 17, 0x170(3) // context->uc_mcontext.gp_regs[17]
+  std 18, 0x178(3) // context->uc_mcontext.gp_regs[18]
+  std 19, 0x180(3) // context->uc_mcontext.gp_regs[19]
+  std 20, 0x188(3) // context->uc_mcontext.gp_regs[20]
+  std 21, 0x190(3) // context->uc_mcontext.gp_regs[21]
+  std 22, 0x198(3) // context->uc_mcontext.gp_regs[22]
+  std 23, 0x1a0(3) // context->uc_mcontext.gp_regs[23]
+  std 24, 0x1a8(3) // context->uc_mcontext.gp_regs[24]
+  std 25, 0x1b0(3) // context->uc_mcontext.gp_regs[25]
+  std 26, 0x1b8(3) // context->uc_mcontext.gp_regs[26]
+  std 27, 0x1c0(3) // context->uc_mcontext.gp_regs[27]
+  std 28, 0x1c8(3) // context->uc_mcontext.gp_regs[28]
+  std 29, 0x1d0(3) // context->uc_mcontext.gp_regs[29]
+  std 30, 0x1d8(3) // context->uc_mcontext.gp_regs[30]
+  std 31, 0x1e0(3) // context->uc_mcontext.gp_regs[31]
+
+  // For NIP, we can use the value in the link register
+  mflr 0
+  std 0, 0x1e8(3) // context->uc_mcontext.gp_regs[PT_NIP]
+
+  // CTR
+  mfctr 0
+  std 0, 0x200(3) // context->uc_mcontext.gp_regs[PT_CTR]
+
+  // For LNK, we'll use the caller's LR save area (2 stack frames up).
+  // r4 can be used as a scratch register since it has already been saved.
+  ld 4, 0(1)
+  ld 4, 16(4)
+  std 4, 0x208(3) // context->uc_mcontext.gp_regs[PT_LNK]
+
+  // XER
+  mfxer 0
+  std 0, 0x210(3) // context->uc_mcontext.gp_regs[PT_XER]
+
+  // CCR
+  mfcr 0
+  std 0, 0x218(3) // context->uc_mcontext.gp_regs[PT_CCR]
+
+  // MSR, orig_r3, MQ, TRAP, DAR, DSISR, RESULT, DSCR,
+  // not used or not relevant,  zero them out.
+  li 4, 0
+  std 4, 0x1f0(3) // context->uc_mcontext.gp_regs[PT_MSR]
+  std 4, 0x1f8(3) // context->uc_mcontext.gp_regs[PT_ORIG_R3]
+  std 4, 0x220(3) // context->uc_mcontext.gp_regs[PT_MQ]
+  std 4, 0x228(3) // context->uc_mcontext.gp_regs[PT_TRAP]
+  std 4, 0x230(3) // context->uc_mcontext.gp_regs[PT_DAR]
+  std 4, 0x238(3) // context->uc_mcontext.gp_regs[PT_DSISR]
+  std 4, 0x240(3) // context->uc_mcontext.gp_regs[PT_RESULT]
+  std 4, 0x248(3) // context->uc_mcontext.gp_regs[PT_DSCR]
+
+  // Update context->uc_mcontext.regs to point to gp_regs
+  addi 0, 3, 0xe8
+  std 0, 0xe0(3)
+
+  // Save floating point registers 0-31
+  stfd 0, 0x268(3)  // context->uc_mcontext.fp_regs[0]
+  stfd 1, 0x270(3)  // context->uc_mcontext.fp_regs[1]
+  stfd 2, 0x278(3)  // context->uc_mcontext.fp_regs[2]
+  stfd 3, 0x280(3)  // context->uc_mcontext.fp_regs[3]
+  stfd 4, 0x288(3)  // context->uc_mcontext.fp_regs[4]
+  stfd 5, 0x290(3)  // context->uc_mcontext.fp_regs[5]
+  stfd 6, 0x298(3)  // context->uc_mcontext.fp_regs[6]
+  stfd 7, 0x2a0(3)  // context->uc_mcontext.fp_regs[7]
+  stfd 8, 0x2a8(3)  // context->uc_mcontext.fp_regs[8]
+  stfd 9, 0x2b0(3)  // context->uc_mcontext.fp_regs[9]
+  stfd 10, 0x2b8(3) // context->uc_mcontext.fp_regs[10]
+  stfd 11, 0x2c0(3) // context->uc_mcontext.fp_regs[11]
+  stfd 12, 0x2c8(3) // context->uc_mcontext.fp_regs[12]
+  stfd 13, 0x2d0(3) // context->uc_mcontext.fp_regs[13]
+  stfd 14, 0x2d8(3) // context->uc_mcontext.fp_regs[14]
+  stfd 15, 0x2e0(3) // context->uc_mcontext.fp_regs[15]
+  stfd 16, 0x2e8(3) // context->uc_mcontext.fp_regs[16]
+  stfd 17, 0x2f0(3) // context->uc_mcontext.fp_regs[17]
+  stfd 18, 0x2f8(3) // context->uc_mcontext.fp_regs[18]
+  stfd 19, 0x300(3) // context->uc_mcontext.fp_regs[19]
+  stfd 20, 0x308(3) // context->uc_mcontext.fp_regs[20]
+  stfd 21, 0x310(3) // context->uc_mcontext.fp_regs[21]
+  stfd 22, 0x318(3) // context->uc_mcontext.fp_regs[22]
+  stfd 23, 0x320(3) // context->uc_mcontext.fp_regs[23]
+  stfd 24, 0x328(3) // context->uc_mcontext.fp_regs[24]
+  stfd 25, 0x330(3) // context->uc_mcontext.fp_regs[25]
+  stfd 26, 0x338(3) // context->uc_mcontext.fp_regs[26]
+  stfd 27, 0x340(3) // context->uc_mcontext.fp_regs[27]
+  stfd 28, 0x348(3) // context->uc_mcontext.fp_regs[28]
+  stfd 29, 0x350(3) // context->uc_mcontext.fp_regs[29]
+  stfd 30, 0x358(3) // context->uc_mcontext.fp_regs[30]
+  stfd 31, 0x360(3) // context->uc_mcontext.fp_regs[31]
+
+  // FPSCR
+  mffs 0
+  stfd 0, 0x368(3) // context->uc_mcontext.fp_regs[32]
+
+  // Save VMX Vector registers
+  // Update r4 to contain the base address of vmx_reserve
+  addi 4, 3, 0x378
+  // Ensure that it is quadword aligned
+  andi. 5, 4, 0xF
+  beq 1f // No alignment is necessary
+  // Address is doubleword aligned and not quadword aligned, add 8
+  addi 4, 4, 8
+
+1:
+  // Store VMX registers 0-31
+  // r4 will contain the base address
+  // r5 will contain the index
+  li 5, 0
+  stvx 0, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 0]
+  addi 5, 5, 16
+  stvx 1, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 1]
+  addi 5, 5, 16
+  stvx 2, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 2]
+  addi 5, 5, 16
+  stvx 3, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 3]
+  addi 5, 5, 16
+  stvx 4, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 4]
+  addi 5, 5, 16
+  stvx 5, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 5]
+  addi 5, 5, 16
+  stvx 6, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 6]
+  addi 5, 5, 16
+  stvx 7, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 7]
+  addi 5, 5, 16
+  stvx 8, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 8]
+  addi 5, 5, 16
+  stvx 9, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 9]
+  addi 5, 5, 16
+  stvx 10, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 10]
+  addi 5, 5, 16
+  stvx 11, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 11]
+  addi 5, 5, 16
+  stvx 12, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 12]
+  addi 5, 5, 16
+  stvx 13, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 13]
+  addi 5, 5, 16
+  stvx 14, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 14]
+  addi 5, 5, 16
+  stvx 15, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 15]
+  addi 5, 5, 16
+  stvx 16, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 16]
+  addi 5, 5, 16
+  stvx 17, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 17]
+  addi 5, 5, 16
+  stvx 18, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 18]
+  addi 5, 5, 16
+  stvx 19, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 19]
+  addi 5, 5, 16
+  stvx 20, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 20]
+  addi 5, 5, 16
+  stvx 21, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 21]
+  addi 5, 5, 16
+  stvx 22, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 22]
+  addi 5, 5, 16
+  stvx 23, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 23]
+  addi 5, 5, 16
+  stvx 24, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 24]
+  addi 5, 5, 16
+  stvx 25, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 25]
+  addi 5, 5, 16
+  stvx 26, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 26]
+  addi 5, 5, 16
+  stvx 27, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 27]
+  addi 5, 5, 16
+  stvx 28, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 28]
+  addi 5, 5, 16
+  stvx 29, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 29]
+  addi 5, 5, 16
+  stvx 30, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 30]
+  addi 5, 5, 16
+  stvx 31, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 31]
+  addi 5, 5, 16
+
+  // VSCR
+  mfvscr 0
+  stvx 0, 4, 5
+  addi 5, 5, 16
+
+  // VRSAVE
+  mfvrsave 0
+  stwx 0, 4, 5
+
+  // Update context->uc_mcontext.v_regs to point to vmx_reserve + alignment.
+  std 4, 0x370(3)
+
+  // Zero out all unused fields
+  li 4, 0
+  std 4, 0xc8(3) // context->uc_mcontext.signal
+  std 4, 0xd0(3) // context->uc_mcontext.handler
+  std 4, 0xd8(3) // context->uc_mcontext.oldmask
+
+  blr
 #endif  // __i386__
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test.cc	2025-05-30 16:04:50.000000000 +0800
@@ -57,7 +57,7 @@
   uintptr_t pc = ProgramCounterFromContext(context_1);
 
 #if !defined(ADDRESS_SANITIZER) && !defined(ARCH_CPU_MIPS_FAMILY) && \
-    !defined(MEMORY_SANITIZER)
+    !defined(MEMORY_SANITIZER) && !defined(ARCH_CPU_PPC64_FAMILY)
   // Sanitizers can cause enough code bloat that the “nearby” check would
   // likely fail.
   const uintptr_t kReferencePC =
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc	2025-05-30 16:04:50.000000000 +0800
@@ -35,6 +35,8 @@
   EXPECT_EQ(context.uc_mcontext.regs[0], FromPointerCast<uintptr_t>(&context));
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   EXPECT_EQ(context.uc_mcontext.gregs[4], FromPointerCast<uintptr_t>(&context));
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  EXPECT_EQ(context.uc_mcontext.gp_regs[3], FromPointerCast<uintptr_t>(&context));
 #endif
 }
 
@@ -49,6 +51,8 @@
   return context.uc_mcontext.pc;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return context.uc_mcontext.pc;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  return context.uc_mcontext.gp_regs[PT_NIP];
 #endif
 }
 
@@ -63,6 +67,8 @@
   return context.uc_mcontext.sp;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return context.uc_mcontext.gregs[29];
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  return context.uc_mcontext.gp_regs[1];
 #endif
 }
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/posix/signals_test.cc b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/posix/signals_test.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/posix/signals_test.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/crashpad/crashpad/util/posix/signals_test.cc	2025-05-30 16:04:50.000000000 +0800
@@ -46,9 +46,9 @@
   return sig == SIGABRT ||
          sig == SIGALRM ||
          sig == SIGBUS ||
-#if !defined(ARCH_CPU_ARM64)
+#if !defined(ARCH_CPU_ARM64) && !defined(ARCH_CPU_PPC64)
          sig == SIGFPE ||
-#endif  // !defined(ARCH_CPU_ARM64)
+#endif  // !defined(ARCH_CPU_ARM64) && !defined(ARCH_CPU_PPC64)
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARMEL)
          sig == SIGILL ||
 #endif  // defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARMEL)
@@ -117,9 +117,11 @@
       break;
     }
 
-#if !defined(ARCH_CPU_ARM64)
+#if !defined(ARCH_CPU_ARM64) && !defined(ARCH_CPU_PPC64)
     // ARM64 has hardware integer division instructions that don’t generate a
     // trap for divide-by-zero, so this doesn’t produce SIGFPE.
+    //
+    // PPC64 fixed-point division by zero also doesn't produce a SIGFPE.
     case SIGFPE: {
       // Optimization makes this tricky, so get zero from a system call likely
       // to succeed, and try to do something with the result.
@@ -137,7 +139,7 @@
       fstat(quotient, &stat_buf);
       break;
     }
-#endif  // ARCH_CPU_ARM64
+#endif  // !defined(ARCH_CPU_ARM64) && !defined(ARCH_CPU_PPC64)
 
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARMEL)
     case SIGILL: {
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/dav1d/BUILD.gn b/qtwebengine/src/3rdparty/chromium/third_party/dav1d/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/third_party/dav1d/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/dav1d/BUILD.gn	2025-06-05 15:01:41.000000000 +0800
@@ -183,6 +183,8 @@
     sources += arm_template_sources
   } else if (current_cpu == "arm64") {
     sources += arm_template_sources
+  } else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+    sources += ppc64_template_sources
   }
 
   cflags = dav1d_copts
@@ -211,6 +213,8 @@
     sources += arm_template_sources
   } else if (current_cpu == "arm64") {
     sources += arm_template_sources
+  } else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+    sources += ppc64_template_sources
   }
 
   cflags = dav1d_copts
@@ -264,6 +268,21 @@
 
     cflags = dav1d_copts
   }
+} else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+  static_library("dav1d_ppc64") {
+    sources = [
+      "libdav1d/src/ppc/cpu.c",
+      "libdav1d/src/ppc/cpu.h",
+    ]
+
+    configs -= [ "//build/config/compiler:chromium_code" ]
+    configs += [
+      "//build/config/compiler:no_chromium_code",
+      ":dav1d_config",
+    ]
+
+    cflags = dav1d_copts
+  }
 }
 
 static_library("dav1d") {
@@ -291,5 +310,7 @@
     }
   } else if (current_cpu == "arm" || current_cpu == "arm64") {
     deps += [ ":dav1d_arm" ]
+  } else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+    deps += [ ":dav1d_ppc64" ]
   }
 }
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/dav1d/config/linux/ppc64le/config.h b/qtwebengine/src/3rdparty/chromium/third_party/dav1d/config/linux/ppc64le/config.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/dav1d/config/linux/ppc64le/config.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/dav1d/config/linux/ppc64le/config.h	2025-06-03 13:44:26.000000000 +0800
@@ -0,0 +1,40 @@
+/*
+ * Autogenerated by the Meson build system.
+ * Do not edit, your changes will be lost.
+ */
+
+#pragma once
+
+#define ARCH_AARCH64 0
+
+#define ARCH_ARM 0
+
+#define ARCH_PPC64LE 1
+
+#define ARCH_X86 0
+
+#define ARCH_X86_32 0
+
+#define ARCH_X86_64 0
+
+#define CONFIG_16BPC 1
+
+#define CONFIG_8BPC 1
+
+// #define CONFIG_LOG 1 -- Logging is controlled by Chromium
+
+#define ENDIANNESS_BIG 0
+
+#define HAVE_ASM 1
+
+#define HAVE_CLOCK_GETTIME 1
+
+#define HAVE_DLSYM 1
+
+#define HAVE_GETAUXVAL 1
+
+#define HAVE_POSIX_MEMALIGN 1
+
+#define HAVE_UNISTD_H 1
+
+
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/dav1d/dav1d_generated.gni b/qtwebengine/src/3rdparty/chromium/third_party/dav1d/dav1d_generated.gni
--- a/qtwebengine/src/3rdparty/chromium/third_party/dav1d/dav1d_generated.gni	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/dav1d/dav1d_generated.gni	2025-06-05 18:51:49.000000000 +0800
@@ -76,6 +76,11 @@
   "libdav1d/src/arm/mc_init_tmpl.c",
 ]
 
+ppc64_template_sources = [
+  "libdav1d/src/ppc/cdef_init_tmpl.c",
+  "libdav1d/src/ppc/looprestoration_init_tmpl.c",
+]
+
 template_sources = [
   "libdav1d/src/cdef_apply_tmpl.c",
   "libdav1d/src/cdef_tmpl.c",
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/dav1d/generate_configs.py b/qtwebengine/src/3rdparty/chromium/third_party/dav1d/generate_configs.py
--- a/qtwebengine/src/3rdparty/chromium/third_party/dav1d/generate_configs.py	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/dav1d/generate_configs.py	2025-06-05 16:29:36.000000000 +0800
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+!/usr/bin/python
 #
 # Copyright 2019 The Chromium Authors. All rights reserved.
 # Use of this source code is governed by a BSD-style license that can be
@@ -20,7 +20,7 @@
 sys.path.append(os.path.join(CHROMIUM_ROOT_DIR, 'build'))
 import gn_helpers
 
-MESON = ['meson.py']
+MESON = ['meson']
 
 DEFAULT_BUILD_ARGS = [
     '-Denable_tools=false', '-Denable_tests=false', '-Ddefault_library=static',
@@ -164,31 +164,7 @@
   linux_env = os.environ
   linux_env['CC'] = 'clang'
 
-  GenerateConfig('config/linux/x64', linux_env)
-  GenerateConfig('config/linux-noasm/x64', linux_env, ['-Denable_asm=false'])
-
-  GenerateConfig('config/linux/x86', linux_env,
-                 ['--cross-file', '../crossfiles/linux32.crossfile'])
-  GenerateConfig('config/linux/arm', linux_env,
-                 ['--cross-file', '../crossfiles/arm.crossfile'])
-  GenerateConfig('config/linux/arm64', linux_env,
-                 ['--cross-file', '../crossfiles/arm64.crossfile'])
-
-  win_x86_env = SetupWindowsCrossCompileToolchain('x86')
-  GenerateConfig('config/win/x86', win_x86_env,
-                 ['--cross-file', '../crossfiles/win32.crossfile'] +
-                 WINDOWS_BUILD_ARGS)
-
-  win_x64_dir = 'config/win/x64'
-  win_x64_env = SetupWindowsCrossCompileToolchain('x64')
-  GenerateConfig(win_x64_dir, win_x64_env,
-                 ['--cross-file', '../crossfiles/win64.crossfile'] +
-                 WINDOWS_BUILD_ARGS)
-
-  # Sadly meson doesn't support arm64 + clang-cl, so we need to create the
-  # Windows arm64 config from the Windows x64 config.
-  GenerateWindowsArm64Config(win_x64_dir)
-
+  GenerateConfig('config/linux/ppc64', linux_env)
 
 if __name__ == '__main__':
   main()
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/dav1d/generate_source.py b/qtwebengine/src/3rdparty/chromium/third_party/dav1d/generate_source.py
--- a/qtwebengine/src/3rdparty/chromium/third_party/dav1d/generate_source.py	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/dav1d/generate_source.py	2025-06-03 08:55:17.000000000 +0800
@@ -51,6 +51,8 @@
   WriteArray(fd, "arm64_asm_sources", glob.glob("libdav1d/src/arm/64/*.S"))
   WriteArray(fd, "arm_template_sources", glob.glob("libdav1d/src/arm/*_tmpl.c"))
 
+  WriteArray(fd, "ppc64_template_sources", glob.glob("libdav1d/src/ppc/*_tmpl.c"))
+
   template_sources = glob.glob("libdav1d/src/*_tmpl.c")
   WriteArray(fd, "template_sources", template_sources)
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/dav1d/libdav1d/src/ppc/types.h b/qtwebengine/src/3rdparty/chromium/third_party/dav1d/libdav1d/src/ppc/types.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/dav1d/libdav1d/src/ppc/types.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/dav1d/libdav1d/src/ppc/types.h	2025-06-05 16:30:37.000000000 +0800
@@ -51,4 +51,19 @@
 #define u16l_to_i32(v) ((i32x4) vec_mergel((u16x8) v, vec_splat_u16(0)))
 #define i16l_to_i32(v) ((i32x4) vec_unpackl((i16x8)v))
 
+#if defined(__clang__)
+#undef vec_splats
+#define vec_splats(N)                     \
+    _Generic((N),                         \
+        unsigned char:      ((u8x16)(N)), \
+        signed char:        ((i8x16)(N)), \
+        unsigned short:     ((u16x8)(N)), \
+        signed short:       ((i16x8)(N)), \
+        unsigned int:       ((u32x4)(N)), \
+        signed int:         ((i32x4)(N)), \
+        unsigned long long: ((u64x2)(N)), \
+        signed long long:   ((i64x2)(N))  \
+    )
+#endif
+
 #endif /* DAV1D_SRC_PPC_TYPES_H */
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/build_inspector_overlay.py b/qtwebengine/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/build_inspector_overlay.py
--- a/qtwebengine/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/build_inspector_overlay.py	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/build_inspector_overlay.py	2025-06-04 13:32:46.000000000 +0800
@@ -58,8 +58,8 @@
             text=True)
 
     out, error = rollup_process.communicate()
-    if not out:
-        raise Exception("rollup failed: " + error)
+    ## if not out:
+    ##    raise Exception("rollup failed: " + error)
     min = rjsmin.jsmin(out)
     check_size(filename, min, max_size)
     write_file(join(output_path, filename), min)
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/config.h b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/config.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/config.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/config.h	2025-06-03 14:36:25.000000000 +0800
@@ -0,0 +1,2630 @@
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_H
+#define FFMPEG_CONFIG_H
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-lzo --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/hdd1/workspace/chrome2/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=mips64el --enable-mipsfpu --disable-mipsdsp --disable-mipsdspr2 --extra-cflags='-march=mips64el' --extra-ldflags='-z notext' --enable-cross-compile --target-os=linux --sysroot=/hdd1/workspace/chrome2/src/build/linux/debian_sid_mips64el-sysroot --enable-mips64r2 --disable-mips64r6 --disable-msa --extra-cflags='-mcpu=mips64r2' --extra-cflags='--target=mips64el-linux-gnuabi64' --extra-ldflags='--target=mips64el-linux-gnuabi64' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld'" -- elide long configuration string from binary */
+#define FFMPEG_LICENSE "LGPL version 2.1 or later"
+#define CONFIG_THIS_YEAR 2020
+#define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
+#define AVCONV_DATADIR "/usr/local/share/ffmpeg"
+#define CC_IDENT "clang version 12.0.0 (https://github.com/llvm/llvm-project/ a1caa302970de86b15d360212b526be8f1d59641)"
+#define av_restrict restrict
+#define EXTERN_PREFIX ""
+#define EXTERN_ASM 
+#define BUILDSUF ""
+#define SLIBSUF ".so"
+#define HAVE_MMX2 HAVE_MMXEXT
+#define SWS_MAX_FILTER_SIZE 256
+#define ARCH_PPC64LE 1
+#define ARCH_AARCH64 0
+#define ARCH_ALPHA 0
+#define ARCH_ARM 0
+#define ARCH_AVR32 0
+#define ARCH_AVR32_AP 0
+#define ARCH_AVR32_UC 0
+#define ARCH_BFIN 0
+#define ARCH_IA64 0
+#define ARCH_M68K 0
+#define ARCH_MIPS 0
+#define ARCH_MIPS64 0
+#define ARCH_PARISC 0
+#define ARCH_PPC 0
+#define ARCH_PPC64 0
+#define ARCH_S390 0
+#define ARCH_SH4 0
+#define ARCH_SPARC 0
+#define ARCH_SPARC64 0
+#define ARCH_TILEGX 0
+#define ARCH_TILEPRO 0
+#define ARCH_TOMI 0
+#define ARCH_X86 0
+#define ARCH_X86_32 0
+#define ARCH_X86_64 0
+#define HAVE_ARMV5TE 0
+#define HAVE_ARMV6 0
+#define HAVE_ARMV6T2 0
+#define HAVE_ARMV8 0
+#define HAVE_NEON 0
+#define HAVE_VFP 0
+#define HAVE_VFPV3 0
+#define HAVE_SETEND 0
+#define HAVE_ALTIVEC 0
+#define HAVE_DCBZL 0
+#define HAVE_LDBRX 0
+#define HAVE_POWER8 0
+#define HAVE_PPC4XX 0
+#define HAVE_VSX 0
+#define HAVE_AESNI 0
+#define HAVE_AMD3DNOW 0
+#define HAVE_AMD3DNOWEXT 0
+#define HAVE_AVX 0
+#define HAVE_AVX2 0
+#define HAVE_AVX512 0
+#define HAVE_FMA3 0
+#define HAVE_FMA4 0
+#define HAVE_MMX 0
+#define HAVE_MMXEXT 0
+#define HAVE_SSE 0
+#define HAVE_SSE2 0
+#define HAVE_SSE3 0
+#define HAVE_SSE4 0
+#define HAVE_SSE42 0
+#define HAVE_SSSE3 0
+#define HAVE_XOP 0
+#define HAVE_CPUNOP 0
+#define HAVE_I686 0
+#define HAVE_MIPSFPU 0
+#define HAVE_MIPS32R2 0
+#define HAVE_MIPS32R5 0
+#define HAVE_MIPS64R2 0
+#define HAVE_MIPS32R6 0
+#define HAVE_MIPS64R6 0
+#define HAVE_MIPSDSP 0
+#define HAVE_MIPSDSPR2 0
+#define HAVE_MSA 0
+#define HAVE_MSA2 0
+#define HAVE_LOONGSON2 0
+#define HAVE_LOONGSON3 0
+#define HAVE_MMI 0
+#define HAVE_ARMV5TE_EXTERNAL 0
+#define HAVE_ARMV6_EXTERNAL 0
+#define HAVE_ARMV6T2_EXTERNAL 0
+#define HAVE_ARMV8_EXTERNAL 0
+#define HAVE_NEON_EXTERNAL 0
+#define HAVE_VFP_EXTERNAL 0
+#define HAVE_VFPV3_EXTERNAL 0
+#define HAVE_SETEND_EXTERNAL 0
+#define HAVE_ALTIVEC_EXTERNAL 0
+#define HAVE_DCBZL_EXTERNAL 0
+#define HAVE_LDBRX_EXTERNAL 0
+#define HAVE_POWER8_EXTERNAL 0
+#define HAVE_PPC4XX_EXTERNAL 0
+#define HAVE_VSX_EXTERNAL 0
+#define HAVE_AESNI_EXTERNAL 0
+#define HAVE_AMD3DNOW_EXTERNAL 0
+#define HAVE_AMD3DNOWEXT_EXTERNAL 0
+#define HAVE_AVX_EXTERNAL 0
+#define HAVE_AVX2_EXTERNAL 0
+#define HAVE_AVX512_EXTERNAL 0
+#define HAVE_FMA3_EXTERNAL 0
+#define HAVE_FMA4_EXTERNAL 0
+#define HAVE_MMX_EXTERNAL 0
+#define HAVE_MMXEXT_EXTERNAL 0
+#define HAVE_SSE_EXTERNAL 0
+#define HAVE_SSE2_EXTERNAL 0
+#define HAVE_SSE3_EXTERNAL 0
+#define HAVE_SSE4_EXTERNAL 0
+#define HAVE_SSE42_EXTERNAL 0
+#define HAVE_SSSE3_EXTERNAL 0
+#define HAVE_XOP_EXTERNAL 0
+#define HAVE_CPUNOP_EXTERNAL 0
+#define HAVE_I686_EXTERNAL 0
+#define HAVE_MIPSFPU_EXTERNAL 0
+#define HAVE_MIPS32R2_EXTERNAL 0
+#define HAVE_MIPS32R5_EXTERNAL 0
+#define HAVE_MIPS64R2_EXTERNAL 0
+#define HAVE_MIPS32R6_EXTERNAL 0
+#define HAVE_MIPS64R6_EXTERNAL 0
+#define HAVE_MIPSDSP_EXTERNAL 0
+#define HAVE_MIPSDSPR2_EXTERNAL 0
+#define HAVE_MSA_EXTERNAL 0
+#define HAVE_MSA2_EXTERNAL 0
+#define HAVE_LOONGSON2_EXTERNAL 0
+#define HAVE_LOONGSON3_EXTERNAL 0
+#define HAVE_MMI_EXTERNAL 0
+#define HAVE_ARMV5TE_INLINE 0
+#define HAVE_ARMV6_INLINE 0
+#define HAVE_ARMV6T2_INLINE 0
+#define HAVE_ARMV8_INLINE 0
+#define HAVE_NEON_INLINE 0
+#define HAVE_VFP_INLINE 0
+#define HAVE_VFPV3_INLINE 0
+#define HAVE_SETEND_INLINE 0
+#define HAVE_ALTIVEC_INLINE 0
+#define HAVE_DCBZL_INLINE 0
+#define HAVE_LDBRX_INLINE 0
+#define HAVE_POWER8_INLINE 0
+#define HAVE_PPC4XX_INLINE 0
+#define HAVE_VSX_INLINE 0
+#define HAVE_AESNI_INLINE 0
+#define HAVE_AMD3DNOW_INLINE 0
+#define HAVE_AMD3DNOWEXT_INLINE 0
+#define HAVE_AVX_INLINE 0
+#define HAVE_AVX2_INLINE 0
+#define HAVE_AVX512_INLINE 0
+#define HAVE_FMA3_INLINE 0
+#define HAVE_FMA4_INLINE 0
+#define HAVE_MMX_INLINE 0
+#define HAVE_MMXEXT_INLINE 0
+#define HAVE_SSE_INLINE 0
+#define HAVE_SSE2_INLINE 0
+#define HAVE_SSE3_INLINE 0
+#define HAVE_SSE4_INLINE 0
+#define HAVE_SSE42_INLINE 0
+#define HAVE_SSSE3_INLINE 0
+#define HAVE_XOP_INLINE 0
+#define HAVE_CPUNOP_INLINE 0
+#define HAVE_I686_INLINE 0
+#define HAVE_MIPSFPU_INLINE 0
+#define HAVE_MIPS32R2_INLINE 0
+#define HAVE_MIPS32R5_INLINE 0
+#define HAVE_MIPS64R2_INLINE 0
+#define HAVE_MIPS32R6_INLINE 0
+#define HAVE_MIPS64R6_INLINE 0
+#define HAVE_MIPSDSP_INLINE 0
+#define HAVE_MIPSDSPR2_INLINE 0
+#define HAVE_MSA_INLINE 0
+#define HAVE_MSA2_INLINE 0
+#define HAVE_LOONGSON2_INLINE 0
+#define HAVE_LOONGSON3_INLINE 0
+#define HAVE_MMI_INLINE 0
+#define HAVE_ALIGNED_STACK 0
+#define HAVE_FAST_64BIT 1
+#define HAVE_FAST_CLZ 1
+#define HAVE_FAST_CMOV 0
+#define HAVE_LOCAL_ALIGNED 0
+#define HAVE_SIMD_ALIGN_16 0
+#define HAVE_SIMD_ALIGN_32 0
+#define HAVE_SIMD_ALIGN_64 0
+#define HAVE_ATOMIC_CAS_PTR 0
+#define HAVE_MACHINE_RW_BARRIER 0
+#define HAVE_MEMORYBARRIER 0
+#define HAVE_MM_EMPTY 0
+#define HAVE_RDTSC 0
+#define HAVE_SEM_TIMEDWAIT 1
+#define HAVE_SYNC_VAL_COMPARE_AND_SWAP 1
+#define HAVE_CABS 0
+#define HAVE_CEXP 0
+#define HAVE_INLINE_ASM 1
+#define HAVE_SYMVER 0
+#define HAVE_X86ASM 0
+#define HAVE_BIGENDIAN 0
+#define HAVE_FAST_UNALIGNED 0
+#define HAVE_ARPA_INET_H 0
+#define ENDIANNESS_BIG 0
+#define HAVE_ASM 1
+#define HAVE_DLSYM 1
+#define HAVE_GETAUXVAL 1
+#define HAVE_UNISTD_H 1
+#define HAVE_ASM_TYPES_H 1
+#define HAVE_CDIO_PARANOIA_H 0
+#define HAVE_CDIO_PARANOIA_PARANOIA_H 0
+#define HAVE_CUDA_H 0
+#define HAVE_DISPATCH_DISPATCH_H 0
+#define HAVE_DEV_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_BKTR_IOCTL_METEOR_H 0
+#define HAVE_DEV_IC_BT8XX_H 0
+#define HAVE_DEV_VIDEO_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_VIDEO_METEOR_IOCTL_METEOR_H 0
+#define HAVE_DIRECT_H 0
+#define HAVE_DIRENT_H 1
+#define HAVE_DXGIDEBUG_H 0
+#define HAVE_DXVA_H 0
+#define HAVE_ES2_GL_H 0
+#define HAVE_GSM_H 0
+#define HAVE_IO_H 0
+#define HAVE_LINUX_PERF_EVENT_H 1
+#define HAVE_MACHINE_IOCTL_BT848_H 0
+#define HAVE_MACHINE_IOCTL_METEOR_H 0
+#define HAVE_MALLOC_H 1
+#define HAVE_OPENCV2_CORE_CORE_C_H 0
+#define HAVE_OPENGL_GL3_H 0
+#define HAVE_POLL_H 1
+#define HAVE_SYS_PARAM_H 1
+#define HAVE_SYS_RESOURCE_H 1
+#define HAVE_SYS_SELECT_H 1
+#define HAVE_SYS_SOUNDCARD_H 1
+#define HAVE_SYS_TIME_H 1
+#define HAVE_SYS_UN_H 1
+#define HAVE_SYS_VIDEOIO_H 0
+#define HAVE_TERMIOS_H 1
+#define HAVE_UDPLITE_H 0
+#define HAVE_VALGRIND_VALGRIND_H 0 /* #define HAVE_VALGRIND_VALGRIND_H 0 -- forced to 0. See https://crbug.com/590440 */
+#define HAVE_WINDOWS_H 0
+#define HAVE_WINSOCK2_H 0
+#define HAVE_INTRINSICS_NEON 0
+#define HAVE_ATANF 1
+#define HAVE_ATAN2F 1
+#define HAVE_CBRT 1
+#define HAVE_CBRTF 1
+#define HAVE_COPYSIGN 1
+#define HAVE_COSF 1
+#define HAVE_ERF 1
+#define HAVE_EXP2 1
+#define HAVE_EXP2F 1
+#define HAVE_EXPF 1
+#define HAVE_HYPOT 1
+#define HAVE_ISFINITE 1
+#define HAVE_ISINF 1
+#define HAVE_ISNAN 1
+#define HAVE_LDEXPF 1
+#define HAVE_LLRINT 1
+#define HAVE_LLRINTF 1
+#define HAVE_LOG2 1
+#define HAVE_LOG2F 1
+#define HAVE_LOG10F 1
+#define HAVE_LRINT 1
+#define HAVE_LRINTF 1
+#define HAVE_POWF 1
+#define HAVE_RINT 1
+#define HAVE_ROUND 1
+#define HAVE_ROUNDF 1
+#define HAVE_SINF 1
+#define HAVE_TRUNC 1
+#define HAVE_TRUNCF 1
+#define HAVE_DOS_PATHS 0
+#define HAVE_LIBC_MSVCRT 0
+#define HAVE_MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS 0
+#define HAVE_SECTION_DATA_REL_RO 1
+#define HAVE_THREADS 1
+#define HAVE_UWP 0
+#define HAVE_WINRT 0
+#define HAVE_ACCESS 1
+#define HAVE_ALIGNED_MALLOC 0
+#define HAVE_ARC4RANDOM 0
+#define HAVE_CLOCK_GETTIME 1
+#define HAVE_CLOSESOCKET 0
+#define HAVE_COMMANDLINETOARGVW 0
+#define HAVE_FCNTL 1
+#define HAVE_GETADDRINFO 0
+#define HAVE_GETHRTIME 0
+#define HAVE_GETOPT 1
+#define HAVE_GETMODULEHANDLE 0
+#define HAVE_GETPROCESSAFFINITYMASK 0
+#define HAVE_GETPROCESSMEMORYINFO 0
+#define HAVE_GETPROCESSTIMES 0
+#define HAVE_GETRUSAGE 1
+#define HAVE_GETSTDHANDLE 0
+#define HAVE_GETSYSTEMTIMEASFILETIME 0
+#define HAVE_GETTIMEOFDAY 1
+#define HAVE_GLOB 1
+#define HAVE_GLXGETPROCADDRESS 0
+#define HAVE_GMTIME_R 1
+#define HAVE_INET_ATON 0
+#define HAVE_ISATTY 1
+#define HAVE_KBHIT 0
+#define HAVE_LOCALTIME_R 1
+#define HAVE_LSTAT 1
+#define HAVE_LZO1X_999_COMPRESS 0
+#define HAVE_MACH_ABSOLUTE_TIME 0
+#define HAVE_MAPVIEWOFFILE 0
+#define HAVE_MEMALIGN 1
+#define HAVE_MKSTEMP 1
+#define HAVE_MMAP 1
+#define HAVE_MPROTECT 1
+#define HAVE_NANOSLEEP 1
+#define HAVE_PEEKNAMEDPIPE 0
+#define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PTHREAD_CANCEL 1
+#define HAVE_SCHED_GETAFFINITY 1
+#define HAVE_SECITEMIMPORT 0
+#define HAVE_SETCONSOLETEXTATTRIBUTE 0
+#define HAVE_SETCONSOLECTRLHANDLER 0
+#define HAVE_SETDLLDIRECTORY 0
+#define HAVE_SETMODE 0
+#define HAVE_SETRLIMIT 1
+#define HAVE_SLEEP 0
+#define HAVE_STRERROR_R 1
+#define HAVE_SYSCONF 1
+#define HAVE_SYSCTL 0 /* #define HAVE_SYSCTL 1 -- forced to 0 for Fuchsia */
+#define HAVE_USLEEP 1
+#define HAVE_UTGETOSTYPEFROMSTRING 0
+#define HAVE_VIRTUALALLOC 0
+#define HAVE_WGLGETPROCADDRESS 0
+#define HAVE_BCRYPT 0
+#define HAVE_VAAPI_DRM 0
+#define HAVE_VAAPI_X11 0
+#define HAVE_VDPAU_X11 0
+#define HAVE_PTHREADS 1
+#define HAVE_OS2THREADS 0
+#define HAVE_W32THREADS 0
+#define HAVE_AS_ARCH_DIRECTIVE 0
+#define HAVE_AS_DN_DIRECTIVE 0
+#define HAVE_AS_FPU_DIRECTIVE 0
+#define HAVE_AS_FUNC 0
+#define HAVE_AS_OBJECT_ARCH 0
+#define HAVE_ASM_MOD_Q 0
+#define HAVE_BLOCKS_EXTENSION 0
+#define HAVE_EBP_AVAILABLE 0
+#define HAVE_EBX_AVAILABLE 0
+#define HAVE_GNU_AS 0
+#define HAVE_GNU_WINDRES 0
+#define HAVE_IBM_ASM 0
+#define HAVE_INLINE_ASM_DIRECT_SYMBOL_REFS 0
+#define HAVE_INLINE_ASM_LABELS 1
+#define HAVE_INLINE_ASM_NONLOCAL_LABELS 1
+#define HAVE_PRAGMA_DEPRECATED 1
+#define HAVE_RSYNC_CONTIMEOUT 1
+#define HAVE_SYMVER_ASM_LABEL 1
+#define HAVE_SYMVER_GNU_ASM 1
+#define HAVE_VFP_ARGS 0
+#define HAVE_XFORM_ASM 0
+#define HAVE_XMM_CLOBBERS 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+#define HAVE_SOCKLEN_T 0
+#define HAVE_STRUCT_ADDRINFO 0
+#define HAVE_STRUCT_GROUP_SOURCE_REQ 0
+#define HAVE_STRUCT_IP_MREQ_SOURCE 0
+#define HAVE_STRUCT_IPV6_MREQ 0
+#define HAVE_STRUCT_MSGHDR_MSG_FLAGS 0
+#define HAVE_STRUCT_POLLFD 0
+#define HAVE_STRUCT_RUSAGE_RU_MAXRSS 1
+#define HAVE_STRUCT_SCTP_EVENT_SUBSCRIBE 0
+#define HAVE_STRUCT_SOCKADDR_IN6 0
+#define HAVE_STRUCT_SOCKADDR_SA_LEN 0
+#define HAVE_STRUCT_SOCKADDR_STORAGE 0
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
+#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
+#define HAVE_LIBDRM_GETFB2 0
+#define HAVE_MAKEINFO 1
+#define HAVE_MAKEINFO_HTML 1
+#define HAVE_OPENCL_D3D11 0
+#define HAVE_OPENCL_DRM_ARM 0
+#define HAVE_OPENCL_DRM_BEIGNET 0
+#define HAVE_OPENCL_DXVA2 0
+#define HAVE_OPENCL_VAAPI_BEIGNET 0
+#define HAVE_OPENCL_VAAPI_INTEL_MEDIA 0
+#define HAVE_PERL 1
+#define HAVE_POD2MAN 1
+#define HAVE_TEXI2HTML 0
+#define CONFIG_DOC 0
+#define CONFIG_HTMLPAGES 0
+#define CONFIG_MANPAGES 0
+#define CONFIG_PODPAGES 0
+#define CONFIG_TXTPAGES 0
+#define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
+#define CONFIG_AVIO_READING_EXAMPLE 1
+#define CONFIG_DECODE_AUDIO_EXAMPLE 1
+#define CONFIG_DECODE_VIDEO_EXAMPLE 1
+#define CONFIG_DEMUXING_DECODING_EXAMPLE 1
+#define CONFIG_ENCODE_AUDIO_EXAMPLE 1
+#define CONFIG_ENCODE_VIDEO_EXAMPLE 1
+#define CONFIG_EXTRACT_MVS_EXAMPLE 1
+#define CONFIG_FILTER_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_VIDEO_EXAMPLE 0
+#define CONFIG_HTTP_MULTICLIENT_EXAMPLE 1
+#define CONFIG_HW_DECODE_EXAMPLE 1
+#define CONFIG_METADATA_EXAMPLE 1
+#define CONFIG_MUXING_EXAMPLE 0
+#define CONFIG_QSVDEC_EXAMPLE 0
+#define CONFIG_REMUXING_EXAMPLE 1
+#define CONFIG_RESAMPLING_AUDIO_EXAMPLE 0
+#define CONFIG_SCALING_VIDEO_EXAMPLE 0
+#define CONFIG_TRANSCODE_AAC_EXAMPLE 0
+#define CONFIG_TRANSCODING_EXAMPLE 0
+#define CONFIG_VAAPI_ENCODE_EXAMPLE 0
+#define CONFIG_VAAPI_TRANSCODE_EXAMPLE 0
+#define CONFIG_AVISYNTH 0
+#define CONFIG_FREI0R 0
+#define CONFIG_LIBCDIO 0
+#define CONFIG_LIBDAVS2 0
+#define CONFIG_LIBRUBBERBAND 0
+#define CONFIG_LIBVIDSTAB 0
+#define CONFIG_LIBX264 0
+#define CONFIG_LIBX265 0
+#define CONFIG_LIBXAVS 0
+#define CONFIG_LIBXAVS2 0
+#define CONFIG_LIBXVID 0
+#define CONFIG_DECKLINK 0
+#define CONFIG_LIBFDK_AAC 0
+#define CONFIG_OPENSSL 0
+#define CONFIG_LIBTLS 0
+#define CONFIG_GMP 0
+#define CONFIG_LIBARIBB24 0
+#define CONFIG_LIBLENSFUN 0
+#define CONFIG_LIBOPENCORE_AMRNB 0
+#define CONFIG_LIBOPENCORE_AMRWB 0
+#define CONFIG_LIBVO_AMRWBENC 0
+#define CONFIG_MBEDTLS 0
+#define CONFIG_RKMPP 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_CHROMAPRINT 0
+#define CONFIG_GCRYPT 0
+#define CONFIG_GNUTLS 0
+#define CONFIG_JNI 0
+#define CONFIG_LADSPA 0
+#define CONFIG_LIBAOM 0
+#define CONFIG_LIBASS 0
+#define CONFIG_LIBBLURAY 0
+#define CONFIG_LIBBS2B 0
+#define CONFIG_LIBCACA 0
+#define CONFIG_LIBCELT 0
+#define CONFIG_LIBCODEC2 0
+#define CONFIG_LIBDAV1D 0
+#define CONFIG_LIBDC1394 0
+#define CONFIG_LIBDRM 0
+#define CONFIG_LIBFLITE 0
+#define CONFIG_LIBFONTCONFIG 0
+#define CONFIG_LIBFREETYPE 0
+#define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGLSLANG 0
+#define CONFIG_LIBGME 0
+#define CONFIG_LIBGSM 0
+#define CONFIG_LIBIEC61883 0
+#define CONFIG_LIBILBC 0
+#define CONFIG_LIBJACK 0
+#define CONFIG_LIBKLVANC 0
+#define CONFIG_LIBKVAZAAR 0
+#define CONFIG_LIBMODPLUG 0
+#define CONFIG_LIBMP3LAME 0
+#define CONFIG_LIBMYSOFA 0
+#define CONFIG_LIBOPENCV 0
+#define CONFIG_LIBOPENH264 0
+#define CONFIG_LIBOPENJPEG 0
+#define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPENVINO 0
+#define CONFIG_LIBOPUS 1
+#define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRABBITMQ 0
+#define CONFIG_LIBRAV1E 0
+#define CONFIG_LIBRSVG 0
+#define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHINE 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_LIBSNAPPY 0
+#define CONFIG_LIBSOXR 0
+#define CONFIG_LIBSPEEX 0
+#define CONFIG_LIBSRT 0
+#define CONFIG_LIBSSH 0
+#define CONFIG_LIBSVTAV1 0
+#define CONFIG_LIBTENSORFLOW 0
+#define CONFIG_LIBTESSERACT 0
+#define CONFIG_LIBTHEORA 0
+#define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVMAF 0
+#define CONFIG_LIBVORBIS 0
+#define CONFIG_LIBVPX 0
+#define CONFIG_LIBWAVPACK 0
+#define CONFIG_LIBWEBP 0
+#define CONFIG_LIBXML2 0
+#define CONFIG_LIBZIMG 0
+#define CONFIG_LIBZMQ 0
+#define CONFIG_LIBZVBI 0
+#define CONFIG_LV2 0
+#define CONFIG_MEDIACODEC 0
+#define CONFIG_OPENAL 0
+#define CONFIG_OPENGL 0
+#define CONFIG_POCKETSPHINX 0
+#define CONFIG_VAPOURSYNTH 0
+#define CONFIG_ALSA 0
+#define CONFIG_APPKIT 0
+#define CONFIG_AVFOUNDATION 0
+#define CONFIG_BZLIB 0
+#define CONFIG_COREIMAGE 0
+#define CONFIG_ICONV 0
+#define CONFIG_LIBXCB 0
+#define CONFIG_LIBXCB_SHM 0
+#define CONFIG_LIBXCB_SHAPE 0
+#define CONFIG_LIBXCB_XFIXES 0
+#define CONFIG_LZMA 0
+#define CONFIG_MEDIAFOUNDATION 0
+#define CONFIG_SCHANNEL 0
+#define CONFIG_SDL2 0
+#define CONFIG_SECURETRANSPORT 0
+#define CONFIG_SNDIO 0
+#define CONFIG_XLIB 0
+#define CONFIG_ZLIB 0
+#define CONFIG_CUDA_NVCC 0
+#define CONFIG_CUDA_SDK 0
+#define CONFIG_LIBNPP 0
+#define CONFIG_LIBMFX 0
+#define CONFIG_MMAL 0
+#define CONFIG_OMX 0
+#define CONFIG_OPENCL 0
+#define CONFIG_VULKAN 0
+#define CONFIG_AMF 0
+#define CONFIG_AUDIOTOOLBOX 0
+#define CONFIG_CRYSTALHD 0
+#define CONFIG_CUDA 0
+#define CONFIG_CUDA_LLVM 0
+#define CONFIG_CUVID 0
+#define CONFIG_D3D11VA 0
+#define CONFIG_DXVA2 0
+#define CONFIG_FFNVCODEC 0
+#define CONFIG_NVDEC 0
+#define CONFIG_NVENC 0
+#define CONFIG_VAAPI 0
+#define CONFIG_VDPAU 0
+#define CONFIG_VIDEOTOOLBOX 0
+#define CONFIG_V4L2_M2M 0
+#define CONFIG_XVMC 0
+#define CONFIG_FTRAPV 0
+#define CONFIG_GRAY 0
+#define CONFIG_HARDCODED_TABLES 0
+#define CONFIG_OMX_RPI 0
+#define CONFIG_RUNTIME_CPUDETECT 1
+#define CONFIG_SAFE_BITSTREAM_READER 1
+#define CONFIG_SHARED 0
+#define CONFIG_SMALL 0
+#define CONFIG_STATIC 1
+#define CONFIG_SWSCALE_ALPHA 1
+#define CONFIG_GPL 0
+#define CONFIG_NONFREE 0
+#define CONFIG_VERSION3 0
+#define CONFIG_AVDEVICE 0
+#define CONFIG_AVFILTER 0
+#define CONFIG_SWSCALE 0
+#define CONFIG_POSTPROC 0
+#define CONFIG_AVFORMAT 1
+#define CONFIG_AVCODEC 1
+#define CONFIG_SWRESAMPLE 0
+#define CONFIG_AVRESAMPLE 0
+#define CONFIG_AVUTIL 1
+#define CONFIG_FFPLAY 0
+#define CONFIG_FFPROBE 0
+#define CONFIG_FFMPEG 0
+#define CONFIG_DCT 1
+#define CONFIG_DWT 0
+#define CONFIG_ERROR_RESILIENCE 0
+#define CONFIG_FAAN 0
+#define CONFIG_FAST_UNALIGNED 0
+#define CONFIG_FFT 1
+#define CONFIG_LSP 0
+#define CONFIG_LZO 0
+#define CONFIG_MDCT 1
+#define CONFIG_PIXELUTILS 0
+#define CONFIG_NETWORK 0
+#define CONFIG_RDFT 1
+#define CONFIG_AUTODETECT 0
+#define CONFIG_FONTCONFIG 0
+#define CONFIG_LARGE_TESTS 1
+#define CONFIG_LINUX_PERF 0
+#define CONFIG_MEMORY_POISONING 0
+#define CONFIG_NEON_CLOBBER_TEST 0
+#define CONFIG_OSSFUZZ 0
+#define CONFIG_PIC 1
+#define CONFIG_THUMB 0
+#define CONFIG_VALGRIND_BACKTRACE 0
+#define CONFIG_XMM_CLOBBER_TEST 0
+#define CONFIG_BSFS 1
+#define CONFIG_DECODERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_HWACCELS 0
+#define CONFIG_PARSERS 1
+#define CONFIG_INDEVS 0
+#define CONFIG_OUTDEVS 0
+#define CONFIG_FILTERS 0
+#define CONFIG_DEMUXERS 1
+#define CONFIG_MUXERS 0
+#define CONFIG_PROTOCOLS 0
+#define CONFIG_AANDCTTABLES 0
+#define CONFIG_AC3DSP 0
+#define CONFIG_ADTS_HEADER 0
+#define CONFIG_ATSC_A53 0
+#define CONFIG_AUDIO_FRAME_QUEUE 0
+#define CONFIG_AUDIODSP 0
+#define CONFIG_BLOCKDSP 0
+#define CONFIG_BSWAPDSP 0
+#define CONFIG_CABAC 0
+#define CONFIG_CBS 0
+#define CONFIG_CBS_AV1 0
+#define CONFIG_CBS_H264 0
+#define CONFIG_CBS_H265 0
+#define CONFIG_CBS_JPEG 0
+#define CONFIG_CBS_MPEG2 0
+#define CONFIG_CBS_VP9 0
+#define CONFIG_DIRAC_PARSE 1
+#define CONFIG_DNN 0
+#define CONFIG_DVPROFILE 0
+#define CONFIG_EXIF 0
+#define CONFIG_FAANDCT 0
+#define CONFIG_FAANIDCT 0
+#define CONFIG_FDCTDSP 0
+#define CONFIG_FLACDSP 1
+#define CONFIG_FMTCONVERT 0
+#define CONFIG_FRAME_THREAD_ENCODER 0
+#define CONFIG_G722DSP 0
+#define CONFIG_GOLOMB 1
+#define CONFIG_GPLV3 0
+#define CONFIG_H263DSP 0
+#define CONFIG_H264CHROMA 0
+#define CONFIG_H264DSP 0
+#define CONFIG_H264PARSE 0
+#define CONFIG_H264PRED 1
+#define CONFIG_H264QPEL 0
+#define CONFIG_HEVCPARSE 0
+#define CONFIG_HPELDSP 1
+#define CONFIG_HUFFMAN 0
+#define CONFIG_HUFFYUVDSP 0
+#define CONFIG_HUFFYUVENCDSP 0
+#define CONFIG_IDCTDSP 0
+#define CONFIG_IIRFILTER 0
+#define CONFIG_MDCT15 0
+#define CONFIG_INTRAX8 0
+#define CONFIG_ISO_MEDIA 1
+#define CONFIG_IVIDSP 0
+#define CONFIG_JPEGTABLES 0
+#define CONFIG_LGPLV3 0
+#define CONFIG_LIBX262 0
+#define CONFIG_LLAUDDSP 0
+#define CONFIG_LLVIDDSP 0
+#define CONFIG_LLVIDENCDSP 0
+#define CONFIG_LPC 0
+#define CONFIG_LZF 0
+#define CONFIG_ME_CMP 0
+#define CONFIG_MPEG_ER 0
+#define CONFIG_MPEGAUDIO 1
+#define CONFIG_MPEGAUDIODSP 1
+#define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEOENC 0
+#define CONFIG_MSS34DSP 0
+#define CONFIG_PIXBLOCKDSP 0
+#define CONFIG_QPELDSP 0
+#define CONFIG_QSV 0
+#define CONFIG_QSVDEC 0
+#define CONFIG_QSVENC 0
+#define CONFIG_QSVVPP 0
+#define CONFIG_RANGECODER 0
+#define CONFIG_RIFFDEC 1
+#define CONFIG_RIFFENC 0
+#define CONFIG_RTPDEC 0
+#define CONFIG_RTPENC_CHAIN 0
+#define CONFIG_RV34DSP 0
+#define CONFIG_SCENE_SAD 0
+#define CONFIG_SINEWIN 0
+#define CONFIG_SNAPPY 0
+#define CONFIG_SRTP 0
+#define CONFIG_STARTCODE 0
+#define CONFIG_TEXTUREDSP 0
+#define CONFIG_TEXTUREDSPENC 0
+#define CONFIG_TPELDSP 0
+#define CONFIG_VAAPI_1 0
+#define CONFIG_VAAPI_ENCODE 0
+#define CONFIG_VC1DSP 0
+#define CONFIG_VIDEODSP 1
+#define CONFIG_VP3DSP 1
+#define CONFIG_VP56DSP 0
+#define CONFIG_VP8DSP 1
+#define CONFIG_WMA_FREQS 0
+#define CONFIG_WMV2DSP 0
+#define CONFIG_AAC_ADTSTOASC_BSF 0
+#define CONFIG_AV1_FRAME_MERGE_BSF 0
+#define CONFIG_AV1_FRAME_SPLIT_BSF 0
+#define CONFIG_AV1_METADATA_BSF 0
+#define CONFIG_CHOMP_BSF 0
+#define CONFIG_DUMP_EXTRADATA_BSF 0
+#define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_EAC3_CORE_BSF 0
+#define CONFIG_EXTRACT_EXTRADATA_BSF 0
+#define CONFIG_FILTER_UNITS_BSF 0
+#define CONFIG_H264_METADATA_BSF 0
+#define CONFIG_H264_MP4TOANNEXB_BSF 0
+#define CONFIG_H264_REDUNDANT_PPS_BSF 0
+#define CONFIG_HAPQA_EXTRACT_BSF 0
+#define CONFIG_HEVC_METADATA_BSF 0
+#define CONFIG_HEVC_MP4TOANNEXB_BSF 0
+#define CONFIG_IMX_DUMP_HEADER_BSF 0
+#define CONFIG_MJPEG2JPEG_BSF 0
+#define CONFIG_MJPEGA_DUMP_HEADER_BSF 0
+#define CONFIG_MP3_HEADER_DECOMPRESS_BSF 0
+#define CONFIG_MPEG2_METADATA_BSF 0
+#define CONFIG_MPEG4_UNPACK_BFRAMES_BSF 0
+#define CONFIG_MOV2TEXTSUB_BSF 0
+#define CONFIG_NOISE_BSF 0
+#define CONFIG_NULL_BSF 1
+#define CONFIG_OPUS_METADATA_BSF 0
+#define CONFIG_PCM_RECHUNK_BSF 0
+#define CONFIG_PRORES_METADATA_BSF 0
+#define CONFIG_REMOVE_EXTRADATA_BSF 0
+#define CONFIG_TEXT2MOVSUB_BSF 0
+#define CONFIG_TRACE_HEADERS_BSF 0
+#define CONFIG_TRUEHD_CORE_BSF 0
+#define CONFIG_VP9_METADATA_BSF 0
+#define CONFIG_VP9_RAW_REORDER_BSF 0
+#define CONFIG_VP9_SUPERFRAME_BSF 0
+#define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 0
+#define CONFIG_AASC_DECODER 0
+#define CONFIG_AIC_DECODER 0
+#define CONFIG_ALIAS_PIX_DECODER 0
+#define CONFIG_AGM_DECODER 0
+#define CONFIG_AMV_DECODER 0
+#define CONFIG_ANM_DECODER 0
+#define CONFIG_ANSI_DECODER 0
+#define CONFIG_APNG_DECODER 0
+#define CONFIG_ARBC_DECODER 0
+#define CONFIG_ASV1_DECODER 0
+#define CONFIG_ASV2_DECODER 0
+#define CONFIG_AURA_DECODER 0
+#define CONFIG_AURA2_DECODER 0
+#define CONFIG_AVRP_DECODER 0
+#define CONFIG_AVRN_DECODER 0
+#define CONFIG_AVS_DECODER 0
+#define CONFIG_AVUI_DECODER 0
+#define CONFIG_AYUV_DECODER 0
+#define CONFIG_BETHSOFTVID_DECODER 0
+#define CONFIG_BFI_DECODER 0
+#define CONFIG_BINK_DECODER 0
+#define CONFIG_BITPACKED_DECODER 0
+#define CONFIG_BMP_DECODER 0
+#define CONFIG_BMV_VIDEO_DECODER 0
+#define CONFIG_BRENDER_PIX_DECODER 0
+#define CONFIG_C93_DECODER 0
+#define CONFIG_CAVS_DECODER 0
+#define CONFIG_CDGRAPHICS_DECODER 0
+#define CONFIG_CDTOONS_DECODER 0
+#define CONFIG_CDXL_DECODER 0
+#define CONFIG_CFHD_DECODER 0
+#define CONFIG_CINEPAK_DECODER 0
+#define CONFIG_CLEARVIDEO_DECODER 0
+#define CONFIG_CLJR_DECODER 0
+#define CONFIG_CLLC_DECODER 0
+#define CONFIG_COMFORTNOISE_DECODER 0
+#define CONFIG_CPIA_DECODER 0
+#define CONFIG_CSCD_DECODER 0
+#define CONFIG_CYUV_DECODER 0
+#define CONFIG_DDS_DECODER 0
+#define CONFIG_DFA_DECODER 0
+#define CONFIG_DIRAC_DECODER 0
+#define CONFIG_DNXHD_DECODER 0
+#define CONFIG_DPX_DECODER 0
+#define CONFIG_DSICINVIDEO_DECODER 0
+#define CONFIG_DVAUDIO_DECODER 0
+#define CONFIG_DVVIDEO_DECODER 0
+#define CONFIG_DXA_DECODER 0
+#define CONFIG_DXTORY_DECODER 0
+#define CONFIG_DXV_DECODER 0
+#define CONFIG_EACMV_DECODER 0
+#define CONFIG_EAMAD_DECODER 0
+#define CONFIG_EATGQ_DECODER 0
+#define CONFIG_EATGV_DECODER 0
+#define CONFIG_EATQI_DECODER 0
+#define CONFIG_EIGHTBPS_DECODER 0
+#define CONFIG_EIGHTSVX_EXP_DECODER 0
+#define CONFIG_EIGHTSVX_FIB_DECODER 0
+#define CONFIG_ESCAPE124_DECODER 0
+#define CONFIG_ESCAPE130_DECODER 0
+#define CONFIG_EXR_DECODER 0
+#define CONFIG_FFV1_DECODER 0
+#define CONFIG_FFVHUFF_DECODER 0
+#define CONFIG_FIC_DECODER 0
+#define CONFIG_FITS_DECODER 0
+#define CONFIG_FLASHSV_DECODER 0
+#define CONFIG_FLASHSV2_DECODER 0
+#define CONFIG_FLIC_DECODER 0
+#define CONFIG_FLV_DECODER 0
+#define CONFIG_FMVC_DECODER 0
+#define CONFIG_FOURXM_DECODER 0
+#define CONFIG_FRAPS_DECODER 0
+#define CONFIG_FRWU_DECODER 0
+#define CONFIG_G2M_DECODER 0
+#define CONFIG_GDV_DECODER 0
+#define CONFIG_GIF_DECODER 0
+#define CONFIG_H261_DECODER 0
+#define CONFIG_H263_DECODER 0
+#define CONFIG_H263I_DECODER 0
+#define CONFIG_H263P_DECODER 0
+#define CONFIG_H263_V4L2M2M_DECODER 0
+#define CONFIG_H264_DECODER 0
+#define CONFIG_H264_CRYSTALHD_DECODER 0
+#define CONFIG_H264_V4L2M2M_DECODER 0
+#define CONFIG_H264_MEDIACODEC_DECODER 0
+#define CONFIG_H264_MMAL_DECODER 0
+#define CONFIG_H264_QSV_DECODER 0
+#define CONFIG_H264_RKMPP_DECODER 0
+#define CONFIG_HAP_DECODER 0
+#define CONFIG_HEVC_DECODER 0
+#define CONFIG_HEVC_QSV_DECODER 0
+#define CONFIG_HEVC_RKMPP_DECODER 0
+#define CONFIG_HEVC_V4L2M2M_DECODER 0
+#define CONFIG_HNM4_VIDEO_DECODER 0
+#define CONFIG_HQ_HQA_DECODER 0
+#define CONFIG_HQX_DECODER 0
+#define CONFIG_HUFFYUV_DECODER 0
+#define CONFIG_HYMT_DECODER 0
+#define CONFIG_IDCIN_DECODER 0
+#define CONFIG_IFF_ILBM_DECODER 0
+#define CONFIG_IMM4_DECODER 0
+#define CONFIG_IMM5_DECODER 0
+#define CONFIG_INDEO2_DECODER 0
+#define CONFIG_INDEO3_DECODER 0
+#define CONFIG_INDEO4_DECODER 0
+#define CONFIG_INDEO5_DECODER 0
+#define CONFIG_INTERPLAY_VIDEO_DECODER 0
+#define CONFIG_JPEG2000_DECODER 0
+#define CONFIG_JPEGLS_DECODER 0
+#define CONFIG_JV_DECODER 0
+#define CONFIG_KGV1_DECODER 0
+#define CONFIG_KMVC_DECODER 0
+#define CONFIG_LAGARITH_DECODER 0
+#define CONFIG_LOCO_DECODER 0
+#define CONFIG_LSCR_DECODER 0
+#define CONFIG_M101_DECODER 0
+#define CONFIG_MAGICYUV_DECODER 0
+#define CONFIG_MDEC_DECODER 0
+#define CONFIG_MIMIC_DECODER 0
+#define CONFIG_MJPEG_DECODER 0
+#define CONFIG_MJPEGB_DECODER 0
+#define CONFIG_MMVIDEO_DECODER 0
+#define CONFIG_MOTIONPIXELS_DECODER 0
+#define CONFIG_MPEG1VIDEO_DECODER 0
+#define CONFIG_MPEG2VIDEO_DECODER 0
+#define CONFIG_MPEG4_DECODER 0
+#define CONFIG_MPEG4_CRYSTALHD_DECODER 0
+#define CONFIG_MPEG4_V4L2M2M_DECODER 0
+#define CONFIG_MPEG4_MMAL_DECODER 0
+#define CONFIG_MPEGVIDEO_DECODER 0
+#define CONFIG_MPEG1_V4L2M2M_DECODER 0
+#define CONFIG_MPEG2_MMAL_DECODER 0
+#define CONFIG_MPEG2_CRYSTALHD_DECODER 0
+#define CONFIG_MPEG2_V4L2M2M_DECODER 0
+#define CONFIG_MPEG2_QSV_DECODER 0
+#define CONFIG_MPEG2_MEDIACODEC_DECODER 0
+#define CONFIG_MSA1_DECODER 0
+#define CONFIG_MSCC_DECODER 0
+#define CONFIG_MSMPEG4V1_DECODER 0
+#define CONFIG_MSMPEG4V2_DECODER 0
+#define CONFIG_MSMPEG4V3_DECODER 0
+#define CONFIG_MSMPEG4_CRYSTALHD_DECODER 0
+#define CONFIG_MSRLE_DECODER 0
+#define CONFIG_MSS1_DECODER 0
+#define CONFIG_MSS2_DECODER 0
+#define CONFIG_MSVIDEO1_DECODER 0
+#define CONFIG_MSZH_DECODER 0
+#define CONFIG_MTS2_DECODER 0
+#define CONFIG_MV30_DECODER 0
+#define CONFIG_MVC1_DECODER 0
+#define CONFIG_MVC2_DECODER 0
+#define CONFIG_MVDV_DECODER 0
+#define CONFIG_MVHA_DECODER 0
+#define CONFIG_MWSC_DECODER 0
+#define CONFIG_MXPEG_DECODER 0
+#define CONFIG_NOTCHLC_DECODER 0
+#define CONFIG_NUV_DECODER 0
+#define CONFIG_PAF_VIDEO_DECODER 0
+#define CONFIG_PAM_DECODER 0
+#define CONFIG_PBM_DECODER 0
+#define CONFIG_PCX_DECODER 0
+#define CONFIG_PFM_DECODER 0
+#define CONFIG_PGM_DECODER 0
+#define CONFIG_PGMYUV_DECODER 0
+#define CONFIG_PGX_DECODER 0
+#define CONFIG_PICTOR_DECODER 0
+#define CONFIG_PIXLET_DECODER 0
+#define CONFIG_PNG_DECODER 0
+#define CONFIG_PPM_DECODER 0
+#define CONFIG_PRORES_DECODER 0
+#define CONFIG_PROSUMER_DECODER 0
+#define CONFIG_PSD_DECODER 0
+#define CONFIG_PTX_DECODER 0
+#define CONFIG_QDRAW_DECODER 0
+#define CONFIG_QPEG_DECODER 0
+#define CONFIG_QTRLE_DECODER 0
+#define CONFIG_R10K_DECODER 0
+#define CONFIG_R210_DECODER 0
+#define CONFIG_RASC_DECODER 0
+#define CONFIG_RAWVIDEO_DECODER 0
+#define CONFIG_RL2_DECODER 0
+#define CONFIG_ROQ_DECODER 0
+#define CONFIG_RPZA_DECODER 0
+#define CONFIG_RSCC_DECODER 0
+#define CONFIG_RV10_DECODER 0
+#define CONFIG_RV20_DECODER 0
+#define CONFIG_RV30_DECODER 0
+#define CONFIG_RV40_DECODER 0
+#define CONFIG_S302M_DECODER 0
+#define CONFIG_SANM_DECODER 0
+#define CONFIG_SCPR_DECODER 0
+#define CONFIG_SCREENPRESSO_DECODER 0
+#define CONFIG_SGI_DECODER 0
+#define CONFIG_SGIRLE_DECODER 0
+#define CONFIG_SHEERVIDEO_DECODER 0
+#define CONFIG_SMACKER_DECODER 0
+#define CONFIG_SMC_DECODER 0
+#define CONFIG_SMVJPEG_DECODER 0
+#define CONFIG_SNOW_DECODER 0
+#define CONFIG_SP5X_DECODER 0
+#define CONFIG_SPEEDHQ_DECODER 0
+#define CONFIG_SRGC_DECODER 0
+#define CONFIG_SUNRAST_DECODER 0
+#define CONFIG_SVQ1_DECODER 0
+#define CONFIG_SVQ3_DECODER 0
+#define CONFIG_TARGA_DECODER 0
+#define CONFIG_TARGA_Y216_DECODER 0
+#define CONFIG_TDSC_DECODER 0
+#define CONFIG_THEORA_DECODER 1
+#define CONFIG_THP_DECODER 0
+#define CONFIG_TIERTEXSEQVIDEO_DECODER 0
+#define CONFIG_TIFF_DECODER 0
+#define CONFIG_TMV_DECODER 0
+#define CONFIG_TRUEMOTION1_DECODER 0
+#define CONFIG_TRUEMOTION2_DECODER 0
+#define CONFIG_TRUEMOTION2RT_DECODER 0
+#define CONFIG_TSCC_DECODER 0
+#define CONFIG_TSCC2_DECODER 0
+#define CONFIG_TXD_DECODER 0
+#define CONFIG_ULTI_DECODER 0
+#define CONFIG_UTVIDEO_DECODER 0
+#define CONFIG_V210_DECODER 0
+#define CONFIG_V210X_DECODER 0
+#define CONFIG_V308_DECODER 0
+#define CONFIG_V408_DECODER 0
+#define CONFIG_V410_DECODER 0
+#define CONFIG_VB_DECODER 0
+#define CONFIG_VBLE_DECODER 0
+#define CONFIG_VC1_DECODER 0
+#define CONFIG_VC1_CRYSTALHD_DECODER 0
+#define CONFIG_VC1IMAGE_DECODER 0
+#define CONFIG_VC1_MMAL_DECODER 0
+#define CONFIG_VC1_QSV_DECODER 0
+#define CONFIG_VC1_V4L2M2M_DECODER 0
+#define CONFIG_VCR1_DECODER 0
+#define CONFIG_VMDVIDEO_DECODER 0
+#define CONFIG_VMNC_DECODER 0
+#define CONFIG_VP3_DECODER 1
+#define CONFIG_VP4_DECODER 0
+#define CONFIG_VP5_DECODER 0
+#define CONFIG_VP6_DECODER 0
+#define CONFIG_VP6A_DECODER 0
+#define CONFIG_VP6F_DECODER 0
+#define CONFIG_VP7_DECODER 0
+#define CONFIG_VP8_DECODER 1
+#define CONFIG_VP8_RKMPP_DECODER 0
+#define CONFIG_VP8_V4L2M2M_DECODER 0
+#define CONFIG_VP9_DECODER 0
+#define CONFIG_VP9_RKMPP_DECODER 0
+#define CONFIG_VP9_V4L2M2M_DECODER 0
+#define CONFIG_VQA_DECODER 0
+#define CONFIG_WEBP_DECODER 0
+#define CONFIG_WCMV_DECODER 0
+#define CONFIG_WRAPPED_AVFRAME_DECODER 0
+#define CONFIG_WMV1_DECODER 0
+#define CONFIG_WMV2_DECODER 0
+#define CONFIG_WMV3_DECODER 0
+#define CONFIG_WMV3_CRYSTALHD_DECODER 0
+#define CONFIG_WMV3IMAGE_DECODER 0
+#define CONFIG_WNV1_DECODER 0
+#define CONFIG_XAN_WC3_DECODER 0
+#define CONFIG_XAN_WC4_DECODER 0
+#define CONFIG_XBM_DECODER 0
+#define CONFIG_XFACE_DECODER 0
+#define CONFIG_XL_DECODER 0
+#define CONFIG_XPM_DECODER 0
+#define CONFIG_XWD_DECODER 0
+#define CONFIG_Y41P_DECODER 0
+#define CONFIG_YLC_DECODER 0
+#define CONFIG_YOP_DECODER 0
+#define CONFIG_YUV4_DECODER 0
+#define CONFIG_ZERO12V_DECODER 0
+#define CONFIG_ZEROCODEC_DECODER 0
+#define CONFIG_ZLIB_DECODER 0
+#define CONFIG_ZMBV_DECODER 0
+#define CONFIG_AAC_DECODER 0
+#define CONFIG_AAC_FIXED_DECODER 0
+#define CONFIG_AAC_LATM_DECODER 0
+#define CONFIG_AC3_DECODER 0
+#define CONFIG_AC3_FIXED_DECODER 0
+#define CONFIG_ACELP_KELVIN_DECODER 0
+#define CONFIG_ALAC_DECODER 0
+#define CONFIG_ALS_DECODER 0
+#define CONFIG_AMRNB_DECODER 0
+#define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APE_DECODER 0
+#define CONFIG_APTX_DECODER 0
+#define CONFIG_APTX_HD_DECODER 0
+#define CONFIG_ATRAC1_DECODER 0
+#define CONFIG_ATRAC3_DECODER 0
+#define CONFIG_ATRAC3AL_DECODER 0
+#define CONFIG_ATRAC3P_DECODER 0
+#define CONFIG_ATRAC3PAL_DECODER 0
+#define CONFIG_ATRAC9_DECODER 0
+#define CONFIG_BINKAUDIO_DCT_DECODER 0
+#define CONFIG_BINKAUDIO_RDFT_DECODER 0
+#define CONFIG_BMV_AUDIO_DECODER 0
+#define CONFIG_COOK_DECODER 0
+#define CONFIG_DCA_DECODER 0
+#define CONFIG_DOLBY_E_DECODER 0
+#define CONFIG_DSD_LSBF_DECODER 0
+#define CONFIG_DSD_MSBF_DECODER 0
+#define CONFIG_DSD_LSBF_PLANAR_DECODER 0
+#define CONFIG_DSD_MSBF_PLANAR_DECODER 0
+#define CONFIG_DSICINAUDIO_DECODER 0
+#define CONFIG_DSS_SP_DECODER 0
+#define CONFIG_DST_DECODER 0
+#define CONFIG_EAC3_DECODER 0
+#define CONFIG_EVRC_DECODER 0
+#define CONFIG_FFWAVESYNTH_DECODER 0
+#define CONFIG_FLAC_DECODER 1
+#define CONFIG_G723_1_DECODER 0
+#define CONFIG_G729_DECODER 0
+#define CONFIG_GSM_DECODER 0
+#define CONFIG_GSM_MS_DECODER 0
+#define CONFIG_HCA_DECODER 0
+#define CONFIG_HCOM_DECODER 0
+#define CONFIG_IAC_DECODER 0
+#define CONFIG_ILBC_DECODER 0
+#define CONFIG_IMC_DECODER 0
+#define CONFIG_INTERPLAY_ACM_DECODER 0
+#define CONFIG_MACE3_DECODER 0
+#define CONFIG_MACE6_DECODER 0
+#define CONFIG_METASOUND_DECODER 0
+#define CONFIG_MLP_DECODER 0
+#define CONFIG_MP1_DECODER 0
+#define CONFIG_MP1FLOAT_DECODER 0
+#define CONFIG_MP2_DECODER 0
+#define CONFIG_MP2FLOAT_DECODER 0
+#define CONFIG_MP3FLOAT_DECODER 0
+#define CONFIG_MP3_DECODER 1
+#define CONFIG_MP3ADUFLOAT_DECODER 0
+#define CONFIG_MP3ADU_DECODER 0
+#define CONFIG_MP3ON4FLOAT_DECODER 0
+#define CONFIG_MP3ON4_DECODER 0
+#define CONFIG_MPC7_DECODER 0
+#define CONFIG_MPC8_DECODER 0
+#define CONFIG_NELLYMOSER_DECODER 0
+#define CONFIG_ON2AVC_DECODER 0
+#define CONFIG_OPUS_DECODER 0
+#define CONFIG_PAF_AUDIO_DECODER 0
+#define CONFIG_QCELP_DECODER 0
+#define CONFIG_QDM2_DECODER 0
+#define CONFIG_QDMC_DECODER 0
+#define CONFIG_RA_144_DECODER 0
+#define CONFIG_RA_288_DECODER 0
+#define CONFIG_RALF_DECODER 0
+#define CONFIG_SBC_DECODER 0
+#define CONFIG_SHORTEN_DECODER 0
+#define CONFIG_SIPR_DECODER 0
+#define CONFIG_SIREN_DECODER 0
+#define CONFIG_SMACKAUD_DECODER 0
+#define CONFIG_SONIC_DECODER 0
+#define CONFIG_TAK_DECODER 0
+#define CONFIG_TRUEHD_DECODER 0
+#define CONFIG_TRUESPEECH_DECODER 0
+#define CONFIG_TTA_DECODER 0
+#define CONFIG_TWINVQ_DECODER 0
+#define CONFIG_VMDAUDIO_DECODER 0
+#define CONFIG_VORBIS_DECODER 1
+#define CONFIG_WAVPACK_DECODER 0
+#define CONFIG_WMALOSSLESS_DECODER 0
+#define CONFIG_WMAPRO_DECODER 0
+#define CONFIG_WMAV1_DECODER 0
+#define CONFIG_WMAV2_DECODER 0
+#define CONFIG_WMAVOICE_DECODER 0
+#define CONFIG_WS_SND1_DECODER 0
+#define CONFIG_XMA1_DECODER 0
+#define CONFIG_XMA2_DECODER 0
+#define CONFIG_PCM_ALAW_DECODER 1
+#define CONFIG_PCM_BLURAY_DECODER 0
+#define CONFIG_PCM_DVD_DECODER 0
+#define CONFIG_PCM_F16LE_DECODER 0
+#define CONFIG_PCM_F24LE_DECODER 0
+#define CONFIG_PCM_F32BE_DECODER 0
+#define CONFIG_PCM_F32LE_DECODER 1
+#define CONFIG_PCM_F64BE_DECODER 0
+#define CONFIG_PCM_F64LE_DECODER 0
+#define CONFIG_PCM_LXF_DECODER 0
+#define CONFIG_PCM_MULAW_DECODER 1
+#define CONFIG_PCM_S8_DECODER 0
+#define CONFIG_PCM_S8_PLANAR_DECODER 0
+#define CONFIG_PCM_S16BE_DECODER 1
+#define CONFIG_PCM_S16BE_PLANAR_DECODER 0
+#define CONFIG_PCM_S16LE_DECODER 1
+#define CONFIG_PCM_S16LE_PLANAR_DECODER 0
+#define CONFIG_PCM_S24BE_DECODER 1
+#define CONFIG_PCM_S24DAUD_DECODER 0
+#define CONFIG_PCM_S24LE_DECODER 1
+#define CONFIG_PCM_S24LE_PLANAR_DECODER 0
+#define CONFIG_PCM_S32BE_DECODER 0
+#define CONFIG_PCM_S32LE_DECODER 1
+#define CONFIG_PCM_S32LE_PLANAR_DECODER 0
+#define CONFIG_PCM_S64BE_DECODER 0
+#define CONFIG_PCM_S64LE_DECODER 0
+#define CONFIG_PCM_U8_DECODER 1
+#define CONFIG_PCM_U16BE_DECODER 0
+#define CONFIG_PCM_U16LE_DECODER 0
+#define CONFIG_PCM_U24BE_DECODER 0
+#define CONFIG_PCM_U24LE_DECODER 0
+#define CONFIG_PCM_U32BE_DECODER 0
+#define CONFIG_PCM_U32LE_DECODER 0
+#define CONFIG_PCM_VIDC_DECODER 0
+#define CONFIG_DERF_DPCM_DECODER 0
+#define CONFIG_GREMLIN_DPCM_DECODER 0
+#define CONFIG_INTERPLAY_DPCM_DECODER 0
+#define CONFIG_ROQ_DPCM_DECODER 0
+#define CONFIG_SDX2_DPCM_DECODER 0
+#define CONFIG_SOL_DPCM_DECODER 0
+#define CONFIG_XAN_DPCM_DECODER 0
+#define CONFIG_ADPCM_4XM_DECODER 0
+#define CONFIG_ADPCM_ADX_DECODER 0
+#define CONFIG_ADPCM_AFC_DECODER 0
+#define CONFIG_ADPCM_AGM_DECODER 0
+#define CONFIG_ADPCM_AICA_DECODER 0
+#define CONFIG_ADPCM_ARGO_DECODER 0
+#define CONFIG_ADPCM_CT_DECODER 0
+#define CONFIG_ADPCM_DTK_DECODER 0
+#define CONFIG_ADPCM_EA_DECODER 0
+#define CONFIG_ADPCM_EA_MAXIS_XA_DECODER 0
+#define CONFIG_ADPCM_EA_R1_DECODER 0
+#define CONFIG_ADPCM_EA_R2_DECODER 0
+#define CONFIG_ADPCM_EA_R3_DECODER 0
+#define CONFIG_ADPCM_EA_XAS_DECODER 0
+#define CONFIG_ADPCM_G722_DECODER 0
+#define CONFIG_ADPCM_G726_DECODER 0
+#define CONFIG_ADPCM_G726LE_DECODER 0
+#define CONFIG_ADPCM_IMA_AMV_DECODER 0
+#define CONFIG_ADPCM_IMA_ALP_DECODER 0
+#define CONFIG_ADPCM_IMA_APC_DECODER 0
+#define CONFIG_ADPCM_IMA_APM_DECODER 0
+#define CONFIG_ADPCM_IMA_CUNNING_DECODER 0
+#define CONFIG_ADPCM_IMA_DAT4_DECODER 0
+#define CONFIG_ADPCM_IMA_DK3_DECODER 0
+#define CONFIG_ADPCM_IMA_DK4_DECODER 0
+#define CONFIG_ADPCM_IMA_EA_EACS_DECODER 0
+#define CONFIG_ADPCM_IMA_EA_SEAD_DECODER 0
+#define CONFIG_ADPCM_IMA_ISS_DECODER 0
+#define CONFIG_ADPCM_IMA_MTF_DECODER 0
+#define CONFIG_ADPCM_IMA_OKI_DECODER 0
+#define CONFIG_ADPCM_IMA_QT_DECODER 0
+#define CONFIG_ADPCM_IMA_RAD_DECODER 0
+#define CONFIG_ADPCM_IMA_SSI_DECODER 0
+#define CONFIG_ADPCM_IMA_SMJPEG_DECODER 0
+#define CONFIG_ADPCM_IMA_WAV_DECODER 0
+#define CONFIG_ADPCM_IMA_WS_DECODER 0
+#define CONFIG_ADPCM_MS_DECODER 0
+#define CONFIG_ADPCM_MTAF_DECODER 0
+#define CONFIG_ADPCM_PSX_DECODER 0
+#define CONFIG_ADPCM_SBPRO_2_DECODER 0
+#define CONFIG_ADPCM_SBPRO_3_DECODER 0
+#define CONFIG_ADPCM_SBPRO_4_DECODER 0
+#define CONFIG_ADPCM_SWF_DECODER 0
+#define CONFIG_ADPCM_THP_DECODER 0
+#define CONFIG_ADPCM_THP_LE_DECODER 0
+#define CONFIG_ADPCM_VIMA_DECODER 0
+#define CONFIG_ADPCM_XA_DECODER 0
+#define CONFIG_ADPCM_YAMAHA_DECODER 0
+#define CONFIG_ADPCM_ZORK_DECODER 0
+#define CONFIG_SSA_DECODER 0
+#define CONFIG_ASS_DECODER 0
+#define CONFIG_CCAPTION_DECODER 0
+#define CONFIG_DVBSUB_DECODER 0
+#define CONFIG_DVDSUB_DECODER 0
+#define CONFIG_JACOSUB_DECODER 0
+#define CONFIG_MICRODVD_DECODER 0
+#define CONFIG_MOVTEXT_DECODER 0
+#define CONFIG_MPL2_DECODER 0
+#define CONFIG_PGSSUB_DECODER 0
+#define CONFIG_PJS_DECODER 0
+#define CONFIG_REALTEXT_DECODER 0
+#define CONFIG_SAMI_DECODER 0
+#define CONFIG_SRT_DECODER 0
+#define CONFIG_STL_DECODER 0
+#define CONFIG_SUBRIP_DECODER 0
+#define CONFIG_SUBVIEWER_DECODER 0
+#define CONFIG_SUBVIEWER1_DECODER 0
+#define CONFIG_TEXT_DECODER 0
+#define CONFIG_VPLAYER_DECODER 0
+#define CONFIG_WEBVTT_DECODER 0
+#define CONFIG_XSUB_DECODER 0
+#define CONFIG_AAC_AT_DECODER 0
+#define CONFIG_AC3_AT_DECODER 0
+#define CONFIG_ADPCM_IMA_QT_AT_DECODER 0
+#define CONFIG_ALAC_AT_DECODER 0
+#define CONFIG_AMR_NB_AT_DECODER 0
+#define CONFIG_EAC3_AT_DECODER 0
+#define CONFIG_GSM_MS_AT_DECODER 0
+#define CONFIG_ILBC_AT_DECODER 0
+#define CONFIG_MP1_AT_DECODER 0
+#define CONFIG_MP2_AT_DECODER 0
+#define CONFIG_MP3_AT_DECODER 0
+#define CONFIG_PCM_ALAW_AT_DECODER 0
+#define CONFIG_PCM_MULAW_AT_DECODER 0
+#define CONFIG_QDMC_AT_DECODER 0
+#define CONFIG_QDM2_AT_DECODER 0
+#define CONFIG_LIBARIBB24_DECODER 0
+#define CONFIG_LIBCELT_DECODER 0
+#define CONFIG_LIBCODEC2_DECODER 0
+#define CONFIG_LIBDAV1D_DECODER 0
+#define CONFIG_LIBDAVS2_DECODER 0
+#define CONFIG_LIBFDK_AAC_DECODER 0
+#define CONFIG_LIBGSM_DECODER 0
+#define CONFIG_LIBGSM_MS_DECODER 0
+#define CONFIG_LIBILBC_DECODER 0
+#define CONFIG_LIBOPENCORE_AMRNB_DECODER 0
+#define CONFIG_LIBOPENCORE_AMRWB_DECODER 0
+#define CONFIG_LIBOPENJPEG_DECODER 0
+#define CONFIG_LIBOPUS_DECODER 1
+#define CONFIG_LIBRSVG_DECODER 0
+#define CONFIG_LIBSPEEX_DECODER 0
+#define CONFIG_LIBVORBIS_DECODER 0
+#define CONFIG_LIBVPX_VP8_DECODER 0
+#define CONFIG_LIBVPX_VP9_DECODER 0
+#define CONFIG_LIBZVBI_TELETEXT_DECODER 0
+#define CONFIG_BINTEXT_DECODER 0
+#define CONFIG_XBIN_DECODER 0
+#define CONFIG_IDF_DECODER 0
+#define CONFIG_LIBAOM_AV1_DECODER 0
+#define CONFIG_LIBOPENH264_DECODER 0
+#define CONFIG_H264_CUVID_DECODER 0
+#define CONFIG_HEVC_CUVID_DECODER 0
+#define CONFIG_HEVC_MEDIACODEC_DECODER 0
+#define CONFIG_MJPEG_CUVID_DECODER 0
+#define CONFIG_MJPEG_QSV_DECODER 0
+#define CONFIG_MPEG1_CUVID_DECODER 0
+#define CONFIG_MPEG2_CUVID_DECODER 0
+#define CONFIG_MPEG4_CUVID_DECODER 0
+#define CONFIG_MPEG4_MEDIACODEC_DECODER 0
+#define CONFIG_VC1_CUVID_DECODER 0
+#define CONFIG_VP8_CUVID_DECODER 0
+#define CONFIG_VP8_MEDIACODEC_DECODER 0
+#define CONFIG_VP8_QSV_DECODER 0
+#define CONFIG_VP9_CUVID_DECODER 0
+#define CONFIG_VP9_MEDIACODEC_DECODER 0
+#define CONFIG_VP9_QSV_DECODER 0
+#define CONFIG_A64MULTI_ENCODER 0
+#define CONFIG_A64MULTI5_ENCODER 0
+#define CONFIG_ALIAS_PIX_ENCODER 0
+#define CONFIG_AMV_ENCODER 0
+#define CONFIG_APNG_ENCODER 0
+#define CONFIG_ASV1_ENCODER 0
+#define CONFIG_ASV2_ENCODER 0
+#define CONFIG_AVRP_ENCODER 0
+#define CONFIG_AVUI_ENCODER 0
+#define CONFIG_AYUV_ENCODER 0
+#define CONFIG_BMP_ENCODER 0
+#define CONFIG_CFHD_ENCODER 0
+#define CONFIG_CINEPAK_ENCODER 0
+#define CONFIG_CLJR_ENCODER 0
+#define CONFIG_COMFORTNOISE_ENCODER 0
+#define CONFIG_DNXHD_ENCODER 0
+#define CONFIG_DPX_ENCODER 0
+#define CONFIG_DVVIDEO_ENCODER 0
+#define CONFIG_FFV1_ENCODER 0
+#define CONFIG_FFVHUFF_ENCODER 0
+#define CONFIG_FITS_ENCODER 0
+#define CONFIG_FLASHSV_ENCODER 0
+#define CONFIG_FLASHSV2_ENCODER 0
+#define CONFIG_FLV_ENCODER 0
+#define CONFIG_GIF_ENCODER 0
+#define CONFIG_H261_ENCODER 0
+#define CONFIG_H263_ENCODER 0
+#define CONFIG_H263P_ENCODER 0
+#define CONFIG_HAP_ENCODER 0
+#define CONFIG_HUFFYUV_ENCODER 0
+#define CONFIG_JPEG2000_ENCODER 0
+#define CONFIG_JPEGLS_ENCODER 0
+#define CONFIG_LJPEG_ENCODER 0
+#define CONFIG_MAGICYUV_ENCODER 0
+#define CONFIG_MJPEG_ENCODER 0
+#define CONFIG_MPEG1VIDEO_ENCODER 0
+#define CONFIG_MPEG2VIDEO_ENCODER 0
+#define CONFIG_MPEG4_ENCODER 0
+#define CONFIG_MSMPEG4V2_ENCODER 0
+#define CONFIG_MSMPEG4V3_ENCODER 0
+#define CONFIG_MSVIDEO1_ENCODER 0
+#define CONFIG_PAM_ENCODER 0
+#define CONFIG_PBM_ENCODER 0
+#define CONFIG_PCX_ENCODER 0
+#define CONFIG_PGM_ENCODER 0
+#define CONFIG_PGMYUV_ENCODER 0
+#define CONFIG_PNG_ENCODER 0
+#define CONFIG_PPM_ENCODER 0
+#define CONFIG_PRORES_ENCODER 0
+#define CONFIG_PRORES_AW_ENCODER 0
+#define CONFIG_PRORES_KS_ENCODER 0
+#define CONFIG_QTRLE_ENCODER 0
+#define CONFIG_R10K_ENCODER 0
+#define CONFIG_R210_ENCODER 0
+#define CONFIG_RAWVIDEO_ENCODER 0
+#define CONFIG_ROQ_ENCODER 0
+#define CONFIG_RPZA_ENCODER 0
+#define CONFIG_RV10_ENCODER 0
+#define CONFIG_RV20_ENCODER 0
+#define CONFIG_S302M_ENCODER 0
+#define CONFIG_SGI_ENCODER 0
+#define CONFIG_SNOW_ENCODER 0
+#define CONFIG_SUNRAST_ENCODER 0
+#define CONFIG_SVQ1_ENCODER 0
+#define CONFIG_TARGA_ENCODER 0
+#define CONFIG_TIFF_ENCODER 0
+#define CONFIG_UTVIDEO_ENCODER 0
+#define CONFIG_V210_ENCODER 0
+#define CONFIG_V308_ENCODER 0
+#define CONFIG_V408_ENCODER 0
+#define CONFIG_V410_ENCODER 0
+#define CONFIG_VC2_ENCODER 0
+#define CONFIG_WRAPPED_AVFRAME_ENCODER 0
+#define CONFIG_WMV1_ENCODER 0
+#define CONFIG_WMV2_ENCODER 0
+#define CONFIG_XBM_ENCODER 0
+#define CONFIG_XFACE_ENCODER 0
+#define CONFIG_XWD_ENCODER 0
+#define CONFIG_Y41P_ENCODER 0
+#define CONFIG_YUV4_ENCODER 0
+#define CONFIG_ZLIB_ENCODER 0
+#define CONFIG_ZMBV_ENCODER 0
+#define CONFIG_AAC_ENCODER 0
+#define CONFIG_AC3_ENCODER 0
+#define CONFIG_AC3_FIXED_ENCODER 0
+#define CONFIG_ALAC_ENCODER 0
+#define CONFIG_APTX_ENCODER 0
+#define CONFIG_APTX_HD_ENCODER 0
+#define CONFIG_DCA_ENCODER 0
+#define CONFIG_EAC3_ENCODER 0
+#define CONFIG_FLAC_ENCODER 0
+#define CONFIG_G723_1_ENCODER 0
+#define CONFIG_MLP_ENCODER 0
+#define CONFIG_MP2_ENCODER 0
+#define CONFIG_MP2FIXED_ENCODER 0
+#define CONFIG_NELLYMOSER_ENCODER 0
+#define CONFIG_OPUS_ENCODER 0
+#define CONFIG_RA_144_ENCODER 0
+#define CONFIG_SBC_ENCODER 0
+#define CONFIG_SONIC_ENCODER 0
+#define CONFIG_SONIC_LS_ENCODER 0
+#define CONFIG_TRUEHD_ENCODER 0
+#define CONFIG_TTA_ENCODER 0
+#define CONFIG_VORBIS_ENCODER 0
+#define CONFIG_WAVPACK_ENCODER 0
+#define CONFIG_WMAV1_ENCODER 0
+#define CONFIG_WMAV2_ENCODER 0
+#define CONFIG_PCM_ALAW_ENCODER 0
+#define CONFIG_PCM_DVD_ENCODER 0
+#define CONFIG_PCM_F32BE_ENCODER 0
+#define CONFIG_PCM_F32LE_ENCODER 0
+#define CONFIG_PCM_F64BE_ENCODER 0
+#define CONFIG_PCM_F64LE_ENCODER 0
+#define CONFIG_PCM_MULAW_ENCODER 0
+#define CONFIG_PCM_S8_ENCODER 0
+#define CONFIG_PCM_S8_PLANAR_ENCODER 0
+#define CONFIG_PCM_S16BE_ENCODER 0
+#define CONFIG_PCM_S16BE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S16LE_ENCODER 0
+#define CONFIG_PCM_S16LE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S24BE_ENCODER 0
+#define CONFIG_PCM_S24DAUD_ENCODER 0
+#define CONFIG_PCM_S24LE_ENCODER 0
+#define CONFIG_PCM_S24LE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S32BE_ENCODER 0
+#define CONFIG_PCM_S32LE_ENCODER 0
+#define CONFIG_PCM_S32LE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S64BE_ENCODER 0
+#define CONFIG_PCM_S64LE_ENCODER 0
+#define CONFIG_PCM_U8_ENCODER 0
+#define CONFIG_PCM_U16BE_ENCODER 0
+#define CONFIG_PCM_U16LE_ENCODER 0
+#define CONFIG_PCM_U24BE_ENCODER 0
+#define CONFIG_PCM_U24LE_ENCODER 0
+#define CONFIG_PCM_U32BE_ENCODER 0
+#define CONFIG_PCM_U32LE_ENCODER 0
+#define CONFIG_PCM_VIDC_ENCODER 0
+#define CONFIG_ROQ_DPCM_ENCODER 0
+#define CONFIG_ADPCM_ADX_ENCODER 0
+#define CONFIG_ADPCM_ARGO_ENCODER 0
+#define CONFIG_ADPCM_G722_ENCODER 0
+#define CONFIG_ADPCM_G726_ENCODER 0
+#define CONFIG_ADPCM_G726LE_ENCODER 0
+#define CONFIG_ADPCM_IMA_APM_ENCODER 0
+#define CONFIG_ADPCM_IMA_QT_ENCODER 0
+#define CONFIG_ADPCM_IMA_SSI_ENCODER 0
+#define CONFIG_ADPCM_IMA_WAV_ENCODER 0
+#define CONFIG_ADPCM_MS_ENCODER 0
+#define CONFIG_ADPCM_SWF_ENCODER 0
+#define CONFIG_ADPCM_YAMAHA_ENCODER 0
+#define CONFIG_SSA_ENCODER 0
+#define CONFIG_ASS_ENCODER 0
+#define CONFIG_DVBSUB_ENCODER 0
+#define CONFIG_DVDSUB_ENCODER 0
+#define CONFIG_MOVTEXT_ENCODER 0
+#define CONFIG_SRT_ENCODER 0
+#define CONFIG_SUBRIP_ENCODER 0
+#define CONFIG_TEXT_ENCODER 0
+#define CONFIG_WEBVTT_ENCODER 0
+#define CONFIG_XSUB_ENCODER 0
+#define CONFIG_AAC_AT_ENCODER 0
+#define CONFIG_ALAC_AT_ENCODER 0
+#define CONFIG_ILBC_AT_ENCODER 0
+#define CONFIG_PCM_ALAW_AT_ENCODER 0
+#define CONFIG_PCM_MULAW_AT_ENCODER 0
+#define CONFIG_LIBAOM_AV1_ENCODER 0
+#define CONFIG_LIBCODEC2_ENCODER 0
+#define CONFIG_LIBFDK_AAC_ENCODER 0
+#define CONFIG_LIBGSM_ENCODER 0
+#define CONFIG_LIBGSM_MS_ENCODER 0
+#define CONFIG_LIBILBC_ENCODER 0
+#define CONFIG_LIBMP3LAME_ENCODER 0
+#define CONFIG_LIBOPENCORE_AMRNB_ENCODER 0
+#define CONFIG_LIBOPENJPEG_ENCODER 0
+#define CONFIG_LIBOPUS_ENCODER 0
+#define CONFIG_LIBRAV1E_ENCODER 0
+#define CONFIG_LIBSHINE_ENCODER 0
+#define CONFIG_LIBSPEEX_ENCODER 0
+#define CONFIG_LIBSVTAV1_ENCODER 0
+#define CONFIG_LIBTHEORA_ENCODER 0
+#define CONFIG_LIBTWOLAME_ENCODER 0
+#define CONFIG_LIBVO_AMRWBENC_ENCODER 0
+#define CONFIG_LIBVORBIS_ENCODER 0
+#define CONFIG_LIBVPX_VP8_ENCODER 0
+#define CONFIG_LIBVPX_VP9_ENCODER 0
+#define CONFIG_LIBWAVPACK_ENCODER 0
+#define CONFIG_LIBWEBP_ANIM_ENCODER 0
+#define CONFIG_LIBWEBP_ENCODER 0
+#define CONFIG_LIBX262_ENCODER 0
+#define CONFIG_LIBX264_ENCODER 0
+#define CONFIG_LIBX264RGB_ENCODER 0
+#define CONFIG_LIBX265_ENCODER 0
+#define CONFIG_LIBXAVS_ENCODER 0
+#define CONFIG_LIBXAVS2_ENCODER 0
+#define CONFIG_LIBXVID_ENCODER 0
+#define CONFIG_AAC_MF_ENCODER 0
+#define CONFIG_AC3_MF_ENCODER 0
+#define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_LIBOPENH264_ENCODER 0
+#define CONFIG_H264_AMF_ENCODER 0
+#define CONFIG_H264_MF_ENCODER 0
+#define CONFIG_H264_NVENC_ENCODER 0
+#define CONFIG_H264_OMX_ENCODER 0
+#define CONFIG_H264_QSV_ENCODER 0
+#define CONFIG_H264_V4L2M2M_ENCODER 0
+#define CONFIG_H264_VAAPI_ENCODER 0
+#define CONFIG_H264_VIDEOTOOLBOX_ENCODER 0
+#define CONFIG_NVENC_ENCODER 0
+#define CONFIG_NVENC_H264_ENCODER 0
+#define CONFIG_NVENC_HEVC_ENCODER 0
+#define CONFIG_HEVC_AMF_ENCODER 0
+#define CONFIG_HEVC_MF_ENCODER 0
+#define CONFIG_HEVC_NVENC_ENCODER 0
+#define CONFIG_HEVC_QSV_ENCODER 0
+#define CONFIG_HEVC_V4L2M2M_ENCODER 0
+#define CONFIG_HEVC_VAAPI_ENCODER 0
+#define CONFIG_HEVC_VIDEOTOOLBOX_ENCODER 0
+#define CONFIG_LIBKVAZAAR_ENCODER 0
+#define CONFIG_MJPEG_QSV_ENCODER 0
+#define CONFIG_MJPEG_VAAPI_ENCODER 0
+#define CONFIG_MP3_MF_ENCODER 0
+#define CONFIG_MPEG2_QSV_ENCODER 0
+#define CONFIG_MPEG2_VAAPI_ENCODER 0
+#define CONFIG_MPEG4_OMX_ENCODER 0
+#define CONFIG_MPEG4_V4L2M2M_ENCODER 0
+#define CONFIG_VP8_V4L2M2M_ENCODER 0
+#define CONFIG_VP8_VAAPI_ENCODER 0
+#define CONFIG_VP9_VAAPI_ENCODER 0
+#define CONFIG_VP9_QSV_ENCODER 0
+#define CONFIG_H263_VAAPI_HWACCEL 0
+#define CONFIG_H263_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_H264_D3D11VA_HWACCEL 0
+#define CONFIG_H264_D3D11VA2_HWACCEL 0
+#define CONFIG_H264_DXVA2_HWACCEL 0
+#define CONFIG_H264_NVDEC_HWACCEL 0
+#define CONFIG_H264_VAAPI_HWACCEL 0
+#define CONFIG_H264_VDPAU_HWACCEL 0
+#define CONFIG_H264_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_HEVC_D3D11VA_HWACCEL 0
+#define CONFIG_HEVC_D3D11VA2_HWACCEL 0
+#define CONFIG_HEVC_DXVA2_HWACCEL 0
+#define CONFIG_HEVC_NVDEC_HWACCEL 0
+#define CONFIG_HEVC_VAAPI_HWACCEL 0
+#define CONFIG_HEVC_VDPAU_HWACCEL 0
+#define CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_MJPEG_NVDEC_HWACCEL 0
+#define CONFIG_MJPEG_VAAPI_HWACCEL 0
+#define CONFIG_MPEG1_NVDEC_HWACCEL 0
+#define CONFIG_MPEG1_VDPAU_HWACCEL 0
+#define CONFIG_MPEG1_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_MPEG1_XVMC_HWACCEL 0
+#define CONFIG_MPEG2_D3D11VA_HWACCEL 0
+#define CONFIG_MPEG2_D3D11VA2_HWACCEL 0
+#define CONFIG_MPEG2_NVDEC_HWACCEL 0
+#define CONFIG_MPEG2_DXVA2_HWACCEL 0
+#define CONFIG_MPEG2_VAAPI_HWACCEL 0
+#define CONFIG_MPEG2_VDPAU_HWACCEL 0
+#define CONFIG_MPEG2_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_MPEG2_XVMC_HWACCEL 0
+#define CONFIG_MPEG4_NVDEC_HWACCEL 0
+#define CONFIG_MPEG4_VAAPI_HWACCEL 0
+#define CONFIG_MPEG4_VDPAU_HWACCEL 0
+#define CONFIG_MPEG4_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_VC1_D3D11VA_HWACCEL 0
+#define CONFIG_VC1_D3D11VA2_HWACCEL 0
+#define CONFIG_VC1_DXVA2_HWACCEL 0
+#define CONFIG_VC1_NVDEC_HWACCEL 0
+#define CONFIG_VC1_VAAPI_HWACCEL 0
+#define CONFIG_VC1_VDPAU_HWACCEL 0
+#define CONFIG_VP8_NVDEC_HWACCEL 0
+#define CONFIG_VP8_VAAPI_HWACCEL 0
+#define CONFIG_VP9_D3D11VA_HWACCEL 0
+#define CONFIG_VP9_D3D11VA2_HWACCEL 0
+#define CONFIG_VP9_DXVA2_HWACCEL 0
+#define CONFIG_VP9_NVDEC_HWACCEL 0
+#define CONFIG_VP9_VAAPI_HWACCEL 0
+#define CONFIG_VP9_VDPAU_HWACCEL 0
+#define CONFIG_WMV3_D3D11VA_HWACCEL 0
+#define CONFIG_WMV3_D3D11VA2_HWACCEL 0
+#define CONFIG_WMV3_DXVA2_HWACCEL 0
+#define CONFIG_WMV3_NVDEC_HWACCEL 0
+#define CONFIG_WMV3_VAAPI_HWACCEL 0
+#define CONFIG_WMV3_VDPAU_HWACCEL 0
+#define CONFIG_AAC_PARSER 0
+#define CONFIG_AAC_LATM_PARSER 0
+#define CONFIG_AC3_PARSER 0
+#define CONFIG_ADX_PARSER 0
+#define CONFIG_AV1_PARSER 0
+#define CONFIG_AVS2_PARSER 0
+#define CONFIG_BMP_PARSER 0
+#define CONFIG_CAVSVIDEO_PARSER 0
+#define CONFIG_COOK_PARSER 0
+#define CONFIG_DCA_PARSER 0
+#define CONFIG_DIRAC_PARSER 0
+#define CONFIG_DNXHD_PARSER 0
+#define CONFIG_DPX_PARSER 0
+#define CONFIG_DVAUDIO_PARSER 0
+#define CONFIG_DVBSUB_PARSER 0
+#define CONFIG_DVDSUB_PARSER 0
+#define CONFIG_DVD_NAV_PARSER 0
+#define CONFIG_FLAC_PARSER 1
+#define CONFIG_G723_1_PARSER 0
+#define CONFIG_G729_PARSER 0
+#define CONFIG_GIF_PARSER 0
+#define CONFIG_GSM_PARSER 0
+#define CONFIG_H261_PARSER 0
+#define CONFIG_H263_PARSER 0
+#define CONFIG_H264_PARSER 0
+#define CONFIG_HEVC_PARSER 0
+#define CONFIG_JPEG2000_PARSER 0
+#define CONFIG_MJPEG_PARSER 0
+#define CONFIG_MLP_PARSER 0
+#define CONFIG_MPEG4VIDEO_PARSER 0
+#define CONFIG_MPEGAUDIO_PARSER 1
+#define CONFIG_MPEGVIDEO_PARSER 0
+#define CONFIG_OPUS_PARSER 1
+#define CONFIG_PNG_PARSER 0
+#define CONFIG_PNM_PARSER 0
+#define CONFIG_RV30_PARSER 0
+#define CONFIG_RV40_PARSER 0
+#define CONFIG_SBC_PARSER 0
+#define CONFIG_SIPR_PARSER 0
+#define CONFIG_TAK_PARSER 0
+#define CONFIG_VC1_PARSER 0
+#define CONFIG_VORBIS_PARSER 1
+#define CONFIG_VP3_PARSER 1
+#define CONFIG_VP8_PARSER 1
+#define CONFIG_VP9_PARSER 1
+#define CONFIG_WEBP_PARSER 0
+#define CONFIG_XMA_PARSER 0
+#define CONFIG_ALSA_INDEV 0
+#define CONFIG_ANDROID_CAMERA_INDEV 0
+#define CONFIG_AVFOUNDATION_INDEV 0
+#define CONFIG_BKTR_INDEV 0
+#define CONFIG_DECKLINK_INDEV 0
+#define CONFIG_DSHOW_INDEV 0
+#define CONFIG_FBDEV_INDEV 0
+#define CONFIG_GDIGRAB_INDEV 0
+#define CONFIG_IEC61883_INDEV 0
+#define CONFIG_JACK_INDEV 0
+#define CONFIG_KMSGRAB_INDEV 0
+#define CONFIG_LAVFI_INDEV 0
+#define CONFIG_OPENAL_INDEV 0
+#define CONFIG_OSS_INDEV 0
+#define CONFIG_PULSE_INDEV 0
+#define CONFIG_SNDIO_INDEV 0
+#define CONFIG_V4L2_INDEV 0
+#define CONFIG_VFWCAP_INDEV 0
+#define CONFIG_XCBGRAB_INDEV 0
+#define CONFIG_LIBCDIO_INDEV 0
+#define CONFIG_LIBDC1394_INDEV 0
+#define CONFIG_ALSA_OUTDEV 0
+#define CONFIG_AUDIOTOOLBOX_OUTDEV 0
+#define CONFIG_CACA_OUTDEV 0
+#define CONFIG_DECKLINK_OUTDEV 0
+#define CONFIG_FBDEV_OUTDEV 0
+#define CONFIG_OPENGL_OUTDEV 0
+#define CONFIG_OSS_OUTDEV 0
+#define CONFIG_PULSE_OUTDEV 0
+#define CONFIG_SDL2_OUTDEV 0
+#define CONFIG_SNDIO_OUTDEV 0
+#define CONFIG_V4L2_OUTDEV 0
+#define CONFIG_XV_OUTDEV 0
+#define CONFIG_ABENCH_FILTER 0
+#define CONFIG_ACOMPRESSOR_FILTER 0
+#define CONFIG_ACONTRAST_FILTER 0
+#define CONFIG_ACOPY_FILTER 0
+#define CONFIG_ACUE_FILTER 0
+#define CONFIG_ACROSSFADE_FILTER 0
+#define CONFIG_ACROSSOVER_FILTER 0
+#define CONFIG_ACRUSHER_FILTER 0
+#define CONFIG_ADECLICK_FILTER 0
+#define CONFIG_ADECLIP_FILTER 0
+#define CONFIG_ADELAY_FILTER 0
+#define CONFIG_ADERIVATIVE_FILTER 0
+#define CONFIG_AECHO_FILTER 0
+#define CONFIG_AEMPHASIS_FILTER 0
+#define CONFIG_AEVAL_FILTER 0
+#define CONFIG_AFADE_FILTER 0
+#define CONFIG_AFFTDN_FILTER 0
+#define CONFIG_AFFTFILT_FILTER 0
+#define CONFIG_AFIR_FILTER 0
+#define CONFIG_AFORMAT_FILTER 0
+#define CONFIG_AGATE_FILTER 0
+#define CONFIG_AIIR_FILTER 0
+#define CONFIG_AINTEGRAL_FILTER 0
+#define CONFIG_AINTERLEAVE_FILTER 0
+#define CONFIG_ALIMITER_FILTER 0
+#define CONFIG_ALLPASS_FILTER 0
+#define CONFIG_ALOOP_FILTER 0
+#define CONFIG_AMERGE_FILTER 0
+#define CONFIG_AMETADATA_FILTER 0
+#define CONFIG_AMIX_FILTER 0
+#define CONFIG_AMULTIPLY_FILTER 0
+#define CONFIG_ANEQUALIZER_FILTER 0
+#define CONFIG_ANLMDN_FILTER 0
+#define CONFIG_ANLMS_FILTER 0
+#define CONFIG_ANULL_FILTER 0
+#define CONFIG_APAD_FILTER 0
+#define CONFIG_APERMS_FILTER 0
+#define CONFIG_APHASER_FILTER 0
+#define CONFIG_APULSATOR_FILTER 0
+#define CONFIG_AREALTIME_FILTER 0
+#define CONFIG_ARESAMPLE_FILTER 0
+#define CONFIG_AREVERSE_FILTER 0
+#define CONFIG_ARNNDN_FILTER 0
+#define CONFIG_ASELECT_FILTER 0
+#define CONFIG_ASENDCMD_FILTER 0
+#define CONFIG_ASETNSAMPLES_FILTER 0
+#define CONFIG_ASETPTS_FILTER 0
+#define CONFIG_ASETRATE_FILTER 0
+#define CONFIG_ASETTB_FILTER 0
+#define CONFIG_ASHOWINFO_FILTER 0
+#define CONFIG_ASIDEDATA_FILTER 0
+#define CONFIG_ASOFTCLIP_FILTER 0
+#define CONFIG_ASPLIT_FILTER 0
+#define CONFIG_ASR_FILTER 0
+#define CONFIG_ASTATS_FILTER 0
+#define CONFIG_ASTREAMSELECT_FILTER 0
+#define CONFIG_ASUBBOOST_FILTER 0
+#define CONFIG_ATEMPO_FILTER 0
+#define CONFIG_ATRIM_FILTER 0
+#define CONFIG_AXCORRELATE_FILTER 0
+#define CONFIG_AZMQ_FILTER 0
+#define CONFIG_BANDPASS_FILTER 0
+#define CONFIG_BANDREJECT_FILTER 0
+#define CONFIG_BASS_FILTER 0
+#define CONFIG_BIQUAD_FILTER 0
+#define CONFIG_BS2B_FILTER 0
+#define CONFIG_CHROMABER_VULKAN_FILTER 0
+#define CONFIG_CHANNELMAP_FILTER 0
+#define CONFIG_CHANNELSPLIT_FILTER 0
+#define CONFIG_CHORUS_FILTER 0
+#define CONFIG_COMPAND_FILTER 0
+#define CONFIG_COMPENSATIONDELAY_FILTER 0
+#define CONFIG_CROSSFEED_FILTER 0
+#define CONFIG_CRYSTALIZER_FILTER 0
+#define CONFIG_DCSHIFT_FILTER 0
+#define CONFIG_DEESSER_FILTER 0
+#define CONFIG_DRMETER_FILTER 0
+#define CONFIG_DYNAUDNORM_FILTER 0
+#define CONFIG_EARWAX_FILTER 0
+#define CONFIG_EBUR128_FILTER 0
+#define CONFIG_EQUALIZER_FILTER 0
+#define CONFIG_EXTRASTEREO_FILTER 0
+#define CONFIG_FIREQUALIZER_FILTER 0
+#define CONFIG_FLANGER_FILTER 0
+#define CONFIG_HAAS_FILTER 0
+#define CONFIG_HDCD_FILTER 0
+#define CONFIG_HEADPHONE_FILTER 0
+#define CONFIG_HIGHPASS_FILTER 0
+#define CONFIG_HIGHSHELF_FILTER 0
+#define CONFIG_JOIN_FILTER 0
+#define CONFIG_LADSPA_FILTER 0
+#define CONFIG_LOUDNORM_FILTER 0
+#define CONFIG_LOWPASS_FILTER 0
+#define CONFIG_LOWSHELF_FILTER 0
+#define CONFIG_LV2_FILTER 0
+#define CONFIG_MCOMPAND_FILTER 0
+#define CONFIG_PAN_FILTER 0
+#define CONFIG_REPLAYGAIN_FILTER 0
+#define CONFIG_RESAMPLE_FILTER 0
+#define CONFIG_RUBBERBAND_FILTER 0
+#define CONFIG_SIDECHAINCOMPRESS_FILTER 0
+#define CONFIG_SIDECHAINGATE_FILTER 0
+#define CONFIG_SILENCEDETECT_FILTER 0
+#define CONFIG_SILENCEREMOVE_FILTER 0
+#define CONFIG_SOFALIZER_FILTER 0
+#define CONFIG_STEREOTOOLS_FILTER 0
+#define CONFIG_STEREOWIDEN_FILTER 0
+#define CONFIG_SUPEREQUALIZER_FILTER 0
+#define CONFIG_SURROUND_FILTER 0
+#define CONFIG_TREBLE_FILTER 0
+#define CONFIG_TREMOLO_FILTER 0
+#define CONFIG_VIBRATO_FILTER 0
+#define CONFIG_VOLUME_FILTER 0
+#define CONFIG_VOLUMEDETECT_FILTER 0
+#define CONFIG_AEVALSRC_FILTER 0
+#define CONFIG_AFIRSRC_FILTER 0
+#define CONFIG_ANOISESRC_FILTER 0
+#define CONFIG_ANULLSRC_FILTER 0
+#define CONFIG_FLITE_FILTER 0
+#define CONFIG_HILBERT_FILTER 0
+#define CONFIG_SINC_FILTER 0
+#define CONFIG_SINE_FILTER 0
+#define CONFIG_ANULLSINK_FILTER 0
+#define CONFIG_ADDROI_FILTER 0
+#define CONFIG_ALPHAEXTRACT_FILTER 0
+#define CONFIG_ALPHAMERGE_FILTER 0
+#define CONFIG_AMPLIFY_FILTER 0
+#define CONFIG_ASS_FILTER 0
+#define CONFIG_ATADENOISE_FILTER 0
+#define CONFIG_AVGBLUR_FILTER 0
+#define CONFIG_AVGBLUR_OPENCL_FILTER 0
+#define CONFIG_AVGBLUR_VULKAN_FILTER 0
+#define CONFIG_BBOX_FILTER 0
+#define CONFIG_BENCH_FILTER 0
+#define CONFIG_BILATERAL_FILTER 0
+#define CONFIG_BITPLANENOISE_FILTER 0
+#define CONFIG_BLACKDETECT_FILTER 0
+#define CONFIG_BLACKFRAME_FILTER 0
+#define CONFIG_BLEND_FILTER 0
+#define CONFIG_BM3D_FILTER 0
+#define CONFIG_BOXBLUR_FILTER 0
+#define CONFIG_BOXBLUR_OPENCL_FILTER 0
+#define CONFIG_BWDIF_FILTER 0
+#define CONFIG_CAS_FILTER 0
+#define CONFIG_CHROMAHOLD_FILTER 0
+#define CONFIG_CHROMAKEY_FILTER 0
+#define CONFIG_CHROMANR_FILTER 0
+#define CONFIG_CHROMASHIFT_FILTER 0
+#define CONFIG_CIESCOPE_FILTER 0
+#define CONFIG_CODECVIEW_FILTER 0
+#define CONFIG_COLORBALANCE_FILTER 0
+#define CONFIG_COLORCHANNELMIXER_FILTER 0
+#define CONFIG_COLORKEY_FILTER 0
+#define CONFIG_COLORKEY_OPENCL_FILTER 0
+#define CONFIG_COLORHOLD_FILTER 0
+#define CONFIG_COLORLEVELS_FILTER 0
+#define CONFIG_COLORMATRIX_FILTER 0
+#define CONFIG_COLORSPACE_FILTER 0
+#define CONFIG_CONVOLUTION_FILTER 0
+#define CONFIG_CONVOLUTION_OPENCL_FILTER 0
+#define CONFIG_CONVOLVE_FILTER 0
+#define CONFIG_COPY_FILTER 0
+#define CONFIG_COREIMAGE_FILTER 0
+#define CONFIG_COVER_RECT_FILTER 0
+#define CONFIG_CROP_FILTER 0
+#define CONFIG_CROPDETECT_FILTER 0
+#define CONFIG_CUE_FILTER 0
+#define CONFIG_CURVES_FILTER 0
+#define CONFIG_DATASCOPE_FILTER 0
+#define CONFIG_DBLUR_FILTER 0
+#define CONFIG_DCTDNOIZ_FILTER 0
+#define CONFIG_DEBAND_FILTER 0
+#define CONFIG_DEBLOCK_FILTER 0
+#define CONFIG_DECIMATE_FILTER 0
+#define CONFIG_DECONVOLVE_FILTER 0
+#define CONFIG_DEDOT_FILTER 0
+#define CONFIG_DEFLATE_FILTER 0
+#define CONFIG_DEFLICKER_FILTER 0
+#define CONFIG_DEINTERLACE_QSV_FILTER 0
+#define CONFIG_DEINTERLACE_VAAPI_FILTER 0
+#define CONFIG_DEJUDDER_FILTER 0
+#define CONFIG_DELOGO_FILTER 0
+#define CONFIG_DENOISE_VAAPI_FILTER 0
+#define CONFIG_DERAIN_FILTER 0
+#define CONFIG_DESHAKE_FILTER 0
+#define CONFIG_DESHAKE_OPENCL_FILTER 0
+#define CONFIG_DESPILL_FILTER 0
+#define CONFIG_DETELECINE_FILTER 0
+#define CONFIG_DILATION_FILTER 0
+#define CONFIG_DILATION_OPENCL_FILTER 0
+#define CONFIG_DISPLACE_FILTER 0
+#define CONFIG_DNN_PROCESSING_FILTER 0
+#define CONFIG_DOUBLEWEAVE_FILTER 0
+#define CONFIG_DRAWBOX_FILTER 0
+#define CONFIG_DRAWGRAPH_FILTER 0
+#define CONFIG_DRAWGRID_FILTER 0
+#define CONFIG_DRAWTEXT_FILTER 0
+#define CONFIG_EDGEDETECT_FILTER 0
+#define CONFIG_ELBG_FILTER 0
+#define CONFIG_ENTROPY_FILTER 0
+#define CONFIG_EQ_FILTER 0
+#define CONFIG_EROSION_FILTER 0
+#define CONFIG_EROSION_OPENCL_FILTER 0
+#define CONFIG_EXTRACTPLANES_FILTER 0
+#define CONFIG_FADE_FILTER 0
+#define CONFIG_FFTDNOIZ_FILTER 0
+#define CONFIG_FFTFILT_FILTER 0
+#define CONFIG_FIELD_FILTER 0
+#define CONFIG_FIELDHINT_FILTER 0
+#define CONFIG_FIELDMATCH_FILTER 0
+#define CONFIG_FIELDORDER_FILTER 0
+#define CONFIG_FILLBORDERS_FILTER 0
+#define CONFIG_FIND_RECT_FILTER 0
+#define CONFIG_FLOODFILL_FILTER 0
+#define CONFIG_FORMAT_FILTER 0
+#define CONFIG_FPS_FILTER 0
+#define CONFIG_FRAMEPACK_FILTER 0
+#define CONFIG_FRAMERATE_FILTER 0
+#define CONFIG_FRAMESTEP_FILTER 0
+#define CONFIG_FREEZEDETECT_FILTER 0
+#define CONFIG_FREEZEFRAMES_FILTER 0
+#define CONFIG_FREI0R_FILTER 0
+#define CONFIG_FSPP_FILTER 0
+#define CONFIG_GBLUR_FILTER 0
+#define CONFIG_GEQ_FILTER 0
+#define CONFIG_GRADFUN_FILTER 0
+#define CONFIG_GRAPHMONITOR_FILTER 0
+#define CONFIG_GREYEDGE_FILTER 0
+#define CONFIG_HALDCLUT_FILTER 0
+#define CONFIG_HFLIP_FILTER 0
+#define CONFIG_HISTEQ_FILTER 0
+#define CONFIG_HISTOGRAM_FILTER 0
+#define CONFIG_HQDN3D_FILTER 0
+#define CONFIG_HQX_FILTER 0
+#define CONFIG_HSTACK_FILTER 0
+#define CONFIG_HUE_FILTER 0
+#define CONFIG_HWDOWNLOAD_FILTER 0
+#define CONFIG_HWMAP_FILTER 0
+#define CONFIG_HWUPLOAD_FILTER 0
+#define CONFIG_HWUPLOAD_CUDA_FILTER 0
+#define CONFIG_HYSTERESIS_FILTER 0
+#define CONFIG_IDET_FILTER 0
+#define CONFIG_IL_FILTER 0
+#define CONFIG_INFLATE_FILTER 0
+#define CONFIG_INTERLACE_FILTER 0
+#define CONFIG_INTERLEAVE_FILTER 0
+#define CONFIG_KERNDEINT_FILTER 0
+#define CONFIG_LAGFUN_FILTER 0
+#define CONFIG_LENSCORRECTION_FILTER 0
+#define CONFIG_LENSFUN_FILTER 0
+#define CONFIG_LIBVMAF_FILTER 0
+#define CONFIG_LIMITER_FILTER 0
+#define CONFIG_LOOP_FILTER 0
+#define CONFIG_LUMAKEY_FILTER 0
+#define CONFIG_LUT_FILTER 0
+#define CONFIG_LUT1D_FILTER 0
+#define CONFIG_LUT2_FILTER 0
+#define CONFIG_LUT3D_FILTER 0
+#define CONFIG_LUTRGB_FILTER 0
+#define CONFIG_LUTYUV_FILTER 0
+#define CONFIG_MASKEDCLAMP_FILTER 0
+#define CONFIG_MASKEDMAX_FILTER 0
+#define CONFIG_MASKEDMERGE_FILTER 0
+#define CONFIG_MASKEDMIN_FILTER 0
+#define CONFIG_MASKEDTHRESHOLD_FILTER 0
+#define CONFIG_MASKFUN_FILTER 0
+#define CONFIG_MCDEINT_FILTER 0
+#define CONFIG_MEDIAN_FILTER 0
+#define CONFIG_MERGEPLANES_FILTER 0
+#define CONFIG_MESTIMATE_FILTER 0
+#define CONFIG_METADATA_FILTER 0
+#define CONFIG_MIDEQUALIZER_FILTER 0
+#define CONFIG_MINTERPOLATE_FILTER 0
+#define CONFIG_MIX_FILTER 0
+#define CONFIG_MPDECIMATE_FILTER 0
+#define CONFIG_NEGATE_FILTER 0
+#define CONFIG_NLMEANS_FILTER 0
+#define CONFIG_NLMEANS_OPENCL_FILTER 0
+#define CONFIG_NNEDI_FILTER 0
+#define CONFIG_NOFORMAT_FILTER 0
+#define CONFIG_NOISE_FILTER 0
+#define CONFIG_NORMALIZE_FILTER 0
+#define CONFIG_NULL_FILTER 0
+#define CONFIG_OCR_FILTER 0
+#define CONFIG_OCV_FILTER 0
+#define CONFIG_OSCILLOSCOPE_FILTER 0
+#define CONFIG_OVERLAY_FILTER 0
+#define CONFIG_OVERLAY_OPENCL_FILTER 0
+#define CONFIG_OVERLAY_QSV_FILTER 0
+#define CONFIG_OVERLAY_VULKAN_FILTER 0
+#define CONFIG_OVERLAY_CUDA_FILTER 0
+#define CONFIG_OWDENOISE_FILTER 0
+#define CONFIG_PAD_FILTER 0
+#define CONFIG_PAD_OPENCL_FILTER 0
+#define CONFIG_PALETTEGEN_FILTER 0
+#define CONFIG_PALETTEUSE_FILTER 0
+#define CONFIG_PERMS_FILTER 0
+#define CONFIG_PERSPECTIVE_FILTER 0
+#define CONFIG_PHASE_FILTER 0
+#define CONFIG_PHOTOSENSITIVITY_FILTER 0
+#define CONFIG_PIXDESCTEST_FILTER 0
+#define CONFIG_PIXSCOPE_FILTER 0
+#define CONFIG_PP_FILTER 0
+#define CONFIG_PP7_FILTER 0
+#define CONFIG_PREMULTIPLY_FILTER 0
+#define CONFIG_PREWITT_FILTER 0
+#define CONFIG_PREWITT_OPENCL_FILTER 0
+#define CONFIG_PROCAMP_VAAPI_FILTER 0
+#define CONFIG_PROGRAM_OPENCL_FILTER 0
+#define CONFIG_PSEUDOCOLOR_FILTER 0
+#define CONFIG_PSNR_FILTER 0
+#define CONFIG_PULLUP_FILTER 0
+#define CONFIG_QP_FILTER 0
+#define CONFIG_RANDOM_FILTER 0
+#define CONFIG_READEIA608_FILTER 0
+#define CONFIG_READVITC_FILTER 0
+#define CONFIG_REALTIME_FILTER 0
+#define CONFIG_REMAP_FILTER 0
+#define CONFIG_REMOVEGRAIN_FILTER 0
+#define CONFIG_REMOVELOGO_FILTER 0
+#define CONFIG_REPEATFIELDS_FILTER 0
+#define CONFIG_REVERSE_FILTER 0
+#define CONFIG_RGBASHIFT_FILTER 0
+#define CONFIG_ROBERTS_FILTER 0
+#define CONFIG_ROBERTS_OPENCL_FILTER 0
+#define CONFIG_ROTATE_FILTER 0
+#define CONFIG_SAB_FILTER 0
+#define CONFIG_SCALE_FILTER 0
+#define CONFIG_SCALE_CUDA_FILTER 0
+#define CONFIG_SCALE_NPP_FILTER 0
+#define CONFIG_SCALE_QSV_FILTER 0
+#define CONFIG_SCALE_VAAPI_FILTER 0
+#define CONFIG_SCALE_VULKAN_FILTER 0
+#define CONFIG_SCALE2REF_FILTER 0
+#define CONFIG_SCDET_FILTER 0
+#define CONFIG_SCROLL_FILTER 0
+#define CONFIG_SELECT_FILTER 0
+#define CONFIG_SELECTIVECOLOR_FILTER 0
+#define CONFIG_SENDCMD_FILTER 0
+#define CONFIG_SEPARATEFIELDS_FILTER 0
+#define CONFIG_SETDAR_FILTER 0
+#define CONFIG_SETFIELD_FILTER 0
+#define CONFIG_SETPARAMS_FILTER 0
+#define CONFIG_SETPTS_FILTER 0
+#define CONFIG_SETRANGE_FILTER 0
+#define CONFIG_SETSAR_FILTER 0
+#define CONFIG_SETTB_FILTER 0
+#define CONFIG_SHARPNESS_VAAPI_FILTER 0
+#define CONFIG_SHOWINFO_FILTER 0
+#define CONFIG_SHOWPALETTE_FILTER 0
+#define CONFIG_SHUFFLEFRAMES_FILTER 0
+#define CONFIG_SHUFFLEPLANES_FILTER 0
+#define CONFIG_SIDEDATA_FILTER 0
+#define CONFIG_SIGNALSTATS_FILTER 0
+#define CONFIG_SIGNATURE_FILTER 0
+#define CONFIG_SMARTBLUR_FILTER 0
+#define CONFIG_SOBEL_FILTER 0
+#define CONFIG_SOBEL_OPENCL_FILTER 0
+#define CONFIG_SPLIT_FILTER 0
+#define CONFIG_SPP_FILTER 0
+#define CONFIG_SR_FILTER 0
+#define CONFIG_SSIM_FILTER 0
+#define CONFIG_STEREO3D_FILTER 0
+#define CONFIG_STREAMSELECT_FILTER 0
+#define CONFIG_SUBTITLES_FILTER 0
+#define CONFIG_SUPER2XSAI_FILTER 0
+#define CONFIG_SWAPRECT_FILTER 0
+#define CONFIG_SWAPUV_FILTER 0
+#define CONFIG_TBLEND_FILTER 0
+#define CONFIG_TELECINE_FILTER 0
+#define CONFIG_THISTOGRAM_FILTER 0
+#define CONFIG_THRESHOLD_FILTER 0
+#define CONFIG_THUMBNAIL_FILTER 0
+#define CONFIG_THUMBNAIL_CUDA_FILTER 0
+#define CONFIG_TILE_FILTER 0
+#define CONFIG_TINTERLACE_FILTER 0
+#define CONFIG_TLUT2_FILTER 0
+#define CONFIG_TMEDIAN_FILTER 0
+#define CONFIG_TMIX_FILTER 0
+#define CONFIG_TONEMAP_FILTER 0
+#define CONFIG_TONEMAP_OPENCL_FILTER 0
+#define CONFIG_TONEMAP_VAAPI_FILTER 0
+#define CONFIG_TPAD_FILTER 0
+#define CONFIG_TRANSPOSE_FILTER 0
+#define CONFIG_TRANSPOSE_NPP_FILTER 0
+#define CONFIG_TRANSPOSE_OPENCL_FILTER 0
+#define CONFIG_TRANSPOSE_VAAPI_FILTER 0
+#define CONFIG_TRIM_FILTER 0
+#define CONFIG_UNPREMULTIPLY_FILTER 0
+#define CONFIG_UNSHARP_FILTER 0
+#define CONFIG_UNSHARP_OPENCL_FILTER 0
+#define CONFIG_UNTILE_FILTER 0
+#define CONFIG_USPP_FILTER 0
+#define CONFIG_V360_FILTER 0
+#define CONFIG_VAGUEDENOISER_FILTER 0
+#define CONFIG_VECTORSCOPE_FILTER 0
+#define CONFIG_VFLIP_FILTER 0
+#define CONFIG_VFRDET_FILTER 0
+#define CONFIG_VIBRANCE_FILTER 0
+#define CONFIG_VIDSTABDETECT_FILTER 0
+#define CONFIG_VIDSTABTRANSFORM_FILTER 0
+#define CONFIG_VIGNETTE_FILTER 0
+#define CONFIG_VMAFMOTION_FILTER 0
+#define CONFIG_VPP_QSV_FILTER 0
+#define CONFIG_VSTACK_FILTER 0
+#define CONFIG_W3FDIF_FILTER 0
+#define CONFIG_WAVEFORM_FILTER 0
+#define CONFIG_WEAVE_FILTER 0
+#define CONFIG_XBR_FILTER 0
+#define CONFIG_XFADE_FILTER 0
+#define CONFIG_XFADE_OPENCL_FILTER 0
+#define CONFIG_XMEDIAN_FILTER 0
+#define CONFIG_XSTACK_FILTER 0
+#define CONFIG_YADIF_FILTER 0
+#define CONFIG_YADIF_CUDA_FILTER 0
+#define CONFIG_YAEPBLUR_FILTER 0
+#define CONFIG_ZMQ_FILTER 0
+#define CONFIG_ZOOMPAN_FILTER 0
+#define CONFIG_ZSCALE_FILTER 0
+#define CONFIG_ALLRGB_FILTER 0
+#define CONFIG_ALLYUV_FILTER 0
+#define CONFIG_CELLAUTO_FILTER 0
+#define CONFIG_COLOR_FILTER 0
+#define CONFIG_COREIMAGESRC_FILTER 0
+#define CONFIG_FREI0R_SRC_FILTER 0
+#define CONFIG_GRADIENTS_FILTER 0
+#define CONFIG_HALDCLUTSRC_FILTER 0
+#define CONFIG_LIFE_FILTER 0
+#define CONFIG_MANDELBROT_FILTER 0
+#define CONFIG_MPTESTSRC_FILTER 0
+#define CONFIG_NULLSRC_FILTER 0
+#define CONFIG_OPENCLSRC_FILTER 0
+#define CONFIG_PAL75BARS_FILTER 0
+#define CONFIG_PAL100BARS_FILTER 0
+#define CONFIG_RGBTESTSRC_FILTER 0
+#define CONFIG_SIERPINSKI_FILTER 0
+#define CONFIG_SMPTEBARS_FILTER 0
+#define CONFIG_SMPTEHDBARS_FILTER 0
+#define CONFIG_TESTSRC_FILTER 0
+#define CONFIG_TESTSRC2_FILTER 0
+#define CONFIG_YUVTESTSRC_FILTER 0
+#define CONFIG_NULLSINK_FILTER 0
+#define CONFIG_ABITSCOPE_FILTER 0
+#define CONFIG_ADRAWGRAPH_FILTER 0
+#define CONFIG_AGRAPHMONITOR_FILTER 0
+#define CONFIG_AHISTOGRAM_FILTER 0
+#define CONFIG_APHASEMETER_FILTER 0
+#define CONFIG_AVECTORSCOPE_FILTER 0
+#define CONFIG_CONCAT_FILTER 0
+#define CONFIG_SHOWCQT_FILTER 0
+#define CONFIG_SHOWFREQS_FILTER 0
+#define CONFIG_SHOWSPATIAL_FILTER 0
+#define CONFIG_SHOWSPECTRUM_FILTER 0
+#define CONFIG_SHOWSPECTRUMPIC_FILTER 0
+#define CONFIG_SHOWVOLUME_FILTER 0
+#define CONFIG_SHOWWAVES_FILTER 0
+#define CONFIG_SHOWWAVESPIC_FILTER 0
+#define CONFIG_SPECTRUMSYNTH_FILTER 0
+#define CONFIG_AMOVIE_FILTER 0
+#define CONFIG_MOVIE_FILTER 0
+#define CONFIG_AFIFO_FILTER 0
+#define CONFIG_FIFO_FILTER 0
+#define CONFIG_AA_DEMUXER 0
+#define CONFIG_AAC_DEMUXER 0
+#define CONFIG_AC3_DEMUXER 0
+#define CONFIG_ACM_DEMUXER 0
+#define CONFIG_ACT_DEMUXER 0
+#define CONFIG_ADF_DEMUXER 0
+#define CONFIG_ADP_DEMUXER 0
+#define CONFIG_ADS_DEMUXER 0
+#define CONFIG_ADX_DEMUXER 0
+#define CONFIG_AEA_DEMUXER 0
+#define CONFIG_AFC_DEMUXER 0
+#define CONFIG_AIFF_DEMUXER 0
+#define CONFIG_AIX_DEMUXER 0
+#define CONFIG_ALP_DEMUXER 0
+#define CONFIG_AMR_DEMUXER 0
+#define CONFIG_AMRNB_DEMUXER 0
+#define CONFIG_AMRWB_DEMUXER 0
+#define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APC_DEMUXER 0
+#define CONFIG_APE_DEMUXER 0
+#define CONFIG_APM_DEMUXER 0
+#define CONFIG_APNG_DEMUXER 0
+#define CONFIG_APTX_DEMUXER 0
+#define CONFIG_APTX_HD_DEMUXER 0
+#define CONFIG_AQTITLE_DEMUXER 0
+#define CONFIG_ARGO_ASF_DEMUXER 0
+#define CONFIG_ASF_DEMUXER 0
+#define CONFIG_ASF_O_DEMUXER 0
+#define CONFIG_ASS_DEMUXER 0
+#define CONFIG_AST_DEMUXER 0
+#define CONFIG_AU_DEMUXER 0
+#define CONFIG_AV1_DEMUXER 0
+#define CONFIG_AVI_DEMUXER 0
+#define CONFIG_AVISYNTH_DEMUXER 0
+#define CONFIG_AVR_DEMUXER 0
+#define CONFIG_AVS_DEMUXER 0
+#define CONFIG_AVS2_DEMUXER 0
+#define CONFIG_BETHSOFTVID_DEMUXER 0
+#define CONFIG_BFI_DEMUXER 0
+#define CONFIG_BINTEXT_DEMUXER 0
+#define CONFIG_BINK_DEMUXER 0
+#define CONFIG_BIT_DEMUXER 0
+#define CONFIG_BMV_DEMUXER 0
+#define CONFIG_BFSTM_DEMUXER 0
+#define CONFIG_BRSTM_DEMUXER 0
+#define CONFIG_BOA_DEMUXER 0
+#define CONFIG_C93_DEMUXER 0
+#define CONFIG_CAF_DEMUXER 0
+#define CONFIG_CAVSVIDEO_DEMUXER 0
+#define CONFIG_CDG_DEMUXER 0
+#define CONFIG_CDXL_DEMUXER 0
+#define CONFIG_CINE_DEMUXER 0
+#define CONFIG_CODEC2_DEMUXER 0
+#define CONFIG_CODEC2RAW_DEMUXER 0
+#define CONFIG_CONCAT_DEMUXER 0
+#define CONFIG_DASH_DEMUXER 0
+#define CONFIG_DATA_DEMUXER 0
+#define CONFIG_DAUD_DEMUXER 0
+#define CONFIG_DCSTR_DEMUXER 0
+#define CONFIG_DERF_DEMUXER 0
+#define CONFIG_DFA_DEMUXER 0
+#define CONFIG_DHAV_DEMUXER 0
+#define CONFIG_DIRAC_DEMUXER 0
+#define CONFIG_DNXHD_DEMUXER 0
+#define CONFIG_DSF_DEMUXER 0
+#define CONFIG_DSICIN_DEMUXER 0
+#define CONFIG_DSS_DEMUXER 0
+#define CONFIG_DTS_DEMUXER 0
+#define CONFIG_DTSHD_DEMUXER 0
+#define CONFIG_DV_DEMUXER 0
+#define CONFIG_DVBSUB_DEMUXER 0
+#define CONFIG_DVBTXT_DEMUXER 0
+#define CONFIG_DXA_DEMUXER 0
+#define CONFIG_EA_DEMUXER 0
+#define CONFIG_EA_CDATA_DEMUXER 0
+#define CONFIG_EAC3_DEMUXER 0
+#define CONFIG_EPAF_DEMUXER 0
+#define CONFIG_FFMETADATA_DEMUXER 0
+#define CONFIG_FILMSTRIP_DEMUXER 0
+#define CONFIG_FITS_DEMUXER 0
+#define CONFIG_FLAC_DEMUXER 1
+#define CONFIG_FLIC_DEMUXER 0
+#define CONFIG_FLV_DEMUXER 0
+#define CONFIG_LIVE_FLV_DEMUXER 0
+#define CONFIG_FOURXM_DEMUXER 0
+#define CONFIG_FRM_DEMUXER 0
+#define CONFIG_FSB_DEMUXER 0
+#define CONFIG_FWSE_DEMUXER 0
+#define CONFIG_G722_DEMUXER 0
+#define CONFIG_G723_1_DEMUXER 0
+#define CONFIG_G726_DEMUXER 0
+#define CONFIG_G726LE_DEMUXER 0
+#define CONFIG_G729_DEMUXER 0
+#define CONFIG_GDV_DEMUXER 0
+#define CONFIG_GENH_DEMUXER 0
+#define CONFIG_GIF_DEMUXER 0
+#define CONFIG_GSM_DEMUXER 0
+#define CONFIG_GXF_DEMUXER 0
+#define CONFIG_H261_DEMUXER 0
+#define CONFIG_H263_DEMUXER 0
+#define CONFIG_H264_DEMUXER 0
+#define CONFIG_HCA_DEMUXER 0
+#define CONFIG_HCOM_DEMUXER 0
+#define CONFIG_HEVC_DEMUXER 0
+#define CONFIG_HLS_DEMUXER 0
+#define CONFIG_HNM_DEMUXER 0
+#define CONFIG_ICO_DEMUXER 0
+#define CONFIG_IDCIN_DEMUXER 0
+#define CONFIG_IDF_DEMUXER 0
+#define CONFIG_IFF_DEMUXER 0
+#define CONFIG_IFV_DEMUXER 0
+#define CONFIG_ILBC_DEMUXER 0
+#define CONFIG_IMAGE2_DEMUXER 0
+#define CONFIG_IMAGE2PIPE_DEMUXER 0
+#define CONFIG_IMAGE2_ALIAS_PIX_DEMUXER 0
+#define CONFIG_IMAGE2_BRENDER_PIX_DEMUXER 0
+#define CONFIG_INGENIENT_DEMUXER 0
+#define CONFIG_IPMOVIE_DEMUXER 0
+#define CONFIG_IRCAM_DEMUXER 0
+#define CONFIG_ISS_DEMUXER 0
+#define CONFIG_IV8_DEMUXER 0
+#define CONFIG_IVF_DEMUXER 0
+#define CONFIG_IVR_DEMUXER 0
+#define CONFIG_JACOSUB_DEMUXER 0
+#define CONFIG_JV_DEMUXER 0
+#define CONFIG_KUX_DEMUXER 0
+#define CONFIG_KVAG_DEMUXER 0
+#define CONFIG_LMLM4_DEMUXER 0
+#define CONFIG_LOAS_DEMUXER 0
+#define CONFIG_LRC_DEMUXER 0
+#define CONFIG_LVF_DEMUXER 0
+#define CONFIG_LXF_DEMUXER 0
+#define CONFIG_M4V_DEMUXER 0
+#define CONFIG_MCC_DEMUXER 0
+#define CONFIG_MATROSKA_DEMUXER 1
+#define CONFIG_MGSTS_DEMUXER 0
+#define CONFIG_MICRODVD_DEMUXER 0
+#define CONFIG_MJPEG_DEMUXER 0
+#define CONFIG_MJPEG_2000_DEMUXER 0
+#define CONFIG_MLP_DEMUXER 0
+#define CONFIG_MLV_DEMUXER 0
+#define CONFIG_MM_DEMUXER 0
+#define CONFIG_MMF_DEMUXER 0
+#define CONFIG_MOV_DEMUXER 1
+#define CONFIG_MP3_DEMUXER 1
+#define CONFIG_MPC_DEMUXER 0
+#define CONFIG_MPC8_DEMUXER 0
+#define CONFIG_MPEGPS_DEMUXER 0
+#define CONFIG_MPEGTS_DEMUXER 0
+#define CONFIG_MPEGTSRAW_DEMUXER 0
+#define CONFIG_MPEGVIDEO_DEMUXER 0
+#define CONFIG_MPJPEG_DEMUXER 0
+#define CONFIG_MPL2_DEMUXER 0
+#define CONFIG_MPSUB_DEMUXER 0
+#define CONFIG_MSF_DEMUXER 0
+#define CONFIG_MSNWC_TCP_DEMUXER 0
+#define CONFIG_MTAF_DEMUXER 0
+#define CONFIG_MTV_DEMUXER 0
+#define CONFIG_MUSX_DEMUXER 0
+#define CONFIG_MV_DEMUXER 0
+#define CONFIG_MVI_DEMUXER 0
+#define CONFIG_MXF_DEMUXER 0
+#define CONFIG_MXG_DEMUXER 0
+#define CONFIG_NC_DEMUXER 0
+#define CONFIG_NISTSPHERE_DEMUXER 0
+#define CONFIG_NSP_DEMUXER 0
+#define CONFIG_NSV_DEMUXER 0
+#define CONFIG_NUT_DEMUXER 0
+#define CONFIG_NUV_DEMUXER 0
+#define CONFIG_OBU_DEMUXER 0
+#define CONFIG_OGG_DEMUXER 1
+#define CONFIG_OMA_DEMUXER 0
+#define CONFIG_PAF_DEMUXER 0
+#define CONFIG_PCM_ALAW_DEMUXER 0
+#define CONFIG_PCM_MULAW_DEMUXER 0
+#define CONFIG_PCM_VIDC_DEMUXER 0
+#define CONFIG_PCM_F64BE_DEMUXER 0
+#define CONFIG_PCM_F64LE_DEMUXER 0
+#define CONFIG_PCM_F32BE_DEMUXER 0
+#define CONFIG_PCM_F32LE_DEMUXER 0
+#define CONFIG_PCM_S32BE_DEMUXER 0
+#define CONFIG_PCM_S32LE_DEMUXER 0
+#define CONFIG_PCM_S24BE_DEMUXER 0
+#define CONFIG_PCM_S24LE_DEMUXER 0
+#define CONFIG_PCM_S16BE_DEMUXER 0
+#define CONFIG_PCM_S16LE_DEMUXER 0
+#define CONFIG_PCM_S8_DEMUXER 0
+#define CONFIG_PCM_U32BE_DEMUXER 0
+#define CONFIG_PCM_U32LE_DEMUXER 0
+#define CONFIG_PCM_U24BE_DEMUXER 0
+#define CONFIG_PCM_U24LE_DEMUXER 0
+#define CONFIG_PCM_U16BE_DEMUXER 0
+#define CONFIG_PCM_U16LE_DEMUXER 0
+#define CONFIG_PCM_U8_DEMUXER 0
+#define CONFIG_PJS_DEMUXER 0
+#define CONFIG_PMP_DEMUXER 0
+#define CONFIG_PP_BNK_DEMUXER 0
+#define CONFIG_PVA_DEMUXER 0
+#define CONFIG_PVF_DEMUXER 0
+#define CONFIG_QCP_DEMUXER 0
+#define CONFIG_R3D_DEMUXER 0
+#define CONFIG_RAWVIDEO_DEMUXER 0
+#define CONFIG_REALTEXT_DEMUXER 0
+#define CONFIG_REDSPARK_DEMUXER 0
+#define CONFIG_RL2_DEMUXER 0
+#define CONFIG_RM_DEMUXER 0
+#define CONFIG_ROQ_DEMUXER 0
+#define CONFIG_RPL_DEMUXER 0
+#define CONFIG_RSD_DEMUXER 0
+#define CONFIG_RSO_DEMUXER 0
+#define CONFIG_RTP_DEMUXER 0
+#define CONFIG_RTSP_DEMUXER 0
+#define CONFIG_S337M_DEMUXER 0
+#define CONFIG_SAMI_DEMUXER 0
+#define CONFIG_SAP_DEMUXER 0
+#define CONFIG_SBC_DEMUXER 0
+#define CONFIG_SBG_DEMUXER 0
+#define CONFIG_SCC_DEMUXER 0
+#define CONFIG_SDP_DEMUXER 0
+#define CONFIG_SDR2_DEMUXER 0
+#define CONFIG_SDS_DEMUXER 0
+#define CONFIG_SDX_DEMUXER 0
+#define CONFIG_SEGAFILM_DEMUXER 0
+#define CONFIG_SER_DEMUXER 0
+#define CONFIG_SHORTEN_DEMUXER 0
+#define CONFIG_SIFF_DEMUXER 0
+#define CONFIG_SLN_DEMUXER 0
+#define CONFIG_SMACKER_DEMUXER 0
+#define CONFIG_SMJPEG_DEMUXER 0
+#define CONFIG_SMUSH_DEMUXER 0
+#define CONFIG_SOL_DEMUXER 0
+#define CONFIG_SOX_DEMUXER 0
+#define CONFIG_SPDIF_DEMUXER 0
+#define CONFIG_SRT_DEMUXER 0
+#define CONFIG_STR_DEMUXER 0
+#define CONFIG_STL_DEMUXER 0
+#define CONFIG_SUBVIEWER1_DEMUXER 0
+#define CONFIG_SUBVIEWER_DEMUXER 0
+#define CONFIG_SUP_DEMUXER 0
+#define CONFIG_SVAG_DEMUXER 0
+#define CONFIG_SWF_DEMUXER 0
+#define CONFIG_TAK_DEMUXER 0
+#define CONFIG_TEDCAPTIONS_DEMUXER 0
+#define CONFIG_THP_DEMUXER 0
+#define CONFIG_THREEDOSTR_DEMUXER 0
+#define CONFIG_TIERTEXSEQ_DEMUXER 0
+#define CONFIG_TMV_DEMUXER 0
+#define CONFIG_TRUEHD_DEMUXER 0
+#define CONFIG_TTA_DEMUXER 0
+#define CONFIG_TXD_DEMUXER 0
+#define CONFIG_TTY_DEMUXER 0
+#define CONFIG_TY_DEMUXER 0
+#define CONFIG_V210_DEMUXER 0
+#define CONFIG_V210X_DEMUXER 0
+#define CONFIG_VAG_DEMUXER 0
+#define CONFIG_VC1_DEMUXER 0
+#define CONFIG_VC1T_DEMUXER 0
+#define CONFIG_VIVIDAS_DEMUXER 0
+#define CONFIG_VIVO_DEMUXER 0
+#define CONFIG_VMD_DEMUXER 0
+#define CONFIG_VOBSUB_DEMUXER 0
+#define CONFIG_VOC_DEMUXER 0
+#define CONFIG_VPK_DEMUXER 0
+#define CONFIG_VPLAYER_DEMUXER 0
+#define CONFIG_VQF_DEMUXER 0
+#define CONFIG_W64_DEMUXER 0
+#define CONFIG_WAV_DEMUXER 1
+#define CONFIG_WC3_DEMUXER 0
+#define CONFIG_WEBM_DASH_MANIFEST_DEMUXER 0
+#define CONFIG_WEBVTT_DEMUXER 0
+#define CONFIG_WSAUD_DEMUXER 0
+#define CONFIG_WSD_DEMUXER 0
+#define CONFIG_WSVQA_DEMUXER 0
+#define CONFIG_WTV_DEMUXER 0
+#define CONFIG_WVE_DEMUXER 0
+#define CONFIG_WV_DEMUXER 0
+#define CONFIG_XA_DEMUXER 0
+#define CONFIG_XBIN_DEMUXER 0
+#define CONFIG_XMV_DEMUXER 0
+#define CONFIG_XVAG_DEMUXER 0
+#define CONFIG_XWMA_DEMUXER 0
+#define CONFIG_YOP_DEMUXER 0
+#define CONFIG_YUV4MPEGPIPE_DEMUXER 0
+#define CONFIG_IMAGE_BMP_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_DDS_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_DPX_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_EXR_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_GIF_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_J2K_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_JPEG_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_JPEGLS_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PAM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PBM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PCX_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PGMYUV_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PGM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PGX_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PICTOR_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PNG_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PPM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PSD_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_QDRAW_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_SGI_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_SVG_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_SUNRAST_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_TIFF_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_WEBP_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_XPM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_XWD_PIPE_DEMUXER 0
+#define CONFIG_LIBGME_DEMUXER 0
+#define CONFIG_LIBMODPLUG_DEMUXER 0
+#define CONFIG_LIBOPENMPT_DEMUXER 0
+#define CONFIG_VAPOURSYNTH_DEMUXER 0
+#define CONFIG_A64_MUXER 0
+#define CONFIG_AC3_MUXER 0
+#define CONFIG_ADTS_MUXER 0
+#define CONFIG_ADX_MUXER 0
+#define CONFIG_AIFF_MUXER 0
+#define CONFIG_AMR_MUXER 0
+#define CONFIG_APM_MUXER 0
+#define CONFIG_APNG_MUXER 0
+#define CONFIG_APTX_MUXER 0
+#define CONFIG_APTX_HD_MUXER 0
+#define CONFIG_ARGO_ASF_MUXER 0
+#define CONFIG_ASF_MUXER 0
+#define CONFIG_ASS_MUXER 0
+#define CONFIG_AST_MUXER 0
+#define CONFIG_ASF_STREAM_MUXER 0
+#define CONFIG_AU_MUXER 0
+#define CONFIG_AVI_MUXER 0
+#define CONFIG_AVM2_MUXER 0
+#define CONFIG_AVS2_MUXER 0
+#define CONFIG_BIT_MUXER 0
+#define CONFIG_CAF_MUXER 0
+#define CONFIG_CAVSVIDEO_MUXER 0
+#define CONFIG_CODEC2_MUXER 0
+#define CONFIG_CODEC2RAW_MUXER 0
+#define CONFIG_CRC_MUXER 0
+#define CONFIG_DASH_MUXER 0
+#define CONFIG_DATA_MUXER 0
+#define CONFIG_DAUD_MUXER 0
+#define CONFIG_DIRAC_MUXER 0
+#define CONFIG_DNXHD_MUXER 0
+#define CONFIG_DTS_MUXER 0
+#define CONFIG_DV_MUXER 0
+#define CONFIG_EAC3_MUXER 0
+#define CONFIG_F4V_MUXER 0
+#define CONFIG_FFMETADATA_MUXER 0
+#define CONFIG_FIFO_MUXER 0
+#define CONFIG_FIFO_TEST_MUXER 0
+#define CONFIG_FILMSTRIP_MUXER 0
+#define CONFIG_FITS_MUXER 0
+#define CONFIG_FLAC_MUXER 0
+#define CONFIG_FLV_MUXER 0
+#define CONFIG_FRAMECRC_MUXER 0
+#define CONFIG_FRAMEHASH_MUXER 0
+#define CONFIG_FRAMEMD5_MUXER 0
+#define CONFIG_G722_MUXER 0
+#define CONFIG_G723_1_MUXER 0
+#define CONFIG_G726_MUXER 0
+#define CONFIG_G726LE_MUXER 0
+#define CONFIG_GIF_MUXER 0
+#define CONFIG_GSM_MUXER 0
+#define CONFIG_GXF_MUXER 0
+#define CONFIG_H261_MUXER 0
+#define CONFIG_H263_MUXER 0
+#define CONFIG_H264_MUXER 0
+#define CONFIG_HASH_MUXER 0
+#define CONFIG_HDS_MUXER 0
+#define CONFIG_HEVC_MUXER 0
+#define CONFIG_HLS_MUXER 0
+#define CONFIG_ICO_MUXER 0
+#define CONFIG_ILBC_MUXER 0
+#define CONFIG_IMAGE2_MUXER 0
+#define CONFIG_IMAGE2PIPE_MUXER 0
+#define CONFIG_IPOD_MUXER 0
+#define CONFIG_IRCAM_MUXER 0
+#define CONFIG_ISMV_MUXER 0
+#define CONFIG_IVF_MUXER 0
+#define CONFIG_JACOSUB_MUXER 0
+#define CONFIG_KVAG_MUXER 0
+#define CONFIG_LATM_MUXER 0
+#define CONFIG_LRC_MUXER 0
+#define CONFIG_M4V_MUXER 0
+#define CONFIG_MD5_MUXER 0
+#define CONFIG_MATROSKA_MUXER 0
+#define CONFIG_MATROSKA_AUDIO_MUXER 0
+#define CONFIG_MICRODVD_MUXER 0
+#define CONFIG_MJPEG_MUXER 0
+#define CONFIG_MLP_MUXER 0
+#define CONFIG_MMF_MUXER 0
+#define CONFIG_MOV_MUXER 0
+#define CONFIG_MP2_MUXER 0
+#define CONFIG_MP3_MUXER 0
+#define CONFIG_MP4_MUXER 0
+#define CONFIG_MPEG1SYSTEM_MUXER 0
+#define CONFIG_MPEG1VCD_MUXER 0
+#define CONFIG_MPEG1VIDEO_MUXER 0
+#define CONFIG_MPEG2DVD_MUXER 0
+#define CONFIG_MPEG2SVCD_MUXER 0
+#define CONFIG_MPEG2VIDEO_MUXER 0
+#define CONFIG_MPEG2VOB_MUXER 0
+#define CONFIG_MPEGTS_MUXER 0
+#define CONFIG_MPJPEG_MUXER 0
+#define CONFIG_MXF_MUXER 0
+#define CONFIG_MXF_D10_MUXER 0
+#define CONFIG_MXF_OPATOM_MUXER 0
+#define CONFIG_NULL_MUXER 0
+#define CONFIG_NUT_MUXER 0
+#define CONFIG_OGA_MUXER 0
+#define CONFIG_OGG_MUXER 0
+#define CONFIG_OGV_MUXER 0
+#define CONFIG_OMA_MUXER 0
+#define CONFIG_OPUS_MUXER 0
+#define CONFIG_PCM_ALAW_MUXER 0
+#define CONFIG_PCM_MULAW_MUXER 0
+#define CONFIG_PCM_VIDC_MUXER 0
+#define CONFIG_PCM_F64BE_MUXER 0
+#define CONFIG_PCM_F64LE_MUXER 0
+#define CONFIG_PCM_F32BE_MUXER 0
+#define CONFIG_PCM_F32LE_MUXER 0
+#define CONFIG_PCM_S32BE_MUXER 0
+#define CONFIG_PCM_S32LE_MUXER 0
+#define CONFIG_PCM_S24BE_MUXER 0
+#define CONFIG_PCM_S24LE_MUXER 0
+#define CONFIG_PCM_S16BE_MUXER 0
+#define CONFIG_PCM_S16LE_MUXER 0
+#define CONFIG_PCM_S8_MUXER 0
+#define CONFIG_PCM_U32BE_MUXER 0
+#define CONFIG_PCM_U32LE_MUXER 0
+#define CONFIG_PCM_U24BE_MUXER 0
+#define CONFIG_PCM_U24LE_MUXER 0
+#define CONFIG_PCM_U16BE_MUXER 0
+#define CONFIG_PCM_U16LE_MUXER 0
+#define CONFIG_PCM_U8_MUXER 0
+#define CONFIG_PSP_MUXER 0
+#define CONFIG_RAWVIDEO_MUXER 0
+#define CONFIG_RM_MUXER 0
+#define CONFIG_ROQ_MUXER 0
+#define CONFIG_RSO_MUXER 0
+#define CONFIG_RTP_MUXER 0
+#define CONFIG_RTP_MPEGTS_MUXER 0
+#define CONFIG_RTSP_MUXER 0
+#define CONFIG_SAP_MUXER 0
+#define CONFIG_SBC_MUXER 0
+#define CONFIG_SCC_MUXER 0
+#define CONFIG_SEGAFILM_MUXER 0
+#define CONFIG_SEGMENT_MUXER 0
+#define CONFIG_STREAM_SEGMENT_MUXER 0
+#define CONFIG_SINGLEJPEG_MUXER 0
+#define CONFIG_SMJPEG_MUXER 0
+#define CONFIG_SMOOTHSTREAMING_MUXER 0
+#define CONFIG_SOX_MUXER 0
+#define CONFIG_SPX_MUXER 0
+#define CONFIG_SPDIF_MUXER 0
+#define CONFIG_SRT_MUXER 0
+#define CONFIG_STREAMHASH_MUXER 0
+#define CONFIG_SUP_MUXER 0
+#define CONFIG_SWF_MUXER 0
+#define CONFIG_TEE_MUXER 0
+#define CONFIG_TG2_MUXER 0
+#define CONFIG_TGP_MUXER 0
+#define CONFIG_MKVTIMESTAMP_V2_MUXER 0
+#define CONFIG_TRUEHD_MUXER 0
+#define CONFIG_TTA_MUXER 0
+#define CONFIG_UNCODEDFRAMECRC_MUXER 0
+#define CONFIG_VC1_MUXER 0
+#define CONFIG_VC1T_MUXER 0
+#define CONFIG_VOC_MUXER 0
+#define CONFIG_W64_MUXER 0
+#define CONFIG_WAV_MUXER 0
+#define CONFIG_WEBM_MUXER 0
+#define CONFIG_WEBM_DASH_MANIFEST_MUXER 0
+#define CONFIG_WEBM_CHUNK_MUXER 0
+#define CONFIG_WEBP_MUXER 0
+#define CONFIG_WEBVTT_MUXER 0
+#define CONFIG_WTV_MUXER 0
+#define CONFIG_WV_MUXER 0
+#define CONFIG_YUV4MPEGPIPE_MUXER 0
+#define CONFIG_CHROMAPRINT_MUXER 0
+#define CONFIG_ASYNC_PROTOCOL 0
+#define CONFIG_BLURAY_PROTOCOL 0
+#define CONFIG_CACHE_PROTOCOL 0
+#define CONFIG_CONCAT_PROTOCOL 0
+#define CONFIG_CRYPTO_PROTOCOL 0
+#define CONFIG_DATA_PROTOCOL 0
+#define CONFIG_FFRTMPCRYPT_PROTOCOL 0
+#define CONFIG_FFRTMPHTTP_PROTOCOL 0
+#define CONFIG_FILE_PROTOCOL 0
+#define CONFIG_FTP_PROTOCOL 0
+#define CONFIG_GOPHER_PROTOCOL 0
+#define CONFIG_HLS_PROTOCOL 0
+#define CONFIG_HTTP_PROTOCOL 0
+#define CONFIG_HTTPPROXY_PROTOCOL 0
+#define CONFIG_HTTPS_PROTOCOL 0
+#define CONFIG_ICECAST_PROTOCOL 0
+#define CONFIG_MMSH_PROTOCOL 0
+#define CONFIG_MMST_PROTOCOL 0
+#define CONFIG_MD5_PROTOCOL 0
+#define CONFIG_PIPE_PROTOCOL 0
+#define CONFIG_PROMPEG_PROTOCOL 0
+#define CONFIG_RTMP_PROTOCOL 0
+#define CONFIG_RTMPE_PROTOCOL 0
+#define CONFIG_RTMPS_PROTOCOL 0
+#define CONFIG_RTMPT_PROTOCOL 0
+#define CONFIG_RTMPTE_PROTOCOL 0
+#define CONFIG_RTMPTS_PROTOCOL 0
+#define CONFIG_RTP_PROTOCOL 0
+#define CONFIG_SCTP_PROTOCOL 0
+#define CONFIG_SRTP_PROTOCOL 0
+#define CONFIG_SUBFILE_PROTOCOL 0
+#define CONFIG_TEE_PROTOCOL 0
+#define CONFIG_TCP_PROTOCOL 0
+#define CONFIG_TLS_PROTOCOL 0
+#define CONFIG_UDP_PROTOCOL 0
+#define CONFIG_UDPLITE_PROTOCOL 0
+#define CONFIG_UNIX_PROTOCOL 0
+#define CONFIG_LIBAMQP_PROTOCOL 0
+#define CONFIG_LIBRTMP_PROTOCOL 0
+#define CONFIG_LIBRTMPE_PROTOCOL 0
+#define CONFIG_LIBRTMPS_PROTOCOL 0
+#define CONFIG_LIBRTMPT_PROTOCOL 0
+#define CONFIG_LIBRTMPTE_PROTOCOL 0
+#define CONFIG_LIBSRT_PROTOCOL 0
+#define CONFIG_LIBSSH_PROTOCOL 0
+#define CONFIG_LIBSMBCLIENT_PROTOCOL 0
+#define CONFIG_LIBZMQ_PROTOCOL 0
+#endif /* FFMPEG_CONFIG_H */
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/config.h.p b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/config.h.p
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/config.h.p	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/config.h.p	2025-06-03 14:32:24.000000000 +0800
@@ -0,0 +1,23 @@
+/*
+ * Autogenerated by the Meson build system.
+ * Do not edit, your changes will be lost.
+ */
+#pragma once
+#define ARCH_AARCH64 0
+#define ARCH_ARM 0
+#define ARCH_PPC64LE 1
+#define ARCH_X86 0
+#define ARCH_X86_32 0
+#define ARCH_X86_64 0
+#define CONFIG_16BPC 1
+#define CONFIG_8BPC 1
+// #define CONFIG_LOG 1 -- Logging is controlled by Chromium
+#define ENDIANNESS_BIG 0
+#define HAVE_ASM 1
+#define HAVE_CLOCK_GETTIME 1
+#define HAVE_DLSYM 1
+#define HAVE_GETAUXVAL 1
+#define HAVE_POSIX_MEMALIGN 1
+#define HAVE_UNISTD_H 1
+
+
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavcodec/bsf_list.c b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavcodec/bsf_list.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavcodec/bsf_list.c	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavcodec/bsf_list.c	2025-06-03 14:37:24.000000000 +0800
@@ -0,0 +1,3 @@
+static const AVBitStreamFilter * const bitstream_filters[] = {
+    &ff_null_bsf,
+    NULL };
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavcodec/codec_list.c b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavcodec/codec_list.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavcodec/codec_list.c	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavcodec/codec_list.c	2025-06-03 14:37:24.000000000 +0800
@@ -0,0 +1,18 @@
+static const AVCodec * const codec_list[] = {
+    &ff_theora_decoder,
+    &ff_vp3_decoder,
+    &ff_vp8_decoder,
+    &ff_flac_decoder,
+    &ff_mp3_decoder,
+    &ff_vorbis_decoder,
+    &ff_pcm_alaw_decoder,
+    &ff_pcm_f32le_decoder,
+    &ff_pcm_mulaw_decoder,
+    &ff_pcm_s16be_decoder,
+    &ff_pcm_s16le_decoder,
+    &ff_pcm_s24be_decoder,
+    &ff_pcm_s24le_decoder,
+    &ff_pcm_s32le_decoder,
+    &ff_pcm_u8_decoder,
+    &ff_libopus_decoder,
+    NULL };
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavcodec/parser_list.c b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavcodec/parser_list.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavcodec/parser_list.c	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavcodec/parser_list.c	2025-06-03 14:37:24.000000000 +0800
@@ -0,0 +1,9 @@
+static const AVCodecParser * const parser_list[] = {
+    &ff_flac_parser,
+    &ff_mpegaudio_parser,
+    &ff_opus_parser,
+    &ff_vorbis_parser,
+    &ff_vp3_parser,
+    &ff_vp8_parser,
+    &ff_vp9_parser,
+    NULL };
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavformat/demuxer_list.c b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavformat/demuxer_list.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavformat/demuxer_list.c	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavformat/demuxer_list.c	2025-06-03 14:37:24.000000000 +0800
@@ -0,0 +1,8 @@
+static const AVInputFormat * const demuxer_list[] = {
+    &ff_flac_demuxer,
+    &ff_matroska_demuxer,
+    &ff_mov_demuxer,
+    &ff_mp3_demuxer,
+    &ff_ogg_demuxer,
+    &ff_wav_demuxer,
+    NULL };
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavformat/muxer_list.c b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavformat/muxer_list.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavformat/muxer_list.c	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavformat/muxer_list.c	2025-06-03 14:37:24.000000000 +0800
@@ -0,0 +1,2 @@
+static const AVOutputFormat * const muxer_list[] = {
+    NULL };
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavformat/protocol_list.c b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavformat/protocol_list.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavformat/protocol_list.c	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavformat/protocol_list.c	2025-06-03 14:37:24.000000000 +0800
@@ -0,0 +1,2 @@
+static const URLProtocol * const url_protocols[] = {
+    NULL };
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavutil/avconfig.h b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavutil/avconfig.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavutil/avconfig.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavutil/avconfig.h	2025-06-03 14:37:24.000000000 +0800
@@ -0,0 +1,6 @@
+/* Generated by ffmpeg configure */
+#ifndef AVUTIL_AVCONFIG_H
+#define AVUTIL_AVCONFIG_H
+#define AV_HAVE_BIGENDIAN 0
+#define AV_HAVE_FAST_UNALIGNED 0
+#endif /* AVUTIL_AVCONFIG_H */
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavutil/ffversion.h b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavutil/ffversion.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavutil/ffversion.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/config/Chromium/linux/ppc64le/libavutil/ffversion.h	2025-06-03 14:37:24.000000000 +0800
@@ -0,0 +1,5 @@
+/* Automatically generated by version.sh, do not manually edit! */
+#ifndef AVUTIL_FFVERSION_H
+#define AVUTIL_FFVERSION_H
+#define FFMPEG_VERSION "N-99931-gb6530ca24d"
+#endif /* AVUTIL_FFVERSION_H */
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py	2025-06-05 22:49:07.000000000 +0800
@@ -37,7 +37,7 @@
     'android': ['ia32', 'x64', 'arm-neon', 'arm64'],
     'linux': [
         'ia32', 'x64', 'mipsel', 'mips64el', 'noasm-x64', 'arm', 'arm-neon',
-        'arm64'
+        'arm64', 'ppc64'
     ],
     'mac': ['x64', 'arm64'],
     'win': ['ia32', 'x64', 'arm64'],
@@ -139,6 +139,8 @@
     host_arch = 'mips64el'
   elif platform.machine().startswith('arm'):
     host_arch = 'arm'
+  elif platform.machine() == 'ppc64le':
+    host_arch = 'ppc64'
   else:
     return None
 
@@ -172,9 +174,9 @@
                                     'android', 'config.gni')
   with open(android_config_gni, 'r') as f:
     gni_contents = f.read()
-    api64_match = re.search('android64_ndk_api_level\s*=\s*(\d{2})',
+    api64_match = re.search('android64_ndk_api_level\\s*=\\s*(\\d{2})',
                             gni_contents)
-    api_match = re.search('android32_ndk_api_level\s*=\s*(\d{2})', gni_contents)
+    api_match = re.search('android32_ndk_api_level\\s*=\\s*(\\d{2})', gni_contents)
     if not api_match or not api64_match:
       raise Exception('Failed to find the android api level or toolchain '
                       'version in ' + android_config_gni)
@@ -820,6 +822,11 @@
             '--extra-cflags=--target=mips64el-linux-gnuabi64',
             '--extra-ldflags=--target=mips64el-linux-gnuabi64',
         ])
+    elif target_arch == 'ppc64':
+      configure_flags['Common'].extend([
+        '--arch=ppc64le',
+        '--extra-cflags=-mcpu=power9'
+      ])
     else:
       print(
           'Error: Unknown target arch %r for target OS %r!' % (target_arch,
@@ -836,16 +843,16 @@
   if 'win' not in target_os:
     configure_flags['Common'].extend([
         '--enable-pic',
-        '--cc=clang',
-        '--cxx=clang++',
-        '--ld=clang',
+        '--cc=ccache %s' % os.environ['CC'],
+        '--cxx=ccache %s' % os.environ['CXX'],
+        '--ld=ccache %s' % os.environ['CC'],
     ])
 
     # Clang Linux will use the first 'ld' it finds on the path, which will
     # typically be the system one, so explicitly configure use of Clang's
     # ld.lld, to ensure that things like cross-compilation and LTO work.
     # This does not work for ia32 and is always used on mac.
-    if target_arch != 'ia32' and target_os != 'mac':
+    if target_arch != 'ia32' and target_arch != 'ppc64' and target_os != 'mac':
       configure_flags['Common'].append('--extra-ldflags=-fuse-ld=lld')
 
   # Should be run on Mac, unless we're cross-compiling on Linux.
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/copy_config.sh b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/copy_config.sh
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/copy_config.sh	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/copy_config.sh	2025-05-30 15:28:03.000000000 +0800
@@ -10,7 +10,7 @@
     # Copy config files for various architectures:
     #   - ia32/x64 have config.asm, config.h
     #   - arm/arm-neon have config.h
-    for arch in arm arm-neon arm64 ia32 x64 mipsel mips64el; do
+    for arch in arm arm-neon arm64 ia32 x64 mipsel mips64el ppc64; do
       # Don't waste time on non-existent configs, if no config.h then skip.
       [ ! -e "build.$arch.$os/$target/config.h" ] && continue
       for f in config.h config.asm libavutil/avconfig.h libavutil/ffversion.h libavcodec/bsf_list.c libavcodec/codec_list.c libavcodec/parser_list.c libavformat/demuxer_list.c libavformat/muxer_list.c libavformat/protocol_list.c; do
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/generate_gn.py b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/generate_gn.py
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/generate_gn.py	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/generate_gn.py	2025-06-05 23:13:29.000000000 +0800
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python2
 #
 # Copyright (c) 2012 The Chromium Authors. All rights reserved.
 # Use of this source code is governed by a BSD-style license that can be
@@ -74,10 +74,11 @@
 """
 
 # Controls conditional stanza generation.
+#        set(['ia32', 'x64', 'ppc64', 'ppc64le','arm',  'arm64', 'arm-neon', 'mipsel', 'mips64el']),
 Attr = enum('ARCHITECTURE', 'TARGET', 'PLATFORM')
 SUPPORT_MATRIX = {
     Attr.ARCHITECTURE:
-        set(['ia32', 'x64', 'arm', 'arm64', 'arm-neon', 'mipsel', 'mips64el']),
+        set(['ia32', 'x64', 'ppc64', 'ppc64le','arm',  'arm64', 'arm-neon', 'mipsel', 'mips64el']),
     Attr.TARGET:
         set(['Chromium', 'Chrome', 'ChromeOS']),
     Attr.PLATFORM:
@@ -942,10 +943,10 @@
   for source_set in sets:
     ReduceConditionalLogic(source_set)
 
-  if not sets:
-    exit('ERROR: failed to find any source sets. ' +
-         'Are build_dir (%s) and/or source_dir (%s) options correct?' %
-         (options.build_dir, options.source_dir))
+#  if not sets:
+#    exit('ERROR: failed to find any source sets. ' +
+#         'Are build_arch(%s) target(%s) platform(%s) build_dir (%s) and/or source_dir (%s) options correct?' %
+#         (arch, target, platform, options.build_dir, options.source_dir))
 
   all_renames, old_renames_to_delete = FixObjectBasenameCollisions(
                                          sets,
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/generate_gn_unittest.py b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/generate_gn_unittest.py
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/generate_gn_unittest.py	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/chromium/scripts/generate_gn_unittest.py	2025-05-30 15:28:03.000000000 +0800
@@ -324,6 +324,10 @@
     f = SourceSet(
         set(['common', 'arm-neon', 'chrome', 'chromeos']),
         set([SourceListCondition('arm-neon', 'ChromeOS', 'linux')]))
+    g = SourceSet(
+        set(['common']),
+        set([SourceListCondition('ppc64', 'Chromium', 'linux')]))
+
 
     expected = set()
     expected.add(
@@ -335,7 +339,8 @@
                 SourceListCondition('x64', 'Chromium', 'linux'),
                 SourceListCondition('x64', 'Chrome', 'linux'),
                 SourceListCondition('arm', 'Chromium', 'linux'),
-                SourceListCondition('arm-neon', 'ChromeOS', 'linux')
+                SourceListCondition('arm-neon', 'ChromeOS', 'linux'),
+                SourceListCondition('ppc64', 'Chromium', 'linux')
             ])))
     expected.add(
         SourceSet(
@@ -363,7 +368,7 @@
             set(['arm-neon', 'chromeos']),
             set([SourceListCondition('arm-neon', 'ChromeOS', 'linux')])))
 
-    source_sets = gg.CreatePairwiseDisjointSets([a, b, c, d, e, f])
+    source_sets = gg.CreatePairwiseDisjointSets([a, b, c, d, e, f, g])
     self.assertEqualSourceSets(expected, set(source_sets))
 
   def testReduceConditions(self):
@@ -378,6 +383,7 @@
             SourceListCondition('arm-neon', 'Chromium', 'linux'),
             SourceListCondition('mipsel', 'Chromium', 'linux'),
             SourceListCondition('mips64el', 'Chromium', 'linux'),
+            SourceListCondition('ppc64', 'Chromium', 'linux'),
         ]))
     gg.ReduceConditionalLogic(a)
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/libavformat/utils.c b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/libavformat/utils.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/libavformat/utils.c	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/ffmpeg/libavformat/utils.c	2025-06-03 11:01:19.000000000 +0800
@@ -623,9 +623,11 @@
         ff_id3v2_read_dict(s->pb, &s->internal->id3v2_meta, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta);
 
 
+    /*
     if (!(s->flags&AVFMT_FLAG_PRIV_OPT) && s->iformat->read_header)
         if ((ret = s->iformat->read_header(s)) < 0)
             goto fail;
+    */
 
     if (!s->metadata) {
         s->metadata = s->internal->id3v2_meta;
@@ -3355,7 +3357,7 @@
 
 int ff_rfps_add_frame(AVFormatContext *ic, AVStream *st, int64_t ts)
 {
-    int i, j;
+    volatile int i, j;
     int64_t last = st->info->last_dts;
 
     if (   ts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE && ts > last
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/flatbuffers/src/docs/header.html b/qtwebengine/src/3rdparty/chromium/third_party/flatbuffers/src/docs/header.html
--- a/qtwebengine/src/3rdparty/chromium/third_party/flatbuffers/src/docs/header.html	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/flatbuffers/src/docs/header.html	2025-06-03 10:48:24.000000000 +0800
@@ -14,7 +14,7 @@
 $search
 $mathjax
 <link href="$relpath^$stylesheet" rel="stylesheet" type="text/css" />
-<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400italic,500,500italic,700,700italic|Roboto+Mono:400,700" rel="stylesheet">
+<link href="chrome://resources/css/roboto.css" rel="stylesheet">
 $extrastylesheet
 </head>
 <body>
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/icu/icu.gyp b/qtwebengine/src/3rdparty/chromium/third_party/icu/icu.gyp
--- a/qtwebengine/src/3rdparty/chromium/third_party/icu/icu.gyp	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/icu/icu.gyp	2025-06-05 15:03:24.000000000 +0800
@@ -77,7 +77,7 @@
          or OS=="netbsd" or OS=="mac" or OS=="android" or OS=="qnx") and \
         (target_arch=="arm64" or target_arch=="x64" or \
          target_arch=="mips64el" or target_arch=="mips64" or \
-         target_arch=="ppc64" or target_arch=="s390x")', {
+         target_arch=="ppc64" or target_arch=="ppc64le" or target_arch=="s390x")', {
         'target_conditions': [
           ['_toolset=="host"', {
             'cflags': [ '-m64' ],
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libaom/BUILD.gn b/qtwebengine/src/3rdparty/chromium/third_party/libaom/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/third_party/libaom/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libaom/BUILD.gn	2025-06-05 15:06:23.000000000 +0800
@@ -198,6 +198,30 @@
     }
   }
 
+  if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+    source_set("libaom_intrinsics_vsx") {
+      configs -= [ "//build/config/compiler:chromium_code" ]
+      configs += [ "//build/config/compiler:no_chromium_code" ]
+      configs += [ ":libaom_config" ]
+      sources = [
+        "//third_party/libaom/source/libaom/aom_ports/ppc_cpudetect.c",
+      ]
+      sources += aom_av1_common_intrin_vsx
+    }
+  }
+
+  if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+    source_set("libaom_intrinsics_vsx") {
+      configs -= [ "//build/config/compiler:chromium_code" ]
+      configs += [ "//build/config/compiler:no_chromium_code" ]
+      configs += [ ":libaom_config" ]
+      sources = [
+        "//third_party/libaom/source/libaom/aom_ports/ppc_cpudetect.c",
+      ]
+      sources += aom_av1_common_intrin_vsx
+    }
+  }
+
   static_library("libaom") {
     if (!is_debug && is_win) {
       configs -= [ "//build/config/compiler:default_optimization" ]
@@ -234,6 +258,12 @@
         cpu_arch_full == "arm-neon-cpu-detect") {
       deps += [ ":libaom_intrinsics_neon" ]
     }
+    if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+      deps += [ ":libaom_intrinsics_vsx" ]
+    }
+    if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+      deps += [ ":libaom_intrinsics_vsx" ]
+    }
     if (is_android) {
       deps += [ "//third_party/android_ndk:cpu_features" ]
     }
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libaom/cmake_update.sh b/qtwebengine/src/3rdparty/chromium/third_party/libaom/cmake_update.sh
--- a/qtwebengine/src/3rdparty/chromium/third_party/libaom/cmake_update.sh	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libaom/cmake_update.sh	2025-06-03 14:19:56.000000000 +0800
@@ -185,6 +185,12 @@
 reset_dirs ios/arm64
 gen_config_files ios/arm64 "${toolchain}/arm64-ios.cmake ${all_platforms}"
 
+reset_dirs linux/ppc64
+gen_config_files linux/ppc64 "${toolchain}/ppc-linux-gcc.cmake ${all_platforms}"
+
+reset_dirs linux/ppc64
+gen_config_files linux/ppc64 "${toolchain}/ppc-linux-gcc.cmake ${all_platforms}"
+
 # Copy linux configurations and modify for Windows.
 reset_dirs win/arm64
 cp "${CFG}/linux/arm64/config"/* "${CFG}/win/arm64/config/"
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_config.asm b/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_config.asm
--- a/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_config.asm	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_config.asm	2025-05-30 15:28:03.000000000 +0800
@@ -0,0 +1,78 @@
+;
+; Copyright (c) 2019, Alliance for Open Media. All rights reserved
+;
+; This source code is subject to the terms of the BSD 2 Clause License and
+; the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
+; was not distributed with this source code in the LICENSE file, you can
+; obtain it at www.aomedia.org/license/software. If the Alliance for Open
+; Media Patent License 1.0 was not distributed with this source code in the
+; PATENTS file, you can obtain it at www.aomedia.org/license/patent.
+;
+ARCH_ARM equ 0
+ARCH_MIPS equ 0
+ARCH_PPC equ 1
+ARCH_X86 equ 0
+ARCH_X86_64 equ 0
+CONFIG_2PASS_PARTITION_SEARCH_LVL equ 1
+CONFIG_ACCOUNTING equ 0
+CONFIG_ANALYZER equ 0
+CONFIG_AV1_DECODER equ 1
+CONFIG_AV1_ENCODER equ 0
+CONFIG_BIG_ENDIAN equ 0
+CONFIG_BITSTREAM_DEBUG equ 0
+CONFIG_COEFFICIENT_RANGE_CHECKING equ 0
+CONFIG_COLLECT_INTER_MODE_RD_STATS equ 1
+CONFIG_COLLECT_PARTITION_STATS equ 0
+CONFIG_COLLECT_RD_STATS equ 0
+CONFIG_DEBUG equ 0
+CONFIG_DENOISE equ 1
+CONFIG_DISABLE_FULL_PIXEL_SPLIT_8X8 equ 1
+CONFIG_DIST_8X8 equ 0
+CONFIG_ENTROPY_STATS equ 0
+CONFIG_FILEOPTIONS equ 1
+CONFIG_FP_MB_STATS equ 0
+CONFIG_GCC equ 1
+CONFIG_GCOV equ 0
+CONFIG_GPROF equ 0
+CONFIG_INSPECTION equ 0
+CONFIG_INTERNAL_STATS equ 0
+CONFIG_INTER_STATS_ONLY equ 0
+CONFIG_LIBYUV equ 1
+CONFIG_LOWBITDEPTH equ 1
+CONFIG_MAX_DECODE_PROFILE equ 0
+CONFIG_MISMATCH_DEBUG equ 0
+CONFIG_MULTITHREAD equ 1
+CONFIG_NORMAL_TILE_MODE equ 1
+CONFIG_ONE_PASS_SVM equ 0
+CONFIG_OS_SUPPORT equ 1
+CONFIG_PIC equ 0
+CONFIG_RD_DEBUG equ 0
+CONFIG_RUNTIME_CPU_DETECT equ 0
+CONFIG_SHARED equ 0
+CONFIG_SHARP_SETTINGS equ 0
+CONFIG_SIZE_LIMIT equ 1
+CONFIG_SPATIAL_RESAMPLING equ 1
+CONFIG_SPEED_STATS equ 0
+CONFIG_STATIC equ 1
+CONFIG_WEBM_IO equ 1
+DECODE_HEIGHT_LIMIT equ 16384
+DECODE_WIDTH_LIMIT equ 16384
+HAVE_AVX equ 0
+HAVE_AVX2 equ 0
+HAVE_DSPR2 equ 0
+HAVE_FEXCEPT equ 1
+HAVE_MIPS32 equ 0
+HAVE_MIPS64 equ 0
+HAVE_MMX equ 0
+HAVE_MSA equ 0
+HAVE_NEON equ 0
+HAVE_PTHREAD_H equ 1
+HAVE_SSE equ 0
+HAVE_SSE2 equ 0
+HAVE_SSE3 equ 0
+HAVE_SSE4_1 equ 0
+HAVE_SSE4_2 equ 0
+HAVE_SSSE3 equ 0
+HAVE_UNISTD_H equ 1
+HAVE_VSX equ 1
+HAVE_WXWIDGETS equ 0
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_config.c b/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_config.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_config.c	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_config.c	2025-05-30 15:28:03.000000000 +0800
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2016, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 2 Clause License and
+ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
+ * was not distributed with this source code in the LICENSE file, you can
+ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
+ * Media Patent License 1.0 was not distributed with this source code in the
+ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
+ */
+#include "aom/aom_codec.h"
+static const char* const cfg = "cmake ../source/libaom -G \"Unix Makefiles\" -DCMAKE_TOOLCHAIN_FILE=\"../source/libaom/build/cmake/toolchains/ppc-linux-gcc.cmake\" -DCONFIG_AV1_ENCODER=0 -DCONFIG_LOWBITDEPTH=1 -DCONFIG_MAX_DECODE_PROFILE=0 -DCONFIG_NORMAL_TILE_MODE=1 -DCONFIG_SIZE_LIMIT=1 -DDECODE_HEIGHT_LIMIT=16384 -DDECODE_WIDTH_LIMIT=16384";
+const char *aom_codec_build_config(void) {return cfg;}
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_config.h b/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_config.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_config.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_config.h	2025-05-30 15:28:03.000000000 +0800
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2019, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 2 Clause License and
+ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
+ * was not distributed with this source code in the LICENSE file, you can
+ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
+ * Media Patent License 1.0 was not distributed with this source code in the
+ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
+ */
+#ifndef AOM_CONFIG_H_
+#define AOM_CONFIG_H_
+#define ARCH_ARM 0
+#define ARCH_MIPS 0
+#define ARCH_PPC 1
+#define ARCH_X86 0
+#define ARCH_X86_64 0
+#define CONFIG_2PASS_PARTITION_SEARCH_LVL 1
+#define CONFIG_ACCOUNTING 0
+#define CONFIG_ANALYZER 0
+#define CONFIG_AV1_DECODER 1
+#define CONFIG_AV1_ENCODER 0
+#define CONFIG_BIG_ENDIAN 0
+#define CONFIG_BITSTREAM_DEBUG 0
+#define CONFIG_COEFFICIENT_RANGE_CHECKING 0
+#define CONFIG_COLLECT_INTER_MODE_RD_STATS 1
+#define CONFIG_COLLECT_PARTITION_STATS 0
+#define CONFIG_COLLECT_RD_STATS 0
+#define CONFIG_DEBUG 0
+#define CONFIG_DENOISE 1
+#define CONFIG_DISABLE_FULL_PIXEL_SPLIT_8X8 1
+#define CONFIG_DIST_8X8 0
+#define CONFIG_ENTROPY_STATS 0
+#define CONFIG_FILEOPTIONS 1
+#define CONFIG_FP_MB_STATS 0
+#define CONFIG_GCC 1
+#define CONFIG_GCOV 0
+#define CONFIG_GPROF 0
+#define CONFIG_INSPECTION 0
+#define CONFIG_INTERNAL_STATS 0
+#define CONFIG_INTER_STATS_ONLY 0
+#define CONFIG_LIBYUV 1
+#define CONFIG_LOWBITDEPTH 1
+#define CONFIG_MAX_DECODE_PROFILE 0
+#define CONFIG_MISMATCH_DEBUG 0
+#define CONFIG_MULTITHREAD 1
+#define CONFIG_NORMAL_TILE_MODE 1
+#define CONFIG_ONE_PASS_SVM 0
+#define CONFIG_OS_SUPPORT 1
+#define CONFIG_PIC 0
+#define CONFIG_RD_DEBUG 0
+#define CONFIG_RUNTIME_CPU_DETECT 0
+#define CONFIG_SHARED 0
+#define CONFIG_SHARP_SETTINGS 0
+#define CONFIG_SIZE_LIMIT 1
+#define CONFIG_SPATIAL_RESAMPLING 1
+#define CONFIG_SPEED_STATS 0
+#define CONFIG_STATIC 1
+#define CONFIG_WEBM_IO 1
+#define DECODE_HEIGHT_LIMIT 16384
+#define DECODE_WIDTH_LIMIT 16384
+#define HAVE_AVX 0
+#define HAVE_AVX2 0
+#define HAVE_DSPR2 0
+#define HAVE_FEXCEPT 1
+#define HAVE_MIPS32 0
+#define HAVE_MIPS64 0
+#define HAVE_MMX 0
+#define HAVE_MSA 0
+#define HAVE_NEON 0
+#define HAVE_PTHREAD_H 1
+#define HAVE_SSE 0
+#define HAVE_SSE2 0
+#define HAVE_SSE3 0
+#define HAVE_SSE4_1 0
+#define HAVE_SSE4_2 0
+#define HAVE_SSSE3 0
+#define HAVE_UNISTD_H 1
+#define HAVE_VSX 1
+#define HAVE_WXWIDGETS 0
+#define INLINE inline
+#endif  // AOM_CONFIG_H_
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_dsp_rtcd.h b/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_dsp_rtcd.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_dsp_rtcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_dsp_rtcd.h	2025-05-30 15:28:03.000000000 +0800
@@ -0,0 +1,3128 @@
+// This file is generated. Do not edit.
+#ifndef AOM_DSP_RTCD_H_
+#define AOM_DSP_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * DSP
+ */
+
+#include "aom/aom_integer.h"
+#include "aom_dsp/aom_dsp_common.h"
+#include "av1/common/blockd.h"
+#include "av1/common/enums.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void aom_blend_a64_hmask_c(uint8_t* dst,
+                           uint32_t dst_stride,
+                           const uint8_t* src0,
+                           uint32_t src0_stride,
+                           const uint8_t* src1,
+                           uint32_t src1_stride,
+                           const uint8_t* mask,
+                           int w,
+                           int h);
+#define aom_blend_a64_hmask aom_blend_a64_hmask_c
+
+void aom_blend_a64_mask_c(uint8_t* dst,
+                          uint32_t dst_stride,
+                          const uint8_t* src0,
+                          uint32_t src0_stride,
+                          const uint8_t* src1,
+                          uint32_t src1_stride,
+                          const uint8_t* mask,
+                          uint32_t mask_stride,
+                          int w,
+                          int h,
+                          int subx,
+                          int suby);
+#define aom_blend_a64_mask aom_blend_a64_mask_c
+
+void aom_blend_a64_vmask_c(uint8_t* dst,
+                           uint32_t dst_stride,
+                           const uint8_t* src0,
+                           uint32_t src0_stride,
+                           const uint8_t* src1,
+                           uint32_t src1_stride,
+                           const uint8_t* mask,
+                           int w,
+                           int h);
+#define aom_blend_a64_vmask aom_blend_a64_vmask_c
+
+void aom_convolve8_horiz_c(const uint8_t* src,
+                           ptrdiff_t src_stride,
+                           uint8_t* dst,
+                           ptrdiff_t dst_stride,
+                           const int16_t* filter_x,
+                           int x_step_q4,
+                           const int16_t* filter_y,
+                           int y_step_q4,
+                           int w,
+                           int h);
+#define aom_convolve8_horiz aom_convolve8_horiz_c
+
+void aom_convolve8_vert_c(const uint8_t* src,
+                          ptrdiff_t src_stride,
+                          uint8_t* dst,
+                          ptrdiff_t dst_stride,
+                          const int16_t* filter_x,
+                          int x_step_q4,
+                          const int16_t* filter_y,
+                          int y_step_q4,
+                          int w,
+                          int h);
+#define aom_convolve8_vert aom_convolve8_vert_c
+
+void aom_convolve_copy_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const int16_t* filter_x,
+                         int x_step_q4,
+                         const int16_t* filter_y,
+                         int y_step_q4,
+                         int w,
+                         int h);
+#define aom_convolve_copy aom_convolve_copy_c
+
+void aom_dc_128_predictor_16x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_128_predictor_16x16 aom_dc_128_predictor_16x16_c
+
+void aom_dc_128_predictor_16x32_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_128_predictor_16x32 aom_dc_128_predictor_16x32_c
+
+void aom_dc_128_predictor_16x4_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_128_predictor_16x4 aom_dc_128_predictor_16x4_c
+
+void aom_dc_128_predictor_16x64_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_128_predictor_16x64 aom_dc_128_predictor_16x64_c
+
+void aom_dc_128_predictor_16x8_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_128_predictor_16x8 aom_dc_128_predictor_16x8_c
+
+void aom_dc_128_predictor_2x2_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_dc_128_predictor_2x2 aom_dc_128_predictor_2x2_c
+
+void aom_dc_128_predictor_32x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_128_predictor_32x16 aom_dc_128_predictor_32x16_c
+
+void aom_dc_128_predictor_32x32_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_128_predictor_32x32 aom_dc_128_predictor_32x32_c
+
+void aom_dc_128_predictor_32x64_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_128_predictor_32x64 aom_dc_128_predictor_32x64_c
+
+void aom_dc_128_predictor_32x8_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_128_predictor_32x8 aom_dc_128_predictor_32x8_c
+
+void aom_dc_128_predictor_4x16_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_128_predictor_4x16 aom_dc_128_predictor_4x16_c
+
+void aom_dc_128_predictor_4x4_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_dc_128_predictor_4x4 aom_dc_128_predictor_4x4_c
+
+void aom_dc_128_predictor_4x8_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_dc_128_predictor_4x8 aom_dc_128_predictor_4x8_c
+
+void aom_dc_128_predictor_64x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_128_predictor_64x16 aom_dc_128_predictor_64x16_c
+
+void aom_dc_128_predictor_64x32_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_128_predictor_64x32 aom_dc_128_predictor_64x32_c
+
+void aom_dc_128_predictor_64x64_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_128_predictor_64x64 aom_dc_128_predictor_64x64_c
+
+void aom_dc_128_predictor_8x16_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_128_predictor_8x16 aom_dc_128_predictor_8x16_c
+
+void aom_dc_128_predictor_8x32_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_128_predictor_8x32 aom_dc_128_predictor_8x32_c
+
+void aom_dc_128_predictor_8x4_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_dc_128_predictor_8x4 aom_dc_128_predictor_8x4_c
+
+void aom_dc_128_predictor_8x8_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_dc_128_predictor_8x8 aom_dc_128_predictor_8x8_c
+
+void aom_dc_left_predictor_16x16_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_dc_left_predictor_16x16 aom_dc_left_predictor_16x16_c
+
+void aom_dc_left_predictor_16x32_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_dc_left_predictor_16x32 aom_dc_left_predictor_16x32_c
+
+void aom_dc_left_predictor_16x4_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_left_predictor_16x4 aom_dc_left_predictor_16x4_c
+
+void aom_dc_left_predictor_16x64_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_dc_left_predictor_16x64 aom_dc_left_predictor_16x64_c
+
+void aom_dc_left_predictor_16x8_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_left_predictor_16x8 aom_dc_left_predictor_16x8_c
+
+void aom_dc_left_predictor_2x2_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_left_predictor_2x2 aom_dc_left_predictor_2x2_c
+
+void aom_dc_left_predictor_32x16_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_dc_left_predictor_32x16 aom_dc_left_predictor_32x16_c
+
+void aom_dc_left_predictor_32x32_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_dc_left_predictor_32x32 aom_dc_left_predictor_32x32_c
+
+void aom_dc_left_predictor_32x64_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_dc_left_predictor_32x64 aom_dc_left_predictor_32x64_c
+
+void aom_dc_left_predictor_32x8_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_left_predictor_32x8 aom_dc_left_predictor_32x8_c
+
+void aom_dc_left_predictor_4x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_left_predictor_4x16 aom_dc_left_predictor_4x16_c
+
+void aom_dc_left_predictor_4x4_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_left_predictor_4x4 aom_dc_left_predictor_4x4_c
+
+void aom_dc_left_predictor_4x8_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_left_predictor_4x8 aom_dc_left_predictor_4x8_c
+
+void aom_dc_left_predictor_64x16_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_dc_left_predictor_64x16 aom_dc_left_predictor_64x16_c
+
+void aom_dc_left_predictor_64x32_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_dc_left_predictor_64x32 aom_dc_left_predictor_64x32_c
+
+void aom_dc_left_predictor_64x64_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_dc_left_predictor_64x64 aom_dc_left_predictor_64x64_c
+
+void aom_dc_left_predictor_8x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_left_predictor_8x16 aom_dc_left_predictor_8x16_c
+
+void aom_dc_left_predictor_8x32_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_left_predictor_8x32 aom_dc_left_predictor_8x32_c
+
+void aom_dc_left_predictor_8x4_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_left_predictor_8x4 aom_dc_left_predictor_8x4_c
+
+void aom_dc_left_predictor_8x8_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_left_predictor_8x8 aom_dc_left_predictor_8x8_c
+
+void aom_dc_predictor_16x16_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define aom_dc_predictor_16x16 aom_dc_predictor_16x16_c
+
+void aom_dc_predictor_16x32_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define aom_dc_predictor_16x32 aom_dc_predictor_16x32_c
+
+void aom_dc_predictor_16x4_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_dc_predictor_16x4 aom_dc_predictor_16x4_c
+
+void aom_dc_predictor_16x64_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define aom_dc_predictor_16x64 aom_dc_predictor_16x64_c
+
+void aom_dc_predictor_16x8_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_dc_predictor_16x8 aom_dc_predictor_16x8_c
+
+void aom_dc_predictor_2x2_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_dc_predictor_2x2 aom_dc_predictor_2x2_c
+
+void aom_dc_predictor_32x16_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define aom_dc_predictor_32x16 aom_dc_predictor_32x16_c
+
+void aom_dc_predictor_32x32_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define aom_dc_predictor_32x32 aom_dc_predictor_32x32_c
+
+void aom_dc_predictor_32x64_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define aom_dc_predictor_32x64 aom_dc_predictor_32x64_c
+
+void aom_dc_predictor_32x8_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_dc_predictor_32x8 aom_dc_predictor_32x8_c
+
+void aom_dc_predictor_4x16_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_dc_predictor_4x16 aom_dc_predictor_4x16_c
+
+void aom_dc_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_dc_predictor_4x4 aom_dc_predictor_4x4_c
+
+void aom_dc_predictor_4x8_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_dc_predictor_4x8 aom_dc_predictor_4x8_c
+
+void aom_dc_predictor_64x16_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define aom_dc_predictor_64x16 aom_dc_predictor_64x16_c
+
+void aom_dc_predictor_64x32_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define aom_dc_predictor_64x32 aom_dc_predictor_64x32_c
+
+void aom_dc_predictor_64x64_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define aom_dc_predictor_64x64 aom_dc_predictor_64x64_c
+
+void aom_dc_predictor_8x16_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_dc_predictor_8x16 aom_dc_predictor_8x16_c
+
+void aom_dc_predictor_8x32_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_dc_predictor_8x32 aom_dc_predictor_8x32_c
+
+void aom_dc_predictor_8x4_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_dc_predictor_8x4 aom_dc_predictor_8x4_c
+
+void aom_dc_predictor_8x8_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_dc_predictor_8x8 aom_dc_predictor_8x8_c
+
+void aom_dc_top_predictor_16x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_top_predictor_16x16 aom_dc_top_predictor_16x16_c
+
+void aom_dc_top_predictor_16x32_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_top_predictor_16x32 aom_dc_top_predictor_16x32_c
+
+void aom_dc_top_predictor_16x4_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_top_predictor_16x4 aom_dc_top_predictor_16x4_c
+
+void aom_dc_top_predictor_16x64_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_top_predictor_16x64 aom_dc_top_predictor_16x64_c
+
+void aom_dc_top_predictor_16x8_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_top_predictor_16x8 aom_dc_top_predictor_16x8_c
+
+void aom_dc_top_predictor_2x2_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_dc_top_predictor_2x2 aom_dc_top_predictor_2x2_c
+
+void aom_dc_top_predictor_32x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_top_predictor_32x16 aom_dc_top_predictor_32x16_c
+
+void aom_dc_top_predictor_32x32_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_top_predictor_32x32 aom_dc_top_predictor_32x32_c
+
+void aom_dc_top_predictor_32x64_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_top_predictor_32x64 aom_dc_top_predictor_32x64_c
+
+void aom_dc_top_predictor_32x8_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_top_predictor_32x8 aom_dc_top_predictor_32x8_c
+
+void aom_dc_top_predictor_4x16_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_top_predictor_4x16 aom_dc_top_predictor_4x16_c
+
+void aom_dc_top_predictor_4x4_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_dc_top_predictor_4x4 aom_dc_top_predictor_4x4_c
+
+void aom_dc_top_predictor_4x8_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_dc_top_predictor_4x8 aom_dc_top_predictor_4x8_c
+
+void aom_dc_top_predictor_64x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_top_predictor_64x16 aom_dc_top_predictor_64x16_c
+
+void aom_dc_top_predictor_64x32_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_top_predictor_64x32 aom_dc_top_predictor_64x32_c
+
+void aom_dc_top_predictor_64x64_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_dc_top_predictor_64x64 aom_dc_top_predictor_64x64_c
+
+void aom_dc_top_predictor_8x16_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_top_predictor_8x16 aom_dc_top_predictor_8x16_c
+
+void aom_dc_top_predictor_8x32_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_dc_top_predictor_8x32 aom_dc_top_predictor_8x32_c
+
+void aom_dc_top_predictor_8x4_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_dc_top_predictor_8x4 aom_dc_top_predictor_8x4_c
+
+void aom_dc_top_predictor_8x8_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_dc_top_predictor_8x8 aom_dc_top_predictor_8x8_c
+
+void aom_h_predictor_16x16_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_h_predictor_16x16 aom_h_predictor_16x16_c
+
+void aom_h_predictor_16x32_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_h_predictor_16x32 aom_h_predictor_16x32_c
+
+void aom_h_predictor_16x4_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_h_predictor_16x4 aom_h_predictor_16x4_c
+
+void aom_h_predictor_16x64_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_h_predictor_16x64 aom_h_predictor_16x64_c
+
+void aom_h_predictor_16x8_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_h_predictor_16x8 aom_h_predictor_16x8_c
+
+void aom_h_predictor_2x2_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define aom_h_predictor_2x2 aom_h_predictor_2x2_c
+
+void aom_h_predictor_32x16_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_h_predictor_32x16 aom_h_predictor_32x16_c
+
+void aom_h_predictor_32x32_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_h_predictor_32x32 aom_h_predictor_32x32_c
+
+void aom_h_predictor_32x64_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_h_predictor_32x64 aom_h_predictor_32x64_c
+
+void aom_h_predictor_32x8_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_h_predictor_32x8 aom_h_predictor_32x8_c
+
+void aom_h_predictor_4x16_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_h_predictor_4x16 aom_h_predictor_4x16_c
+
+void aom_h_predictor_4x4_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define aom_h_predictor_4x4 aom_h_predictor_4x4_c
+
+void aom_h_predictor_4x8_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define aom_h_predictor_4x8 aom_h_predictor_4x8_c
+
+void aom_h_predictor_64x16_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_h_predictor_64x16 aom_h_predictor_64x16_c
+
+void aom_h_predictor_64x32_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_h_predictor_64x32 aom_h_predictor_64x32_c
+
+void aom_h_predictor_64x64_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_h_predictor_64x64 aom_h_predictor_64x64_c
+
+void aom_h_predictor_8x16_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_h_predictor_8x16 aom_h_predictor_8x16_c
+
+void aom_h_predictor_8x32_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_h_predictor_8x32 aom_h_predictor_8x32_c
+
+void aom_h_predictor_8x4_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define aom_h_predictor_8x4 aom_h_predictor_8x4_c
+
+void aom_h_predictor_8x8_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define aom_h_predictor_8x8 aom_h_predictor_8x8_c
+
+void aom_highbd_blend_a64_d16_mask_c(uint8_t* dst,
+                                     uint32_t dst_stride,
+                                     const CONV_BUF_TYPE* src0,
+                                     uint32_t src0_stride,
+                                     const CONV_BUF_TYPE* src1,
+                                     uint32_t src1_stride,
+                                     const uint8_t* mask,
+                                     uint32_t mask_stride,
+                                     int w,
+                                     int h,
+                                     int subx,
+                                     int suby,
+                                     ConvolveParams* conv_params,
+                                     const int bd);
+#define aom_highbd_blend_a64_d16_mask aom_highbd_blend_a64_d16_mask_c
+
+void aom_highbd_blend_a64_hmask_c(uint8_t* dst,
+                                  uint32_t dst_stride,
+                                  const uint8_t* src0,
+                                  uint32_t src0_stride,
+                                  const uint8_t* src1,
+                                  uint32_t src1_stride,
+                                  const uint8_t* mask,
+                                  int w,
+                                  int h,
+                                  int bd);
+#define aom_highbd_blend_a64_hmask aom_highbd_blend_a64_hmask_c
+
+void aom_highbd_blend_a64_mask_c(uint8_t* dst,
+                                 uint32_t dst_stride,
+                                 const uint8_t* src0,
+                                 uint32_t src0_stride,
+                                 const uint8_t* src1,
+                                 uint32_t src1_stride,
+                                 const uint8_t* mask,
+                                 uint32_t mask_stride,
+                                 int w,
+                                 int h,
+                                 int subx,
+                                 int suby,
+                                 int bd);
+#define aom_highbd_blend_a64_mask aom_highbd_blend_a64_mask_c
+
+void aom_highbd_blend_a64_vmask_c(uint8_t* dst,
+                                  uint32_t dst_stride,
+                                  const uint8_t* src0,
+                                  uint32_t src0_stride,
+                                  const uint8_t* src1,
+                                  uint32_t src1_stride,
+                                  const uint8_t* mask,
+                                  int w,
+                                  int h,
+                                  int bd);
+#define aom_highbd_blend_a64_vmask aom_highbd_blend_a64_vmask_c
+
+void aom_highbd_convolve8_horiz_c(const uint8_t* src,
+                                  ptrdiff_t src_stride,
+                                  uint8_t* dst,
+                                  ptrdiff_t dst_stride,
+                                  const int16_t* filter_x,
+                                  int x_step_q4,
+                                  const int16_t* filter_y,
+                                  int y_step_q4,
+                                  int w,
+                                  int h,
+                                  int bps);
+#define aom_highbd_convolve8_horiz aom_highbd_convolve8_horiz_c
+
+void aom_highbd_convolve8_vert_c(const uint8_t* src,
+                                 ptrdiff_t src_stride,
+                                 uint8_t* dst,
+                                 ptrdiff_t dst_stride,
+                                 const int16_t* filter_x,
+                                 int x_step_q4,
+                                 const int16_t* filter_y,
+                                 int y_step_q4,
+                                 int w,
+                                 int h,
+                                 int bps);
+#define aom_highbd_convolve8_vert aom_highbd_convolve8_vert_c
+
+void aom_highbd_convolve_copy_c(const uint8_t* src,
+                                ptrdiff_t src_stride,
+                                uint8_t* dst,
+                                ptrdiff_t dst_stride,
+                                const int16_t* filter_x,
+                                int x_step_q4,
+                                const int16_t* filter_y,
+                                int y_step_q4,
+                                int w,
+                                int h,
+                                int bps);
+#define aom_highbd_convolve_copy aom_highbd_convolve_copy_c
+
+void aom_highbd_dc_128_predictor_16x16_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_128_predictor_16x16 aom_highbd_dc_128_predictor_16x16_c
+
+void aom_highbd_dc_128_predictor_16x32_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_128_predictor_16x32 aom_highbd_dc_128_predictor_16x32_c
+
+void aom_highbd_dc_128_predictor_16x4_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_128_predictor_16x4 aom_highbd_dc_128_predictor_16x4_c
+
+void aom_highbd_dc_128_predictor_16x64_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_128_predictor_16x64 aom_highbd_dc_128_predictor_16x64_c
+
+void aom_highbd_dc_128_predictor_16x8_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_128_predictor_16x8 aom_highbd_dc_128_predictor_16x8_c
+
+void aom_highbd_dc_128_predictor_2x2_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_dc_128_predictor_2x2 aom_highbd_dc_128_predictor_2x2_c
+
+void aom_highbd_dc_128_predictor_32x16_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_128_predictor_32x16 aom_highbd_dc_128_predictor_32x16_c
+
+void aom_highbd_dc_128_predictor_32x32_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_128_predictor_32x32 aom_highbd_dc_128_predictor_32x32_c
+
+void aom_highbd_dc_128_predictor_32x64_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_128_predictor_32x64 aom_highbd_dc_128_predictor_32x64_c
+
+void aom_highbd_dc_128_predictor_32x8_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_128_predictor_32x8 aom_highbd_dc_128_predictor_32x8_c
+
+void aom_highbd_dc_128_predictor_4x16_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_128_predictor_4x16 aom_highbd_dc_128_predictor_4x16_c
+
+void aom_highbd_dc_128_predictor_4x4_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_dc_128_predictor_4x4 aom_highbd_dc_128_predictor_4x4_c
+
+void aom_highbd_dc_128_predictor_4x8_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_dc_128_predictor_4x8 aom_highbd_dc_128_predictor_4x8_c
+
+void aom_highbd_dc_128_predictor_64x16_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_128_predictor_64x16 aom_highbd_dc_128_predictor_64x16_c
+
+void aom_highbd_dc_128_predictor_64x32_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_128_predictor_64x32 aom_highbd_dc_128_predictor_64x32_c
+
+void aom_highbd_dc_128_predictor_64x64_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_128_predictor_64x64 aom_highbd_dc_128_predictor_64x64_c
+
+void aom_highbd_dc_128_predictor_8x16_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_128_predictor_8x16 aom_highbd_dc_128_predictor_8x16_c
+
+void aom_highbd_dc_128_predictor_8x32_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_128_predictor_8x32 aom_highbd_dc_128_predictor_8x32_c
+
+void aom_highbd_dc_128_predictor_8x4_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_dc_128_predictor_8x4 aom_highbd_dc_128_predictor_8x4_c
+
+void aom_highbd_dc_128_predictor_8x8_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_dc_128_predictor_8x8 aom_highbd_dc_128_predictor_8x8_c
+
+void aom_highbd_dc_left_predictor_16x16_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_dc_left_predictor_16x16 aom_highbd_dc_left_predictor_16x16_c
+
+void aom_highbd_dc_left_predictor_16x32_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_dc_left_predictor_16x32 aom_highbd_dc_left_predictor_16x32_c
+
+void aom_highbd_dc_left_predictor_16x4_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_left_predictor_16x4 aom_highbd_dc_left_predictor_16x4_c
+
+void aom_highbd_dc_left_predictor_16x64_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_dc_left_predictor_16x64 aom_highbd_dc_left_predictor_16x64_c
+
+void aom_highbd_dc_left_predictor_16x8_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_left_predictor_16x8 aom_highbd_dc_left_predictor_16x8_c
+
+void aom_highbd_dc_left_predictor_2x2_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_left_predictor_2x2 aom_highbd_dc_left_predictor_2x2_c
+
+void aom_highbd_dc_left_predictor_32x16_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_dc_left_predictor_32x16 aom_highbd_dc_left_predictor_32x16_c
+
+void aom_highbd_dc_left_predictor_32x32_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_dc_left_predictor_32x32 aom_highbd_dc_left_predictor_32x32_c
+
+void aom_highbd_dc_left_predictor_32x64_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_dc_left_predictor_32x64 aom_highbd_dc_left_predictor_32x64_c
+
+void aom_highbd_dc_left_predictor_32x8_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_left_predictor_32x8 aom_highbd_dc_left_predictor_32x8_c
+
+void aom_highbd_dc_left_predictor_4x16_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_left_predictor_4x16 aom_highbd_dc_left_predictor_4x16_c
+
+void aom_highbd_dc_left_predictor_4x4_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_left_predictor_4x4 aom_highbd_dc_left_predictor_4x4_c
+
+void aom_highbd_dc_left_predictor_4x8_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_left_predictor_4x8 aom_highbd_dc_left_predictor_4x8_c
+
+void aom_highbd_dc_left_predictor_64x16_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_dc_left_predictor_64x16 aom_highbd_dc_left_predictor_64x16_c
+
+void aom_highbd_dc_left_predictor_64x32_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_dc_left_predictor_64x32 aom_highbd_dc_left_predictor_64x32_c
+
+void aom_highbd_dc_left_predictor_64x64_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_dc_left_predictor_64x64 aom_highbd_dc_left_predictor_64x64_c
+
+void aom_highbd_dc_left_predictor_8x16_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_left_predictor_8x16 aom_highbd_dc_left_predictor_8x16_c
+
+void aom_highbd_dc_left_predictor_8x32_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_left_predictor_8x32 aom_highbd_dc_left_predictor_8x32_c
+
+void aom_highbd_dc_left_predictor_8x4_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_left_predictor_8x4 aom_highbd_dc_left_predictor_8x4_c
+
+void aom_highbd_dc_left_predictor_8x8_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_left_predictor_8x8 aom_highbd_dc_left_predictor_8x8_c
+
+void aom_highbd_dc_predictor_16x16_c(uint16_t* dst,
+                                     ptrdiff_t y_stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define aom_highbd_dc_predictor_16x16 aom_highbd_dc_predictor_16x16_c
+
+void aom_highbd_dc_predictor_16x32_c(uint16_t* dst,
+                                     ptrdiff_t y_stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define aom_highbd_dc_predictor_16x32 aom_highbd_dc_predictor_16x32_c
+
+void aom_highbd_dc_predictor_16x4_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_dc_predictor_16x4 aom_highbd_dc_predictor_16x4_c
+
+void aom_highbd_dc_predictor_16x64_c(uint16_t* dst,
+                                     ptrdiff_t y_stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define aom_highbd_dc_predictor_16x64 aom_highbd_dc_predictor_16x64_c
+
+void aom_highbd_dc_predictor_16x8_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_dc_predictor_16x8 aom_highbd_dc_predictor_16x8_c
+
+void aom_highbd_dc_predictor_2x2_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_dc_predictor_2x2 aom_highbd_dc_predictor_2x2_c
+
+void aom_highbd_dc_predictor_32x16_c(uint16_t* dst,
+                                     ptrdiff_t y_stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define aom_highbd_dc_predictor_32x16 aom_highbd_dc_predictor_32x16_c
+
+void aom_highbd_dc_predictor_32x32_c(uint16_t* dst,
+                                     ptrdiff_t y_stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define aom_highbd_dc_predictor_32x32 aom_highbd_dc_predictor_32x32_c
+
+void aom_highbd_dc_predictor_32x64_c(uint16_t* dst,
+                                     ptrdiff_t y_stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define aom_highbd_dc_predictor_32x64 aom_highbd_dc_predictor_32x64_c
+
+void aom_highbd_dc_predictor_32x8_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_dc_predictor_32x8 aom_highbd_dc_predictor_32x8_c
+
+void aom_highbd_dc_predictor_4x16_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_dc_predictor_4x16 aom_highbd_dc_predictor_4x16_c
+
+void aom_highbd_dc_predictor_4x4_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_dc_predictor_4x4 aom_highbd_dc_predictor_4x4_c
+
+void aom_highbd_dc_predictor_4x8_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_dc_predictor_4x8 aom_highbd_dc_predictor_4x8_c
+
+void aom_highbd_dc_predictor_64x16_c(uint16_t* dst,
+                                     ptrdiff_t y_stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define aom_highbd_dc_predictor_64x16 aom_highbd_dc_predictor_64x16_c
+
+void aom_highbd_dc_predictor_64x32_c(uint16_t* dst,
+                                     ptrdiff_t y_stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define aom_highbd_dc_predictor_64x32 aom_highbd_dc_predictor_64x32_c
+
+void aom_highbd_dc_predictor_64x64_c(uint16_t* dst,
+                                     ptrdiff_t y_stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define aom_highbd_dc_predictor_64x64 aom_highbd_dc_predictor_64x64_c
+
+void aom_highbd_dc_predictor_8x16_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_dc_predictor_8x16 aom_highbd_dc_predictor_8x16_c
+
+void aom_highbd_dc_predictor_8x32_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_dc_predictor_8x32 aom_highbd_dc_predictor_8x32_c
+
+void aom_highbd_dc_predictor_8x4_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_dc_predictor_8x4 aom_highbd_dc_predictor_8x4_c
+
+void aom_highbd_dc_predictor_8x8_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_dc_predictor_8x8 aom_highbd_dc_predictor_8x8_c
+
+void aom_highbd_dc_top_predictor_16x16_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_top_predictor_16x16 aom_highbd_dc_top_predictor_16x16_c
+
+void aom_highbd_dc_top_predictor_16x32_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_top_predictor_16x32 aom_highbd_dc_top_predictor_16x32_c
+
+void aom_highbd_dc_top_predictor_16x4_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_top_predictor_16x4 aom_highbd_dc_top_predictor_16x4_c
+
+void aom_highbd_dc_top_predictor_16x64_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_top_predictor_16x64 aom_highbd_dc_top_predictor_16x64_c
+
+void aom_highbd_dc_top_predictor_16x8_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_top_predictor_16x8 aom_highbd_dc_top_predictor_16x8_c
+
+void aom_highbd_dc_top_predictor_2x2_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_dc_top_predictor_2x2 aom_highbd_dc_top_predictor_2x2_c
+
+void aom_highbd_dc_top_predictor_32x16_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_top_predictor_32x16 aom_highbd_dc_top_predictor_32x16_c
+
+void aom_highbd_dc_top_predictor_32x32_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_top_predictor_32x32 aom_highbd_dc_top_predictor_32x32_c
+
+void aom_highbd_dc_top_predictor_32x64_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_top_predictor_32x64 aom_highbd_dc_top_predictor_32x64_c
+
+void aom_highbd_dc_top_predictor_32x8_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_top_predictor_32x8 aom_highbd_dc_top_predictor_32x8_c
+
+void aom_highbd_dc_top_predictor_4x16_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_top_predictor_4x16 aom_highbd_dc_top_predictor_4x16_c
+
+void aom_highbd_dc_top_predictor_4x4_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_dc_top_predictor_4x4 aom_highbd_dc_top_predictor_4x4_c
+
+void aom_highbd_dc_top_predictor_4x8_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_dc_top_predictor_4x8 aom_highbd_dc_top_predictor_4x8_c
+
+void aom_highbd_dc_top_predictor_64x16_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_top_predictor_64x16 aom_highbd_dc_top_predictor_64x16_c
+
+void aom_highbd_dc_top_predictor_64x32_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_top_predictor_64x32 aom_highbd_dc_top_predictor_64x32_c
+
+void aom_highbd_dc_top_predictor_64x64_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_dc_top_predictor_64x64 aom_highbd_dc_top_predictor_64x64_c
+
+void aom_highbd_dc_top_predictor_8x16_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_top_predictor_8x16 aom_highbd_dc_top_predictor_8x16_c
+
+void aom_highbd_dc_top_predictor_8x32_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_dc_top_predictor_8x32 aom_highbd_dc_top_predictor_8x32_c
+
+void aom_highbd_dc_top_predictor_8x4_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_dc_top_predictor_8x4 aom_highbd_dc_top_predictor_8x4_c
+
+void aom_highbd_dc_top_predictor_8x8_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_dc_top_predictor_8x8 aom_highbd_dc_top_predictor_8x8_c
+
+void aom_highbd_h_predictor_16x16_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_h_predictor_16x16 aom_highbd_h_predictor_16x16_c
+
+void aom_highbd_h_predictor_16x32_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_h_predictor_16x32 aom_highbd_h_predictor_16x32_c
+
+void aom_highbd_h_predictor_16x4_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_h_predictor_16x4 aom_highbd_h_predictor_16x4_c
+
+void aom_highbd_h_predictor_16x64_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_h_predictor_16x64 aom_highbd_h_predictor_16x64_c
+
+void aom_highbd_h_predictor_16x8_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_h_predictor_16x8 aom_highbd_h_predictor_16x8_c
+
+void aom_highbd_h_predictor_2x2_c(uint16_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define aom_highbd_h_predictor_2x2 aom_highbd_h_predictor_2x2_c
+
+void aom_highbd_h_predictor_32x16_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_h_predictor_32x16 aom_highbd_h_predictor_32x16_c
+
+void aom_highbd_h_predictor_32x32_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_h_predictor_32x32 aom_highbd_h_predictor_32x32_c
+
+void aom_highbd_h_predictor_32x64_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_h_predictor_32x64 aom_highbd_h_predictor_32x64_c
+
+void aom_highbd_h_predictor_32x8_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_h_predictor_32x8 aom_highbd_h_predictor_32x8_c
+
+void aom_highbd_h_predictor_4x16_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_h_predictor_4x16 aom_highbd_h_predictor_4x16_c
+
+void aom_highbd_h_predictor_4x4_c(uint16_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define aom_highbd_h_predictor_4x4 aom_highbd_h_predictor_4x4_c
+
+void aom_highbd_h_predictor_4x8_c(uint16_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define aom_highbd_h_predictor_4x8 aom_highbd_h_predictor_4x8_c
+
+void aom_highbd_h_predictor_64x16_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_h_predictor_64x16 aom_highbd_h_predictor_64x16_c
+
+void aom_highbd_h_predictor_64x32_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_h_predictor_64x32 aom_highbd_h_predictor_64x32_c
+
+void aom_highbd_h_predictor_64x64_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_h_predictor_64x64 aom_highbd_h_predictor_64x64_c
+
+void aom_highbd_h_predictor_8x16_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_h_predictor_8x16 aom_highbd_h_predictor_8x16_c
+
+void aom_highbd_h_predictor_8x32_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_h_predictor_8x32 aom_highbd_h_predictor_8x32_c
+
+void aom_highbd_h_predictor_8x4_c(uint16_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define aom_highbd_h_predictor_8x4 aom_highbd_h_predictor_8x4_c
+
+void aom_highbd_h_predictor_8x8_c(uint16_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define aom_highbd_h_predictor_8x8 aom_highbd_h_predictor_8x8_c
+
+void aom_highbd_lpf_horizontal_14_c(uint16_t* s,
+                                    int pitch,
+                                    const uint8_t* blimit,
+                                    const uint8_t* limit,
+                                    const uint8_t* thresh,
+                                    int bd);
+#define aom_highbd_lpf_horizontal_14 aom_highbd_lpf_horizontal_14_c
+
+void aom_highbd_lpf_horizontal_14_dual_c(uint16_t* s,
+                                         int pitch,
+                                         const uint8_t* blimit0,
+                                         const uint8_t* limit0,
+                                         const uint8_t* thresh0,
+                                         const uint8_t* blimit1,
+                                         const uint8_t* limt1,
+                                         const uint8_t* thresh1,
+                                         int bd);
+#define aom_highbd_lpf_horizontal_14_dual aom_highbd_lpf_horizontal_14_dual_c
+
+void aom_highbd_lpf_horizontal_4_c(uint16_t* s,
+                                   int pitch,
+                                   const uint8_t* blimit,
+                                   const uint8_t* limit,
+                                   const uint8_t* thresh,
+                                   int bd);
+#define aom_highbd_lpf_horizontal_4 aom_highbd_lpf_horizontal_4_c
+
+void aom_highbd_lpf_horizontal_4_dual_c(uint16_t* s,
+                                        int pitch,
+                                        const uint8_t* blimit0,
+                                        const uint8_t* limit0,
+                                        const uint8_t* thresh0,
+                                        const uint8_t* blimit1,
+                                        const uint8_t* limit1,
+                                        const uint8_t* thresh1,
+                                        int bd);
+#define aom_highbd_lpf_horizontal_4_dual aom_highbd_lpf_horizontal_4_dual_c
+
+void aom_highbd_lpf_horizontal_6_c(uint16_t* s,
+                                   int pitch,
+                                   const uint8_t* blimit,
+                                   const uint8_t* limit,
+                                   const uint8_t* thresh,
+                                   int bd);
+#define aom_highbd_lpf_horizontal_6 aom_highbd_lpf_horizontal_6_c
+
+void aom_highbd_lpf_horizontal_6_dual_c(uint16_t* s,
+                                        int pitch,
+                                        const uint8_t* blimit0,
+                                        const uint8_t* limit0,
+                                        const uint8_t* thresh0,
+                                        const uint8_t* blimit1,
+                                        const uint8_t* limit1,
+                                        const uint8_t* thresh1,
+                                        int bd);
+#define aom_highbd_lpf_horizontal_6_dual aom_highbd_lpf_horizontal_6_dual_c
+
+void aom_highbd_lpf_horizontal_8_c(uint16_t* s,
+                                   int pitch,
+                                   const uint8_t* blimit,
+                                   const uint8_t* limit,
+                                   const uint8_t* thresh,
+                                   int bd);
+#define aom_highbd_lpf_horizontal_8 aom_highbd_lpf_horizontal_8_c
+
+void aom_highbd_lpf_horizontal_8_dual_c(uint16_t* s,
+                                        int pitch,
+                                        const uint8_t* blimit0,
+                                        const uint8_t* limit0,
+                                        const uint8_t* thresh0,
+                                        const uint8_t* blimit1,
+                                        const uint8_t* limit1,
+                                        const uint8_t* thresh1,
+                                        int bd);
+#define aom_highbd_lpf_horizontal_8_dual aom_highbd_lpf_horizontal_8_dual_c
+
+void aom_highbd_lpf_vertical_14_c(uint16_t* s,
+                                  int pitch,
+                                  const uint8_t* blimit,
+                                  const uint8_t* limit,
+                                  const uint8_t* thresh,
+                                  int bd);
+#define aom_highbd_lpf_vertical_14 aom_highbd_lpf_vertical_14_c
+
+void aom_highbd_lpf_vertical_14_dual_c(uint16_t* s,
+                                       int pitch,
+                                       const uint8_t* blimit0,
+                                       const uint8_t* limit0,
+                                       const uint8_t* thresh0,
+                                       const uint8_t* blimit1,
+                                       const uint8_t* limit1,
+                                       const uint8_t* thresh1,
+                                       int bd);
+#define aom_highbd_lpf_vertical_14_dual aom_highbd_lpf_vertical_14_dual_c
+
+void aom_highbd_lpf_vertical_4_c(uint16_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit,
+                                 const uint8_t* limit,
+                                 const uint8_t* thresh,
+                                 int bd);
+#define aom_highbd_lpf_vertical_4 aom_highbd_lpf_vertical_4_c
+
+void aom_highbd_lpf_vertical_4_dual_c(uint16_t* s,
+                                      int pitch,
+                                      const uint8_t* blimit0,
+                                      const uint8_t* limit0,
+                                      const uint8_t* thresh0,
+                                      const uint8_t* blimit1,
+                                      const uint8_t* limit1,
+                                      const uint8_t* thresh1,
+                                      int bd);
+#define aom_highbd_lpf_vertical_4_dual aom_highbd_lpf_vertical_4_dual_c
+
+void aom_highbd_lpf_vertical_6_c(uint16_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit,
+                                 const uint8_t* limit,
+                                 const uint8_t* thresh,
+                                 int bd);
+#define aom_highbd_lpf_vertical_6 aom_highbd_lpf_vertical_6_c
+
+void aom_highbd_lpf_vertical_6_dual_c(uint16_t* s,
+                                      int pitch,
+                                      const uint8_t* blimit0,
+                                      const uint8_t* limit0,
+                                      const uint8_t* thresh0,
+                                      const uint8_t* blimit1,
+                                      const uint8_t* limit1,
+                                      const uint8_t* thresh1,
+                                      int bd);
+#define aom_highbd_lpf_vertical_6_dual aom_highbd_lpf_vertical_6_dual_c
+
+void aom_highbd_lpf_vertical_8_c(uint16_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit,
+                                 const uint8_t* limit,
+                                 const uint8_t* thresh,
+                                 int bd);
+#define aom_highbd_lpf_vertical_8 aom_highbd_lpf_vertical_8_c
+
+void aom_highbd_lpf_vertical_8_dual_c(uint16_t* s,
+                                      int pitch,
+                                      const uint8_t* blimit0,
+                                      const uint8_t* limit0,
+                                      const uint8_t* thresh0,
+                                      const uint8_t* blimit1,
+                                      const uint8_t* limit1,
+                                      const uint8_t* thresh1,
+                                      int bd);
+#define aom_highbd_lpf_vertical_8_dual aom_highbd_lpf_vertical_8_dual_c
+
+void aom_highbd_paeth_predictor_16x16_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_paeth_predictor_16x16 aom_highbd_paeth_predictor_16x16_c
+
+void aom_highbd_paeth_predictor_16x32_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_paeth_predictor_16x32 aom_highbd_paeth_predictor_16x32_c
+
+void aom_highbd_paeth_predictor_16x4_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_paeth_predictor_16x4 aom_highbd_paeth_predictor_16x4_c
+
+void aom_highbd_paeth_predictor_16x64_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_paeth_predictor_16x64 aom_highbd_paeth_predictor_16x64_c
+
+void aom_highbd_paeth_predictor_16x8_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_paeth_predictor_16x8 aom_highbd_paeth_predictor_16x8_c
+
+void aom_highbd_paeth_predictor_2x2_c(uint16_t* dst,
+                                      ptrdiff_t y_stride,
+                                      const uint16_t* above,
+                                      const uint16_t* left,
+                                      int bd);
+#define aom_highbd_paeth_predictor_2x2 aom_highbd_paeth_predictor_2x2_c
+
+void aom_highbd_paeth_predictor_32x16_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_paeth_predictor_32x16 aom_highbd_paeth_predictor_32x16_c
+
+void aom_highbd_paeth_predictor_32x32_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_paeth_predictor_32x32 aom_highbd_paeth_predictor_32x32_c
+
+void aom_highbd_paeth_predictor_32x64_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_paeth_predictor_32x64 aom_highbd_paeth_predictor_32x64_c
+
+void aom_highbd_paeth_predictor_32x8_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_paeth_predictor_32x8 aom_highbd_paeth_predictor_32x8_c
+
+void aom_highbd_paeth_predictor_4x16_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_paeth_predictor_4x16 aom_highbd_paeth_predictor_4x16_c
+
+void aom_highbd_paeth_predictor_4x4_c(uint16_t* dst,
+                                      ptrdiff_t y_stride,
+                                      const uint16_t* above,
+                                      const uint16_t* left,
+                                      int bd);
+#define aom_highbd_paeth_predictor_4x4 aom_highbd_paeth_predictor_4x4_c
+
+void aom_highbd_paeth_predictor_4x8_c(uint16_t* dst,
+                                      ptrdiff_t y_stride,
+                                      const uint16_t* above,
+                                      const uint16_t* left,
+                                      int bd);
+#define aom_highbd_paeth_predictor_4x8 aom_highbd_paeth_predictor_4x8_c
+
+void aom_highbd_paeth_predictor_64x16_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_paeth_predictor_64x16 aom_highbd_paeth_predictor_64x16_c
+
+void aom_highbd_paeth_predictor_64x32_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_paeth_predictor_64x32 aom_highbd_paeth_predictor_64x32_c
+
+void aom_highbd_paeth_predictor_64x64_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_paeth_predictor_64x64 aom_highbd_paeth_predictor_64x64_c
+
+void aom_highbd_paeth_predictor_8x16_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_paeth_predictor_8x16 aom_highbd_paeth_predictor_8x16_c
+
+void aom_highbd_paeth_predictor_8x32_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_paeth_predictor_8x32 aom_highbd_paeth_predictor_8x32_c
+
+void aom_highbd_paeth_predictor_8x4_c(uint16_t* dst,
+                                      ptrdiff_t y_stride,
+                                      const uint16_t* above,
+                                      const uint16_t* left,
+                                      int bd);
+#define aom_highbd_paeth_predictor_8x4 aom_highbd_paeth_predictor_8x4_c
+
+void aom_highbd_paeth_predictor_8x8_c(uint16_t* dst,
+                                      ptrdiff_t y_stride,
+                                      const uint16_t* above,
+                                      const uint16_t* left,
+                                      int bd);
+#define aom_highbd_paeth_predictor_8x8 aom_highbd_paeth_predictor_8x8_c
+
+void aom_highbd_smooth_h_predictor_16x16_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_h_predictor_16x16 \
+  aom_highbd_smooth_h_predictor_16x16_c
+
+void aom_highbd_smooth_h_predictor_16x32_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_h_predictor_16x32 \
+  aom_highbd_smooth_h_predictor_16x32_c
+
+void aom_highbd_smooth_h_predictor_16x4_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_smooth_h_predictor_16x4 aom_highbd_smooth_h_predictor_16x4_c
+
+void aom_highbd_smooth_h_predictor_16x64_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_h_predictor_16x64 \
+  aom_highbd_smooth_h_predictor_16x64_c
+
+void aom_highbd_smooth_h_predictor_16x8_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_smooth_h_predictor_16x8 aom_highbd_smooth_h_predictor_16x8_c
+
+void aom_highbd_smooth_h_predictor_2x2_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_h_predictor_2x2 aom_highbd_smooth_h_predictor_2x2_c
+
+void aom_highbd_smooth_h_predictor_32x16_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_h_predictor_32x16 \
+  aom_highbd_smooth_h_predictor_32x16_c
+
+void aom_highbd_smooth_h_predictor_32x32_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_h_predictor_32x32 \
+  aom_highbd_smooth_h_predictor_32x32_c
+
+void aom_highbd_smooth_h_predictor_32x64_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_h_predictor_32x64 \
+  aom_highbd_smooth_h_predictor_32x64_c
+
+void aom_highbd_smooth_h_predictor_32x8_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_smooth_h_predictor_32x8 aom_highbd_smooth_h_predictor_32x8_c
+
+void aom_highbd_smooth_h_predictor_4x16_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_smooth_h_predictor_4x16 aom_highbd_smooth_h_predictor_4x16_c
+
+void aom_highbd_smooth_h_predictor_4x4_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_h_predictor_4x4 aom_highbd_smooth_h_predictor_4x4_c
+
+void aom_highbd_smooth_h_predictor_4x8_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_h_predictor_4x8 aom_highbd_smooth_h_predictor_4x8_c
+
+void aom_highbd_smooth_h_predictor_64x16_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_h_predictor_64x16 \
+  aom_highbd_smooth_h_predictor_64x16_c
+
+void aom_highbd_smooth_h_predictor_64x32_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_h_predictor_64x32 \
+  aom_highbd_smooth_h_predictor_64x32_c
+
+void aom_highbd_smooth_h_predictor_64x64_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_h_predictor_64x64 \
+  aom_highbd_smooth_h_predictor_64x64_c
+
+void aom_highbd_smooth_h_predictor_8x16_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_smooth_h_predictor_8x16 aom_highbd_smooth_h_predictor_8x16_c
+
+void aom_highbd_smooth_h_predictor_8x32_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_smooth_h_predictor_8x32 aom_highbd_smooth_h_predictor_8x32_c
+
+void aom_highbd_smooth_h_predictor_8x4_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_h_predictor_8x4 aom_highbd_smooth_h_predictor_8x4_c
+
+void aom_highbd_smooth_h_predictor_8x8_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_h_predictor_8x8 aom_highbd_smooth_h_predictor_8x8_c
+
+void aom_highbd_smooth_predictor_16x16_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_predictor_16x16 aom_highbd_smooth_predictor_16x16_c
+
+void aom_highbd_smooth_predictor_16x32_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_predictor_16x32 aom_highbd_smooth_predictor_16x32_c
+
+void aom_highbd_smooth_predictor_16x4_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_smooth_predictor_16x4 aom_highbd_smooth_predictor_16x4_c
+
+void aom_highbd_smooth_predictor_16x64_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_predictor_16x64 aom_highbd_smooth_predictor_16x64_c
+
+void aom_highbd_smooth_predictor_16x8_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_smooth_predictor_16x8 aom_highbd_smooth_predictor_16x8_c
+
+void aom_highbd_smooth_predictor_2x2_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_smooth_predictor_2x2 aom_highbd_smooth_predictor_2x2_c
+
+void aom_highbd_smooth_predictor_32x16_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_predictor_32x16 aom_highbd_smooth_predictor_32x16_c
+
+void aom_highbd_smooth_predictor_32x32_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_predictor_32x32 aom_highbd_smooth_predictor_32x32_c
+
+void aom_highbd_smooth_predictor_32x64_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_predictor_32x64 aom_highbd_smooth_predictor_32x64_c
+
+void aom_highbd_smooth_predictor_32x8_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_smooth_predictor_32x8 aom_highbd_smooth_predictor_32x8_c
+
+void aom_highbd_smooth_predictor_4x16_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_smooth_predictor_4x16 aom_highbd_smooth_predictor_4x16_c
+
+void aom_highbd_smooth_predictor_4x4_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_smooth_predictor_4x4 aom_highbd_smooth_predictor_4x4_c
+
+void aom_highbd_smooth_predictor_4x8_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_smooth_predictor_4x8 aom_highbd_smooth_predictor_4x8_c
+
+void aom_highbd_smooth_predictor_64x16_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_predictor_64x16 aom_highbd_smooth_predictor_64x16_c
+
+void aom_highbd_smooth_predictor_64x32_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_predictor_64x32 aom_highbd_smooth_predictor_64x32_c
+
+void aom_highbd_smooth_predictor_64x64_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_predictor_64x64 aom_highbd_smooth_predictor_64x64_c
+
+void aom_highbd_smooth_predictor_8x16_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_smooth_predictor_8x16 aom_highbd_smooth_predictor_8x16_c
+
+void aom_highbd_smooth_predictor_8x32_c(uint16_t* dst,
+                                        ptrdiff_t y_stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define aom_highbd_smooth_predictor_8x32 aom_highbd_smooth_predictor_8x32_c
+
+void aom_highbd_smooth_predictor_8x4_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_smooth_predictor_8x4 aom_highbd_smooth_predictor_8x4_c
+
+void aom_highbd_smooth_predictor_8x8_c(uint16_t* dst,
+                                       ptrdiff_t y_stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define aom_highbd_smooth_predictor_8x8 aom_highbd_smooth_predictor_8x8_c
+
+void aom_highbd_smooth_v_predictor_16x16_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_v_predictor_16x16 \
+  aom_highbd_smooth_v_predictor_16x16_c
+
+void aom_highbd_smooth_v_predictor_16x32_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_v_predictor_16x32 \
+  aom_highbd_smooth_v_predictor_16x32_c
+
+void aom_highbd_smooth_v_predictor_16x4_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_smooth_v_predictor_16x4 aom_highbd_smooth_v_predictor_16x4_c
+
+void aom_highbd_smooth_v_predictor_16x64_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_v_predictor_16x64 \
+  aom_highbd_smooth_v_predictor_16x64_c
+
+void aom_highbd_smooth_v_predictor_16x8_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_smooth_v_predictor_16x8 aom_highbd_smooth_v_predictor_16x8_c
+
+void aom_highbd_smooth_v_predictor_2x2_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_v_predictor_2x2 aom_highbd_smooth_v_predictor_2x2_c
+
+void aom_highbd_smooth_v_predictor_32x16_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_v_predictor_32x16 \
+  aom_highbd_smooth_v_predictor_32x16_c
+
+void aom_highbd_smooth_v_predictor_32x32_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_v_predictor_32x32 \
+  aom_highbd_smooth_v_predictor_32x32_c
+
+void aom_highbd_smooth_v_predictor_32x64_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_v_predictor_32x64 \
+  aom_highbd_smooth_v_predictor_32x64_c
+
+void aom_highbd_smooth_v_predictor_32x8_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_smooth_v_predictor_32x8 aom_highbd_smooth_v_predictor_32x8_c
+
+void aom_highbd_smooth_v_predictor_4x16_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_smooth_v_predictor_4x16 aom_highbd_smooth_v_predictor_4x16_c
+
+void aom_highbd_smooth_v_predictor_4x4_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_v_predictor_4x4 aom_highbd_smooth_v_predictor_4x4_c
+
+void aom_highbd_smooth_v_predictor_4x8_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_v_predictor_4x8 aom_highbd_smooth_v_predictor_4x8_c
+
+void aom_highbd_smooth_v_predictor_64x16_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_v_predictor_64x16 \
+  aom_highbd_smooth_v_predictor_64x16_c
+
+void aom_highbd_smooth_v_predictor_64x32_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_v_predictor_64x32 \
+  aom_highbd_smooth_v_predictor_64x32_c
+
+void aom_highbd_smooth_v_predictor_64x64_c(uint16_t* dst,
+                                           ptrdiff_t y_stride,
+                                           const uint16_t* above,
+                                           const uint16_t* left,
+                                           int bd);
+#define aom_highbd_smooth_v_predictor_64x64 \
+  aom_highbd_smooth_v_predictor_64x64_c
+
+void aom_highbd_smooth_v_predictor_8x16_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_smooth_v_predictor_8x16 aom_highbd_smooth_v_predictor_8x16_c
+
+void aom_highbd_smooth_v_predictor_8x32_c(uint16_t* dst,
+                                          ptrdiff_t y_stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define aom_highbd_smooth_v_predictor_8x32 aom_highbd_smooth_v_predictor_8x32_c
+
+void aom_highbd_smooth_v_predictor_8x4_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_v_predictor_8x4 aom_highbd_smooth_v_predictor_8x4_c
+
+void aom_highbd_smooth_v_predictor_8x8_c(uint16_t* dst,
+                                         ptrdiff_t y_stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define aom_highbd_smooth_v_predictor_8x8 aom_highbd_smooth_v_predictor_8x8_c
+
+void aom_highbd_v_predictor_16x16_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_v_predictor_16x16 aom_highbd_v_predictor_16x16_c
+
+void aom_highbd_v_predictor_16x32_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_v_predictor_16x32 aom_highbd_v_predictor_16x32_c
+
+void aom_highbd_v_predictor_16x4_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_v_predictor_16x4 aom_highbd_v_predictor_16x4_c
+
+void aom_highbd_v_predictor_16x64_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_v_predictor_16x64 aom_highbd_v_predictor_16x64_c
+
+void aom_highbd_v_predictor_16x8_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_v_predictor_16x8 aom_highbd_v_predictor_16x8_c
+
+void aom_highbd_v_predictor_2x2_c(uint16_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define aom_highbd_v_predictor_2x2 aom_highbd_v_predictor_2x2_c
+
+void aom_highbd_v_predictor_32x16_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_v_predictor_32x16 aom_highbd_v_predictor_32x16_c
+
+void aom_highbd_v_predictor_32x32_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_v_predictor_32x32 aom_highbd_v_predictor_32x32_c
+
+void aom_highbd_v_predictor_32x64_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_v_predictor_32x64 aom_highbd_v_predictor_32x64_c
+
+void aom_highbd_v_predictor_32x8_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_v_predictor_32x8 aom_highbd_v_predictor_32x8_c
+
+void aom_highbd_v_predictor_4x16_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_v_predictor_4x16 aom_highbd_v_predictor_4x16_c
+
+void aom_highbd_v_predictor_4x4_c(uint16_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define aom_highbd_v_predictor_4x4 aom_highbd_v_predictor_4x4_c
+
+void aom_highbd_v_predictor_4x8_c(uint16_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define aom_highbd_v_predictor_4x8 aom_highbd_v_predictor_4x8_c
+
+void aom_highbd_v_predictor_64x16_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_v_predictor_64x16 aom_highbd_v_predictor_64x16_c
+
+void aom_highbd_v_predictor_64x32_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_v_predictor_64x32 aom_highbd_v_predictor_64x32_c
+
+void aom_highbd_v_predictor_64x64_c(uint16_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define aom_highbd_v_predictor_64x64 aom_highbd_v_predictor_64x64_c
+
+void aom_highbd_v_predictor_8x16_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_v_predictor_8x16 aom_highbd_v_predictor_8x16_c
+
+void aom_highbd_v_predictor_8x32_c(uint16_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define aom_highbd_v_predictor_8x32 aom_highbd_v_predictor_8x32_c
+
+void aom_highbd_v_predictor_8x4_c(uint16_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define aom_highbd_v_predictor_8x4 aom_highbd_v_predictor_8x4_c
+
+void aom_highbd_v_predictor_8x8_c(uint16_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define aom_highbd_v_predictor_8x8 aom_highbd_v_predictor_8x8_c
+
+void aom_lowbd_blend_a64_d16_mask_c(uint8_t* dst,
+                                    uint32_t dst_stride,
+                                    const CONV_BUF_TYPE* src0,
+                                    uint32_t src0_stride,
+                                    const CONV_BUF_TYPE* src1,
+                                    uint32_t src1_stride,
+                                    const uint8_t* mask,
+                                    uint32_t mask_stride,
+                                    int w,
+                                    int h,
+                                    int subx,
+                                    int suby,
+                                    ConvolveParams* conv_params);
+#define aom_lowbd_blend_a64_d16_mask aom_lowbd_blend_a64_d16_mask_c
+
+void aom_lpf_horizontal_14_c(uint8_t* s,
+                             int pitch,
+                             const uint8_t* blimit,
+                             const uint8_t* limit,
+                             const uint8_t* thresh);
+#define aom_lpf_horizontal_14 aom_lpf_horizontal_14_c
+
+void aom_lpf_horizontal_14_dual_c(uint8_t* s,
+                                  int pitch,
+                                  const uint8_t* blimit0,
+                                  const uint8_t* limit0,
+                                  const uint8_t* thresh0,
+                                  const uint8_t* blimit1,
+                                  const uint8_t* limit1,
+                                  const uint8_t* thresh1);
+#define aom_lpf_horizontal_14_dual aom_lpf_horizontal_14_dual_c
+
+void aom_lpf_horizontal_4_c(uint8_t* s,
+                            int pitch,
+                            const uint8_t* blimit,
+                            const uint8_t* limit,
+                            const uint8_t* thresh);
+#define aom_lpf_horizontal_4 aom_lpf_horizontal_4_c
+
+void aom_lpf_horizontal_4_dual_c(uint8_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit0,
+                                 const uint8_t* limit0,
+                                 const uint8_t* thresh0,
+                                 const uint8_t* blimit1,
+                                 const uint8_t* limit1,
+                                 const uint8_t* thresh1);
+#define aom_lpf_horizontal_4_dual aom_lpf_horizontal_4_dual_c
+
+void aom_lpf_horizontal_6_c(uint8_t* s,
+                            int pitch,
+                            const uint8_t* blimit,
+                            const uint8_t* limit,
+                            const uint8_t* thresh);
+#define aom_lpf_horizontal_6 aom_lpf_horizontal_6_c
+
+void aom_lpf_horizontal_6_dual_c(uint8_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit0,
+                                 const uint8_t* limit0,
+                                 const uint8_t* thresh0,
+                                 const uint8_t* blimit1,
+                                 const uint8_t* limit1,
+                                 const uint8_t* thresh1);
+#define aom_lpf_horizontal_6_dual aom_lpf_horizontal_6_dual_c
+
+void aom_lpf_horizontal_8_c(uint8_t* s,
+                            int pitch,
+                            const uint8_t* blimit,
+                            const uint8_t* limit,
+                            const uint8_t* thresh);
+#define aom_lpf_horizontal_8 aom_lpf_horizontal_8_c
+
+void aom_lpf_horizontal_8_dual_c(uint8_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit0,
+                                 const uint8_t* limit0,
+                                 const uint8_t* thresh0,
+                                 const uint8_t* blimit1,
+                                 const uint8_t* limit1,
+                                 const uint8_t* thresh1);
+#define aom_lpf_horizontal_8_dual aom_lpf_horizontal_8_dual_c
+
+void aom_lpf_vertical_14_c(uint8_t* s,
+                           int pitch,
+                           const uint8_t* blimit,
+                           const uint8_t* limit,
+                           const uint8_t* thresh);
+#define aom_lpf_vertical_14 aom_lpf_vertical_14_c
+
+void aom_lpf_vertical_14_dual_c(uint8_t* s,
+                                int pitch,
+                                const uint8_t* blimit0,
+                                const uint8_t* limit0,
+                                const uint8_t* thresh0,
+                                const uint8_t* blimit1,
+                                const uint8_t* limit1,
+                                const uint8_t* thresh1);
+#define aom_lpf_vertical_14_dual aom_lpf_vertical_14_dual_c
+
+void aom_lpf_vertical_4_c(uint8_t* s,
+                          int pitch,
+                          const uint8_t* blimit,
+                          const uint8_t* limit,
+                          const uint8_t* thresh);
+#define aom_lpf_vertical_4 aom_lpf_vertical_4_c
+
+void aom_lpf_vertical_4_dual_c(uint8_t* s,
+                               int pitch,
+                               const uint8_t* blimit0,
+                               const uint8_t* limit0,
+                               const uint8_t* thresh0,
+                               const uint8_t* blimit1,
+                               const uint8_t* limit1,
+                               const uint8_t* thresh1);
+#define aom_lpf_vertical_4_dual aom_lpf_vertical_4_dual_c
+
+void aom_lpf_vertical_6_c(uint8_t* s,
+                          int pitch,
+                          const uint8_t* blimit,
+                          const uint8_t* limit,
+                          const uint8_t* thresh);
+#define aom_lpf_vertical_6 aom_lpf_vertical_6_c
+
+void aom_lpf_vertical_6_dual_c(uint8_t* s,
+                               int pitch,
+                               const uint8_t* blimit0,
+                               const uint8_t* limit0,
+                               const uint8_t* thresh0,
+                               const uint8_t* blimit1,
+                               const uint8_t* limit1,
+                               const uint8_t* thresh1);
+#define aom_lpf_vertical_6_dual aom_lpf_vertical_6_dual_c
+
+void aom_lpf_vertical_8_c(uint8_t* s,
+                          int pitch,
+                          const uint8_t* blimit,
+                          const uint8_t* limit,
+                          const uint8_t* thresh);
+#define aom_lpf_vertical_8 aom_lpf_vertical_8_c
+
+void aom_lpf_vertical_8_dual_c(uint8_t* s,
+                               int pitch,
+                               const uint8_t* blimit0,
+                               const uint8_t* limit0,
+                               const uint8_t* thresh0,
+                               const uint8_t* blimit1,
+                               const uint8_t* limit1,
+                               const uint8_t* thresh1);
+#define aom_lpf_vertical_8_dual aom_lpf_vertical_8_dual_c
+
+void aom_paeth_predictor_16x16_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_paeth_predictor_16x16 aom_paeth_predictor_16x16_c
+
+void aom_paeth_predictor_16x32_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_paeth_predictor_16x32 aom_paeth_predictor_16x32_c
+
+void aom_paeth_predictor_16x4_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_paeth_predictor_16x4 aom_paeth_predictor_16x4_c
+
+void aom_paeth_predictor_16x64_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_paeth_predictor_16x64 aom_paeth_predictor_16x64_c
+
+void aom_paeth_predictor_16x8_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_paeth_predictor_16x8 aom_paeth_predictor_16x8_c
+
+void aom_paeth_predictor_2x2_c(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define aom_paeth_predictor_2x2 aom_paeth_predictor_2x2_c
+
+void aom_paeth_predictor_32x16_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_paeth_predictor_32x16 aom_paeth_predictor_32x16_c
+
+void aom_paeth_predictor_32x32_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_paeth_predictor_32x32 aom_paeth_predictor_32x32_c
+
+void aom_paeth_predictor_32x64_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_paeth_predictor_32x64 aom_paeth_predictor_32x64_c
+
+void aom_paeth_predictor_32x8_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_paeth_predictor_32x8 aom_paeth_predictor_32x8_c
+
+void aom_paeth_predictor_4x16_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_paeth_predictor_4x16 aom_paeth_predictor_4x16_c
+
+void aom_paeth_predictor_4x4_c(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define aom_paeth_predictor_4x4 aom_paeth_predictor_4x4_c
+
+void aom_paeth_predictor_4x8_c(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define aom_paeth_predictor_4x8 aom_paeth_predictor_4x8_c
+
+void aom_paeth_predictor_64x16_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_paeth_predictor_64x16 aom_paeth_predictor_64x16_c
+
+void aom_paeth_predictor_64x32_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_paeth_predictor_64x32 aom_paeth_predictor_64x32_c
+
+void aom_paeth_predictor_64x64_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_paeth_predictor_64x64 aom_paeth_predictor_64x64_c
+
+void aom_paeth_predictor_8x16_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_paeth_predictor_8x16 aom_paeth_predictor_8x16_c
+
+void aom_paeth_predictor_8x32_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_paeth_predictor_8x32 aom_paeth_predictor_8x32_c
+
+void aom_paeth_predictor_8x4_c(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define aom_paeth_predictor_8x4 aom_paeth_predictor_8x4_c
+
+void aom_paeth_predictor_8x8_c(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define aom_paeth_predictor_8x8 aom_paeth_predictor_8x8_c
+
+void aom_smooth_h_predictor_16x16_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_h_predictor_16x16 aom_smooth_h_predictor_16x16_c
+
+void aom_smooth_h_predictor_16x32_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_h_predictor_16x32 aom_smooth_h_predictor_16x32_c
+
+void aom_smooth_h_predictor_16x4_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_smooth_h_predictor_16x4 aom_smooth_h_predictor_16x4_c
+
+void aom_smooth_h_predictor_16x64_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_h_predictor_16x64 aom_smooth_h_predictor_16x64_c
+
+void aom_smooth_h_predictor_16x8_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_smooth_h_predictor_16x8 aom_smooth_h_predictor_16x8_c
+
+void aom_smooth_h_predictor_2x2_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_h_predictor_2x2 aom_smooth_h_predictor_2x2_c
+
+void aom_smooth_h_predictor_32x16_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_h_predictor_32x16 aom_smooth_h_predictor_32x16_c
+
+void aom_smooth_h_predictor_32x32_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_h_predictor_32x32 aom_smooth_h_predictor_32x32_c
+
+void aom_smooth_h_predictor_32x64_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_h_predictor_32x64 aom_smooth_h_predictor_32x64_c
+
+void aom_smooth_h_predictor_32x8_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_smooth_h_predictor_32x8 aom_smooth_h_predictor_32x8_c
+
+void aom_smooth_h_predictor_4x16_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_smooth_h_predictor_4x16 aom_smooth_h_predictor_4x16_c
+
+void aom_smooth_h_predictor_4x4_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_h_predictor_4x4 aom_smooth_h_predictor_4x4_c
+
+void aom_smooth_h_predictor_4x8_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_h_predictor_4x8 aom_smooth_h_predictor_4x8_c
+
+void aom_smooth_h_predictor_64x16_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_h_predictor_64x16 aom_smooth_h_predictor_64x16_c
+
+void aom_smooth_h_predictor_64x32_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_h_predictor_64x32 aom_smooth_h_predictor_64x32_c
+
+void aom_smooth_h_predictor_64x64_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_h_predictor_64x64 aom_smooth_h_predictor_64x64_c
+
+void aom_smooth_h_predictor_8x16_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_smooth_h_predictor_8x16 aom_smooth_h_predictor_8x16_c
+
+void aom_smooth_h_predictor_8x32_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_smooth_h_predictor_8x32 aom_smooth_h_predictor_8x32_c
+
+void aom_smooth_h_predictor_8x4_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_h_predictor_8x4 aom_smooth_h_predictor_8x4_c
+
+void aom_smooth_h_predictor_8x8_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_h_predictor_8x8 aom_smooth_h_predictor_8x8_c
+
+void aom_smooth_predictor_16x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_predictor_16x16 aom_smooth_predictor_16x16_c
+
+void aom_smooth_predictor_16x32_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_predictor_16x32 aom_smooth_predictor_16x32_c
+
+void aom_smooth_predictor_16x4_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_smooth_predictor_16x4 aom_smooth_predictor_16x4_c
+
+void aom_smooth_predictor_16x64_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_predictor_16x64 aom_smooth_predictor_16x64_c
+
+void aom_smooth_predictor_16x8_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_smooth_predictor_16x8 aom_smooth_predictor_16x8_c
+
+void aom_smooth_predictor_2x2_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_smooth_predictor_2x2 aom_smooth_predictor_2x2_c
+
+void aom_smooth_predictor_32x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_predictor_32x16 aom_smooth_predictor_32x16_c
+
+void aom_smooth_predictor_32x32_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_predictor_32x32 aom_smooth_predictor_32x32_c
+
+void aom_smooth_predictor_32x64_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_predictor_32x64 aom_smooth_predictor_32x64_c
+
+void aom_smooth_predictor_32x8_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_smooth_predictor_32x8 aom_smooth_predictor_32x8_c
+
+void aom_smooth_predictor_4x16_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_smooth_predictor_4x16 aom_smooth_predictor_4x16_c
+
+void aom_smooth_predictor_4x4_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_smooth_predictor_4x4 aom_smooth_predictor_4x4_c
+
+void aom_smooth_predictor_4x8_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_smooth_predictor_4x8 aom_smooth_predictor_4x8_c
+
+void aom_smooth_predictor_64x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_predictor_64x16 aom_smooth_predictor_64x16_c
+
+void aom_smooth_predictor_64x32_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_predictor_64x32 aom_smooth_predictor_64x32_c
+
+void aom_smooth_predictor_64x64_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_predictor_64x64 aom_smooth_predictor_64x64_c
+
+void aom_smooth_predictor_8x16_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_smooth_predictor_8x16 aom_smooth_predictor_8x16_c
+
+void aom_smooth_predictor_8x32_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define aom_smooth_predictor_8x32 aom_smooth_predictor_8x32_c
+
+void aom_smooth_predictor_8x4_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_smooth_predictor_8x4 aom_smooth_predictor_8x4_c
+
+void aom_smooth_predictor_8x8_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define aom_smooth_predictor_8x8 aom_smooth_predictor_8x8_c
+
+void aom_smooth_v_predictor_16x16_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_v_predictor_16x16 aom_smooth_v_predictor_16x16_c
+
+void aom_smooth_v_predictor_16x32_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_v_predictor_16x32 aom_smooth_v_predictor_16x32_c
+
+void aom_smooth_v_predictor_16x4_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_smooth_v_predictor_16x4 aom_smooth_v_predictor_16x4_c
+
+void aom_smooth_v_predictor_16x64_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_v_predictor_16x64 aom_smooth_v_predictor_16x64_c
+
+void aom_smooth_v_predictor_16x8_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_smooth_v_predictor_16x8 aom_smooth_v_predictor_16x8_c
+
+void aom_smooth_v_predictor_2x2_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_v_predictor_2x2 aom_smooth_v_predictor_2x2_c
+
+void aom_smooth_v_predictor_32x16_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_v_predictor_32x16 aom_smooth_v_predictor_32x16_c
+
+void aom_smooth_v_predictor_32x32_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_v_predictor_32x32 aom_smooth_v_predictor_32x32_c
+
+void aom_smooth_v_predictor_32x64_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_v_predictor_32x64 aom_smooth_v_predictor_32x64_c
+
+void aom_smooth_v_predictor_32x8_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_smooth_v_predictor_32x8 aom_smooth_v_predictor_32x8_c
+
+void aom_smooth_v_predictor_4x16_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_smooth_v_predictor_4x16 aom_smooth_v_predictor_4x16_c
+
+void aom_smooth_v_predictor_4x4_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_v_predictor_4x4 aom_smooth_v_predictor_4x4_c
+
+void aom_smooth_v_predictor_4x8_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_v_predictor_4x8 aom_smooth_v_predictor_4x8_c
+
+void aom_smooth_v_predictor_64x16_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_v_predictor_64x16 aom_smooth_v_predictor_64x16_c
+
+void aom_smooth_v_predictor_64x32_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_v_predictor_64x32 aom_smooth_v_predictor_64x32_c
+
+void aom_smooth_v_predictor_64x64_c(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define aom_smooth_v_predictor_64x64 aom_smooth_v_predictor_64x64_c
+
+void aom_smooth_v_predictor_8x16_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_smooth_v_predictor_8x16 aom_smooth_v_predictor_8x16_c
+
+void aom_smooth_v_predictor_8x32_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define aom_smooth_v_predictor_8x32 aom_smooth_v_predictor_8x32_c
+
+void aom_smooth_v_predictor_8x4_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_v_predictor_8x4 aom_smooth_v_predictor_8x4_c
+
+void aom_smooth_v_predictor_8x8_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define aom_smooth_v_predictor_8x8 aom_smooth_v_predictor_8x8_c
+
+void aom_v_predictor_16x16_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_v_predictor_16x16 aom_v_predictor_16x16_c
+
+void aom_v_predictor_16x32_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_v_predictor_16x32 aom_v_predictor_16x32_c
+
+void aom_v_predictor_16x4_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_v_predictor_16x4 aom_v_predictor_16x4_c
+
+void aom_v_predictor_16x64_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_v_predictor_16x64 aom_v_predictor_16x64_c
+
+void aom_v_predictor_16x8_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_v_predictor_16x8 aom_v_predictor_16x8_c
+
+void aom_v_predictor_2x2_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define aom_v_predictor_2x2 aom_v_predictor_2x2_c
+
+void aom_v_predictor_32x16_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_v_predictor_32x16 aom_v_predictor_32x16_c
+
+void aom_v_predictor_32x32_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_v_predictor_32x32 aom_v_predictor_32x32_c
+
+void aom_v_predictor_32x64_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_v_predictor_32x64 aom_v_predictor_32x64_c
+
+void aom_v_predictor_32x8_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_v_predictor_32x8 aom_v_predictor_32x8_c
+
+void aom_v_predictor_4x16_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_v_predictor_4x16 aom_v_predictor_4x16_c
+
+void aom_v_predictor_4x4_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define aom_v_predictor_4x4 aom_v_predictor_4x4_c
+
+void aom_v_predictor_4x8_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define aom_v_predictor_4x8 aom_v_predictor_4x8_c
+
+void aom_v_predictor_64x16_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_v_predictor_64x16 aom_v_predictor_64x16_c
+
+void aom_v_predictor_64x32_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_v_predictor_64x32 aom_v_predictor_64x32_c
+
+void aom_v_predictor_64x64_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define aom_v_predictor_64x64 aom_v_predictor_64x64_c
+
+void aom_v_predictor_8x16_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_v_predictor_8x16 aom_v_predictor_8x16_c
+
+void aom_v_predictor_8x32_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define aom_v_predictor_8x32 aom_v_predictor_8x32_c
+
+void aom_v_predictor_8x4_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define aom_v_predictor_8x4 aom_v_predictor_8x4_c
+
+void aom_v_predictor_8x8_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define aom_v_predictor_8x8 aom_v_predictor_8x8_c
+
+void aom_dsp_rtcd(void);
+
+#include "config/aom_config.h"
+
+#ifdef RTCD_C
+#include "aom_ports/ppc.h"
+static void setup_rtcd_internal(void) {
+  int flags = ppc_simd_caps();
+
+  (void)flags;
+}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_scale_rtcd.h b/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_scale_rtcd.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_scale_rtcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/aom_scale_rtcd.h	2025-05-30 15:28:03.000000000 +0800
@@ -0,0 +1,166 @@
+// This file is generated. Do not edit.
+#ifndef AOM_SCALE_RTCD_H_
+#define AOM_SCALE_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void aom_extend_frame_borders_c(struct yv12_buffer_config* ybf,
+                                const int num_planes);
+#define aom_extend_frame_borders aom_extend_frame_borders_c
+
+void aom_extend_frame_borders_y_c(struct yv12_buffer_config* ybf);
+#define aom_extend_frame_borders_y aom_extend_frame_borders_y_c
+
+void aom_extend_frame_inner_borders_c(struct yv12_buffer_config* ybf,
+                                      const int num_planes);
+#define aom_extend_frame_inner_borders aom_extend_frame_inner_borders_c
+
+void aom_horizontal_line_2_1_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define aom_horizontal_line_2_1_scale aom_horizontal_line_2_1_scale_c
+
+void aom_horizontal_line_5_3_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define aom_horizontal_line_5_3_scale aom_horizontal_line_5_3_scale_c
+
+void aom_horizontal_line_5_4_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define aom_horizontal_line_5_4_scale aom_horizontal_line_5_4_scale_c
+
+void aom_vertical_band_2_1_scale_c(unsigned char* source,
+                                   int src_pitch,
+                                   unsigned char* dest,
+                                   int dest_pitch,
+                                   unsigned int dest_width);
+#define aom_vertical_band_2_1_scale aom_vertical_band_2_1_scale_c
+
+void aom_vertical_band_2_1_scale_i_c(unsigned char* source,
+                                     int src_pitch,
+                                     unsigned char* dest,
+                                     int dest_pitch,
+                                     unsigned int dest_width);
+#define aom_vertical_band_2_1_scale_i aom_vertical_band_2_1_scale_i_c
+
+void aom_vertical_band_5_3_scale_c(unsigned char* source,
+                                   int src_pitch,
+                                   unsigned char* dest,
+                                   int dest_pitch,
+                                   unsigned int dest_width);
+#define aom_vertical_band_5_3_scale aom_vertical_band_5_3_scale_c
+
+void aom_vertical_band_5_4_scale_c(unsigned char* source,
+                                   int src_pitch,
+                                   unsigned char* dest,
+                                   int dest_pitch,
+                                   unsigned int dest_width);
+#define aom_vertical_band_5_4_scale aom_vertical_band_5_4_scale_c
+
+void aom_yv12_copy_frame_c(const struct yv12_buffer_config* src_bc,
+                           struct yv12_buffer_config* dst_bc,
+                           const int num_planes);
+#define aom_yv12_copy_frame aom_yv12_copy_frame_c
+
+void aom_yv12_copy_u_c(const struct yv12_buffer_config* src_bc,
+                       struct yv12_buffer_config* dst_bc);
+#define aom_yv12_copy_u aom_yv12_copy_u_c
+
+void aom_yv12_copy_v_c(const struct yv12_buffer_config* src_bc,
+                       struct yv12_buffer_config* dst_bc);
+#define aom_yv12_copy_v aom_yv12_copy_v_c
+
+void aom_yv12_copy_y_c(const struct yv12_buffer_config* src_ybc,
+                       struct yv12_buffer_config* dst_ybc);
+#define aom_yv12_copy_y aom_yv12_copy_y_c
+
+void aom_yv12_extend_frame_borders_c(struct yv12_buffer_config* ybf,
+                                     const int num_planes);
+#define aom_yv12_extend_frame_borders aom_yv12_extend_frame_borders_c
+
+void aom_yv12_partial_coloc_copy_u_c(const struct yv12_buffer_config* src_bc,
+                                     struct yv12_buffer_config* dst_bc,
+                                     int hstart,
+                                     int hend,
+                                     int vstart,
+                                     int vend);
+#define aom_yv12_partial_coloc_copy_u aom_yv12_partial_coloc_copy_u_c
+
+void aom_yv12_partial_coloc_copy_v_c(const struct yv12_buffer_config* src_bc,
+                                     struct yv12_buffer_config* dst_bc,
+                                     int hstart,
+                                     int hend,
+                                     int vstart,
+                                     int vend);
+#define aom_yv12_partial_coloc_copy_v aom_yv12_partial_coloc_copy_v_c
+
+void aom_yv12_partial_coloc_copy_y_c(const struct yv12_buffer_config* src_ybc,
+                                     struct yv12_buffer_config* dst_ybc,
+                                     int hstart,
+                                     int hend,
+                                     int vstart,
+                                     int vend);
+#define aom_yv12_partial_coloc_copy_y aom_yv12_partial_coloc_copy_y_c
+
+void aom_yv12_partial_copy_u_c(const struct yv12_buffer_config* src_bc,
+                               int hstart1,
+                               int hend1,
+                               int vstart1,
+                               int vend1,
+                               struct yv12_buffer_config* dst_bc,
+                               int hstart2,
+                               int vstart2);
+#define aom_yv12_partial_copy_u aom_yv12_partial_copy_u_c
+
+void aom_yv12_partial_copy_v_c(const struct yv12_buffer_config* src_bc,
+                               int hstart1,
+                               int hend1,
+                               int vstart1,
+                               int vend1,
+                               struct yv12_buffer_config* dst_bc,
+                               int hstart2,
+                               int vstart2);
+#define aom_yv12_partial_copy_v aom_yv12_partial_copy_v_c
+
+void aom_yv12_partial_copy_y_c(const struct yv12_buffer_config* src_ybc,
+                               int hstart1,
+                               int hend1,
+                               int vstart1,
+                               int vend1,
+                               struct yv12_buffer_config* dst_ybc,
+                               int hstart2,
+                               int vstart2);
+#define aom_yv12_partial_copy_y aom_yv12_partial_copy_y_c
+
+void aom_scale_rtcd(void);
+
+#include "config/aom_config.h"
+
+#ifdef RTCD_C
+#include "aom_ports/ppc.h"
+static void setup_rtcd_internal(void) {
+  int flags = ppc_simd_caps();
+
+  (void)flags;
+}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/av1_rtcd.h b/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/av1_rtcd.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/av1_rtcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libaom/source/config/linux/ppc64/config/av1_rtcd.h	2025-05-30 15:28:03.000000000 +0800
@@ -0,0 +1,896 @@
+// This file is generated. Do not edit.
+#ifndef AV1_RTCD_H_
+#define AV1_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * AV1
+ */
+
+#include "aom/aom_integer.h"
+#include "aom_dsp/txfm_common.h"
+#include "av1/common/av1_txfm.h"
+#include "av1/common/common.h"
+#include "av1/common/convolve.h"
+#include "av1/common/enums.h"
+#include "av1/common/filter.h"
+#include "av1/common/odintrin.h"
+#include "av1/common/quant_common.h"
+#include "av1/common/restoration.h"
+
+struct macroblockd;
+
+/* Encoder forward decls */
+struct macroblock;
+struct txfm_param;
+struct aom_variance_vtable;
+struct search_site_config;
+struct yv12_buffer_config;
+struct NN_CONFIG;
+typedef struct NN_CONFIG NN_CONFIG;
+
+/* Function pointers return by CfL functions */
+typedef void (*cfl_subsample_lbd_fn)(const uint8_t* input,
+                                     int input_stride,
+                                     uint16_t* output_q3);
+
+typedef void (*cfl_subsample_hbd_fn)(const uint16_t* input,
+                                     int input_stride,
+                                     uint16_t* output_q3);
+
+typedef void (*cfl_subtract_average_fn)(const uint16_t* src, int16_t* dst);
+
+typedef void (*cfl_predict_lbd_fn)(const int16_t* src,
+                                   uint8_t* dst,
+                                   int dst_stride,
+                                   int alpha_q3);
+
+typedef void (*cfl_predict_hbd_fn)(const int16_t* src,
+                                   uint16_t* dst,
+                                   int dst_stride,
+                                   int alpha_q3,
+                                   int bd);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void apply_selfguided_restoration_c(const uint8_t* dat,
+                                    int width,
+                                    int height,
+                                    int stride,
+                                    int eps,
+                                    const int* xqd,
+                                    uint8_t* dst,
+                                    int dst_stride,
+                                    int32_t* tmpbuf,
+                                    int bit_depth,
+                                    int highbd);
+#define apply_selfguided_restoration apply_selfguided_restoration_c
+
+void av1_build_compound_diffwtd_mask_c(uint8_t* mask,
+                                       DIFFWTD_MASK_TYPE mask_type,
+                                       const uint8_t* src0,
+                                       int src0_stride,
+                                       const uint8_t* src1,
+                                       int src1_stride,
+                                       int h,
+                                       int w);
+#define av1_build_compound_diffwtd_mask av1_build_compound_diffwtd_mask_c
+
+void av1_build_compound_diffwtd_mask_d16_c(uint8_t* mask,
+                                           DIFFWTD_MASK_TYPE mask_type,
+                                           const CONV_BUF_TYPE* src0,
+                                           int src0_stride,
+                                           const CONV_BUF_TYPE* src1,
+                                           int src1_stride,
+                                           int h,
+                                           int w,
+                                           ConvolveParams* conv_params,
+                                           int bd);
+#define av1_build_compound_diffwtd_mask_d16 \
+  av1_build_compound_diffwtd_mask_d16_c
+
+void av1_build_compound_diffwtd_mask_highbd_c(uint8_t* mask,
+                                              DIFFWTD_MASK_TYPE mask_type,
+                                              const uint8_t* src0,
+                                              int src0_stride,
+                                              const uint8_t* src1,
+                                              int src1_stride,
+                                              int h,
+                                              int w,
+                                              int bd);
+#define av1_build_compound_diffwtd_mask_highbd \
+  av1_build_compound_diffwtd_mask_highbd_c
+
+void av1_convolve_2d_copy_sr_c(const uint8_t* src,
+                               int src_stride,
+                               uint8_t* dst,
+                               int dst_stride,
+                               int w,
+                               int h,
+                               const InterpFilterParams* filter_params_x,
+                               const InterpFilterParams* filter_params_y,
+                               const int subpel_x_q4,
+                               const int subpel_y_q4,
+                               ConvolveParams* conv_params);
+#define av1_convolve_2d_copy_sr av1_convolve_2d_copy_sr_c
+
+void av1_convolve_2d_scale_c(const uint8_t* src,
+                             int src_stride,
+                             uint8_t* dst,
+                             int dst_stride,
+                             int w,
+                             int h,
+                             const InterpFilterParams* filter_params_x,
+                             const InterpFilterParams* filter_params_y,
+                             const int subpel_x_qn,
+                             const int x_step_qn,
+                             const int subpel_y_q4,
+                             const int y_step_qn,
+                             ConvolveParams* conv_params);
+#define av1_convolve_2d_scale av1_convolve_2d_scale_c
+
+void av1_convolve_2d_sr_c(const uint8_t* src,
+                          int src_stride,
+                          uint8_t* dst,
+                          int dst_stride,
+                          int w,
+                          int h,
+                          const InterpFilterParams* filter_params_x,
+                          const InterpFilterParams* filter_params_y,
+                          const int subpel_x_q4,
+                          const int subpel_y_q4,
+                          ConvolveParams* conv_params);
+#define av1_convolve_2d_sr av1_convolve_2d_sr_c
+
+void av1_convolve_horiz_rs_c(const uint8_t* src,
+                             int src_stride,
+                             uint8_t* dst,
+                             int dst_stride,
+                             int w,
+                             int h,
+                             const int16_t* x_filters,
+                             int x0_qn,
+                             int x_step_qn);
+#define av1_convolve_horiz_rs av1_convolve_horiz_rs_c
+
+void av1_convolve_x_sr_c(const uint8_t* src,
+                         int src_stride,
+                         uint8_t* dst,
+                         int dst_stride,
+                         int w,
+                         int h,
+                         const InterpFilterParams* filter_params_x,
+                         const InterpFilterParams* filter_params_y,
+                         const int subpel_x_q4,
+                         const int subpel_y_q4,
+                         ConvolveParams* conv_params);
+#define av1_convolve_x_sr av1_convolve_x_sr_c
+
+void av1_convolve_y_sr_c(const uint8_t* src,
+                         int src_stride,
+                         uint8_t* dst,
+                         int dst_stride,
+                         int w,
+                         int h,
+                         const InterpFilterParams* filter_params_x,
+                         const InterpFilterParams* filter_params_y,
+                         const int subpel_x_q4,
+                         const int subpel_y_q4,
+                         ConvolveParams* conv_params);
+#define av1_convolve_y_sr av1_convolve_y_sr_c
+
+void av1_dist_wtd_convolve_2d_c(const uint8_t* src,
+                                int src_stride,
+                                uint8_t* dst,
+                                int dst_stride,
+                                int w,
+                                int h,
+                                const InterpFilterParams* filter_params_x,
+                                const InterpFilterParams* filter_params_y,
+                                const int subpel_x_q4,
+                                const int subpel_y_q4,
+                                ConvolveParams* conv_params);
+#define av1_dist_wtd_convolve_2d av1_dist_wtd_convolve_2d_c
+
+void av1_dist_wtd_convolve_2d_copy_c(const uint8_t* src,
+                                     int src_stride,
+                                     uint8_t* dst,
+                                     int dst_stride,
+                                     int w,
+                                     int h,
+                                     const InterpFilterParams* filter_params_x,
+                                     const InterpFilterParams* filter_params_y,
+                                     const int subpel_x_q4,
+                                     const int subpel_y_q4,
+                                     ConvolveParams* conv_params);
+#define av1_dist_wtd_convolve_2d_copy av1_dist_wtd_convolve_2d_copy_c
+
+void av1_dist_wtd_convolve_x_c(const uint8_t* src,
+                               int src_stride,
+                               uint8_t* dst,
+                               int dst_stride,
+                               int w,
+                               int h,
+                               const InterpFilterParams* filter_params_x,
+                               const InterpFilterParams* filter_params_y,
+                               const int subpel_x_q4,
+                               const int subpel_y_q4,
+                               ConvolveParams* conv_params);
+#define av1_dist_wtd_convolve_x av1_dist_wtd_convolve_x_c
+
+void av1_dist_wtd_convolve_y_c(const uint8_t* src,
+                               int src_stride,
+                               uint8_t* dst,
+                               int dst_stride,
+                               int w,
+                               int h,
+                               const InterpFilterParams* filter_params_x,
+                               const InterpFilterParams* filter_params_y,
+                               const int subpel_x_q4,
+                               const int subpel_y_q4,
+                               ConvolveParams* conv_params);
+#define av1_dist_wtd_convolve_y av1_dist_wtd_convolve_y_c
+
+void av1_dr_prediction_z1_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            int bw,
+                            int bh,
+                            const uint8_t* above,
+                            const uint8_t* left,
+                            int upsample_above,
+                            int dx,
+                            int dy);
+#define av1_dr_prediction_z1 av1_dr_prediction_z1_c
+
+void av1_dr_prediction_z2_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            int bw,
+                            int bh,
+                            const uint8_t* above,
+                            const uint8_t* left,
+                            int upsample_above,
+                            int upsample_left,
+                            int dx,
+                            int dy);
+#define av1_dr_prediction_z2 av1_dr_prediction_z2_c
+
+void av1_dr_prediction_z3_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            int bw,
+                            int bh,
+                            const uint8_t* above,
+                            const uint8_t* left,
+                            int upsample_left,
+                            int dx,
+                            int dy);
+#define av1_dr_prediction_z3 av1_dr_prediction_z3_c
+
+void av1_filter_intra_edge_c(uint8_t* p, int sz, int strength);
+#define av1_filter_intra_edge av1_filter_intra_edge_c
+
+void av1_filter_intra_edge_high_c(uint16_t* p, int sz, int strength);
+#define av1_filter_intra_edge_high av1_filter_intra_edge_high_c
+
+void av1_filter_intra_predictor_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  TX_SIZE tx_size,
+                                  const uint8_t* above,
+                                  const uint8_t* left,
+                                  int mode);
+#define av1_filter_intra_predictor av1_filter_intra_predictor_c
+
+void av1_highbd_convolve8_c(const uint8_t* src,
+                            ptrdiff_t src_stride,
+                            uint8_t* dst,
+                            ptrdiff_t dst_stride,
+                            const int16_t* filter_x,
+                            int x_step_q4,
+                            const int16_t* filter_y,
+                            int y_step_q4,
+                            int w,
+                            int h,
+                            int bps);
+#define av1_highbd_convolve8 av1_highbd_convolve8_c
+
+void av1_highbd_convolve8_horiz_c(const uint8_t* src,
+                                  ptrdiff_t src_stride,
+                                  uint8_t* dst,
+                                  ptrdiff_t dst_stride,
+                                  const int16_t* filter_x,
+                                  int x_step_q4,
+                                  const int16_t* filter_y,
+                                  int y_step_q4,
+                                  int w,
+                                  int h,
+                                  int bps);
+#define av1_highbd_convolve8_horiz av1_highbd_convolve8_horiz_c
+
+void av1_highbd_convolve8_vert_c(const uint8_t* src,
+                                 ptrdiff_t src_stride,
+                                 uint8_t* dst,
+                                 ptrdiff_t dst_stride,
+                                 const int16_t* filter_x,
+                                 int x_step_q4,
+                                 const int16_t* filter_y,
+                                 int y_step_q4,
+                                 int w,
+                                 int h,
+                                 int bps);
+#define av1_highbd_convolve8_vert av1_highbd_convolve8_vert_c
+
+void av1_highbd_convolve_2d_copy_sr_c(const uint16_t* src,
+                                      int src_stride,
+                                      uint16_t* dst,
+                                      int dst_stride,
+                                      int w,
+                                      int h,
+                                      const InterpFilterParams* filter_params_x,
+                                      const InterpFilterParams* filter_params_y,
+                                      const int subpel_x_q4,
+                                      const int subpel_y_q4,
+                                      ConvolveParams* conv_params,
+                                      int bd);
+#define av1_highbd_convolve_2d_copy_sr av1_highbd_convolve_2d_copy_sr_c
+
+void av1_highbd_convolve_2d_scale_c(const uint16_t* src,
+                                    int src_stride,
+                                    uint16_t* dst,
+                                    int dst_stride,
+                                    int w,
+                                    int h,
+                                    const InterpFilterParams* filter_params_x,
+                                    const InterpFilterParams* filter_params_y,
+                                    const int subpel_x_q4,
+                                    const int x_step_qn,
+                                    const int subpel_y_q4,
+                                    const int y_step_qn,
+                                    ConvolveParams* conv_params,
+                                    int bd);
+#define av1_highbd_convolve_2d_scale av1_highbd_convolve_2d_scale_c
+
+void av1_highbd_convolve_2d_sr_c(const uint16_t* src,
+                                 int src_stride,
+                                 uint16_t* dst,
+                                 int dst_stride,
+                                 int w,
+                                 int h,
+                                 const InterpFilterParams* filter_params_x,
+                                 const InterpFilterParams* filter_params_y,
+                                 const int subpel_x_q4,
+                                 const int subpel_y_q4,
+                                 ConvolveParams* conv_params,
+                                 int bd);
+#define av1_highbd_convolve_2d_sr av1_highbd_convolve_2d_sr_c
+
+void av1_highbd_convolve_avg_c(const uint8_t* src,
+                               ptrdiff_t src_stride,
+                               uint8_t* dst,
+                               ptrdiff_t dst_stride,
+                               const int16_t* filter_x,
+                               int x_step_q4,
+                               const int16_t* filter_y,
+                               int y_step_q4,
+                               int w,
+                               int h,
+                               int bps);
+#define av1_highbd_convolve_avg av1_highbd_convolve_avg_c
+
+void av1_highbd_convolve_copy_c(const uint8_t* src,
+                                ptrdiff_t src_stride,
+                                uint8_t* dst,
+                                ptrdiff_t dst_stride,
+                                const int16_t* filter_x,
+                                int x_step_q4,
+                                const int16_t* filter_y,
+                                int y_step_q4,
+                                int w,
+                                int h,
+                                int bps);
+#define av1_highbd_convolve_copy av1_highbd_convolve_copy_c
+
+void av1_highbd_convolve_horiz_rs_c(const uint16_t* src,
+                                    int src_stride,
+                                    uint16_t* dst,
+                                    int dst_stride,
+                                    int w,
+                                    int h,
+                                    const int16_t* x_filters,
+                                    int x0_qn,
+                                    int x_step_qn,
+                                    int bd);
+#define av1_highbd_convolve_horiz_rs av1_highbd_convolve_horiz_rs_c
+
+void av1_highbd_convolve_x_sr_c(const uint16_t* src,
+                                int src_stride,
+                                uint16_t* dst,
+                                int dst_stride,
+                                int w,
+                                int h,
+                                const InterpFilterParams* filter_params_x,
+                                const InterpFilterParams* filter_params_y,
+                                const int subpel_x_q4,
+                                const int subpel_y_q4,
+                                ConvolveParams* conv_params,
+                                int bd);
+#define av1_highbd_convolve_x_sr av1_highbd_convolve_x_sr_c
+
+void av1_highbd_convolve_y_sr_c(const uint16_t* src,
+                                int src_stride,
+                                uint16_t* dst,
+                                int dst_stride,
+                                int w,
+                                int h,
+                                const InterpFilterParams* filter_params_x,
+                                const InterpFilterParams* filter_params_y,
+                                const int subpel_x_q4,
+                                const int subpel_y_q4,
+                                ConvolveParams* conv_params,
+                                int bd);
+#define av1_highbd_convolve_y_sr av1_highbd_convolve_y_sr_c
+
+void av1_highbd_dist_wtd_convolve_2d_c(
+    const uint16_t* src,
+    int src_stride,
+    uint16_t* dst,
+    int dst_stride,
+    int w,
+    int h,
+    const InterpFilterParams* filter_params_x,
+    const InterpFilterParams* filter_params_y,
+    const int subpel_x_q4,
+    const int subpel_y_q4,
+    ConvolveParams* conv_params,
+    int bd);
+#define av1_highbd_dist_wtd_convolve_2d av1_highbd_dist_wtd_convolve_2d_c
+
+void av1_highbd_dist_wtd_convolve_2d_copy_c(
+    const uint16_t* src,
+    int src_stride,
+    uint16_t* dst,
+    int dst_stride,
+    int w,
+    int h,
+    const InterpFilterParams* filter_params_x,
+    const InterpFilterParams* filter_params_y,
+    const int subpel_x_q4,
+    const int subpel_y_q4,
+    ConvolveParams* conv_params,
+    int bd);
+#define av1_highbd_dist_wtd_convolve_2d_copy \
+  av1_highbd_dist_wtd_convolve_2d_copy_c
+
+void av1_highbd_dist_wtd_convolve_x_c(const uint16_t* src,
+                                      int src_stride,
+                                      uint16_t* dst,
+                                      int dst_stride,
+                                      int w,
+                                      int h,
+                                      const InterpFilterParams* filter_params_x,
+                                      const InterpFilterParams* filter_params_y,
+                                      const int subpel_x_q4,
+                                      const int subpel_y_q4,
+                                      ConvolveParams* conv_params,
+                                      int bd);
+#define av1_highbd_dist_wtd_convolve_x av1_highbd_dist_wtd_convolve_x_c
+
+void av1_highbd_dist_wtd_convolve_y_c(const uint16_t* src,
+                                      int src_stride,
+                                      uint16_t* dst,
+                                      int dst_stride,
+                                      int w,
+                                      int h,
+                                      const InterpFilterParams* filter_params_x,
+                                      const InterpFilterParams* filter_params_y,
+                                      const int subpel_x_q4,
+                                      const int subpel_y_q4,
+                                      ConvolveParams* conv_params,
+                                      int bd);
+#define av1_highbd_dist_wtd_convolve_y av1_highbd_dist_wtd_convolve_y_c
+
+void av1_highbd_dr_prediction_z1_c(uint16_t* dst,
+                                   ptrdiff_t stride,
+                                   int bw,
+                                   int bh,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int upsample_above,
+                                   int dx,
+                                   int dy,
+                                   int bd);
+#define av1_highbd_dr_prediction_z1 av1_highbd_dr_prediction_z1_c
+
+void av1_highbd_dr_prediction_z2_c(uint16_t* dst,
+                                   ptrdiff_t stride,
+                                   int bw,
+                                   int bh,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int upsample_above,
+                                   int upsample_left,
+                                   int dx,
+                                   int dy,
+                                   int bd);
+#define av1_highbd_dr_prediction_z2 av1_highbd_dr_prediction_z2_c
+
+void av1_highbd_dr_prediction_z3_c(uint16_t* dst,
+                                   ptrdiff_t stride,
+                                   int bw,
+                                   int bh,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int upsample_left,
+                                   int dx,
+                                   int dy,
+                                   int bd);
+#define av1_highbd_dr_prediction_z3 av1_highbd_dr_prediction_z3_c
+
+void av1_highbd_inv_txfm_add_c(const tran_low_t* dqcoeff,
+                               uint8_t* dst,
+                               int stride,
+                               const TxfmParam* txfm_param);
+#define av1_highbd_inv_txfm_add av1_highbd_inv_txfm_add_c
+
+void av1_highbd_inv_txfm_add_16x4_c(const tran_low_t* dqcoeff,
+                                    uint8_t* dst,
+                                    int stride,
+                                    const TxfmParam* txfm_param);
+#define av1_highbd_inv_txfm_add_16x4 av1_highbd_inv_txfm_add_16x4_c
+
+void av1_highbd_inv_txfm_add_4x16_c(const tran_low_t* dqcoeff,
+                                    uint8_t* dst,
+                                    int stride,
+                                    const TxfmParam* txfm_param);
+#define av1_highbd_inv_txfm_add_4x16 av1_highbd_inv_txfm_add_4x16_c
+
+void av1_highbd_inv_txfm_add_4x4_c(const tran_low_t* dqcoeff,
+                                   uint8_t* dst,
+                                   int stride,
+                                   const TxfmParam* txfm_param);
+#define av1_highbd_inv_txfm_add_4x4 av1_highbd_inv_txfm_add_4x4_c
+
+void av1_highbd_inv_txfm_add_4x8_c(const tran_low_t* dqcoeff,
+                                   uint8_t* dst,
+                                   int stride,
+                                   const TxfmParam* txfm_param);
+#define av1_highbd_inv_txfm_add_4x8 av1_highbd_inv_txfm_add_4x8_c
+
+void av1_highbd_inv_txfm_add_8x4_c(const tran_low_t* dqcoeff,
+                                   uint8_t* dst,
+                                   int stride,
+                                   const TxfmParam* txfm_param);
+#define av1_highbd_inv_txfm_add_8x4 av1_highbd_inv_txfm_add_8x4_c
+
+void av1_highbd_inv_txfm_add_8x8_c(const tran_low_t* dqcoeff,
+                                   uint8_t* dst,
+                                   int stride,
+                                   const TxfmParam* txfm_param);
+#define av1_highbd_inv_txfm_add_8x8 av1_highbd_inv_txfm_add_8x8_c
+
+void av1_highbd_iwht4x4_16_add_c(const tran_low_t* input,
+                                 uint8_t* dest,
+                                 int dest_stride,
+                                 int bd);
+#define av1_highbd_iwht4x4_16_add av1_highbd_iwht4x4_16_add_c
+
+void av1_highbd_iwht4x4_1_add_c(const tran_low_t* input,
+                                uint8_t* dest,
+                                int dest_stride,
+                                int bd);
+#define av1_highbd_iwht4x4_1_add av1_highbd_iwht4x4_1_add_c
+
+void av1_highbd_warp_affine_c(const int32_t* mat,
+                              const uint16_t* ref,
+                              int width,
+                              int height,
+                              int stride,
+                              uint16_t* pred,
+                              int p_col,
+                              int p_row,
+                              int p_width,
+                              int p_height,
+                              int p_stride,
+                              int subsampling_x,
+                              int subsampling_y,
+                              int bd,
+                              ConvolveParams* conv_params,
+                              int16_t alpha,
+                              int16_t beta,
+                              int16_t gamma,
+                              int16_t delta);
+#define av1_highbd_warp_affine av1_highbd_warp_affine_c
+
+void av1_highbd_wiener_convolve_add_src_c(const uint8_t* src,
+                                          ptrdiff_t src_stride,
+                                          uint8_t* dst,
+                                          ptrdiff_t dst_stride,
+                                          const int16_t* filter_x,
+                                          int x_step_q4,
+                                          const int16_t* filter_y,
+                                          int y_step_q4,
+                                          int w,
+                                          int h,
+                                          const ConvolveParams* conv_params,
+                                          int bps);
+#define av1_highbd_wiener_convolve_add_src av1_highbd_wiener_convolve_add_src_c
+
+void av1_inv_txfm2d_add_16x16_c(const int32_t* input,
+                                uint16_t* output,
+                                int stride,
+                                TX_TYPE tx_type,
+                                int bd);
+#define av1_inv_txfm2d_add_16x16 av1_inv_txfm2d_add_16x16_c
+
+void av1_inv_txfm2d_add_16x32_c(const int32_t* input,
+                                uint16_t* output,
+                                int stride,
+                                TX_TYPE tx_type,
+                                int bd);
+#define av1_inv_txfm2d_add_16x32 av1_inv_txfm2d_add_16x32_c
+
+void av1_inv_txfm2d_add_16x4_c(const int32_t* input,
+                               uint16_t* output,
+                               int stride,
+                               TX_TYPE tx_type,
+                               int bd);
+#define av1_inv_txfm2d_add_16x4 av1_inv_txfm2d_add_16x4_c
+
+void av1_inv_txfm2d_add_16x64_c(const int32_t* input,
+                                uint16_t* output,
+                                int stride,
+                                TX_TYPE tx_type,
+                                int bd);
+#define av1_inv_txfm2d_add_16x64 av1_inv_txfm2d_add_16x64_c
+
+void av1_inv_txfm2d_add_16x8_c(const int32_t* input,
+                               uint16_t* output,
+                               int stride,
+                               TX_TYPE tx_type,
+                               int bd);
+#define av1_inv_txfm2d_add_16x8 av1_inv_txfm2d_add_16x8_c
+
+void av1_inv_txfm2d_add_32x16_c(const int32_t* input,
+                                uint16_t* output,
+                                int stride,
+                                TX_TYPE tx_type,
+                                int bd);
+#define av1_inv_txfm2d_add_32x16 av1_inv_txfm2d_add_32x16_c
+
+void av1_inv_txfm2d_add_32x32_c(const int32_t* input,
+                                uint16_t* output,
+                                int stride,
+                                TX_TYPE tx_type,
+                                int bd);
+#define av1_inv_txfm2d_add_32x32 av1_inv_txfm2d_add_32x32_c
+
+void av1_inv_txfm2d_add_32x64_c(const int32_t* input,
+                                uint16_t* output,
+                                int stride,
+                                TX_TYPE tx_type,
+                                int bd);
+#define av1_inv_txfm2d_add_32x64 av1_inv_txfm2d_add_32x64_c
+
+void av1_inv_txfm2d_add_32x8_c(const int32_t* input,
+                               uint16_t* output,
+                               int stride,
+                               TX_TYPE tx_type,
+                               int bd);
+#define av1_inv_txfm2d_add_32x8 av1_inv_txfm2d_add_32x8_c
+
+void av1_inv_txfm2d_add_4x16_c(const int32_t* input,
+                               uint16_t* output,
+                               int stride,
+                               TX_TYPE tx_type,
+                               int bd);
+#define av1_inv_txfm2d_add_4x16 av1_inv_txfm2d_add_4x16_c
+
+void av1_inv_txfm2d_add_4x4_c(const int32_t* input,
+                              uint16_t* output,
+                              int stride,
+                              TX_TYPE tx_type,
+                              int bd);
+#define av1_inv_txfm2d_add_4x4 av1_inv_txfm2d_add_4x4_c
+
+void av1_inv_txfm2d_add_4x8_c(const int32_t* input,
+                              uint16_t* output,
+                              int stride,
+                              TX_TYPE tx_type,
+                              int bd);
+#define av1_inv_txfm2d_add_4x8 av1_inv_txfm2d_add_4x8_c
+
+void av1_inv_txfm2d_add_64x16_c(const int32_t* input,
+                                uint16_t* output,
+                                int stride,
+                                TX_TYPE tx_type,
+                                int bd);
+#define av1_inv_txfm2d_add_64x16 av1_inv_txfm2d_add_64x16_c
+
+void av1_inv_txfm2d_add_64x32_c(const int32_t* input,
+                                uint16_t* output,
+                                int stride,
+                                TX_TYPE tx_type,
+                                int bd);
+#define av1_inv_txfm2d_add_64x32 av1_inv_txfm2d_add_64x32_c
+
+void av1_inv_txfm2d_add_64x64_c(const int32_t* input,
+                                uint16_t* output,
+                                int stride,
+                                TX_TYPE tx_type,
+                                int bd);
+#define av1_inv_txfm2d_add_64x64 av1_inv_txfm2d_add_64x64_c
+
+void av1_inv_txfm2d_add_8x16_c(const int32_t* input,
+                               uint16_t* output,
+                               int stride,
+                               TX_TYPE tx_type,
+                               int bd);
+#define av1_inv_txfm2d_add_8x16 av1_inv_txfm2d_add_8x16_c
+
+void av1_inv_txfm2d_add_8x32_c(const int32_t* input,
+                               uint16_t* output,
+                               int stride,
+                               TX_TYPE tx_type,
+                               int bd);
+#define av1_inv_txfm2d_add_8x32 av1_inv_txfm2d_add_8x32_c
+
+void av1_inv_txfm2d_add_8x4_c(const int32_t* input,
+                              uint16_t* output,
+                              int stride,
+                              TX_TYPE tx_type,
+                              int bd);
+#define av1_inv_txfm2d_add_8x4 av1_inv_txfm2d_add_8x4_c
+
+void av1_inv_txfm2d_add_8x8_c(const int32_t* input,
+                              uint16_t* output,
+                              int stride,
+                              TX_TYPE tx_type,
+                              int bd);
+#define av1_inv_txfm2d_add_8x8 av1_inv_txfm2d_add_8x8_c
+
+void av1_inv_txfm_add_c(const tran_low_t* dqcoeff,
+                        uint8_t* dst,
+                        int stride,
+                        const TxfmParam* txfm_param);
+#define av1_inv_txfm_add av1_inv_txfm_add_c
+
+void av1_round_shift_array_c(int32_t* arr, int size, int bit);
+#define av1_round_shift_array av1_round_shift_array_c
+
+int av1_selfguided_restoration_c(const uint8_t* dgd8,
+                                 int width,
+                                 int height,
+                                 int dgd_stride,
+                                 int32_t* flt0,
+                                 int32_t* flt1,
+                                 int flt_stride,
+                                 int sgr_params_idx,
+                                 int bit_depth,
+                                 int highbd);
+#define av1_selfguided_restoration av1_selfguided_restoration_c
+
+void av1_upsample_intra_edge_c(uint8_t* p, int sz);
+#define av1_upsample_intra_edge av1_upsample_intra_edge_c
+
+void av1_upsample_intra_edge_high_c(uint16_t* p, int sz, int bd);
+#define av1_upsample_intra_edge_high av1_upsample_intra_edge_high_c
+
+void av1_warp_affine_c(const int32_t* mat,
+                       const uint8_t* ref,
+                       int width,
+                       int height,
+                       int stride,
+                       uint8_t* pred,
+                       int p_col,
+                       int p_row,
+                       int p_width,
+                       int p_height,
+                       int p_stride,
+                       int subsampling_x,
+                       int subsampling_y,
+                       ConvolveParams* conv_params,
+                       int16_t alpha,
+                       int16_t beta,
+                       int16_t gamma,
+                       int16_t delta);
+#define av1_warp_affine av1_warp_affine_c
+
+void av1_wiener_convolve_add_src_c(const uint8_t* src,
+                                   ptrdiff_t src_stride,
+                                   uint8_t* dst,
+                                   ptrdiff_t dst_stride,
+                                   const int16_t* filter_x,
+                                   int x_step_q4,
+                                   const int16_t* filter_y,
+                                   int y_step_q4,
+                                   int w,
+                                   int h,
+                                   const ConvolveParams* conv_params);
+#define av1_wiener_convolve_add_src av1_wiener_convolve_add_src_c
+
+void cdef_filter_block_c(uint8_t* dst8,
+                         uint16_t* dst16,
+                         int dstride,
+                         const uint16_t* in,
+                         int pri_strength,
+                         int sec_strength,
+                         int dir,
+                         int pri_damping,
+                         int sec_damping,
+                         int bsize,
+                         int coeff_shift);
+#define cdef_filter_block cdef_filter_block_c
+
+int cdef_find_dir_c(const uint16_t* img,
+                    int stride,
+                    int32_t* var,
+                    int coeff_shift);
+#define cdef_find_dir cdef_find_dir_c
+
+cfl_subsample_hbd_fn cfl_get_luma_subsampling_420_hbd_c(TX_SIZE tx_size);
+#define cfl_get_luma_subsampling_420_hbd cfl_get_luma_subsampling_420_hbd_c
+
+cfl_subsample_lbd_fn cfl_get_luma_subsampling_420_lbd_c(TX_SIZE tx_size);
+#define cfl_get_luma_subsampling_420_lbd cfl_get_luma_subsampling_420_lbd_c
+
+cfl_subsample_hbd_fn cfl_get_luma_subsampling_422_hbd_c(TX_SIZE tx_size);
+#define cfl_get_luma_subsampling_422_hbd cfl_get_luma_subsampling_422_hbd_c
+
+cfl_subsample_lbd_fn cfl_get_luma_subsampling_422_lbd_c(TX_SIZE tx_size);
+#define cfl_get_luma_subsampling_422_lbd cfl_get_luma_subsampling_422_lbd_c
+
+cfl_subsample_hbd_fn cfl_get_luma_subsampling_444_hbd_c(TX_SIZE tx_size);
+#define cfl_get_luma_subsampling_444_hbd cfl_get_luma_subsampling_444_hbd_c
+
+cfl_subsample_lbd_fn cfl_get_luma_subsampling_444_lbd_c(TX_SIZE tx_size);
+#define cfl_get_luma_subsampling_444_lbd cfl_get_luma_subsampling_444_lbd_c
+
+void copy_rect8_16bit_to_16bit_c(uint16_t* dst,
+                                 int dstride,
+                                 const uint16_t* src,
+                                 int sstride,
+                                 int v,
+                                 int h);
+#define copy_rect8_16bit_to_16bit copy_rect8_16bit_to_16bit_c
+
+void copy_rect8_8bit_to_16bit_c(uint16_t* dst,
+                                int dstride,
+                                const uint8_t* src,
+                                int sstride,
+                                int v,
+                                int h);
+#define copy_rect8_8bit_to_16bit copy_rect8_8bit_to_16bit_c
+
+cfl_predict_hbd_fn get_predict_hbd_fn_c(TX_SIZE tx_size);
+#define get_predict_hbd_fn get_predict_hbd_fn_c
+
+cfl_predict_lbd_fn get_predict_lbd_fn_c(TX_SIZE tx_size);
+#define get_predict_lbd_fn get_predict_lbd_fn_c
+
+cfl_subtract_average_fn get_subtract_average_fn_c(TX_SIZE tx_size);
+cfl_subtract_average_fn get_subtract_average_fn_vsx(TX_SIZE tx_size);
+#define get_subtract_average_fn get_subtract_average_fn_vsx
+
+void av1_rtcd(void);
+
+#include "config/aom_config.h"
+
+#ifdef RTCD_C
+#include "aom_ports/ppc.h"
+static void setup_rtcd_internal(void) {
+  int flags = ppc_simd_caps();
+
+  (void)flags;
+}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libdrm/src/xf86drm.c b/qtwebengine/src/3rdparty/chromium/third_party/libdrm/src/xf86drm.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/libdrm/src/xf86drm.c	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libdrm/src/xf86drm.c	2025-05-30 15:30:16.000000000 +0800
@@ -51,10 +51,10 @@
 #include <sys/ioctl.h>
 #include <sys/time.h>
 #include <stdarg.h>
-#ifdef MAJOR_IN_MKDEV
+#if __has_include(<sys/mkdev.h>)
 #include <sys/mkdev.h>
 #endif
-#ifdef MAJOR_IN_SYSMACROS
+#if __has_include(<sys/sysmacros.h>)
 #include <sys/sysmacros.h>
 #endif
 #include <math.h>
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libjingle_xmpp/xmpp/constants.cc b/qtwebengine/src/3rdparty/chromium/third_party/libjingle_xmpp/xmpp/constants.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/libjingle_xmpp/xmpp/constants.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libjingle_xmpp/xmpp/constants.cc	2025-06-03 10:27:05.000000000 +0800
@@ -194,7 +194,7 @@
 
 // These are non-standard.
 const char NS_GOOGLE_AUTH_PROTOCOL[] =
-    "http://www.google.com/talk/protocol/auth";
+    "trk:236:http://www.google.com/talk/protocol/auth";
 const StaticQName QN_GOOGLE_AUTH_CLIENT_USES_FULL_BIND_RESULT =
     { NS_GOOGLE_AUTH_PROTOCOL, "client-uses-full-bind-result" };
 const StaticQName QN_GOOGLE_ALLOW_NON_GOOGLE_ID_XMPP_LOGIN =
@@ -338,7 +338,7 @@
 const char STR_SHOW_XA[] = "xa";
 const char STR_SHOW_OFFLINE[] = "offline";
 
-const char NS_GOOGLE_PSTN_CONFERENCE[] = "http://www.google.com/pstn-conference";
+const char NS_GOOGLE_PSTN_CONFERENCE[] = "trk:237:http://www.google.com/pstn-conference";
 const StaticQName QN_GOOGLE_PSTN_CONFERENCE_STATUS = { NS_GOOGLE_PSTN_CONFERENCE, "status" };
 const StaticQName QN_ATTR_STATUS = { STR_EMPTY, "status" };
 
@@ -433,7 +433,7 @@
 const char STR_AFFILIATION_NONE[] = "none";
 const char STR_ROLE_PARTICIPANT[] = "participant";
 
-const char NS_GOOGLE_SESSION[] = "http://www.google.com/session";
+const char NS_GOOGLE_SESSION[] = "trk:238:http://www.google.com/session";
 const StaticQName QN_GOOGLE_CIRCLE_ID = { STR_EMPTY, "google-circle-id" };
 const StaticQName QN_GOOGLE_USER_ID = { STR_EMPTY, "google-user-id" };
 const StaticQName QN_GOOGLE_SESSION_BLOCKED = { NS_GOOGLE_SESSION, "blocked" };
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libpng/BUILD.gn b/qtwebengine/src/3rdparty/chromium/third_party/libpng/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/third_party/libpng/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libpng/BUILD.gn	2025-06-05 15:07:06.000000000 +0800
@@ -93,6 +93,11 @@
       "mips/filter_msa_intrinsics.c",
       "mips/mips_init.c",
     ]
+  } else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+    sources += [
+      "powerpc/filter_vsx_intrinsics.c",
+      "powerpc/powerpc_init.c",
+    ]
   }
 
   configs -= [ "//build/config/compiler:chromium_code" ]
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libpng/powerpc/filter_vsx_intrinsics.c b/qtwebengine/src/3rdparty/chromium/third_party/libpng/powerpc/filter_vsx_intrinsics.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/libpng/powerpc/filter_vsx_intrinsics.c	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libpng/powerpc/filter_vsx_intrinsics.c	2025-05-30 15:26:20.000000000 +0800
@@ -0,0 +1,767 @@
+/* filter_vsx_intrinsics.c - PowerPC optimised filter functions
+ *
+ * Copyright (c) 2017 Glenn Randers-Pehrson
+ * Written by Vadim Barkov, 2017.
+ * Last changed in libpng 1.6.29 [March 16, 2017]
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include "../pngpriv.h"
+
+#ifdef PNG_READ_SUPPORTED
+
+/* This code requires -maltivec and -mvsx on the command line: */
+#if PNG_POWERPC_VSX_IMPLEMENTATION == 1 /* intrinsics code from pngpriv.h */
+
+#include <altivec.h>
+
+#if PNG_POWERPC_VSX_OPT > 0
+
+#ifndef __VSX__
+#  error "This code requires VSX support (POWER7 and later). Please provide -mvsx compiler flag."
+#endif
+
+#define vec_ld_unaligned(vec,data) vec = vec_vsx_ld(0,data)
+#define vec_st_unaligned(vec,data) vec_vsx_st(vec,0,data)
+
+
+/* Functions in this file look at most 3 pixels (a,b,c) to predict the 4th (d).
+ * They're positioned like this:
+ *    prev:  c b
+ *    row:   a d
+ * The Sub filter predicts d=a, Avg d=(a+b)/2, and Paeth predicts d to be
+ * whichever of a, b, or c is closest to p=a+b-c.
+ * ( this is taken from ../intel/filter_sse2_intrinsics.c )
+ */
+
+#define vsx_declare_common_vars(row_info,row,prev_row,offset) \
+   png_byte i;\
+   png_bytep rp = row + offset;\
+   png_const_bytep pp = prev_row;\
+   png_size_t unaligned_top = 16 - (((png_size_t)rp % 16));\
+   png_size_t istop;\
+   if(unaligned_top == 16)\
+      unaligned_top = 0;\
+   istop = row_info->rowbytes;\
+   if((unaligned_top < istop))\
+      istop -= unaligned_top;\
+   else{\
+      unaligned_top = istop;\
+      istop = 0;\
+   }
+
+void png_read_filter_row_up_vsx(png_row_infop row_info, png_bytep row,
+                                png_const_bytep prev_row)
+{
+   vector unsigned char rp_vec;
+   vector unsigned char pp_vec;
+   vsx_declare_common_vars(row_info,row,prev_row,0)
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      rp_vec = vec_ld(0,rp);
+      vec_ld_unaligned(pp_vec,pp);
+
+      rp_vec = vec_add(rp_vec,pp_vec);
+
+      vec_st(rp_vec,0,rp);
+
+      pp += 16;
+      rp += 16;
+      istop -= 16;
+   }
+
+   if(istop > 0)
+   {
+      /* If byte count of row is not divisible by 16
+       * we will process remaining part as usual
+       */
+      for (i = 0; i < istop; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+         rp++;
+      }
+}
+
+}
+
+static const vector unsigned char VSX_LEFTSHIFTED1_4 = {16,16,16,16, 0, 1, 2, 3,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED2_4 = {16,16,16,16,16,16,16,16, 4, 5, 6, 7,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED3_4 = {16,16,16,16,16,16,16,16,16,16,16,16, 8, 9,10,11};
+
+static const vector unsigned char VSX_LEFTSHIFTED1_3 = {16,16,16, 0, 1, 2,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED2_3 = {16,16,16,16,16,16, 3, 4, 5,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED3_3 = {16,16,16,16,16,16,16,16,16, 6, 7, 8,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED4_3 = {16,16,16,16,16,16,16,16,16,16,16,16, 9,10,11,16};
+
+static const vector unsigned char VSX_NOT_SHIFTED1_4 = {16,16,16,16, 4, 5, 6, 7,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED2_4 = {16,16,16,16,16,16,16,16, 8, 9,10,11,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED3_4 = {16,16,16,16,16,16,16,16,16,16,16,16,12,13,14,15};
+
+static const vector unsigned char VSX_NOT_SHIFTED1_3 = {16,16,16, 3, 4, 5,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED2_3 = {16,16,16,16,16,16, 6, 7, 8,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED3_3 = {16,16,16,16,16,16,16,16,16, 9,10,11,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED4_3 = {16,16,16,16,16,16,16,16,16,16,16,16,12,13,14,16};
+
+static const vector unsigned char VSX_CHAR_ZERO = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+#ifdef __LITTLE_ENDIAN__
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_4 = { 4,16, 5,16, 6,16, 7,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_4 = { 8,16, 9,16,10,16,11,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_4 = {12,16,13,16,14,16,15,16,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_4 = {16,16,16,16, 0, 2, 4, 6,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_4 = {16,16,16,16,16,16,16,16, 0, 2, 4, 6,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_4 = {16,16,16,16,16,16,16,16,16,16,16,16, 0, 2, 4, 6};
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_3 = { 3,16, 4,16, 5,16,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_3 = { 6,16, 7,16, 8,16,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_3 = { 9,16,10,16,11,16,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT4_3 = {12,16,13,16,14,16,16,16,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_3 = {16,16,16, 0, 2, 4,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_3 = {16,16,16,16,16,16, 0, 2, 4,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_3 = {16,16,16,16,16,16,16,16,16, 0, 2, 4,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR4_3 = {16,16,16,16,16,16,16,16,16,16,16,16, 0, 2, 4,16};
+
+#elif defined(__BIG_ENDIAN__)
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_4 = {16, 4,16, 5,16, 6,16, 7,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_4 = {16, 8,16, 9,16,10,16,11,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_4 = {16,12,16,13,16,14,16,15,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_4 = {16,16,16,16, 1, 3, 5, 7,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_4 = {16,16,16,16,16,16,16,16, 1, 3, 5, 7,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_4 = {16,16,16,16,16,16,16,16,16,16,16,16, 1, 3, 5, 7};
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_3 = {16, 3,16, 4,16, 5,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_3 = {16, 6,16, 7,16, 8,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_3 = {16, 9,16,10,16,11,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT4_3 = {16,12,16,13,16,14,16,16,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_3 = {16,16,16, 1, 3, 5,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_3 = {16,16,16,16,16,16, 1, 3, 5,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_3 = {16,16,16,16,16,16,16,16,16, 1, 3, 5,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR4_3 = {16,16,16,16,16,16,16,16,16,16,16,16, 1, 3, 5,16};
+
+#endif
+
+#define vsx_char_to_short(vec,offset,bpp) (vector unsigned short)vec_perm((vec),VSX_CHAR_ZERO,VSX_CHAR_TO_SHORT##offset##_##bpp)
+#define vsx_short_to_char(vec,offset,bpp) vec_perm(((vector unsigned char)(vec)),VSX_CHAR_ZERO,VSX_SHORT_TO_CHAR##offset##_##bpp)
+
+#ifdef PNG_USE_ABS
+#  define vsx_abs(number) abs(number)
+#else
+#  define vsx_abs(number) (number > 0) ? (number) : -(number)
+#endif
+
+void png_read_filter_row_sub4_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+   const png_byte bpp = 4;
+
+   vector unsigned char rp_vec;
+   vector unsigned char part_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+
+   PNG_UNUSED(pp)
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      for(i=0;i < bpp ; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+         rp++;
+      }
+      rp -= bpp;
+
+      rp_vec = vec_ld(0,rp);
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_4);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_4);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_4);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      vec_st(rp_vec,0,rp);
+
+      rp += 16;
+      istop -= 16;
+   }
+
+   if(istop > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp - bpp))) & 0xff);
+         rp++;
+      }
+
+}
+
+void png_read_filter_row_sub3_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+   const png_byte bpp = 3;
+
+   vector unsigned char rp_vec;
+   vector unsigned char part_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+
+   PNG_UNUSED(pp)
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      for(i=0;i < bpp ; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+         rp++;
+      }
+      rp -= bpp;
+
+      rp_vec = vec_ld(0,rp);
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED4_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      vec_st(rp_vec,0,rp);
+      rp += 15;
+      istop -= 16;
+
+      /* Since 16 % bpp = 16 % 3 = 1, last element of array must
+       * be proceeded manually
+       */
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+
+   if(istop > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+         rp++;
+      }
+}
+
+void png_read_filter_row_avg4_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+   const png_byte bpp = 4;
+
+   vector unsigned char rp_vec;
+   vector unsigned char pp_vec;
+   vector unsigned char pp_part_vec;
+   vector unsigned char rp_part_vec;
+   vector unsigned char avg_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+   rp -= bpp;
+   if(istop >= bpp)
+      istop -= bpp;
+
+   for (i = 0; i < bpp; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) +
+         ((int)(*pp++) / 2 )) & 0xff);
+
+      rp++;
+   }
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) +
+         (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      for(i=0;i < bpp ; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) +
+            (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+         rp++;
+      }
+      rp -= bpp;
+      pp -= bpp;
+
+      vec_ld_unaligned(pp_vec,pp);
+      rp_vec = vec_ld(0,rp);
+
+      rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_4);
+      pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED1_4);
+      avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+      avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+      rp_vec = vec_add(rp_vec,avg_vec);
+
+      rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_4);
+      pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED2_4);
+      avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+      avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+      rp_vec = vec_add(rp_vec,avg_vec);
+
+      rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_4);
+      pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED3_4);
+      avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+      avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+      rp_vec = vec_add(rp_vec,avg_vec);
+
+      vec_st(rp_vec,0,rp);
+
+      rp += 16;
+      pp += 16;
+      istop -= 16;
+   }
+
+   if(istop  > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) +
+            (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+         rp++;
+      }
+}
+
+void png_read_filter_row_avg3_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+  const png_byte bpp = 3;
+
+  vector unsigned char rp_vec;
+  vector unsigned char pp_vec;
+  vector unsigned char pp_part_vec;
+  vector unsigned char rp_part_vec;
+  vector unsigned char avg_vec;
+
+  vsx_declare_common_vars(row_info,row,prev_row,bpp)
+  rp -= bpp;
+  if(istop >= bpp)
+     istop -= bpp;
+
+  for (i = 0; i < bpp; i++)
+  {
+     *rp = (png_byte)(((int)(*rp) +
+        ((int)(*pp++) / 2 )) & 0xff);
+
+     rp++;
+  }
+
+  /* Altivec operations require 16-byte aligned data
+   * but input can be unaligned. So we calculate
+   * unaligned part as usual.
+   */
+  for (i = 0; i < unaligned_top; i++)
+  {
+     *rp = (png_byte)(((int)(*rp) +
+        (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+     rp++;
+  }
+
+  /* Using SIMD while we can */
+  while( istop >= 16 )
+  {
+     for(i=0;i < bpp ; i++)
+     {
+        *rp = (png_byte)(((int)(*rp) +
+           (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+        rp++;
+     }
+     rp -= bpp;
+     pp -= bpp;
+
+     vec_ld_unaligned(pp_vec,pp);
+     rp_vec = vec_ld(0,rp);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED1_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED2_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED3_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED4_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED4_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     vec_st(rp_vec,0,rp);
+
+     rp += 15;
+     pp += 15;
+     istop -= 16;
+
+     /* Since 16 % bpp = 16 % 3 = 1, last element of array must
+      * be proceeded manually
+      */
+     *rp = (png_byte)(((int)(*rp) +
+        (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+     rp++;
+  }
+
+  if(istop  > 0)
+     for (i = 0; i < istop % 16; i++)
+     {
+        *rp = (png_byte)(((int)(*rp) +
+           (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+        rp++;
+     }
+}
+
+/* Bytewise c ? t : e. */
+#define if_then_else(c,t,e) vec_sel(e,t,c)
+
+#define vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp) {\
+      c = *(pp - bpp);\
+      a = *(rp - bpp);\
+      b = *pp++;\
+      p = b - c;\
+      pc = a - c;\
+      pa = vsx_abs(p);\
+      pb = vsx_abs(pc);\
+      pc = vsx_abs(p + pc);\
+      if (pb < pa) pa = pb, a = b;\
+      if (pc < pa) a = c;\
+      a += *rp;\
+      *rp++ = (png_byte)a;\
+      }
+
+void png_read_filter_row_paeth4_vsx(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
+{
+   const png_byte bpp = 4;
+
+   int a, b, c, pa, pb, pc, p;
+   vector unsigned char rp_vec;
+   vector unsigned char pp_vec;
+   vector unsigned short a_vec,b_vec,c_vec,nearest_vec;
+   vector signed short pa_vec,pb_vec,pc_vec,smallest_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+   rp -= bpp;
+   if(istop >= bpp)
+      istop -= bpp;
+
+   /* Process the first pixel in the row completely (this is the same as 'up'
+    * because there is only one candidate predictor for the first row).
+    */
+   for(i = 0; i < bpp ; i++)
+   {
+      *rp = (png_byte)( *rp + *pp);
+      rp++;
+      pp++;
+   }
+
+   for(i = 0; i < unaligned_top ; i++)
+   {
+      vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+   }
+
+   while( istop >= 16)
+   {
+      for(i = 0; i < bpp ; i++)
+      {
+         vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+      }
+
+      rp -= bpp;
+      pp -= bpp;
+      rp_vec = vec_ld(0,rp);
+      vec_ld_unaligned(pp_vec,pp);
+
+      a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_4),1,4);
+      b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED1_4),1,4);
+      c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_4),1,4);
+      pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+      pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+      pc_vec = vec_add(pa_vec,pb_vec);
+      pa_vec = vec_abs(pa_vec);
+      pb_vec = vec_abs(pb_vec);
+      pc_vec = vec_abs(pc_vec);
+      smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+      nearest_vec =  if_then_else(
+            vec_cmpeq(pa_vec,smallest_vec),
+            a_vec,
+            if_then_else(
+              vec_cmpeq(pb_vec,smallest_vec),
+              b_vec,
+              c_vec
+              )
+            );
+      rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,1,4)));
+
+      a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_4),2,4);
+      b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED2_4),2,4);
+      c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_4),2,4);
+      pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+      pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+      pc_vec = vec_add(pa_vec,pb_vec);
+      pa_vec = vec_abs(pa_vec);
+      pb_vec = vec_abs(pb_vec);
+      pc_vec = vec_abs(pc_vec);
+      smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+      nearest_vec =  if_then_else(
+            vec_cmpeq(pa_vec,smallest_vec),
+            a_vec,
+            if_then_else(
+              vec_cmpeq(pb_vec,smallest_vec),
+              b_vec,
+              c_vec
+              )
+            );
+      rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,2,4)));
+
+      a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_4),3,4);
+      b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED3_4),3,4);
+      c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_4),3,4);
+      pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+      pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+      pc_vec = vec_add(pa_vec,pb_vec);
+      pa_vec = vec_abs(pa_vec);
+      pb_vec = vec_abs(pb_vec);
+      pc_vec = vec_abs(pc_vec);
+      smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+      nearest_vec =  if_then_else(
+            vec_cmpeq(pa_vec,smallest_vec),
+            a_vec,
+            if_then_else(
+              vec_cmpeq(pb_vec,smallest_vec),
+              b_vec,
+              c_vec
+              )
+            );
+      rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,3,4)));
+
+      vec_st(rp_vec,0,rp);
+
+      rp += 16;
+      pp += 16;
+      istop -= 16;
+   }
+
+   if(istop > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+      }
+}
+
+void png_read_filter_row_paeth3_vsx(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
+{
+  const png_byte bpp = 3;
+
+  int a, b, c, pa, pb, pc, p;
+  vector unsigned char rp_vec;
+  vector unsigned char pp_vec;
+  vector unsigned short a_vec,b_vec,c_vec,nearest_vec;
+  vector signed short pa_vec,pb_vec,pc_vec,smallest_vec;
+
+  vsx_declare_common_vars(row_info,row,prev_row,bpp)
+  rp -= bpp;
+  if(istop >= bpp)
+     istop -= bpp;
+
+  /* Process the first pixel in the row completely (this is the same as 'up'
+   * because there is only one candidate predictor for the first row).
+   */
+  for(i = 0; i < bpp ; i++)
+  {
+     *rp = (png_byte)( *rp + *pp);
+     rp++;
+     pp++;
+  }
+
+  for(i = 0; i < unaligned_top ; i++)
+  {
+     vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+  }
+
+  while( istop >= 16)
+  {
+     for(i = 0; i < bpp ; i++)
+     {
+        vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+     }
+
+     rp -= bpp;
+     pp -= bpp;
+     rp_vec = vec_ld(0,rp);
+     vec_ld_unaligned(pp_vec,pp);
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_3),1,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED1_3),1,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_3),1,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,1,3)));
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_3),2,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED2_3),2,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_3),2,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,2,3)));
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_3),3,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED3_3),3,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_3),3,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,3,3)));
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED4_3),4,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED4_3),4,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED4_3),4,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,4,3)));
+
+     vec_st(rp_vec,0,rp);
+
+     rp += 15;
+     pp += 15;
+     istop -= 16;
+
+     /* Since 16 % bpp = 16 % 3 = 1, last element of array must
+      * be proceeded manually
+      */
+     vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+  }
+
+  if(istop > 0)
+     for (i = 0; i < istop % 16; i++)
+     {
+        vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+     }
+}
+
+#endif /* PNG_POWERPC_VSX_OPT > 0 */
+#endif /* PNG_POWERPC_VSX_IMPLEMENTATION == 1 (intrinsics) */
+#endif /* READ */
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libpng/powerpc/powerpc_init.c b/qtwebengine/src/3rdparty/chromium/third_party/libpng/powerpc/powerpc_init.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/libpng/powerpc/powerpc_init.c	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libpng/powerpc/powerpc_init.c	2025-05-30 15:26:20.000000000 +0800
@@ -0,0 +1,125 @@
+
+/* powerpc_init.c - POWERPC optimised filter functions
+ *
+ * Copyright (c) 2017 Glenn Randers-Pehrson
+ * Written by Vadim Barkov, 2017.
+ * Last changed in libpng 1.6.29 [March 16, 2017]
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+/* Below, after checking __linux__, various non-C90 POSIX 1003.1 functions are
+ * called.
+ */
+#define _POSIX_SOURCE 1
+
+#include <stdio.h>
+#include "../pngpriv.h"
+
+#ifdef PNG_READ_SUPPORTED
+
+#if PNG_POWERPC_VSX_OPT > 0
+#ifdef PNG_POWERPC_VSX_CHECK_SUPPORTED /* Do run-time checks */
+/* WARNING: it is strongly recommended that you do not build libpng with
+ * run-time checks for CPU features if at all possible.  In the case of the PowerPC
+ * VSX instructions there is no processor-specific way of detecting the
+ * presence of the required support, therefore run-time detection is extremely
+ * OS specific.
+ *
+ * You may set the macro PNG_POWERPC_VSX_FILE to the file name of file containing
+ * a fragment of C source code which defines the png_have_vsx function.  There
+ * are a number of implementations in contrib/powerpc-vsx, but the only one that
+ * has partial support is contrib/powerpc-vsx/linux.c - a generic Linux
+ * implementation which reads /proc/cpufino.
+ */
+#ifndef PNG_POWERPC_VSX_FILE
+#  ifdef __linux__
+#     define  PNG_POWERPC_VSX_FILE "contrib/powerpc-vsx/linux_aux.c"
+#  endif
+#endif
+
+#ifdef PNG_POWERPC_VSX_FILE
+
+#include <signal.h> /* for sig_atomic_t */
+static int png_have_vsx(png_structp png_ptr);
+#include PNG_POWERPC_VSX_FILE
+
+#else  /* PNG_POWERPC_VSX_FILE */
+#  error "PNG_POWERPC_VSX_FILE undefined: no support for run-time POWERPC VSX checks"
+#endif /* PNG_POWERPC_VSX_FILE */
+#endif /* PNG_POWERPC_VSX_CHECK_SUPPORTED */
+
+void
+png_init_filter_functions_vsx(png_structp pp, unsigned int bpp)
+{
+   /* The switch statement is compiled in for POWERPC_VSX_API, the call to
+    * png_have_vsx is compiled in for POWERPC_VSX_CHECK. If both are defined
+    * the check is only performed if the API has not set the PowerPC option on
+    * or off explicitly. In this case the check controls what happens.
+    */
+
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+   switch ((pp->options >> PNG_POWERPC_VSX) & 3)
+   {
+      case PNG_OPTION_UNSET:
+         /* Allow the run-time check to execute if it has been enabled -
+          * thus both API and CHECK can be turned on.  If it isn't supported
+          * this case will fall through to the 'default' below, which just
+          * returns.
+          */
+#endif /* PNG_POWERPC_VSX_API_SUPPORTED */
+#ifdef PNG_POWERPC_VSX_CHECK_SUPPORTED
+         {
+            static volatile sig_atomic_t no_vsx = -1; /* not checked */
+
+            if (no_vsx < 0)
+               no_vsx = !png_have_vsx(pp);
+
+            if (no_vsx)
+               return;
+         }
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+         break;
+#endif
+#endif /* PNG_POWERPC_VSX_CHECK_SUPPORTED */
+
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+      default: /* OFF or INVALID */
+         return;
+
+      case PNG_OPTION_ON:
+         /* Option turned on */
+         break;
+   }
+#endif
+
+   /* IMPORTANT: any new internal functions used here must be declared using
+    * PNG_INTERNAL_FUNCTION in ../pngpriv.h.  This is required so that the
+    * 'prefix' option to configure works:
+    *
+    *    ./configure --with-libpng-prefix=foobar_
+    *
+    * Verify you have got this right by running the above command, doing a build
+    * and examining pngprefix.h; it must contain a #define for every external
+    * function you add.  (Notice that this happens automatically for the
+    * initialization function.)
+    */
+   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up_vsx;
+
+   if (bpp == 3)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub3_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg3_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] = png_read_filter_row_paeth3_vsx;
+   }
+
+   else if (bpp == 4)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub4_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg4_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] = png_read_filter_row_paeth4_vsx;
+   }
+}
+#endif /* PNG_POWERPC_VSX_OPT > 0 */
+#endif /* READ */
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/BUILD.gn b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/BUILD.gn	2025-06-06 10:40:48.000000000 +0800
@@ -101,6 +101,30 @@
       "-Wno-sign-compare",
     ]
   }
+
+  if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+    cflags += [
+      "-mcpu=power9",
+      "-maltivec",
+      "-mvsx",
+    ]
+  }
+
+  if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+    cflags += [
+      "-mcpu=power9",
+      "-maltivec",
+      "-mvsx",
+    ]
+  }
+
+  if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+    cflags += [
+      "-mcpu=power9",
+      "-maltivec",
+      "-mvsx",
+    ]
+  }
 }
 
 # This config is applied to targets that depend on libvpx.
@@ -218,6 +242,9 @@
       sources = libvpx_srcs_x86_avx2
     } else if (current_cpu == "x64") {
       sources = libvpx_srcs_x86_64_avx2
+    }  else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+## TODO for ppc64le || current_cpu == "ppc64le") {
+      sources = libvpx_srcs_ppc64
     }
   }
 
@@ -242,9 +269,12 @@
       sources = libvpx_srcs_x86_avx512
     } else if (current_cpu == "x64") {
       sources = libvpx_srcs_x86_64_avx512
+    }  else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+## TODO for ppc64le || current_cpu == "ppc64le") {
+      sources = libvpx_srcs_ppc64
     }
-  }
-}
+   }
+ }
 
 if (cpu_arch_full == "arm-neon-cpu-detect") {
   static_library("libvpx_intrinsics_neon") {
@@ -344,6 +374,9 @@
     } else {
       sources = libvpx_srcs_arm64
     }
+  } else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+## TODO for ppc64le || current_cpu == "ppc64le") {
+    sources = libvpx_srcs_ppc64
   }
 
   configs -= [ "//build/config/compiler:chromium_code" ]
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/generate_gni.sh b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/generate_gni.sh
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/generate_gni.sh	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/generate_gni.sh	2025-06-05 22:08:23.000000000 +0800
@@ -361,6 +361,7 @@
 gen_config_files linux/arm64-highbd "--target=armv8-linux-gcc ${all_platforms} ${HIGHBD}"
 gen_config_files linux/mipsel "--target=mips32-linux-gcc ${all_platforms}"
 gen_config_files linux/mips64el "--target=mips64-linux-gcc ${all_platforms}"
+gen_config_files linux/ppc64 "--target=ppc64le-linux-gcc ${all_platforms}"
 gen_config_files linux/generic "--target=generic-gnu $HIGHBD ${all_platforms}"
 gen_config_files win/arm64 "--target=arm64-win64-vs15 ${all_platforms} ${HIGHBD}"
 gen_config_files win/ia32 "--target=x86-win32-vs14 ${all_platforms} ${x86_platforms}"
@@ -386,6 +387,7 @@
 lint_config linux/arm64-highbd
 lint_config linux/mipsel
 lint_config linux/mips64el
+lint_config linux/ppc64
 lint_config linux/generic
 lint_config win/arm64
 lint_config win/ia32
@@ -415,6 +417,7 @@
 gen_rtcd_header linux/arm64-highbd armv8
 gen_rtcd_header linux/mipsel mipsel
 gen_rtcd_header linux/mips64el mips64el
+gen_rtcd_header linux/ppc64 ppc
 gen_rtcd_header linux/generic generic
 gen_rtcd_header win/arm64 armv8
 gen_rtcd_header win/ia32 x86 "${require_sse2}"
@@ -500,6 +503,13 @@
 
   echo "MIPS64 source list is identical to MIPS source list. No need to generate it."
 
+  echo "Generate ppc64 source list."
+  config=$(print_config_basic linux/ppc64)
+  make_clean
+  make libvpx_srcs.txt target=libs $config > /dev/null
+  convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_ppc64
+
+
   echo "Generate NaCl source list."
   config=$(print_config_basic nacl)
   make_clean
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/libvpx_srcs.gni b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/libvpx_srcs.gni
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/libvpx_srcs.gni	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/libvpx_srcs.gni	2025-06-06 14:00:36.000000000 +0800
@@ -3737,6 +3737,365 @@
   "//third_party/libvpx/source/libvpx/vpx_util/vpx_write_yuv_frame.h",
 ]
 libvpx_srcs_mips_assembly = []
+libvpx_srcs_ppc64 = [
+  "//third_party/libvpx/source/libvpx/vp8/common/alloccommon.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/alloccommon.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/blockd.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/blockd.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/coefupdateprobs.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/common.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/default_coef_probs.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/dequantize.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropy.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropy.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropymode.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropymode.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropymv.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropymv.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/extend.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/extend.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/filter.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/filter.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/findnearmv.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/findnearmv.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/generic/systemdependent.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/header.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/idct_blk.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/idctllm.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/invtrans.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/loopfilter.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/loopfilter_filters.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/mbpitch.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/mfqe.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/modecont.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/modecont.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/mv.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/onyx.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/onyxc_int.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/onyxd.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/postproc.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/postproc.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/ppflags.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/quant_common.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/quant_common.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconinter.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconinter.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconintra.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconintra.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconintra4x4.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconintra4x4.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/rtcd.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/setupintrarecon.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/setupintrarecon.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/swapyv12buffer.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/swapyv12buffer.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/systemdependent.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/threading.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/treecoder.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/treecoder.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/vp8_entropymodedata.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/vp8_loopfilter.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/vp8_skin_detection.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/vp8_skin_detection.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/dboolhuff.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/dboolhuff.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/decodeframe.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/decodemv.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/decodemv.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/decoderthreading.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/detokenize.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/detokenize.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/onyxd_if.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/onyxd_int.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/threading.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/treereader.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/bitstream.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/bitstream.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/block.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/boolhuff.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/boolhuff.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/dct.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/dct_value_cost.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/dct_value_tokens.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/defaultcoefcounts.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/denoising.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/denoising.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodeframe.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodeframe.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodeintra.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodeintra.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodemb.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodemb.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodemv.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodemv.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/ethreading.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/ethreading.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/firstpass.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/lookahead.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/lookahead.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/mcomp.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/mcomp.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/modecosts.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/modecosts.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/mr_dissim.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/mr_dissim.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/onyx_if.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/onyx_int.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/pickinter.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/pickinter.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/picklpf.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/picklpf.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/quantize.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/ratectrl.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/ratectrl.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/rdopt.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/rdopt.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/segmentation.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/segmentation.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/tokenize.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/tokenize.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/treewriter.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/treewriter.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/vp8_quantize.c",
+  "//third_party/libvpx/source/libvpx/vp8/vp8_cx_iface.c",
+  "//third_party/libvpx/source/libvpx/vp8/vp8_dx_iface.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/ppc/vp9_idct_vsx.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_alloccommon.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_alloccommon.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_blockd.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_blockd.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_common_data.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_common_data.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropy.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropy.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropymode.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropymode.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropymv.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropymv.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_enums.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_filter.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_filter.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_frame_buffers.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_frame_buffers.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_idct.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_idct.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_loopfilter.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_loopfilter.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mfqe.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mfqe.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mv.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mvref_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mvref_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_onyxc_int.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_postproc.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_postproc.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_ppflags.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_pred_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_pred_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_quant_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_quant_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_reconinter.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_reconinter.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_reconintra.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_reconintra.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_rtcd.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_scale.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_scale.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_scan.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_scan.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_seg_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_seg_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_thread_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_thread_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_tile_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_tile_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decodeframe.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decodeframe.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decodemv.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decodemv.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decoder.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decoder.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_detokenize.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_detokenize.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_dsubexp.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_dsubexp.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_job_queue.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_job_queue.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/ppc/vp9_quantize_vsx.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_alt_ref_aq.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_alt_ref_aq.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_360.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_360.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_complexity.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_complexity.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_cyclicrefresh.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_cyclicrefresh.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_variance.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_variance.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_bitstream.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_bitstream.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_block.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_context_tree.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_context_tree.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_cost.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_cost.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_dct.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_denoiser.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_denoiser.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodeframe.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodeframe.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodemb.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodemb.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodemv.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodemv.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encoder.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encoder.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_ethread.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_ethread.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_extend.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_extend.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_firstpass.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_frame_scale.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_job_queue.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_lookahead.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_lookahead.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_mbgraph.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_mcomp.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_mcomp.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_multi_thread.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_multi_thread.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_noise_estimate.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_noise_estimate.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_picklpf.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_picklpf.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_pickmode.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_pickmode.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_quantize.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_quantize.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_ratectrl.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_ratectrl.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_rd.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_rd.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_rdopt.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_rdopt.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_resize.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_resize.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_segmentation.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_segmentation.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_skin_detection.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_skin_detection.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_speed_features.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_speed_features.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_subexp.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_subexp.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_svc_layercontext.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_svc_layercontext.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_temporal_filter.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_tokenize.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_tokenize.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_treewriter.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_treewriter.h",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_cx_iface.c",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_dx_iface.c",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_dx_iface.h",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_iface_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_iface_common.h",
+  "//third_party/libvpx/source/libvpx/vpx/internal/vpx_codec_internal.h",
+  "//third_party/libvpx/source/libvpx/vpx/src/vpx_codec.c",
+  "//third_party/libvpx/source/libvpx/vpx/src/vpx_decoder.c",
+  "//third_party/libvpx/source/libvpx/vpx/src/vpx_encoder.c",
+  "//third_party/libvpx/source/libvpx/vpx/src/vpx_image.c",
+  "//third_party/libvpx/source/libvpx/vpx/svc_context.h",
+  "//third_party/libvpx/source/libvpx/vpx/vp8.h",
+  "//third_party/libvpx/source/libvpx/vpx/vp8cx.h",
+  "//third_party/libvpx/source/libvpx/vpx/vp8dx.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_codec.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_decoder.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_encoder.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_frame_buffer.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_image.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_integer.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/add_noise.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/avg.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitreader.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitreader.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitreader_buffer.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitreader_buffer.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitwriter.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitwriter.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitwriter_buffer.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitwriter_buffer.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/deblock.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/fwd_txfm.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/fwd_txfm.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/intrapred.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/inv_txfm.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/inv_txfm.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/loopfilter.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/postproc.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/bitdepth_conversion_vsx.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/deblock_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/fdct32x32_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/hadamard_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/intrapred_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/inv_txfm_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/quantize_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/sad_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/subtract_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/transpose_vsx.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/txfm_common_vsx.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/types_vsx.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/variance_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/vpx_convolve_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/prob.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/prob.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/psnr.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/psnr.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/quantize.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/quantize.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/sad.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/skin_detection.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/skin_detection.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/subtract.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/sum_squares.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/txfm_common.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/variance.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/variance.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_convolve.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_convolve.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_dsp_common.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_dsp_rtcd.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_filter.h",
+  "//third_party/libvpx/source/libvpx/vpx_mem/include/vpx_mem_intrnl.h",
+  "//third_party/libvpx/source/libvpx/vpx_mem/vpx_mem.c",
+  "//third_party/libvpx/source/libvpx/vpx_mem/vpx_mem.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/bitops.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/emmintrin_compat.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/mem.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/mem_ops.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/mem_ops_aligned.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/msvc.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/ppc.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/ppc_cpudetect.c",
+  "//third_party/libvpx/source/libvpx/vpx_ports/system_state.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/vpx_once.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/vpx_timer.h",
+  "//third_party/libvpx/source/libvpx/vpx_scale/generic/gen_scalers.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/generic/vpx_scale.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/generic/yv12config.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/generic/yv12extend.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/vpx_scale.h",
+  "//third_party/libvpx/source/libvpx/vpx_scale/vpx_scale_rtcd.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/yv12config.h",
+  "//third_party/libvpx/source/libvpx/vpx_util/endian_inl.h",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_atomics.h",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_thread.c",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_thread.h",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_write_yuv_frame.c",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_write_yuv_frame.h",
+]
+libvpx_srcs_ppc64_assembly = []
 libvpx_srcs_nacl = [
   "//third_party/libvpx/source/libvpx/vp8/common/alloccommon.c",
   "//third_party/libvpx/source/libvpx/vp8/common/alloccommon.h",
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/README.chromium b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/README.chromium
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/README.chromium	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/README.chromium	2025-06-05 23:11:41.000000000 +0800
@@ -6,9 +6,9 @@
 License File: source/libvpx/LICENSE
 Security Critical: yes
 
-Date: Monday September 14 2020
+Date: 
 Branch: master
-Commit: 97356acb50e212fcfb7c91715718ec70953f780c
+Commit: 
 
 Description:
 Contains the sources used to compile libvpx binaries used by Google Chrome and
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp8_rtcd.h b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp8_rtcd.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp8_rtcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp8_rtcd.h	2025-06-05 23:11:35.000000000 +0800
@@ -0,0 +1,357 @@
+// This file is generated. Do not edit.
+#ifndef VP8_RTCD_H_
+#define VP8_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * VP8
+ */
+
+struct blockd;
+struct macroblockd;
+struct loop_filter_info;
+
+/* Encoder forward decls */
+struct block;
+struct macroblock;
+struct variance_vtable;
+union int_mv;
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void vp8_bilinear_predict16x16_c(unsigned char* src_ptr,
+                                 int src_pixels_per_line,
+                                 int xoffset,
+                                 int yoffset,
+                                 unsigned char* dst_ptr,
+                                 int dst_pitch);
+#define vp8_bilinear_predict16x16 vp8_bilinear_predict16x16_c
+
+void vp8_bilinear_predict4x4_c(unsigned char* src_ptr,
+                               int src_pixels_per_line,
+                               int xoffset,
+                               int yoffset,
+                               unsigned char* dst_ptr,
+                               int dst_pitch);
+#define vp8_bilinear_predict4x4 vp8_bilinear_predict4x4_c
+
+void vp8_bilinear_predict8x4_c(unsigned char* src_ptr,
+                               int src_pixels_per_line,
+                               int xoffset,
+                               int yoffset,
+                               unsigned char* dst_ptr,
+                               int dst_pitch);
+#define vp8_bilinear_predict8x4 vp8_bilinear_predict8x4_c
+
+void vp8_bilinear_predict8x8_c(unsigned char* src_ptr,
+                               int src_pixels_per_line,
+                               int xoffset,
+                               int yoffset,
+                               unsigned char* dst_ptr,
+                               int dst_pitch);
+#define vp8_bilinear_predict8x8 vp8_bilinear_predict8x8_c
+
+void vp8_blend_b_c(unsigned char* y,
+                   unsigned char* u,
+                   unsigned char* v,
+                   int y_1,
+                   int u_1,
+                   int v_1,
+                   int alpha,
+                   int stride);
+#define vp8_blend_b vp8_blend_b_c
+
+void vp8_blend_mb_inner_c(unsigned char* y,
+                          unsigned char* u,
+                          unsigned char* v,
+                          int y_1,
+                          int u_1,
+                          int v_1,
+                          int alpha,
+                          int stride);
+#define vp8_blend_mb_inner vp8_blend_mb_inner_c
+
+void vp8_blend_mb_outer_c(unsigned char* y,
+                          unsigned char* u,
+                          unsigned char* v,
+                          int y_1,
+                          int u_1,
+                          int v_1,
+                          int alpha,
+                          int stride);
+#define vp8_blend_mb_outer vp8_blend_mb_outer_c
+
+int vp8_block_error_c(short* coeff, short* dqcoeff);
+#define vp8_block_error vp8_block_error_c
+
+void vp8_copy32xn_c(const unsigned char* src_ptr,
+                    int src_stride,
+                    unsigned char* dst_ptr,
+                    int dst_stride,
+                    int height);
+#define vp8_copy32xn vp8_copy32xn_c
+
+void vp8_copy_mem16x16_c(unsigned char* src,
+                         int src_stride,
+                         unsigned char* dst,
+                         int dst_stride);
+#define vp8_copy_mem16x16 vp8_copy_mem16x16_c
+
+void vp8_copy_mem8x4_c(unsigned char* src,
+                       int src_stride,
+                       unsigned char* dst,
+                       int dst_stride);
+#define vp8_copy_mem8x4 vp8_copy_mem8x4_c
+
+void vp8_copy_mem8x8_c(unsigned char* src,
+                       int src_stride,
+                       unsigned char* dst,
+                       int dst_stride);
+#define vp8_copy_mem8x8 vp8_copy_mem8x8_c
+
+void vp8_dc_only_idct_add_c(short input_dc,
+                            unsigned char* pred_ptr,
+                            int pred_stride,
+                            unsigned char* dst_ptr,
+                            int dst_stride);
+#define vp8_dc_only_idct_add vp8_dc_only_idct_add_c
+
+int vp8_denoiser_filter_c(unsigned char* mc_running_avg_y,
+                          int mc_avg_y_stride,
+                          unsigned char* running_avg_y,
+                          int avg_y_stride,
+                          unsigned char* sig,
+                          int sig_stride,
+                          unsigned int motion_magnitude,
+                          int increase_denoising);
+#define vp8_denoiser_filter vp8_denoiser_filter_c
+
+int vp8_denoiser_filter_uv_c(unsigned char* mc_running_avg,
+                             int mc_avg_stride,
+                             unsigned char* running_avg,
+                             int avg_stride,
+                             unsigned char* sig,
+                             int sig_stride,
+                             unsigned int motion_magnitude,
+                             int increase_denoising);
+#define vp8_denoiser_filter_uv vp8_denoiser_filter_uv_c
+
+void vp8_dequant_idct_add_c(short* input,
+                            short* dq,
+                            unsigned char* dest,
+                            int stride);
+#define vp8_dequant_idct_add vp8_dequant_idct_add_c
+
+void vp8_dequant_idct_add_uv_block_c(short* q,
+                                     short* dq,
+                                     unsigned char* dst_u,
+                                     unsigned char* dst_v,
+                                     int stride,
+                                     char* eobs);
+#define vp8_dequant_idct_add_uv_block vp8_dequant_idct_add_uv_block_c
+
+void vp8_dequant_idct_add_y_block_c(short* q,
+                                    short* dq,
+                                    unsigned char* dst,
+                                    int stride,
+                                    char* eobs);
+#define vp8_dequant_idct_add_y_block vp8_dequant_idct_add_y_block_c
+
+void vp8_dequantize_b_c(struct blockd*, short* DQC);
+#define vp8_dequantize_b vp8_dequantize_b_c
+
+int vp8_diamond_search_sad_c(struct macroblock* x,
+                             struct block* b,
+                             struct blockd* d,
+                             union int_mv* ref_mv,
+                             union int_mv* best_mv,
+                             int search_param,
+                             int sad_per_bit,
+                             int* num00,
+                             struct variance_vtable* fn_ptr,
+                             int* mvcost[2],
+                             union int_mv* center_mv);
+#define vp8_diamond_search_sad vp8_diamond_search_sad_c
+
+void vp8_fast_quantize_b_c(struct block*, struct blockd*);
+#define vp8_fast_quantize_b vp8_fast_quantize_b_c
+
+void vp8_filter_by_weight16x16_c(unsigned char* src,
+                                 int src_stride,
+                                 unsigned char* dst,
+                                 int dst_stride,
+                                 int src_weight);
+#define vp8_filter_by_weight16x16 vp8_filter_by_weight16x16_c
+
+void vp8_filter_by_weight4x4_c(unsigned char* src,
+                               int src_stride,
+                               unsigned char* dst,
+                               int dst_stride,
+                               int src_weight);
+#define vp8_filter_by_weight4x4 vp8_filter_by_weight4x4_c
+
+void vp8_filter_by_weight8x8_c(unsigned char* src,
+                               int src_stride,
+                               unsigned char* dst,
+                               int dst_stride,
+                               int src_weight);
+#define vp8_filter_by_weight8x8 vp8_filter_by_weight8x8_c
+
+int vp8_full_search_sad_c(struct macroblock* x,
+                          struct block* b,
+                          struct blockd* d,
+                          union int_mv* ref_mv,
+                          int sad_per_bit,
+                          int distance,
+                          struct variance_vtable* fn_ptr,
+                          int* mvcost[2],
+                          union int_mv* center_mv);
+#define vp8_full_search_sad vp8_full_search_sad_c
+
+void vp8_loop_filter_bh_c(unsigned char* y_ptr,
+                          unsigned char* u_ptr,
+                          unsigned char* v_ptr,
+                          int y_stride,
+                          int uv_stride,
+                          struct loop_filter_info* lfi);
+#define vp8_loop_filter_bh vp8_loop_filter_bh_c
+
+void vp8_loop_filter_bv_c(unsigned char* y_ptr,
+                          unsigned char* u_ptr,
+                          unsigned char* v_ptr,
+                          int y_stride,
+                          int uv_stride,
+                          struct loop_filter_info* lfi);
+#define vp8_loop_filter_bv vp8_loop_filter_bv_c
+
+void vp8_loop_filter_mbh_c(unsigned char* y_ptr,
+                           unsigned char* u_ptr,
+                           unsigned char* v_ptr,
+                           int y_stride,
+                           int uv_stride,
+                           struct loop_filter_info* lfi);
+#define vp8_loop_filter_mbh vp8_loop_filter_mbh_c
+
+void vp8_loop_filter_mbv_c(unsigned char* y_ptr,
+                           unsigned char* u_ptr,
+                           unsigned char* v_ptr,
+                           int y_stride,
+                           int uv_stride,
+                           struct loop_filter_info* lfi);
+#define vp8_loop_filter_mbv vp8_loop_filter_mbv_c
+
+void vp8_loop_filter_bhs_c(unsigned char* y_ptr,
+                           int y_stride,
+                           const unsigned char* blimit);
+#define vp8_loop_filter_simple_bh vp8_loop_filter_bhs_c
+
+void vp8_loop_filter_bvs_c(unsigned char* y_ptr,
+                           int y_stride,
+                           const unsigned char* blimit);
+#define vp8_loop_filter_simple_bv vp8_loop_filter_bvs_c
+
+void vp8_loop_filter_simple_horizontal_edge_c(unsigned char* y_ptr,
+                                              int y_stride,
+                                              const unsigned char* blimit);
+#define vp8_loop_filter_simple_mbh vp8_loop_filter_simple_horizontal_edge_c
+
+void vp8_loop_filter_simple_vertical_edge_c(unsigned char* y_ptr,
+                                            int y_stride,
+                                            const unsigned char* blimit);
+#define vp8_loop_filter_simple_mbv vp8_loop_filter_simple_vertical_edge_c
+
+int vp8_mbblock_error_c(struct macroblock* mb, int dc);
+#define vp8_mbblock_error vp8_mbblock_error_c
+
+int vp8_mbuverror_c(struct macroblock* mb);
+#define vp8_mbuverror vp8_mbuverror_c
+
+int vp8_refining_search_sad_c(struct macroblock* x,
+                              struct block* b,
+                              struct blockd* d,
+                              union int_mv* ref_mv,
+                              int error_per_bit,
+                              int search_range,
+                              struct variance_vtable* fn_ptr,
+                              int* mvcost[2],
+                              union int_mv* center_mv);
+#define vp8_refining_search_sad vp8_refining_search_sad_c
+
+void vp8_regular_quantize_b_c(struct block*, struct blockd*);
+#define vp8_regular_quantize_b vp8_regular_quantize_b_c
+
+void vp8_short_fdct4x4_c(short* input, short* output, int pitch);
+#define vp8_short_fdct4x4 vp8_short_fdct4x4_c
+
+void vp8_short_fdct8x4_c(short* input, short* output, int pitch);
+#define vp8_short_fdct8x4 vp8_short_fdct8x4_c
+
+void vp8_short_idct4x4llm_c(short* input,
+                            unsigned char* pred_ptr,
+                            int pred_stride,
+                            unsigned char* dst_ptr,
+                            int dst_stride);
+#define vp8_short_idct4x4llm vp8_short_idct4x4llm_c
+
+void vp8_short_inv_walsh4x4_c(short* input, short* mb_dqcoeff);
+#define vp8_short_inv_walsh4x4 vp8_short_inv_walsh4x4_c
+
+void vp8_short_inv_walsh4x4_1_c(short* input, short* mb_dqcoeff);
+#define vp8_short_inv_walsh4x4_1 vp8_short_inv_walsh4x4_1_c
+
+void vp8_short_walsh4x4_c(short* input, short* output, int pitch);
+#define vp8_short_walsh4x4 vp8_short_walsh4x4_c
+
+void vp8_sixtap_predict16x16_c(unsigned char* src_ptr,
+                               int src_pixels_per_line,
+                               int xoffset,
+                               int yoffset,
+                               unsigned char* dst_ptr,
+                               int dst_pitch);
+#define vp8_sixtap_predict16x16 vp8_sixtap_predict16x16_c
+
+void vp8_sixtap_predict4x4_c(unsigned char* src_ptr,
+                             int src_pixels_per_line,
+                             int xoffset,
+                             int yoffset,
+                             unsigned char* dst_ptr,
+                             int dst_pitch);
+#define vp8_sixtap_predict4x4 vp8_sixtap_predict4x4_c
+
+void vp8_sixtap_predict8x4_c(unsigned char* src_ptr,
+                             int src_pixels_per_line,
+                             int xoffset,
+                             int yoffset,
+                             unsigned char* dst_ptr,
+                             int dst_pitch);
+#define vp8_sixtap_predict8x4 vp8_sixtap_predict8x4_c
+
+void vp8_sixtap_predict8x8_c(unsigned char* src_ptr,
+                             int src_pixels_per_line,
+                             int xoffset,
+                             int yoffset,
+                             unsigned char* dst_ptr,
+                             int dst_pitch);
+#define vp8_sixtap_predict8x8 vp8_sixtap_predict8x8_c
+
+void vp8_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void) {}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp9_rtcd.h b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp9_rtcd.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp9_rtcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp9_rtcd.h	2025-06-05 23:11:35.000000000 +0800
@@ -0,0 +1,164 @@
+// This file is generated. Do not edit.
+#ifndef VP9_RTCD_H_
+#define VP9_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * VP9
+ */
+
+#include "vp9/common/vp9_common.h"
+#include "vp9/common/vp9_enums.h"
+#include "vp9/common/vp9_filter.h"
+#include "vpx/vpx_integer.h"
+
+struct macroblockd;
+
+/* Encoder forward decls */
+struct macroblock;
+struct vp9_variance_vtable;
+struct search_site_config;
+struct mv;
+union int_mv;
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int64_t vp9_block_error_c(const tran_low_t* coeff,
+                          const tran_low_t* dqcoeff,
+                          intptr_t block_size,
+                          int64_t* ssz);
+#define vp9_block_error vp9_block_error_c
+
+int64_t vp9_block_error_fp_c(const tran_low_t* coeff,
+                             const tran_low_t* dqcoeff,
+                             int block_size);
+#define vp9_block_error_fp vp9_block_error_fp_c
+
+int vp9_denoiser_filter_c(const uint8_t* sig,
+                          int sig_stride,
+                          const uint8_t* mc_avg,
+                          int mc_avg_stride,
+                          uint8_t* avg,
+                          int avg_stride,
+                          int increase_denoising,
+                          BLOCK_SIZE bs,
+                          int motion_magnitude);
+#define vp9_denoiser_filter vp9_denoiser_filter_c
+
+int vp9_diamond_search_sad_c(const struct macroblock* x,
+                             const struct search_site_config* cfg,
+                             struct mv* ref_mv,
+                             struct mv* best_mv,
+                             int search_param,
+                             int sad_per_bit,
+                             int* num00,
+                             const struct vp9_variance_vtable* fn_ptr,
+                             const struct mv* center_mv);
+#define vp9_diamond_search_sad vp9_diamond_search_sad_c
+
+void vp9_fht16x16_c(const int16_t* input,
+                    tran_low_t* output,
+                    int stride,
+                    int tx_type);
+#define vp9_fht16x16 vp9_fht16x16_c
+
+void vp9_fht4x4_c(const int16_t* input,
+                  tran_low_t* output,
+                  int stride,
+                  int tx_type);
+#define vp9_fht4x4 vp9_fht4x4_c
+
+void vp9_fht8x8_c(const int16_t* input,
+                  tran_low_t* output,
+                  int stride,
+                  int tx_type);
+#define vp9_fht8x8 vp9_fht8x8_c
+
+void vp9_filter_by_weight16x16_c(const uint8_t* src,
+                                 int src_stride,
+                                 uint8_t* dst,
+                                 int dst_stride,
+                                 int src_weight);
+#define vp9_filter_by_weight16x16 vp9_filter_by_weight16x16_c
+
+void vp9_filter_by_weight8x8_c(const uint8_t* src,
+                               int src_stride,
+                               uint8_t* dst,
+                               int dst_stride,
+                               int src_weight);
+#define vp9_filter_by_weight8x8 vp9_filter_by_weight8x8_c
+
+void vp9_fwht4x4_c(const int16_t* input, tran_low_t* output, int stride);
+#define vp9_fwht4x4 vp9_fwht4x4_c
+
+void vp9_iht16x16_256_add_c(const tran_low_t* input,
+                            uint8_t* dest,
+                            int stride,
+                            int tx_type);
+#define vp9_iht16x16_256_add vp9_iht16x16_256_add_c
+
+void vp9_iht4x4_16_add_c(const tran_low_t* input,
+                         uint8_t* dest,
+                         int stride,
+                         int tx_type);
+#define vp9_iht4x4_16_add vp9_iht4x4_16_add_c
+
+void vp9_iht8x8_64_add_c(const tran_low_t* input,
+                         uint8_t* dest,
+                         int stride,
+                         int tx_type);
+#define vp9_iht8x8_64_add vp9_iht8x8_64_add_c
+
+void vp9_quantize_fp_c(const tran_low_t* coeff_ptr,
+                       intptr_t n_coeffs,
+                       int skip_block,
+                       const int16_t* round_ptr,
+                       const int16_t* quant_ptr,
+                       tran_low_t* qcoeff_ptr,
+                       tran_low_t* dqcoeff_ptr,
+                       const int16_t* dequant_ptr,
+                       uint16_t* eob_ptr,
+                       const int16_t* scan,
+                       const int16_t* iscan);
+#define vp9_quantize_fp vp9_quantize_fp_c
+
+void vp9_quantize_fp_32x32_c(const tran_low_t* coeff_ptr,
+                             intptr_t n_coeffs,
+                             int skip_block,
+                             const int16_t* round_ptr,
+                             const int16_t* quant_ptr,
+                             tran_low_t* qcoeff_ptr,
+                             tran_low_t* dqcoeff_ptr,
+                             const int16_t* dequant_ptr,
+                             uint16_t* eob_ptr,
+                             const int16_t* scan,
+                             const int16_t* iscan);
+#define vp9_quantize_fp_32x32 vp9_quantize_fp_32x32_c
+
+void vp9_scale_and_extend_frame_c(const struct yv12_buffer_config* src,
+                                  struct yv12_buffer_config* dst,
+                                  INTERP_FILTER filter_type,
+                                  int phase_scaler);
+#define vp9_scale_and_extend_frame vp9_scale_and_extend_frame_c
+
+void vp9_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void) {}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.asm b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.asm
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.asm	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.asm	2025-06-05 23:11:25.000000000 +0800
@@ -0,0 +1,98 @@
+@ This file was created from a .asm file
+@  using the ads2gas.pl script.
+	.syntax unified
+.equ VPX_ARCH_ARM ,  0
+.equ ARCH_ARM ,  0
+.equ VPX_ARCH_MIPS ,  0
+.equ ARCH_MIPS ,  0
+.equ VPX_ARCH_X86 ,  0
+.equ ARCH_X86 ,  0
+.equ VPX_ARCH_X86_64 ,  0
+.equ ARCH_X86_64 ,  0
+.equ VPX_ARCH_PPC ,  1
+.equ ARCH_PPC ,  1
+.equ HAVE_NEON ,  0
+.equ HAVE_NEON_ASM ,  0
+.equ HAVE_MIPS32 ,  0
+.equ HAVE_DSPR2 ,  0
+.equ HAVE_MSA ,  0
+.equ HAVE_MIPS64 ,  0
+.equ HAVE_MMX ,  0
+.equ HAVE_SSE ,  0
+.equ HAVE_SSE2 ,  0
+.equ HAVE_SSE3 ,  0
+.equ HAVE_SSSE3 ,  0
+.equ HAVE_SSE4_1 ,  0
+.equ HAVE_AVX ,  0
+.equ HAVE_AVX2 ,  0
+.equ HAVE_AVX512 ,  0
+.equ HAVE_VSX ,  0
+.equ HAVE_MMI ,  0
+.equ HAVE_VPX_PORTS ,  1
+.equ HAVE_PTHREAD_H ,  1
+.equ HAVE_UNISTD_H ,  0
+.equ CONFIG_DEPENDENCY_TRACKING ,  1
+.equ CONFIG_EXTERNAL_BUILD ,  1
+.equ CONFIG_INSTALL_DOCS ,  0
+.equ CONFIG_INSTALL_BINS ,  1
+.equ CONFIG_INSTALL_LIBS ,  1
+.equ CONFIG_INSTALL_SRCS ,  0
+.equ CONFIG_DEBUG ,  0
+.equ CONFIG_GPROF ,  0
+.equ CONFIG_GCOV ,  0
+.equ CONFIG_RVCT ,  0
+.equ CONFIG_GCC ,  1
+.equ CONFIG_MSVS ,  0
+.equ CONFIG_PIC ,  0
+.equ CONFIG_BIG_ENDIAN ,  0
+.equ CONFIG_CODEC_SRCS ,  0
+.equ CONFIG_DEBUG_LIBS ,  0
+.equ CONFIG_DEQUANT_TOKENS ,  0
+.equ CONFIG_DC_RECON ,  0
+.equ CONFIG_RUNTIME_CPU_DETECT ,  0
+.equ CONFIG_POSTPROC ,  1
+.equ CONFIG_VP9_POSTPROC ,  1
+.equ CONFIG_MULTITHREAD ,  1
+.equ CONFIG_INTERNAL_STATS ,  0
+.equ CONFIG_VP8_ENCODER ,  1
+.equ CONFIG_VP8_DECODER ,  1
+.equ CONFIG_VP9_ENCODER ,  1
+.equ CONFIG_VP9_DECODER ,  1
+.equ CONFIG_VP8 ,  1
+.equ CONFIG_VP9 ,  1
+.equ CONFIG_ENCODERS ,  1
+.equ CONFIG_DECODERS ,  1
+.equ CONFIG_STATIC_MSVCRT ,  0
+.equ CONFIG_SPATIAL_RESAMPLING ,  1
+.equ CONFIG_REALTIME_ONLY ,  1
+.equ CONFIG_ONTHEFLY_BITPACKING ,  0
+.equ CONFIG_ERROR_CONCEALMENT ,  0
+.equ CONFIG_SHARED ,  0
+.equ CONFIG_STATIC ,  1
+.equ CONFIG_SMALL ,  0
+.equ CONFIG_POSTPROC_VISUALIZER ,  0
+.equ CONFIG_OS_SUPPORT ,  1
+.equ CONFIG_UNIT_TESTS ,  1
+.equ CONFIG_WEBM_IO ,  1
+.equ CONFIG_LIBYUV ,  0
+.equ CONFIG_DECODE_PERF_TESTS ,  0
+.equ CONFIG_ENCODE_PERF_TESTS ,  0
+.equ CONFIG_MULTI_RES_ENCODING ,  1
+.equ CONFIG_TEMPORAL_DENOISING ,  1
+.equ CONFIG_VP9_TEMPORAL_DENOISING ,  1
+.equ CONFIG_CONSISTENT_RECODE ,  0
+.equ CONFIG_COEFFICIENT_RANGE_CHECKING ,  0
+.equ CONFIG_VP9_HIGHBITDEPTH ,  0
+.equ CONFIG_BETTER_HW_COMPATIBILITY ,  0
+.equ CONFIG_EXPERIMENTAL ,  0
+.equ CONFIG_SIZE_LIMIT ,  1
+.equ CONFIG_ALWAYS_ADJUST_BPM ,  0
+.equ CONFIG_BITSTREAM_DEBUG ,  0
+.equ CONFIG_MISMATCH_DEBUG ,  0
+.equ CONFIG_FP_MB_STATS ,  0
+.equ CONFIG_EMULATE_HARDWARE ,  0
+.equ CONFIG_NON_GREEDY_MV ,  0
+.equ CONFIG_RATE_CTRL ,  0
+.equ DECODE_WIDTH_LIMIT ,  16384
+.equ DECODE_HEIGHT_LIMIT ,  16384
+	.section	.note.GNU-stack,"",%progbits
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.c b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.c	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.c	2025-06-05 23:11:25.000000000 +0800
@@ -0,0 +1,10 @@
+/* Copyright (c) 2011 The WebM project authors. All Rights Reserved. */
+/*  */
+/* Use of this source code is governed by a BSD-style license */
+/* that can be found in the LICENSE file in the root of the source */
+/* tree. An additional intellectual property rights grant can be found */
+/* in the file PATENTS.  All contributing project authors may */
+/* be found in the AUTHORS file in the root of the source tree. */
+#include "vpx/vpx_codec.h"
+static const char* const cfg = "--target=ppc64le-linux-gcc --enable-external-build --enable-postproc --enable-multi-res-encoding --enable-temporal-denoising --enable-vp9-temporal-denoising --enable-vp9-postproc --size-limit=16384x16384 --enable-realtime-only --disable-install-docs --disable-libyuv";
+const char *vpx_codec_build_config(void) {return cfg;}
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.h b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.h	2025-06-05 23:11:25.000000000 +0800
@@ -0,0 +1,107 @@
+/* Copyright (c) 2011 The WebM project authors. All Rights Reserved. */
+/*  */
+/* Use of this source code is governed by a BSD-style license */
+/* that can be found in the LICENSE file in the root of the source */
+/* tree. An additional intellectual property rights grant can be found */
+/* in the file PATENTS.  All contributing project authors may */
+/* be found in the AUTHORS file in the root of the source tree. */
+/* This file automatically generated by configure. Do not edit! */
+#ifndef VPX_CONFIG_H
+#define VPX_CONFIG_H
+#define RESTRICT    
+#define INLINE      inline
+#define VPX_ARCH_ARM 0
+#define ARCH_ARM 0
+#define VPX_ARCH_MIPS 0
+#define ARCH_MIPS 0
+#define VPX_ARCH_X86 0
+#define ARCH_X86 0
+#define VPX_ARCH_X86_64 0
+#define ARCH_X86_64 0
+#define VPX_ARCH_PPC 1
+#define ARCH_PPC 1
+#define HAVE_NEON 0
+#define HAVE_NEON_ASM 0
+#define HAVE_MIPS32 0
+#define HAVE_DSPR2 0
+#define HAVE_MSA 0
+#define HAVE_MIPS64 0
+#define HAVE_MMX 0
+#define HAVE_SSE 0
+#define HAVE_SSE2 0
+#define HAVE_SSE3 0
+#define HAVE_SSSE3 0
+#define HAVE_SSE4_1 0
+#define HAVE_AVX 0
+#define HAVE_AVX2 0
+#define HAVE_AVX512 0
+#define HAVE_VSX 0
+#define HAVE_MMI 0
+#define HAVE_VPX_PORTS 1
+#define HAVE_PTHREAD_H 1
+#define HAVE_UNISTD_H 0
+#define CONFIG_DEPENDENCY_TRACKING 1
+#define CONFIG_EXTERNAL_BUILD 1
+#define CONFIG_INSTALL_DOCS 0
+#define CONFIG_INSTALL_BINS 1
+#define CONFIG_INSTALL_LIBS 1
+#define CONFIG_INSTALL_SRCS 0
+#define CONFIG_DEBUG 0
+#define CONFIG_GPROF 0
+#define CONFIG_GCOV 0
+#define CONFIG_RVCT 0
+#define CONFIG_GCC 1
+#define CONFIG_MSVS 0
+#define CONFIG_PIC 0
+#define CONFIG_BIG_ENDIAN 0
+#define CONFIG_CODEC_SRCS 0
+#define CONFIG_DEBUG_LIBS 0
+#define CONFIG_DEQUANT_TOKENS 0
+#define CONFIG_DC_RECON 0
+#define CONFIG_RUNTIME_CPU_DETECT 0
+#define CONFIG_POSTPROC 1
+#define CONFIG_VP9_POSTPROC 1
+#define CONFIG_MULTITHREAD 1
+#define CONFIG_INTERNAL_STATS 0
+#define CONFIG_VP8_ENCODER 1
+#define CONFIG_VP8_DECODER 1
+#define CONFIG_VP9_ENCODER 1
+#define CONFIG_VP9_DECODER 1
+#define CONFIG_VP8 1
+#define CONFIG_VP9 1
+#define CONFIG_ENCODERS 1
+#define CONFIG_DECODERS 1
+#define CONFIG_STATIC_MSVCRT 0
+#define CONFIG_SPATIAL_RESAMPLING 1
+#define CONFIG_REALTIME_ONLY 1
+#define CONFIG_ONTHEFLY_BITPACKING 0
+#define CONFIG_ERROR_CONCEALMENT 0
+#define CONFIG_SHARED 0
+#define CONFIG_STATIC 1
+#define CONFIG_SMALL 0
+#define CONFIG_POSTPROC_VISUALIZER 0
+#define CONFIG_OS_SUPPORT 1
+#define CONFIG_UNIT_TESTS 1
+#define CONFIG_WEBM_IO 1
+#define CONFIG_LIBYUV 0
+#define CONFIG_DECODE_PERF_TESTS 0
+#define CONFIG_ENCODE_PERF_TESTS 0
+#define CONFIG_MULTI_RES_ENCODING 1
+#define CONFIG_TEMPORAL_DENOISING 1
+#define CONFIG_VP9_TEMPORAL_DENOISING 1
+#define CONFIG_CONSISTENT_RECODE 0
+#define CONFIG_COEFFICIENT_RANGE_CHECKING 0
+#define CONFIG_VP9_HIGHBITDEPTH 0
+#define CONFIG_BETTER_HW_COMPATIBILITY 0
+#define CONFIG_EXPERIMENTAL 0
+#define CONFIG_SIZE_LIMIT 1
+#define CONFIG_ALWAYS_ADJUST_BPM 0
+#define CONFIG_BITSTREAM_DEBUG 0
+#define CONFIG_MISMATCH_DEBUG 0
+#define CONFIG_FP_MB_STATS 0
+#define CONFIG_EMULATE_HARDWARE 0
+#define CONFIG_NON_GREEDY_MV 0
+#define CONFIG_RATE_CTRL 0
+#define DECODE_WIDTH_LIMIT 16384
+#define DECODE_HEIGHT_LIMIT 16384
+#endif /* VPX_CONFIG_H */
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_dsp_rtcd.h b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_dsp_rtcd.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_dsp_rtcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_dsp_rtcd.h	2025-06-05 23:11:35.000000000 +0800
@@ -0,0 +1,1583 @@
+// This file is generated. Do not edit.
+#ifndef VPX_DSP_RTCD_H_
+#define VPX_DSP_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * DSP
+ */
+
+#include "vpx/vpx_integer.h"
+#include "vpx_dsp/vpx_dsp_common.h"
+#include "vpx_dsp/vpx_filter.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+unsigned int vpx_avg_4x4_c(const uint8_t*, int p);
+#define vpx_avg_4x4 vpx_avg_4x4_c
+
+unsigned int vpx_avg_8x8_c(const uint8_t*, int p);
+#define vpx_avg_8x8 vpx_avg_8x8_c
+
+void vpx_comp_avg_pred_c(uint8_t* comp_pred,
+                         const uint8_t* pred,
+                         int width,
+                         int height,
+                         const uint8_t* ref,
+                         int ref_stride);
+#define vpx_comp_avg_pred vpx_comp_avg_pred_c
+
+void vpx_convolve8_c(const uint8_t* src,
+                     ptrdiff_t src_stride,
+                     uint8_t* dst,
+                     ptrdiff_t dst_stride,
+                     const InterpKernel* filter,
+                     int x0_q4,
+                     int x_step_q4,
+                     int y0_q4,
+                     int y_step_q4,
+                     int w,
+                     int h);
+#define vpx_convolve8 vpx_convolve8_c
+
+void vpx_convolve8_avg_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const InterpKernel* filter,
+                         int x0_q4,
+                         int x_step_q4,
+                         int y0_q4,
+                         int y_step_q4,
+                         int w,
+                         int h);
+#define vpx_convolve8_avg vpx_convolve8_avg_c
+
+void vpx_convolve8_avg_horiz_c(const uint8_t* src,
+                               ptrdiff_t src_stride,
+                               uint8_t* dst,
+                               ptrdiff_t dst_stride,
+                               const InterpKernel* filter,
+                               int x0_q4,
+                               int x_step_q4,
+                               int y0_q4,
+                               int y_step_q4,
+                               int w,
+                               int h);
+#define vpx_convolve8_avg_horiz vpx_convolve8_avg_horiz_c
+
+void vpx_convolve8_avg_vert_c(const uint8_t* src,
+                              ptrdiff_t src_stride,
+                              uint8_t* dst,
+                              ptrdiff_t dst_stride,
+                              const InterpKernel* filter,
+                              int x0_q4,
+                              int x_step_q4,
+                              int y0_q4,
+                              int y_step_q4,
+                              int w,
+                              int h);
+#define vpx_convolve8_avg_vert vpx_convolve8_avg_vert_c
+
+void vpx_convolve8_horiz_c(const uint8_t* src,
+                           ptrdiff_t src_stride,
+                           uint8_t* dst,
+                           ptrdiff_t dst_stride,
+                           const InterpKernel* filter,
+                           int x0_q4,
+                           int x_step_q4,
+                           int y0_q4,
+                           int y_step_q4,
+                           int w,
+                           int h);
+#define vpx_convolve8_horiz vpx_convolve8_horiz_c
+
+void vpx_convolve8_vert_c(const uint8_t* src,
+                          ptrdiff_t src_stride,
+                          uint8_t* dst,
+                          ptrdiff_t dst_stride,
+                          const InterpKernel* filter,
+                          int x0_q4,
+                          int x_step_q4,
+                          int y0_q4,
+                          int y_step_q4,
+                          int w,
+                          int h);
+#define vpx_convolve8_vert vpx_convolve8_vert_c
+
+void vpx_convolve_avg_c(const uint8_t* src,
+                        ptrdiff_t src_stride,
+                        uint8_t* dst,
+                        ptrdiff_t dst_stride,
+                        const InterpKernel* filter,
+                        int x0_q4,
+                        int x_step_q4,
+                        int y0_q4,
+                        int y_step_q4,
+                        int w,
+                        int h);
+#define vpx_convolve_avg vpx_convolve_avg_c
+
+void vpx_convolve_copy_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const InterpKernel* filter,
+                         int x0_q4,
+                         int x_step_q4,
+                         int y0_q4,
+                         int y_step_q4,
+                         int w,
+                         int h);
+#define vpx_convolve_copy vpx_convolve_copy_c
+
+void vpx_d117_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d117_predictor_16x16 vpx_d117_predictor_16x16_c
+
+void vpx_d117_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d117_predictor_32x32 vpx_d117_predictor_32x32_c
+
+void vpx_d117_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d117_predictor_4x4 vpx_d117_predictor_4x4_c
+
+void vpx_d117_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d117_predictor_8x8 vpx_d117_predictor_8x8_c
+
+void vpx_d135_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d135_predictor_16x16 vpx_d135_predictor_16x16_c
+
+void vpx_d135_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d135_predictor_32x32 vpx_d135_predictor_32x32_c
+
+void vpx_d135_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d135_predictor_4x4 vpx_d135_predictor_4x4_c
+
+void vpx_d135_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d135_predictor_8x8 vpx_d135_predictor_8x8_c
+
+void vpx_d153_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d153_predictor_16x16 vpx_d153_predictor_16x16_c
+
+void vpx_d153_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d153_predictor_32x32 vpx_d153_predictor_32x32_c
+
+void vpx_d153_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d153_predictor_4x4 vpx_d153_predictor_4x4_c
+
+void vpx_d153_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d153_predictor_8x8 vpx_d153_predictor_8x8_c
+
+void vpx_d207_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d207_predictor_16x16 vpx_d207_predictor_16x16_c
+
+void vpx_d207_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d207_predictor_32x32 vpx_d207_predictor_32x32_c
+
+void vpx_d207_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d207_predictor_4x4 vpx_d207_predictor_4x4_c
+
+void vpx_d207_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d207_predictor_8x8 vpx_d207_predictor_8x8_c
+
+void vpx_d45_predictor_16x16_c(uint8_t* dst,
+                               ptrdiff_t stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d45_predictor_16x16 vpx_d45_predictor_16x16_c
+
+void vpx_d45_predictor_32x32_c(uint8_t* dst,
+                               ptrdiff_t stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d45_predictor_32x32 vpx_d45_predictor_32x32_c
+
+void vpx_d45_predictor_4x4_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d45_predictor_4x4 vpx_d45_predictor_4x4_c
+
+void vpx_d45_predictor_8x8_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d45_predictor_8x8 vpx_d45_predictor_8x8_c
+
+void vpx_d45e_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d45e_predictor_4x4 vpx_d45e_predictor_4x4_c
+
+void vpx_d63_predictor_16x16_c(uint8_t* dst,
+                               ptrdiff_t stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d63_predictor_16x16 vpx_d63_predictor_16x16_c
+
+void vpx_d63_predictor_32x32_c(uint8_t* dst,
+                               ptrdiff_t stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d63_predictor_32x32 vpx_d63_predictor_32x32_c
+
+void vpx_d63_predictor_4x4_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d63_predictor_4x4 vpx_d63_predictor_4x4_c
+
+void vpx_d63_predictor_8x8_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d63_predictor_8x8 vpx_d63_predictor_8x8_c
+
+void vpx_d63e_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d63e_predictor_4x4 vpx_d63e_predictor_4x4_c
+
+void vpx_dc_128_predictor_16x16_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define vpx_dc_128_predictor_16x16 vpx_dc_128_predictor_16x16_c
+
+void vpx_dc_128_predictor_32x32_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define vpx_dc_128_predictor_32x32 vpx_dc_128_predictor_32x32_c
+
+void vpx_dc_128_predictor_4x4_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_128_predictor_4x4 vpx_dc_128_predictor_4x4_c
+
+void vpx_dc_128_predictor_8x8_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_128_predictor_8x8 vpx_dc_128_predictor_8x8_c
+
+void vpx_dc_left_predictor_16x16_c(uint8_t* dst,
+                                   ptrdiff_t stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define vpx_dc_left_predictor_16x16 vpx_dc_left_predictor_16x16_c
+
+void vpx_dc_left_predictor_32x32_c(uint8_t* dst,
+                                   ptrdiff_t stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define vpx_dc_left_predictor_32x32 vpx_dc_left_predictor_32x32_c
+
+void vpx_dc_left_predictor_4x4_c(uint8_t* dst,
+                                 ptrdiff_t stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define vpx_dc_left_predictor_4x4 vpx_dc_left_predictor_4x4_c
+
+void vpx_dc_left_predictor_8x8_c(uint8_t* dst,
+                                 ptrdiff_t stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define vpx_dc_left_predictor_8x8 vpx_dc_left_predictor_8x8_c
+
+void vpx_dc_predictor_16x16_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_dc_predictor_16x16 vpx_dc_predictor_16x16_c
+
+void vpx_dc_predictor_32x32_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_dc_predictor_32x32 vpx_dc_predictor_32x32_c
+
+void vpx_dc_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_dc_predictor_4x4 vpx_dc_predictor_4x4_c
+
+void vpx_dc_predictor_8x8_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_dc_predictor_8x8 vpx_dc_predictor_8x8_c
+
+void vpx_dc_top_predictor_16x16_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define vpx_dc_top_predictor_16x16 vpx_dc_top_predictor_16x16_c
+
+void vpx_dc_top_predictor_32x32_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define vpx_dc_top_predictor_32x32 vpx_dc_top_predictor_32x32_c
+
+void vpx_dc_top_predictor_4x4_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_top_predictor_4x4 vpx_dc_top_predictor_4x4_c
+
+void vpx_dc_top_predictor_8x8_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_top_predictor_8x8 vpx_dc_top_predictor_8x8_c
+
+void vpx_fdct16x16_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct16x16 vpx_fdct16x16_c
+
+void vpx_fdct16x16_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct16x16_1 vpx_fdct16x16_1_c
+
+void vpx_fdct32x32_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct32x32 vpx_fdct32x32_c
+
+void vpx_fdct32x32_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct32x32_1 vpx_fdct32x32_1_c
+
+void vpx_fdct32x32_rd_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct32x32_rd vpx_fdct32x32_rd_c
+
+void vpx_fdct4x4_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct4x4 vpx_fdct4x4_c
+
+void vpx_fdct4x4_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct4x4_1 vpx_fdct4x4_1_c
+
+void vpx_fdct8x8_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct8x8 vpx_fdct8x8_c
+
+void vpx_fdct8x8_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct8x8_1 vpx_fdct8x8_1_c
+
+void vpx_get16x16var_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* ref_ptr,
+                       int ref_stride,
+                       unsigned int* sse,
+                       int* sum);
+#define vpx_get16x16var vpx_get16x16var_c
+
+unsigned int vpx_get4x4sse_cs_c(const unsigned char* src_ptr,
+                                int src_stride,
+                                const unsigned char* ref_ptr,
+                                int ref_stride);
+#define vpx_get4x4sse_cs vpx_get4x4sse_cs_c
+
+void vpx_get8x8var_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     unsigned int* sse,
+                     int* sum);
+#define vpx_get8x8var vpx_get8x8var_c
+
+unsigned int vpx_get_mb_ss_c(const int16_t*);
+#define vpx_get_mb_ss vpx_get_mb_ss_c
+
+void vpx_h_predictor_16x16_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_h_predictor_16x16 vpx_h_predictor_16x16_c
+
+void vpx_h_predictor_32x32_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_h_predictor_32x32 vpx_h_predictor_32x32_c
+
+void vpx_h_predictor_4x4_c(uint8_t* dst,
+                           ptrdiff_t stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_h_predictor_4x4 vpx_h_predictor_4x4_c
+
+void vpx_h_predictor_8x8_c(uint8_t* dst,
+                           ptrdiff_t stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_h_predictor_8x8 vpx_h_predictor_8x8_c
+
+void vpx_hadamard_16x16_c(const int16_t* src_diff,
+                          ptrdiff_t src_stride,
+                          int16_t* coeff);
+#define vpx_hadamard_16x16 vpx_hadamard_16x16_c
+
+void vpx_hadamard_32x32_c(const int16_t* src_diff,
+                          ptrdiff_t src_stride,
+                          int16_t* coeff);
+#define vpx_hadamard_32x32 vpx_hadamard_32x32_c
+
+void vpx_hadamard_8x8_c(const int16_t* src_diff,
+                        ptrdiff_t src_stride,
+                        int16_t* coeff);
+#define vpx_hadamard_8x8 vpx_hadamard_8x8_c
+
+void vpx_he_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_he_predictor_4x4 vpx_he_predictor_4x4_c
+
+void vpx_idct16x16_10_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct16x16_10_add vpx_idct16x16_10_add_c
+
+void vpx_idct16x16_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct16x16_1_add vpx_idct16x16_1_add_c
+
+void vpx_idct16x16_256_add_c(const tran_low_t* input,
+                             uint8_t* dest,
+                             int stride);
+#define vpx_idct16x16_256_add vpx_idct16x16_256_add_c
+
+void vpx_idct16x16_38_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct16x16_38_add vpx_idct16x16_38_add_c
+
+void vpx_idct32x32_1024_add_c(const tran_low_t* input,
+                              uint8_t* dest,
+                              int stride);
+#define vpx_idct32x32_1024_add vpx_idct32x32_1024_add_c
+
+void vpx_idct32x32_135_add_c(const tran_low_t* input,
+                             uint8_t* dest,
+                             int stride);
+#define vpx_idct32x32_135_add vpx_idct32x32_135_add_c
+
+void vpx_idct32x32_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct32x32_1_add vpx_idct32x32_1_add_c
+
+void vpx_idct32x32_34_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct32x32_34_add vpx_idct32x32_34_add_c
+
+void vpx_idct4x4_16_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct4x4_16_add vpx_idct4x4_16_add_c
+
+void vpx_idct4x4_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct4x4_1_add vpx_idct4x4_1_add_c
+
+void vpx_idct8x8_12_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct8x8_12_add vpx_idct8x8_12_add_c
+
+void vpx_idct8x8_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct8x8_1_add vpx_idct8x8_1_add_c
+
+void vpx_idct8x8_64_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct8x8_64_add vpx_idct8x8_64_add_c
+
+int16_t vpx_int_pro_col_c(const uint8_t* ref, const int width);
+#define vpx_int_pro_col vpx_int_pro_col_c
+
+void vpx_int_pro_row_c(int16_t* hbuf,
+                       const uint8_t* ref,
+                       const int ref_stride,
+                       const int height);
+#define vpx_int_pro_row vpx_int_pro_row_c
+
+void vpx_iwht4x4_16_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_iwht4x4_16_add vpx_iwht4x4_16_add_c
+
+void vpx_iwht4x4_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_iwht4x4_1_add vpx_iwht4x4_1_add_c
+
+void vpx_lpf_horizontal_16_c(uint8_t* s,
+                             int pitch,
+                             const uint8_t* blimit,
+                             const uint8_t* limit,
+                             const uint8_t* thresh);
+#define vpx_lpf_horizontal_16 vpx_lpf_horizontal_16_c
+
+void vpx_lpf_horizontal_16_dual_c(uint8_t* s,
+                                  int pitch,
+                                  const uint8_t* blimit,
+                                  const uint8_t* limit,
+                                  const uint8_t* thresh);
+#define vpx_lpf_horizontal_16_dual vpx_lpf_horizontal_16_dual_c
+
+void vpx_lpf_horizontal_4_c(uint8_t* s,
+                            int pitch,
+                            const uint8_t* blimit,
+                            const uint8_t* limit,
+                            const uint8_t* thresh);
+#define vpx_lpf_horizontal_4 vpx_lpf_horizontal_4_c
+
+void vpx_lpf_horizontal_4_dual_c(uint8_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit0,
+                                 const uint8_t* limit0,
+                                 const uint8_t* thresh0,
+                                 const uint8_t* blimit1,
+                                 const uint8_t* limit1,
+                                 const uint8_t* thresh1);
+#define vpx_lpf_horizontal_4_dual vpx_lpf_horizontal_4_dual_c
+
+void vpx_lpf_horizontal_8_c(uint8_t* s,
+                            int pitch,
+                            const uint8_t* blimit,
+                            const uint8_t* limit,
+                            const uint8_t* thresh);
+#define vpx_lpf_horizontal_8 vpx_lpf_horizontal_8_c
+
+void vpx_lpf_horizontal_8_dual_c(uint8_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit0,
+                                 const uint8_t* limit0,
+                                 const uint8_t* thresh0,
+                                 const uint8_t* blimit1,
+                                 const uint8_t* limit1,
+                                 const uint8_t* thresh1);
+#define vpx_lpf_horizontal_8_dual vpx_lpf_horizontal_8_dual_c
+
+void vpx_lpf_vertical_16_c(uint8_t* s,
+                           int pitch,
+                           const uint8_t* blimit,
+                           const uint8_t* limit,
+                           const uint8_t* thresh);
+#define vpx_lpf_vertical_16 vpx_lpf_vertical_16_c
+
+void vpx_lpf_vertical_16_dual_c(uint8_t* s,
+                                int pitch,
+                                const uint8_t* blimit,
+                                const uint8_t* limit,
+                                const uint8_t* thresh);
+#define vpx_lpf_vertical_16_dual vpx_lpf_vertical_16_dual_c
+
+void vpx_lpf_vertical_4_c(uint8_t* s,
+                          int pitch,
+                          const uint8_t* blimit,
+                          const uint8_t* limit,
+                          const uint8_t* thresh);
+#define vpx_lpf_vertical_4 vpx_lpf_vertical_4_c
+
+void vpx_lpf_vertical_4_dual_c(uint8_t* s,
+                               int pitch,
+                               const uint8_t* blimit0,
+                               const uint8_t* limit0,
+                               const uint8_t* thresh0,
+                               const uint8_t* blimit1,
+                               const uint8_t* limit1,
+                               const uint8_t* thresh1);
+#define vpx_lpf_vertical_4_dual vpx_lpf_vertical_4_dual_c
+
+void vpx_lpf_vertical_8_c(uint8_t* s,
+                          int pitch,
+                          const uint8_t* blimit,
+                          const uint8_t* limit,
+                          const uint8_t* thresh);
+#define vpx_lpf_vertical_8 vpx_lpf_vertical_8_c
+
+void vpx_lpf_vertical_8_dual_c(uint8_t* s,
+                               int pitch,
+                               const uint8_t* blimit0,
+                               const uint8_t* limit0,
+                               const uint8_t* thresh0,
+                               const uint8_t* blimit1,
+                               const uint8_t* limit1,
+                               const uint8_t* thresh1);
+#define vpx_lpf_vertical_8_dual vpx_lpf_vertical_8_dual_c
+
+void vpx_mbpost_proc_across_ip_c(unsigned char* src,
+                                 int pitch,
+                                 int rows,
+                                 int cols,
+                                 int flimit);
+#define vpx_mbpost_proc_across_ip vpx_mbpost_proc_across_ip_c
+
+void vpx_mbpost_proc_down_c(unsigned char* dst,
+                            int pitch,
+                            int rows,
+                            int cols,
+                            int flimit);
+#define vpx_mbpost_proc_down vpx_mbpost_proc_down_c
+
+void vpx_minmax_8x8_c(const uint8_t* s,
+                      int p,
+                      const uint8_t* d,
+                      int dp,
+                      int* min,
+                      int* max);
+#define vpx_minmax_8x8 vpx_minmax_8x8_c
+
+unsigned int vpx_mse16x16_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride,
+                            unsigned int* sse);
+#define vpx_mse16x16 vpx_mse16x16_c
+
+unsigned int vpx_mse16x8_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride,
+                           unsigned int* sse);
+#define vpx_mse16x8 vpx_mse16x8_c
+
+unsigned int vpx_mse8x16_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride,
+                           unsigned int* sse);
+#define vpx_mse8x16 vpx_mse8x16_c
+
+unsigned int vpx_mse8x8_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride,
+                          unsigned int* sse);
+#define vpx_mse8x8 vpx_mse8x8_c
+
+void vpx_plane_add_noise_c(uint8_t* start,
+                           const int8_t* noise,
+                           int blackclamp,
+                           int whiteclamp,
+                           int width,
+                           int height,
+                           int pitch);
+#define vpx_plane_add_noise vpx_plane_add_noise_c
+
+void vpx_post_proc_down_and_across_mb_row_c(unsigned char* src,
+                                            unsigned char* dst,
+                                            int src_pitch,
+                                            int dst_pitch,
+                                            int cols,
+                                            unsigned char* flimits,
+                                            int size);
+#define vpx_post_proc_down_and_across_mb_row \
+  vpx_post_proc_down_and_across_mb_row_c
+
+void vpx_quantize_b_c(const tran_low_t* coeff_ptr,
+                      intptr_t n_coeffs,
+                      int skip_block,
+                      const int16_t* zbin_ptr,
+                      const int16_t* round_ptr,
+                      const int16_t* quant_ptr,
+                      const int16_t* quant_shift_ptr,
+                      tran_low_t* qcoeff_ptr,
+                      tran_low_t* dqcoeff_ptr,
+                      const int16_t* dequant_ptr,
+                      uint16_t* eob_ptr,
+                      const int16_t* scan,
+                      const int16_t* iscan);
+#define vpx_quantize_b vpx_quantize_b_c
+
+void vpx_quantize_b_32x32_c(const tran_low_t* coeff_ptr,
+                            intptr_t n_coeffs,
+                            int skip_block,
+                            const int16_t* zbin_ptr,
+                            const int16_t* round_ptr,
+                            const int16_t* quant_ptr,
+                            const int16_t* quant_shift_ptr,
+                            tran_low_t* qcoeff_ptr,
+                            tran_low_t* dqcoeff_ptr,
+                            const int16_t* dequant_ptr,
+                            uint16_t* eob_ptr,
+                            const int16_t* scan,
+                            const int16_t* iscan);
+#define vpx_quantize_b_32x32 vpx_quantize_b_32x32_c
+
+unsigned int vpx_sad16x16_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad16x16 vpx_sad16x16_c
+
+unsigned int vpx_sad16x16_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad16x16_avg vpx_sad16x16_avg_c
+
+void vpx_sad16x16x3_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* ref_ptr,
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad16x16x3 vpx_sad16x16x3_c
+
+void vpx_sad16x16x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad16x16x4d vpx_sad16x16x4d_c
+
+void vpx_sad16x16x8_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* ref_ptr,
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad16x16x8 vpx_sad16x16x8_c
+
+unsigned int vpx_sad16x32_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad16x32 vpx_sad16x32_c
+
+unsigned int vpx_sad16x32_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad16x32_avg vpx_sad16x32_avg_c
+
+void vpx_sad16x32x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad16x32x4d vpx_sad16x32x4d_c
+
+unsigned int vpx_sad16x8_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride);
+#define vpx_sad16x8 vpx_sad16x8_c
+
+unsigned int vpx_sad16x8_avg_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               const uint8_t* second_pred);
+#define vpx_sad16x8_avg vpx_sad16x8_avg_c
+
+void vpx_sad16x8x3_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad16x8x3 vpx_sad16x8x3_c
+
+void vpx_sad16x8x4d_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* const ref_array[],
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad16x8x4d vpx_sad16x8x4d_c
+
+void vpx_sad16x8x8_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad16x8x8 vpx_sad16x8x8_c
+
+unsigned int vpx_sad32x16_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad32x16 vpx_sad32x16_c
+
+unsigned int vpx_sad32x16_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad32x16_avg vpx_sad32x16_avg_c
+
+void vpx_sad32x16x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad32x16x4d vpx_sad32x16x4d_c
+
+unsigned int vpx_sad32x32_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad32x32 vpx_sad32x32_c
+
+unsigned int vpx_sad32x32_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad32x32_avg vpx_sad32x32_avg_c
+
+void vpx_sad32x32x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad32x32x4d vpx_sad32x32x4d_c
+
+void vpx_sad32x32x8_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* ref_ptr,
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad32x32x8 vpx_sad32x32x8_c
+
+unsigned int vpx_sad32x64_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad32x64 vpx_sad32x64_c
+
+unsigned int vpx_sad32x64_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad32x64_avg vpx_sad32x64_avg_c
+
+void vpx_sad32x64x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad32x64x4d vpx_sad32x64x4d_c
+
+unsigned int vpx_sad4x4_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad4x4 vpx_sad4x4_c
+
+unsigned int vpx_sad4x4_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad4x4_avg vpx_sad4x4_avg_c
+
+void vpx_sad4x4x3_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad4x4x3 vpx_sad4x4x3_c
+
+void vpx_sad4x4x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_array[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad4x4x4d vpx_sad4x4x4d_c
+
+void vpx_sad4x4x8_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad4x4x8 vpx_sad4x4x8_c
+
+unsigned int vpx_sad4x8_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad4x8 vpx_sad4x8_c
+
+unsigned int vpx_sad4x8_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad4x8_avg vpx_sad4x8_avg_c
+
+void vpx_sad4x8x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_array[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad4x8x4d vpx_sad4x8x4d_c
+
+unsigned int vpx_sad64x32_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad64x32 vpx_sad64x32_c
+
+unsigned int vpx_sad64x32_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad64x32_avg vpx_sad64x32_avg_c
+
+void vpx_sad64x32x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad64x32x4d vpx_sad64x32x4d_c
+
+unsigned int vpx_sad64x64_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad64x64 vpx_sad64x64_c
+
+unsigned int vpx_sad64x64_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad64x64_avg vpx_sad64x64_avg_c
+
+void vpx_sad64x64x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad64x64x4d vpx_sad64x64x4d_c
+
+unsigned int vpx_sad8x16_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride);
+#define vpx_sad8x16 vpx_sad8x16_c
+
+unsigned int vpx_sad8x16_avg_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               const uint8_t* second_pred);
+#define vpx_sad8x16_avg vpx_sad8x16_avg_c
+
+void vpx_sad8x16x3_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x16x3 vpx_sad8x16x3_c
+
+void vpx_sad8x16x4d_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* const ref_array[],
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad8x16x4d vpx_sad8x16x4d_c
+
+void vpx_sad8x16x8_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x16x8 vpx_sad8x16x8_c
+
+unsigned int vpx_sad8x4_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad8x4 vpx_sad8x4_c
+
+unsigned int vpx_sad8x4_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad8x4_avg vpx_sad8x4_avg_c
+
+void vpx_sad8x4x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_array[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x4x4d vpx_sad8x4x4d_c
+
+unsigned int vpx_sad8x8_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad8x8 vpx_sad8x8_c
+
+unsigned int vpx_sad8x8_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad8x8_avg vpx_sad8x8_avg_c
+
+void vpx_sad8x8x3_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad8x8x3 vpx_sad8x8x3_c
+
+void vpx_sad8x8x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_array[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x8x4d vpx_sad8x8x4d_c
+
+void vpx_sad8x8x8_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad8x8x8 vpx_sad8x8x8_c
+
+int vpx_satd_c(const int16_t* coeff, int length);
+#define vpx_satd vpx_satd_c
+
+void vpx_scaled_2d_c(const uint8_t* src,
+                     ptrdiff_t src_stride,
+                     uint8_t* dst,
+                     ptrdiff_t dst_stride,
+                     const InterpKernel* filter,
+                     int x0_q4,
+                     int x_step_q4,
+                     int y0_q4,
+                     int y_step_q4,
+                     int w,
+                     int h);
+#define vpx_scaled_2d vpx_scaled_2d_c
+
+void vpx_scaled_avg_2d_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const InterpKernel* filter,
+                         int x0_q4,
+                         int x_step_q4,
+                         int y0_q4,
+                         int y_step_q4,
+                         int w,
+                         int h);
+#define vpx_scaled_avg_2d vpx_scaled_avg_2d_c
+
+void vpx_scaled_avg_horiz_c(const uint8_t* src,
+                            ptrdiff_t src_stride,
+                            uint8_t* dst,
+                            ptrdiff_t dst_stride,
+                            const InterpKernel* filter,
+                            int x0_q4,
+                            int x_step_q4,
+                            int y0_q4,
+                            int y_step_q4,
+                            int w,
+                            int h);
+#define vpx_scaled_avg_horiz vpx_scaled_avg_horiz_c
+
+void vpx_scaled_avg_vert_c(const uint8_t* src,
+                           ptrdiff_t src_stride,
+                           uint8_t* dst,
+                           ptrdiff_t dst_stride,
+                           const InterpKernel* filter,
+                           int x0_q4,
+                           int x_step_q4,
+                           int y0_q4,
+                           int y_step_q4,
+                           int w,
+                           int h);
+#define vpx_scaled_avg_vert vpx_scaled_avg_vert_c
+
+void vpx_scaled_horiz_c(const uint8_t* src,
+                        ptrdiff_t src_stride,
+                        uint8_t* dst,
+                        ptrdiff_t dst_stride,
+                        const InterpKernel* filter,
+                        int x0_q4,
+                        int x_step_q4,
+                        int y0_q4,
+                        int y_step_q4,
+                        int w,
+                        int h);
+#define vpx_scaled_horiz vpx_scaled_horiz_c
+
+void vpx_scaled_vert_c(const uint8_t* src,
+                       ptrdiff_t src_stride,
+                       uint8_t* dst,
+                       ptrdiff_t dst_stride,
+                       const InterpKernel* filter,
+                       int x0_q4,
+                       int x_step_q4,
+                       int y0_q4,
+                       int y_step_q4,
+                       int w,
+                       int h);
+#define vpx_scaled_vert vpx_scaled_vert_c
+
+uint32_t vpx_sub_pixel_avg_variance16x16_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance16x16 vpx_sub_pixel_avg_variance16x16_c
+
+uint32_t vpx_sub_pixel_avg_variance16x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance16x32 vpx_sub_pixel_avg_variance16x32_c
+
+uint32_t vpx_sub_pixel_avg_variance16x8_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          int x_offset,
+                                          int y_offset,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          uint32_t* sse,
+                                          const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance16x8 vpx_sub_pixel_avg_variance16x8_c
+
+uint32_t vpx_sub_pixel_avg_variance32x16_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance32x16 vpx_sub_pixel_avg_variance32x16_c
+
+uint32_t vpx_sub_pixel_avg_variance32x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance32x32 vpx_sub_pixel_avg_variance32x32_c
+
+uint32_t vpx_sub_pixel_avg_variance32x64_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance32x64 vpx_sub_pixel_avg_variance32x64_c
+
+uint32_t vpx_sub_pixel_avg_variance4x4_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         int x_offset,
+                                         int y_offset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance4x4 vpx_sub_pixel_avg_variance4x4_c
+
+uint32_t vpx_sub_pixel_avg_variance4x8_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         int x_offset,
+                                         int y_offset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance4x8 vpx_sub_pixel_avg_variance4x8_c
+
+uint32_t vpx_sub_pixel_avg_variance64x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance64x32 vpx_sub_pixel_avg_variance64x32_c
+
+uint32_t vpx_sub_pixel_avg_variance64x64_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance64x64 vpx_sub_pixel_avg_variance64x64_c
+
+uint32_t vpx_sub_pixel_avg_variance8x16_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          int x_offset,
+                                          int y_offset,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          uint32_t* sse,
+                                          const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance8x16 vpx_sub_pixel_avg_variance8x16_c
+
+uint32_t vpx_sub_pixel_avg_variance8x4_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         int x_offset,
+                                         int y_offset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance8x4 vpx_sub_pixel_avg_variance8x4_c
+
+uint32_t vpx_sub_pixel_avg_variance8x8_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         int x_offset,
+                                         int y_offset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance8x8 vpx_sub_pixel_avg_variance8x8_c
+
+uint32_t vpx_sub_pixel_variance16x16_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance16x16 vpx_sub_pixel_variance16x16_c
+
+uint32_t vpx_sub_pixel_variance16x32_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance16x32 vpx_sub_pixel_variance16x32_c
+
+uint32_t vpx_sub_pixel_variance16x8_c(const uint8_t* src_ptr,
+                                      int src_stride,
+                                      int x_offset,
+                                      int y_offset,
+                                      const uint8_t* ref_ptr,
+                                      int ref_stride,
+                                      uint32_t* sse);
+#define vpx_sub_pixel_variance16x8 vpx_sub_pixel_variance16x8_c
+
+uint32_t vpx_sub_pixel_variance32x16_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance32x16 vpx_sub_pixel_variance32x16_c
+
+uint32_t vpx_sub_pixel_variance32x32_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance32x32 vpx_sub_pixel_variance32x32_c
+
+uint32_t vpx_sub_pixel_variance32x64_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance32x64 vpx_sub_pixel_variance32x64_c
+
+uint32_t vpx_sub_pixel_variance4x4_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     int x_offset,
+                                     int y_offset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance4x4 vpx_sub_pixel_variance4x4_c
+
+uint32_t vpx_sub_pixel_variance4x8_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     int x_offset,
+                                     int y_offset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance4x8 vpx_sub_pixel_variance4x8_c
+
+uint32_t vpx_sub_pixel_variance64x32_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance64x32 vpx_sub_pixel_variance64x32_c
+
+uint32_t vpx_sub_pixel_variance64x64_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance64x64 vpx_sub_pixel_variance64x64_c
+
+uint32_t vpx_sub_pixel_variance8x16_c(const uint8_t* src_ptr,
+                                      int src_stride,
+                                      int x_offset,
+                                      int y_offset,
+                                      const uint8_t* ref_ptr,
+                                      int ref_stride,
+                                      uint32_t* sse);
+#define vpx_sub_pixel_variance8x16 vpx_sub_pixel_variance8x16_c
+
+uint32_t vpx_sub_pixel_variance8x4_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     int x_offset,
+                                     int y_offset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance8x4 vpx_sub_pixel_variance8x4_c
+
+uint32_t vpx_sub_pixel_variance8x8_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     int x_offset,
+                                     int y_offset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance8x8 vpx_sub_pixel_variance8x8_c
+
+void vpx_subtract_block_c(int rows,
+                          int cols,
+                          int16_t* diff_ptr,
+                          ptrdiff_t diff_stride,
+                          const uint8_t* src_ptr,
+                          ptrdiff_t src_stride,
+                          const uint8_t* pred_ptr,
+                          ptrdiff_t pred_stride);
+#define vpx_subtract_block vpx_subtract_block_c
+
+uint64_t vpx_sum_squares_2d_i16_c(const int16_t* src, int stride, int size);
+#define vpx_sum_squares_2d_i16 vpx_sum_squares_2d_i16_c
+
+void vpx_tm_predictor_16x16_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_tm_predictor_16x16 vpx_tm_predictor_16x16_c
+
+void vpx_tm_predictor_32x32_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_tm_predictor_32x32 vpx_tm_predictor_32x32_c
+
+void vpx_tm_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_tm_predictor_4x4 vpx_tm_predictor_4x4_c
+
+void vpx_tm_predictor_8x8_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_tm_predictor_8x8 vpx_tm_predictor_8x8_c
+
+void vpx_v_predictor_16x16_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_v_predictor_16x16 vpx_v_predictor_16x16_c
+
+void vpx_v_predictor_32x32_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_v_predictor_32x32 vpx_v_predictor_32x32_c
+
+void vpx_v_predictor_4x4_c(uint8_t* dst,
+                           ptrdiff_t stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_v_predictor_4x4 vpx_v_predictor_4x4_c
+
+void vpx_v_predictor_8x8_c(uint8_t* dst,
+                           ptrdiff_t stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_v_predictor_8x8 vpx_v_predictor_8x8_c
+
+unsigned int vpx_variance16x16_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance16x16 vpx_variance16x16_c
+
+unsigned int vpx_variance16x32_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance16x32 vpx_variance16x32_c
+
+unsigned int vpx_variance16x8_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                unsigned int* sse);
+#define vpx_variance16x8 vpx_variance16x8_c
+
+unsigned int vpx_variance32x16_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance32x16 vpx_variance32x16_c
+
+unsigned int vpx_variance32x32_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance32x32 vpx_variance32x32_c
+
+unsigned int vpx_variance32x64_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance32x64 vpx_variance32x64_c
+
+unsigned int vpx_variance4x4_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+#define vpx_variance4x4 vpx_variance4x4_c
+
+unsigned int vpx_variance4x8_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+#define vpx_variance4x8 vpx_variance4x8_c
+
+unsigned int vpx_variance64x32_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance64x32 vpx_variance64x32_c
+
+unsigned int vpx_variance64x64_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance64x64 vpx_variance64x64_c
+
+unsigned int vpx_variance8x16_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                unsigned int* sse);
+#define vpx_variance8x16 vpx_variance8x16_c
+
+unsigned int vpx_variance8x4_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+#define vpx_variance8x4 vpx_variance8x4_c
+
+unsigned int vpx_variance8x8_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+#define vpx_variance8x8 vpx_variance8x8_c
+
+void vpx_ve_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_ve_predictor_4x4 vpx_ve_predictor_4x4_c
+
+int vpx_vector_var_c(const int16_t* ref, const int16_t* src, const int bwl);
+#define vpx_vector_var vpx_vector_var_c
+
+void vpx_dsp_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void) {}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_scale_rtcd.h b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_scale_rtcd.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_scale_rtcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_scale_rtcd.h	2025-06-05 23:11:35.000000000 +0800
@@ -0,0 +1,96 @@
+// This file is generated. Do not edit.
+#ifndef VPX_SCALE_RTCD_H_
+#define VPX_SCALE_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void vp8_horizontal_line_2_1_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define vp8_horizontal_line_2_1_scale vp8_horizontal_line_2_1_scale_c
+
+void vp8_horizontal_line_5_3_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define vp8_horizontal_line_5_3_scale vp8_horizontal_line_5_3_scale_c
+
+void vp8_horizontal_line_5_4_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define vp8_horizontal_line_5_4_scale vp8_horizontal_line_5_4_scale_c
+
+void vp8_vertical_band_2_1_scale_c(unsigned char* source,
+                                   unsigned int src_pitch,
+                                   unsigned char* dest,
+                                   unsigned int dest_pitch,
+                                   unsigned int dest_width);
+#define vp8_vertical_band_2_1_scale vp8_vertical_band_2_1_scale_c
+
+void vp8_vertical_band_2_1_scale_i_c(unsigned char* source,
+                                     unsigned int src_pitch,
+                                     unsigned char* dest,
+                                     unsigned int dest_pitch,
+                                     unsigned int dest_width);
+#define vp8_vertical_band_2_1_scale_i vp8_vertical_band_2_1_scale_i_c
+
+void vp8_vertical_band_5_3_scale_c(unsigned char* source,
+                                   unsigned int src_pitch,
+                                   unsigned char* dest,
+                                   unsigned int dest_pitch,
+                                   unsigned int dest_width);
+#define vp8_vertical_band_5_3_scale vp8_vertical_band_5_3_scale_c
+
+void vp8_vertical_band_5_4_scale_c(unsigned char* source,
+                                   unsigned int src_pitch,
+                                   unsigned char* dest,
+                                   unsigned int dest_pitch,
+                                   unsigned int dest_width);
+#define vp8_vertical_band_5_4_scale vp8_vertical_band_5_4_scale_c
+
+void vp8_yv12_copy_frame_c(const struct yv12_buffer_config* src_ybc,
+                           struct yv12_buffer_config* dst_ybc);
+#define vp8_yv12_copy_frame vp8_yv12_copy_frame_c
+
+void vp8_yv12_extend_frame_borders_c(struct yv12_buffer_config* ybf);
+#define vp8_yv12_extend_frame_borders vp8_yv12_extend_frame_borders_c
+
+void vpx_extend_frame_borders_c(struct yv12_buffer_config* ybf);
+#define vpx_extend_frame_borders vpx_extend_frame_borders_c
+
+void vpx_extend_frame_inner_borders_c(struct yv12_buffer_config* ybf);
+#define vpx_extend_frame_inner_borders vpx_extend_frame_inner_borders_c
+
+void vpx_yv12_copy_frame_c(const struct yv12_buffer_config* src_ybc,
+                           struct yv12_buffer_config* dst_ybc);
+#define vpx_yv12_copy_frame vpx_yv12_copy_frame_c
+
+void vpx_yv12_copy_y_c(const struct yv12_buffer_config* src_ybc,
+                       struct yv12_buffer_config* dst_ybc);
+#define vpx_yv12_copy_y vpx_yv12_copy_y_c
+
+void vpx_scale_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void) {}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vp8_rtcd.h b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vp8_rtcd.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vp8_rtcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vp8_rtcd.h	2025-06-06 11:59:28.000000000 +0800
@@ -0,0 +1,357 @@
+// This file is generated. Do not edit.
+#ifndef VP8_RTCD_H_
+#define VP8_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * VP8
+ */
+
+struct blockd;
+struct macroblockd;
+struct loop_filter_info;
+
+/* Encoder forward decls */
+struct block;
+struct macroblock;
+struct variance_vtable;
+union int_mv;
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void vp8_bilinear_predict16x16_c(unsigned char* src_ptr,
+                                 int src_pixels_per_line,
+                                 int xoffset,
+                                 int yoffset,
+                                 unsigned char* dst_ptr,
+                                 int dst_pitch);
+#define vp8_bilinear_predict16x16 vp8_bilinear_predict16x16_c
+
+void vp8_bilinear_predict4x4_c(unsigned char* src_ptr,
+                               int src_pixels_per_line,
+                               int xoffset,
+                               int yoffset,
+                               unsigned char* dst_ptr,
+                               int dst_pitch);
+#define vp8_bilinear_predict4x4 vp8_bilinear_predict4x4_c
+
+void vp8_bilinear_predict8x4_c(unsigned char* src_ptr,
+                               int src_pixels_per_line,
+                               int xoffset,
+                               int yoffset,
+                               unsigned char* dst_ptr,
+                               int dst_pitch);
+#define vp8_bilinear_predict8x4 vp8_bilinear_predict8x4_c
+
+void vp8_bilinear_predict8x8_c(unsigned char* src_ptr,
+                               int src_pixels_per_line,
+                               int xoffset,
+                               int yoffset,
+                               unsigned char* dst_ptr,
+                               int dst_pitch);
+#define vp8_bilinear_predict8x8 vp8_bilinear_predict8x8_c
+
+void vp8_blend_b_c(unsigned char* y,
+                   unsigned char* u,
+                   unsigned char* v,
+                   int y_1,
+                   int u_1,
+                   int v_1,
+                   int alpha,
+                   int stride);
+#define vp8_blend_b vp8_blend_b_c
+
+void vp8_blend_mb_inner_c(unsigned char* y,
+                          unsigned char* u,
+                          unsigned char* v,
+                          int y_1,
+                          int u_1,
+                          int v_1,
+                          int alpha,
+                          int stride);
+#define vp8_blend_mb_inner vp8_blend_mb_inner_c
+
+void vp8_blend_mb_outer_c(unsigned char* y,
+                          unsigned char* u,
+                          unsigned char* v,
+                          int y_1,
+                          int u_1,
+                          int v_1,
+                          int alpha,
+                          int stride);
+#define vp8_blend_mb_outer vp8_blend_mb_outer_c
+
+int vp8_block_error_c(short* coeff, short* dqcoeff);
+#define vp8_block_error vp8_block_error_c
+
+void vp8_copy32xn_c(const unsigned char* src_ptr,
+                    int src_stride,
+                    unsigned char* dst_ptr,
+                    int dst_stride,
+                    int height);
+#define vp8_copy32xn vp8_copy32xn_c
+
+void vp8_copy_mem16x16_c(unsigned char* src,
+                         int src_stride,
+                         unsigned char* dst,
+                         int dst_stride);
+#define vp8_copy_mem16x16 vp8_copy_mem16x16_c
+
+void vp8_copy_mem8x4_c(unsigned char* src,
+                       int src_stride,
+                       unsigned char* dst,
+                       int dst_stride);
+#define vp8_copy_mem8x4 vp8_copy_mem8x4_c
+
+void vp8_copy_mem8x8_c(unsigned char* src,
+                       int src_stride,
+                       unsigned char* dst,
+                       int dst_stride);
+#define vp8_copy_mem8x8 vp8_copy_mem8x8_c
+
+void vp8_dc_only_idct_add_c(short input_dc,
+                            unsigned char* pred_ptr,
+                            int pred_stride,
+                            unsigned char* dst_ptr,
+                            int dst_stride);
+#define vp8_dc_only_idct_add vp8_dc_only_idct_add_c
+
+int vp8_denoiser_filter_c(unsigned char* mc_running_avg_y,
+                          int mc_avg_y_stride,
+                          unsigned char* running_avg_y,
+                          int avg_y_stride,
+                          unsigned char* sig,
+                          int sig_stride,
+                          unsigned int motion_magnitude,
+                          int increase_denoising);
+#define vp8_denoiser_filter vp8_denoiser_filter_c
+
+int vp8_denoiser_filter_uv_c(unsigned char* mc_running_avg,
+                             int mc_avg_stride,
+                             unsigned char* running_avg,
+                             int avg_stride,
+                             unsigned char* sig,
+                             int sig_stride,
+                             unsigned int motion_magnitude,
+                             int increase_denoising);
+#define vp8_denoiser_filter_uv vp8_denoiser_filter_uv_c
+
+void vp8_dequant_idct_add_c(short* input,
+                            short* dq,
+                            unsigned char* dest,
+                            int stride);
+#define vp8_dequant_idct_add vp8_dequant_idct_add_c
+
+void vp8_dequant_idct_add_uv_block_c(short* q,
+                                     short* dq,
+                                     unsigned char* dst_u,
+                                     unsigned char* dst_v,
+                                     int stride,
+                                     char* eobs);
+#define vp8_dequant_idct_add_uv_block vp8_dequant_idct_add_uv_block_c
+
+void vp8_dequant_idct_add_y_block_c(short* q,
+                                    short* dq,
+                                    unsigned char* dst,
+                                    int stride,
+                                    char* eobs);
+#define vp8_dequant_idct_add_y_block vp8_dequant_idct_add_y_block_c
+
+void vp8_dequantize_b_c(struct blockd*, short* DQC);
+#define vp8_dequantize_b vp8_dequantize_b_c
+
+int vp8_diamond_search_sad_c(struct macroblock* x,
+                             struct block* b,
+                             struct blockd* d,
+                             union int_mv* ref_mv,
+                             union int_mv* best_mv,
+                             int search_param,
+                             int sad_per_bit,
+                             int* num00,
+                             struct variance_vtable* fn_ptr,
+                             int* mvcost[2],
+                             union int_mv* center_mv);
+#define vp8_diamond_search_sad vp8_diamond_search_sad_c
+
+void vp8_fast_quantize_b_c(struct block*, struct blockd*);
+#define vp8_fast_quantize_b vp8_fast_quantize_b_c
+
+void vp8_filter_by_weight16x16_c(unsigned char* src,
+                                 int src_stride,
+                                 unsigned char* dst,
+                                 int dst_stride,
+                                 int src_weight);
+#define vp8_filter_by_weight16x16 vp8_filter_by_weight16x16_c
+
+void vp8_filter_by_weight4x4_c(unsigned char* src,
+                               int src_stride,
+                               unsigned char* dst,
+                               int dst_stride,
+                               int src_weight);
+#define vp8_filter_by_weight4x4 vp8_filter_by_weight4x4_c
+
+void vp8_filter_by_weight8x8_c(unsigned char* src,
+                               int src_stride,
+                               unsigned char* dst,
+                               int dst_stride,
+                               int src_weight);
+#define vp8_filter_by_weight8x8 vp8_filter_by_weight8x8_c
+
+int vp8_full_search_sad_c(struct macroblock* x,
+                          struct block* b,
+                          struct blockd* d,
+                          union int_mv* ref_mv,
+                          int sad_per_bit,
+                          int distance,
+                          struct variance_vtable* fn_ptr,
+                          int* mvcost[2],
+                          union int_mv* center_mv);
+#define vp8_full_search_sad vp8_full_search_sad_c
+
+void vp8_loop_filter_bh_c(unsigned char* y_ptr,
+                          unsigned char* u_ptr,
+                          unsigned char* v_ptr,
+                          int y_stride,
+                          int uv_stride,
+                          struct loop_filter_info* lfi);
+#define vp8_loop_filter_bh vp8_loop_filter_bh_c
+
+void vp8_loop_filter_bv_c(unsigned char* y_ptr,
+                          unsigned char* u_ptr,
+                          unsigned char* v_ptr,
+                          int y_stride,
+                          int uv_stride,
+                          struct loop_filter_info* lfi);
+#define vp8_loop_filter_bv vp8_loop_filter_bv_c
+
+void vp8_loop_filter_mbh_c(unsigned char* y_ptr,
+                           unsigned char* u_ptr,
+                           unsigned char* v_ptr,
+                           int y_stride,
+                           int uv_stride,
+                           struct loop_filter_info* lfi);
+#define vp8_loop_filter_mbh vp8_loop_filter_mbh_c
+
+void vp8_loop_filter_mbv_c(unsigned char* y_ptr,
+                           unsigned char* u_ptr,
+                           unsigned char* v_ptr,
+                           int y_stride,
+                           int uv_stride,
+                           struct loop_filter_info* lfi);
+#define vp8_loop_filter_mbv vp8_loop_filter_mbv_c
+
+void vp8_loop_filter_bhs_c(unsigned char* y_ptr,
+                           int y_stride,
+                           const unsigned char* blimit);
+#define vp8_loop_filter_simple_bh vp8_loop_filter_bhs_c
+
+void vp8_loop_filter_bvs_c(unsigned char* y_ptr,
+                           int y_stride,
+                           const unsigned char* blimit);
+#define vp8_loop_filter_simple_bv vp8_loop_filter_bvs_c
+
+void vp8_loop_filter_simple_horizontal_edge_c(unsigned char* y_ptr,
+                                              int y_stride,
+                                              const unsigned char* blimit);
+#define vp8_loop_filter_simple_mbh vp8_loop_filter_simple_horizontal_edge_c
+
+void vp8_loop_filter_simple_vertical_edge_c(unsigned char* y_ptr,
+                                            int y_stride,
+                                            const unsigned char* blimit);
+#define vp8_loop_filter_simple_mbv vp8_loop_filter_simple_vertical_edge_c
+
+int vp8_mbblock_error_c(struct macroblock* mb, int dc);
+#define vp8_mbblock_error vp8_mbblock_error_c
+
+int vp8_mbuverror_c(struct macroblock* mb);
+#define vp8_mbuverror vp8_mbuverror_c
+
+int vp8_refining_search_sad_c(struct macroblock* x,
+                              struct block* b,
+                              struct blockd* d,
+                              union int_mv* ref_mv,
+                              int error_per_bit,
+                              int search_range,
+                              struct variance_vtable* fn_ptr,
+                              int* mvcost[2],
+                              union int_mv* center_mv);
+#define vp8_refining_search_sad vp8_refining_search_sad_c
+
+void vp8_regular_quantize_b_c(struct block*, struct blockd*);
+#define vp8_regular_quantize_b vp8_regular_quantize_b_c
+
+void vp8_short_fdct4x4_c(short* input, short* output, int pitch);
+#define vp8_short_fdct4x4 vp8_short_fdct4x4_c
+
+void vp8_short_fdct8x4_c(short* input, short* output, int pitch);
+#define vp8_short_fdct8x4 vp8_short_fdct8x4_c
+
+void vp8_short_idct4x4llm_c(short* input,
+                            unsigned char* pred_ptr,
+                            int pred_stride,
+                            unsigned char* dst_ptr,
+                            int dst_stride);
+#define vp8_short_idct4x4llm vp8_short_idct4x4llm_c
+
+void vp8_short_inv_walsh4x4_c(short* input, short* mb_dqcoeff);
+#define vp8_short_inv_walsh4x4 vp8_short_inv_walsh4x4_c
+
+void vp8_short_inv_walsh4x4_1_c(short* input, short* mb_dqcoeff);
+#define vp8_short_inv_walsh4x4_1 vp8_short_inv_walsh4x4_1_c
+
+void vp8_short_walsh4x4_c(short* input, short* output, int pitch);
+#define vp8_short_walsh4x4 vp8_short_walsh4x4_c
+
+void vp8_sixtap_predict16x16_c(unsigned char* src_ptr,
+                               int src_pixels_per_line,
+                               int xoffset,
+                               int yoffset,
+                               unsigned char* dst_ptr,
+                               int dst_pitch);
+#define vp8_sixtap_predict16x16 vp8_sixtap_predict16x16_c
+
+void vp8_sixtap_predict4x4_c(unsigned char* src_ptr,
+                             int src_pixels_per_line,
+                             int xoffset,
+                             int yoffset,
+                             unsigned char* dst_ptr,
+                             int dst_pitch);
+#define vp8_sixtap_predict4x4 vp8_sixtap_predict4x4_c
+
+void vp8_sixtap_predict8x4_c(unsigned char* src_ptr,
+                             int src_pixels_per_line,
+                             int xoffset,
+                             int yoffset,
+                             unsigned char* dst_ptr,
+                             int dst_pitch);
+#define vp8_sixtap_predict8x4 vp8_sixtap_predict8x4_c
+
+void vp8_sixtap_predict8x8_c(unsigned char* src_ptr,
+                             int src_pixels_per_line,
+                             int xoffset,
+                             int yoffset,
+                             unsigned char* dst_ptr,
+                             int dst_pitch);
+#define vp8_sixtap_predict8x8 vp8_sixtap_predict8x8_c
+
+void vp8_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void) {}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vp9_rtcd.h b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vp9_rtcd.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vp9_rtcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vp9_rtcd.h	2025-06-06 11:59:28.000000000 +0800
@@ -0,0 +1,164 @@
+// This file is generated. Do not edit.
+#ifndef VP9_RTCD_H_
+#define VP9_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * VP9
+ */
+
+#include "vp9/common/vp9_common.h"
+#include "vp9/common/vp9_enums.h"
+#include "vp9/common/vp9_filter.h"
+#include "vpx/vpx_integer.h"
+
+struct macroblockd;
+
+/* Encoder forward decls */
+struct macroblock;
+struct vp9_variance_vtable;
+struct search_site_config;
+struct mv;
+union int_mv;
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int64_t vp9_block_error_c(const tran_low_t* coeff,
+                          const tran_low_t* dqcoeff,
+                          intptr_t block_size,
+                          int64_t* ssz);
+#define vp9_block_error vp9_block_error_c
+
+int64_t vp9_block_error_fp_c(const tran_low_t* coeff,
+                             const tran_low_t* dqcoeff,
+                             int block_size);
+#define vp9_block_error_fp vp9_block_error_fp_c
+
+int vp9_denoiser_filter_c(const uint8_t* sig,
+                          int sig_stride,
+                          const uint8_t* mc_avg,
+                          int mc_avg_stride,
+                          uint8_t* avg,
+                          int avg_stride,
+                          int increase_denoising,
+                          BLOCK_SIZE bs,
+                          int motion_magnitude);
+#define vp9_denoiser_filter vp9_denoiser_filter_c
+
+int vp9_diamond_search_sad_c(const struct macroblock* x,
+                             const struct search_site_config* cfg,
+                             struct mv* ref_mv,
+                             struct mv* best_mv,
+                             int search_param,
+                             int sad_per_bit,
+                             int* num00,
+                             const struct vp9_variance_vtable* fn_ptr,
+                             const struct mv* center_mv);
+#define vp9_diamond_search_sad vp9_diamond_search_sad_c
+
+void vp9_fht16x16_c(const int16_t* input,
+                    tran_low_t* output,
+                    int stride,
+                    int tx_type);
+#define vp9_fht16x16 vp9_fht16x16_c
+
+void vp9_fht4x4_c(const int16_t* input,
+                  tran_low_t* output,
+                  int stride,
+                  int tx_type);
+#define vp9_fht4x4 vp9_fht4x4_c
+
+void vp9_fht8x8_c(const int16_t* input,
+                  tran_low_t* output,
+                  int stride,
+                  int tx_type);
+#define vp9_fht8x8 vp9_fht8x8_c
+
+void vp9_filter_by_weight16x16_c(const uint8_t* src,
+                                 int src_stride,
+                                 uint8_t* dst,
+                                 int dst_stride,
+                                 int src_weight);
+#define vp9_filter_by_weight16x16 vp9_filter_by_weight16x16_c
+
+void vp9_filter_by_weight8x8_c(const uint8_t* src,
+                               int src_stride,
+                               uint8_t* dst,
+                               int dst_stride,
+                               int src_weight);
+#define vp9_filter_by_weight8x8 vp9_filter_by_weight8x8_c
+
+void vp9_fwht4x4_c(const int16_t* input, tran_low_t* output, int stride);
+#define vp9_fwht4x4 vp9_fwht4x4_c
+
+void vp9_iht16x16_256_add_c(const tran_low_t* input,
+                            uint8_t* dest,
+                            int stride,
+                            int tx_type);
+#define vp9_iht16x16_256_add vp9_iht16x16_256_add_c
+
+void vp9_iht4x4_16_add_c(const tran_low_t* input,
+                         uint8_t* dest,
+                         int stride,
+                         int tx_type);
+#define vp9_iht4x4_16_add vp9_iht4x4_16_add_c
+
+void vp9_iht8x8_64_add_c(const tran_low_t* input,
+                         uint8_t* dest,
+                         int stride,
+                         int tx_type);
+#define vp9_iht8x8_64_add vp9_iht8x8_64_add_c
+
+void vp9_quantize_fp_c(const tran_low_t* coeff_ptr,
+                       intptr_t n_coeffs,
+                       int skip_block,
+                       const int16_t* round_ptr,
+                       const int16_t* quant_ptr,
+                       tran_low_t* qcoeff_ptr,
+                       tran_low_t* dqcoeff_ptr,
+                       const int16_t* dequant_ptr,
+                       uint16_t* eob_ptr,
+                       const int16_t* scan,
+                       const int16_t* iscan);
+#define vp9_quantize_fp vp9_quantize_fp_c
+
+void vp9_quantize_fp_32x32_c(const tran_low_t* coeff_ptr,
+                             intptr_t n_coeffs,
+                             int skip_block,
+                             const int16_t* round_ptr,
+                             const int16_t* quant_ptr,
+                             tran_low_t* qcoeff_ptr,
+                             tran_low_t* dqcoeff_ptr,
+                             const int16_t* dequant_ptr,
+                             uint16_t* eob_ptr,
+                             const int16_t* scan,
+                             const int16_t* iscan);
+#define vp9_quantize_fp_32x32 vp9_quantize_fp_32x32_c
+
+void vp9_scale_and_extend_frame_c(const struct yv12_buffer_config* src,
+                                  struct yv12_buffer_config* dst,
+                                  INTERP_FILTER filter_type,
+                                  int phase_scaler);
+#define vp9_scale_and_extend_frame vp9_scale_and_extend_frame_c
+
+void vp9_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void) {}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_config.asm b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_config.asm
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_config.asm	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_config.asm	2025-06-06 11:59:28.000000000 +0800
@@ -0,0 +1,98 @@
+@ This file was created from a .asm file
+@  using the ads2gas.pl script.
+	.syntax unified
+.equ VPX_ARCH_ARM ,  0
+.equ ARCH_ARM ,  0
+.equ VPX_ARCH_MIPS ,  0
+.equ ARCH_MIPS ,  0
+.equ VPX_ARCH_X86 ,  0
+.equ ARCH_X86 ,  0
+.equ VPX_ARCH_X86_64 ,  0
+.equ ARCH_X86_64 ,  0
+.equ VPX_ARCH_PPC ,  1
+.equ ARCH_PPC ,  1
+.equ HAVE_NEON ,  0
+.equ HAVE_NEON_ASM ,  0
+.equ HAVE_MIPS32 ,  0
+.equ HAVE_DSPR2 ,  0
+.equ HAVE_MSA ,  0
+.equ HAVE_MIPS64 ,  0
+.equ HAVE_MMX ,  0
+.equ HAVE_SSE ,  0
+.equ HAVE_SSE2 ,  0
+.equ HAVE_SSE3 ,  0
+.equ HAVE_SSSE3 ,  0
+.equ HAVE_SSE4_1 ,  0
+.equ HAVE_AVX ,  0
+.equ HAVE_AVX2 ,  0
+.equ HAVE_AVX512 ,  0
+.equ HAVE_VSX ,  0
+.equ HAVE_MMI ,  0
+.equ HAVE_VPX_PORTS ,  1
+.equ HAVE_PTHREAD_H ,  1
+.equ HAVE_UNISTD_H ,  0
+.equ CONFIG_DEPENDENCY_TRACKING ,  1
+.equ CONFIG_EXTERNAL_BUILD ,  1
+.equ CONFIG_INSTALL_DOCS ,  0
+.equ CONFIG_INSTALL_BINS ,  1
+.equ CONFIG_INSTALL_LIBS ,  1
+.equ CONFIG_INSTALL_SRCS ,  0
+.equ CONFIG_DEBUG ,  0
+.equ CONFIG_GPROF ,  0
+.equ CONFIG_GCOV ,  0
+.equ CONFIG_RVCT ,  0
+.equ CONFIG_GCC ,  1
+.equ CONFIG_MSVS ,  0
+.equ CONFIG_PIC ,  0
+.equ CONFIG_BIG_ENDIAN ,  0
+.equ CONFIG_CODEC_SRCS ,  0
+.equ CONFIG_DEBUG_LIBS ,  0
+.equ CONFIG_DEQUANT_TOKENS ,  0
+.equ CONFIG_DC_RECON ,  0
+.equ CONFIG_RUNTIME_CPU_DETECT ,  0
+.equ CONFIG_POSTPROC ,  1
+.equ CONFIG_VP9_POSTPROC ,  1
+.equ CONFIG_MULTITHREAD ,  1
+.equ CONFIG_INTERNAL_STATS ,  0
+.equ CONFIG_VP8_ENCODER ,  1
+.equ CONFIG_VP8_DECODER ,  1
+.equ CONFIG_VP9_ENCODER ,  1
+.equ CONFIG_VP9_DECODER ,  1
+.equ CONFIG_VP8 ,  1
+.equ CONFIG_VP9 ,  1
+.equ CONFIG_ENCODERS ,  1
+.equ CONFIG_DECODERS ,  1
+.equ CONFIG_STATIC_MSVCRT ,  0
+.equ CONFIG_SPATIAL_RESAMPLING ,  1
+.equ CONFIG_REALTIME_ONLY ,  1
+.equ CONFIG_ONTHEFLY_BITPACKING ,  0
+.equ CONFIG_ERROR_CONCEALMENT ,  0
+.equ CONFIG_SHARED ,  0
+.equ CONFIG_STATIC ,  1
+.equ CONFIG_SMALL ,  0
+.equ CONFIG_POSTPROC_VISUALIZER ,  0
+.equ CONFIG_OS_SUPPORT ,  1
+.equ CONFIG_UNIT_TESTS ,  1
+.equ CONFIG_WEBM_IO ,  1
+.equ CONFIG_LIBYUV ,  0
+.equ CONFIG_DECODE_PERF_TESTS ,  0
+.equ CONFIG_ENCODE_PERF_TESTS ,  0
+.equ CONFIG_MULTI_RES_ENCODING ,  1
+.equ CONFIG_TEMPORAL_DENOISING ,  1
+.equ CONFIG_VP9_TEMPORAL_DENOISING ,  1
+.equ CONFIG_CONSISTENT_RECODE ,  0
+.equ CONFIG_COEFFICIENT_RANGE_CHECKING ,  0
+.equ CONFIG_VP9_HIGHBITDEPTH ,  0
+.equ CONFIG_BETTER_HW_COMPATIBILITY ,  0
+.equ CONFIG_EXPERIMENTAL ,  0
+.equ CONFIG_SIZE_LIMIT ,  1
+.equ CONFIG_ALWAYS_ADJUST_BPM ,  0
+.equ CONFIG_BITSTREAM_DEBUG ,  0
+.equ CONFIG_MISMATCH_DEBUG ,  0
+.equ CONFIG_FP_MB_STATS ,  0
+.equ CONFIG_EMULATE_HARDWARE ,  0
+.equ CONFIG_NON_GREEDY_MV ,  0
+.equ CONFIG_RATE_CTRL ,  0
+.equ DECODE_WIDTH_LIMIT ,  16384
+.equ DECODE_HEIGHT_LIMIT ,  16384
+	.section	.note.GNU-stack,"",%progbits
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_config.c b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_config.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_config.c	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_config.c	2025-06-06 11:59:28.000000000 +0800
@@ -0,0 +1,10 @@
+/* Copyright (c) 2011 The WebM project authors. All Rights Reserved. */
+/*  */
+/* Use of this source code is governed by a BSD-style license */
+/* that can be found in the LICENSE file in the root of the source */
+/* tree. An additional intellectual property rights grant can be found */
+/* in the file PATENTS.  All contributing project authors may */
+/* be found in the AUTHORS file in the root of the source tree. */
+#include "vpx/vpx_codec.h"
+static const char* const cfg = "--target=ppc64le-linux-gcc --enable-external-build --enable-postproc --enable-multi-res-encoding --enable-temporal-denoising --enable-vp9-temporal-denoising --enable-vp9-postproc --size-limit=16384x16384 --enable-realtime-only --disable-install-docs --disable-libyuv";
+const char *vpx_codec_build_config(void) {return cfg;}
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_config.h b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_config.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_config.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_config.h	2025-06-06 11:59:28.000000000 +0800
@@ -0,0 +1,107 @@
+/* Copyright (c) 2011 The WebM project authors. All Rights Reserved. */
+/*  */
+/* Use of this source code is governed by a BSD-style license */
+/* that can be found in the LICENSE file in the root of the source */
+/* tree. An additional intellectual property rights grant can be found */
+/* in the file PATENTS.  All contributing project authors may */
+/* be found in the AUTHORS file in the root of the source tree. */
+/* This file automatically generated by configure. Do not edit! */
+#ifndef VPX_CONFIG_H
+#define VPX_CONFIG_H
+#define RESTRICT    
+#define INLINE      inline
+#define VPX_ARCH_ARM 0
+#define ARCH_ARM 0
+#define VPX_ARCH_MIPS 0
+#define ARCH_MIPS 0
+#define VPX_ARCH_X86 0
+#define ARCH_X86 0
+#define VPX_ARCH_X86_64 0
+#define ARCH_X86_64 0
+#define VPX_ARCH_PPC 1
+#define ARCH_PPC 1
+#define HAVE_NEON 0
+#define HAVE_NEON_ASM 0
+#define HAVE_MIPS32 0
+#define HAVE_DSPR2 0
+#define HAVE_MSA 0
+#define HAVE_MIPS64 0
+#define HAVE_MMX 0
+#define HAVE_SSE 0
+#define HAVE_SSE2 0
+#define HAVE_SSE3 0
+#define HAVE_SSSE3 0
+#define HAVE_SSE4_1 0
+#define HAVE_AVX 0
+#define HAVE_AVX2 0
+#define HAVE_AVX512 0
+#define HAVE_VSX 0
+#define HAVE_MMI 0
+#define HAVE_VPX_PORTS 1
+#define HAVE_PTHREAD_H 1
+#define HAVE_UNISTD_H 0
+#define CONFIG_DEPENDENCY_TRACKING 1
+#define CONFIG_EXTERNAL_BUILD 1
+#define CONFIG_INSTALL_DOCS 0
+#define CONFIG_INSTALL_BINS 1
+#define CONFIG_INSTALL_LIBS 1
+#define CONFIG_INSTALL_SRCS 0
+#define CONFIG_DEBUG 0
+#define CONFIG_GPROF 0
+#define CONFIG_GCOV 0
+#define CONFIG_RVCT 0
+#define CONFIG_GCC 1
+#define CONFIG_MSVS 0
+#define CONFIG_PIC 0
+#define CONFIG_BIG_ENDIAN 0
+#define CONFIG_CODEC_SRCS 0
+#define CONFIG_DEBUG_LIBS 0
+#define CONFIG_DEQUANT_TOKENS 0
+#define CONFIG_DC_RECON 0
+#define CONFIG_RUNTIME_CPU_DETECT 0
+#define CONFIG_POSTPROC 1
+#define CONFIG_VP9_POSTPROC 1
+#define CONFIG_MULTITHREAD 1
+#define CONFIG_INTERNAL_STATS 0
+#define CONFIG_VP8_ENCODER 1
+#define CONFIG_VP8_DECODER 1
+#define CONFIG_VP9_ENCODER 1
+#define CONFIG_VP9_DECODER 1
+#define CONFIG_VP8 1
+#define CONFIG_VP9 1
+#define CONFIG_ENCODERS 1
+#define CONFIG_DECODERS 1
+#define CONFIG_STATIC_MSVCRT 0
+#define CONFIG_SPATIAL_RESAMPLING 1
+#define CONFIG_REALTIME_ONLY 1
+#define CONFIG_ONTHEFLY_BITPACKING 0
+#define CONFIG_ERROR_CONCEALMENT 0
+#define CONFIG_SHARED 0
+#define CONFIG_STATIC 1
+#define CONFIG_SMALL 0
+#define CONFIG_POSTPROC_VISUALIZER 0
+#define CONFIG_OS_SUPPORT 1
+#define CONFIG_UNIT_TESTS 1
+#define CONFIG_WEBM_IO 1
+#define CONFIG_LIBYUV 0
+#define CONFIG_DECODE_PERF_TESTS 0
+#define CONFIG_ENCODE_PERF_TESTS 0
+#define CONFIG_MULTI_RES_ENCODING 1
+#define CONFIG_TEMPORAL_DENOISING 1
+#define CONFIG_VP9_TEMPORAL_DENOISING 1
+#define CONFIG_CONSISTENT_RECODE 0
+#define CONFIG_COEFFICIENT_RANGE_CHECKING 0
+#define CONFIG_VP9_HIGHBITDEPTH 0
+#define CONFIG_BETTER_HW_COMPATIBILITY 0
+#define CONFIG_EXPERIMENTAL 0
+#define CONFIG_SIZE_LIMIT 1
+#define CONFIG_ALWAYS_ADJUST_BPM 0
+#define CONFIG_BITSTREAM_DEBUG 0
+#define CONFIG_MISMATCH_DEBUG 0
+#define CONFIG_FP_MB_STATS 0
+#define CONFIG_EMULATE_HARDWARE 0
+#define CONFIG_NON_GREEDY_MV 0
+#define CONFIG_RATE_CTRL 0
+#define DECODE_WIDTH_LIMIT 16384
+#define DECODE_HEIGHT_LIMIT 16384
+#endif /* VPX_CONFIG_H */
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_dsp_rtcd.h b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_dsp_rtcd.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_dsp_rtcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_dsp_rtcd.h	2025-06-06 11:59:28.000000000 +0800
@@ -0,0 +1,1583 @@
+// This file is generated. Do not edit.
+#ifndef VPX_DSP_RTCD_H_
+#define VPX_DSP_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * DSP
+ */
+
+#include "vpx/vpx_integer.h"
+#include "vpx_dsp/vpx_dsp_common.h"
+#include "vpx_dsp/vpx_filter.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+unsigned int vpx_avg_4x4_c(const uint8_t*, int p);
+#define vpx_avg_4x4 vpx_avg_4x4_c
+
+unsigned int vpx_avg_8x8_c(const uint8_t*, int p);
+#define vpx_avg_8x8 vpx_avg_8x8_c
+
+void vpx_comp_avg_pred_c(uint8_t* comp_pred,
+                         const uint8_t* pred,
+                         int width,
+                         int height,
+                         const uint8_t* ref,
+                         int ref_stride);
+#define vpx_comp_avg_pred vpx_comp_avg_pred_c
+
+void vpx_convolve8_c(const uint8_t* src,
+                     ptrdiff_t src_stride,
+                     uint8_t* dst,
+                     ptrdiff_t dst_stride,
+                     const InterpKernel* filter,
+                     int x0_q4,
+                     int x_step_q4,
+                     int y0_q4,
+                     int y_step_q4,
+                     int w,
+                     int h);
+#define vpx_convolve8 vpx_convolve8_c
+
+void vpx_convolve8_avg_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const InterpKernel* filter,
+                         int x0_q4,
+                         int x_step_q4,
+                         int y0_q4,
+                         int y_step_q4,
+                         int w,
+                         int h);
+#define vpx_convolve8_avg vpx_convolve8_avg_c
+
+void vpx_convolve8_avg_horiz_c(const uint8_t* src,
+                               ptrdiff_t src_stride,
+                               uint8_t* dst,
+                               ptrdiff_t dst_stride,
+                               const InterpKernel* filter,
+                               int x0_q4,
+                               int x_step_q4,
+                               int y0_q4,
+                               int y_step_q4,
+                               int w,
+                               int h);
+#define vpx_convolve8_avg_horiz vpx_convolve8_avg_horiz_c
+
+void vpx_convolve8_avg_vert_c(const uint8_t* src,
+                              ptrdiff_t src_stride,
+                              uint8_t* dst,
+                              ptrdiff_t dst_stride,
+                              const InterpKernel* filter,
+                              int x0_q4,
+                              int x_step_q4,
+                              int y0_q4,
+                              int y_step_q4,
+                              int w,
+                              int h);
+#define vpx_convolve8_avg_vert vpx_convolve8_avg_vert_c
+
+void vpx_convolve8_horiz_c(const uint8_t* src,
+                           ptrdiff_t src_stride,
+                           uint8_t* dst,
+                           ptrdiff_t dst_stride,
+                           const InterpKernel* filter,
+                           int x0_q4,
+                           int x_step_q4,
+                           int y0_q4,
+                           int y_step_q4,
+                           int w,
+                           int h);
+#define vpx_convolve8_horiz vpx_convolve8_horiz_c
+
+void vpx_convolve8_vert_c(const uint8_t* src,
+                          ptrdiff_t src_stride,
+                          uint8_t* dst,
+                          ptrdiff_t dst_stride,
+                          const InterpKernel* filter,
+                          int x0_q4,
+                          int x_step_q4,
+                          int y0_q4,
+                          int y_step_q4,
+                          int w,
+                          int h);
+#define vpx_convolve8_vert vpx_convolve8_vert_c
+
+void vpx_convolve_avg_c(const uint8_t* src,
+                        ptrdiff_t src_stride,
+                        uint8_t* dst,
+                        ptrdiff_t dst_stride,
+                        const InterpKernel* filter,
+                        int x0_q4,
+                        int x_step_q4,
+                        int y0_q4,
+                        int y_step_q4,
+                        int w,
+                        int h);
+#define vpx_convolve_avg vpx_convolve_avg_c
+
+void vpx_convolve_copy_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const InterpKernel* filter,
+                         int x0_q4,
+                         int x_step_q4,
+                         int y0_q4,
+                         int y_step_q4,
+                         int w,
+                         int h);
+#define vpx_convolve_copy vpx_convolve_copy_c
+
+void vpx_d117_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d117_predictor_16x16 vpx_d117_predictor_16x16_c
+
+void vpx_d117_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d117_predictor_32x32 vpx_d117_predictor_32x32_c
+
+void vpx_d117_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d117_predictor_4x4 vpx_d117_predictor_4x4_c
+
+void vpx_d117_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d117_predictor_8x8 vpx_d117_predictor_8x8_c
+
+void vpx_d135_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d135_predictor_16x16 vpx_d135_predictor_16x16_c
+
+void vpx_d135_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d135_predictor_32x32 vpx_d135_predictor_32x32_c
+
+void vpx_d135_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d135_predictor_4x4 vpx_d135_predictor_4x4_c
+
+void vpx_d135_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d135_predictor_8x8 vpx_d135_predictor_8x8_c
+
+void vpx_d153_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d153_predictor_16x16 vpx_d153_predictor_16x16_c
+
+void vpx_d153_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d153_predictor_32x32 vpx_d153_predictor_32x32_c
+
+void vpx_d153_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d153_predictor_4x4 vpx_d153_predictor_4x4_c
+
+void vpx_d153_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d153_predictor_8x8 vpx_d153_predictor_8x8_c
+
+void vpx_d207_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d207_predictor_16x16 vpx_d207_predictor_16x16_c
+
+void vpx_d207_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d207_predictor_32x32 vpx_d207_predictor_32x32_c
+
+void vpx_d207_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d207_predictor_4x4 vpx_d207_predictor_4x4_c
+
+void vpx_d207_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d207_predictor_8x8 vpx_d207_predictor_8x8_c
+
+void vpx_d45_predictor_16x16_c(uint8_t* dst,
+                               ptrdiff_t stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d45_predictor_16x16 vpx_d45_predictor_16x16_c
+
+void vpx_d45_predictor_32x32_c(uint8_t* dst,
+                               ptrdiff_t stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d45_predictor_32x32 vpx_d45_predictor_32x32_c
+
+void vpx_d45_predictor_4x4_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d45_predictor_4x4 vpx_d45_predictor_4x4_c
+
+void vpx_d45_predictor_8x8_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d45_predictor_8x8 vpx_d45_predictor_8x8_c
+
+void vpx_d45e_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d45e_predictor_4x4 vpx_d45e_predictor_4x4_c
+
+void vpx_d63_predictor_16x16_c(uint8_t* dst,
+                               ptrdiff_t stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d63_predictor_16x16 vpx_d63_predictor_16x16_c
+
+void vpx_d63_predictor_32x32_c(uint8_t* dst,
+                               ptrdiff_t stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d63_predictor_32x32 vpx_d63_predictor_32x32_c
+
+void vpx_d63_predictor_4x4_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d63_predictor_4x4 vpx_d63_predictor_4x4_c
+
+void vpx_d63_predictor_8x8_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d63_predictor_8x8 vpx_d63_predictor_8x8_c
+
+void vpx_d63e_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d63e_predictor_4x4 vpx_d63e_predictor_4x4_c
+
+void vpx_dc_128_predictor_16x16_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define vpx_dc_128_predictor_16x16 vpx_dc_128_predictor_16x16_c
+
+void vpx_dc_128_predictor_32x32_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define vpx_dc_128_predictor_32x32 vpx_dc_128_predictor_32x32_c
+
+void vpx_dc_128_predictor_4x4_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_128_predictor_4x4 vpx_dc_128_predictor_4x4_c
+
+void vpx_dc_128_predictor_8x8_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_128_predictor_8x8 vpx_dc_128_predictor_8x8_c
+
+void vpx_dc_left_predictor_16x16_c(uint8_t* dst,
+                                   ptrdiff_t stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define vpx_dc_left_predictor_16x16 vpx_dc_left_predictor_16x16_c
+
+void vpx_dc_left_predictor_32x32_c(uint8_t* dst,
+                                   ptrdiff_t stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define vpx_dc_left_predictor_32x32 vpx_dc_left_predictor_32x32_c
+
+void vpx_dc_left_predictor_4x4_c(uint8_t* dst,
+                                 ptrdiff_t stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define vpx_dc_left_predictor_4x4 vpx_dc_left_predictor_4x4_c
+
+void vpx_dc_left_predictor_8x8_c(uint8_t* dst,
+                                 ptrdiff_t stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define vpx_dc_left_predictor_8x8 vpx_dc_left_predictor_8x8_c
+
+void vpx_dc_predictor_16x16_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_dc_predictor_16x16 vpx_dc_predictor_16x16_c
+
+void vpx_dc_predictor_32x32_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_dc_predictor_32x32 vpx_dc_predictor_32x32_c
+
+void vpx_dc_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_dc_predictor_4x4 vpx_dc_predictor_4x4_c
+
+void vpx_dc_predictor_8x8_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_dc_predictor_8x8 vpx_dc_predictor_8x8_c
+
+void vpx_dc_top_predictor_16x16_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define vpx_dc_top_predictor_16x16 vpx_dc_top_predictor_16x16_c
+
+void vpx_dc_top_predictor_32x32_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define vpx_dc_top_predictor_32x32 vpx_dc_top_predictor_32x32_c
+
+void vpx_dc_top_predictor_4x4_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_top_predictor_4x4 vpx_dc_top_predictor_4x4_c
+
+void vpx_dc_top_predictor_8x8_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_top_predictor_8x8 vpx_dc_top_predictor_8x8_c
+
+void vpx_fdct16x16_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct16x16 vpx_fdct16x16_c
+
+void vpx_fdct16x16_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct16x16_1 vpx_fdct16x16_1_c
+
+void vpx_fdct32x32_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct32x32 vpx_fdct32x32_c
+
+void vpx_fdct32x32_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct32x32_1 vpx_fdct32x32_1_c
+
+void vpx_fdct32x32_rd_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct32x32_rd vpx_fdct32x32_rd_c
+
+void vpx_fdct4x4_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct4x4 vpx_fdct4x4_c
+
+void vpx_fdct4x4_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct4x4_1 vpx_fdct4x4_1_c
+
+void vpx_fdct8x8_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct8x8 vpx_fdct8x8_c
+
+void vpx_fdct8x8_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct8x8_1 vpx_fdct8x8_1_c
+
+void vpx_get16x16var_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* ref_ptr,
+                       int ref_stride,
+                       unsigned int* sse,
+                       int* sum);
+#define vpx_get16x16var vpx_get16x16var_c
+
+unsigned int vpx_get4x4sse_cs_c(const unsigned char* src_ptr,
+                                int src_stride,
+                                const unsigned char* ref_ptr,
+                                int ref_stride);
+#define vpx_get4x4sse_cs vpx_get4x4sse_cs_c
+
+void vpx_get8x8var_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     unsigned int* sse,
+                     int* sum);
+#define vpx_get8x8var vpx_get8x8var_c
+
+unsigned int vpx_get_mb_ss_c(const int16_t*);
+#define vpx_get_mb_ss vpx_get_mb_ss_c
+
+void vpx_h_predictor_16x16_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_h_predictor_16x16 vpx_h_predictor_16x16_c
+
+void vpx_h_predictor_32x32_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_h_predictor_32x32 vpx_h_predictor_32x32_c
+
+void vpx_h_predictor_4x4_c(uint8_t* dst,
+                           ptrdiff_t stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_h_predictor_4x4 vpx_h_predictor_4x4_c
+
+void vpx_h_predictor_8x8_c(uint8_t* dst,
+                           ptrdiff_t stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_h_predictor_8x8 vpx_h_predictor_8x8_c
+
+void vpx_hadamard_16x16_c(const int16_t* src_diff,
+                          ptrdiff_t src_stride,
+                          int16_t* coeff);
+#define vpx_hadamard_16x16 vpx_hadamard_16x16_c
+
+void vpx_hadamard_32x32_c(const int16_t* src_diff,
+                          ptrdiff_t src_stride,
+                          int16_t* coeff);
+#define vpx_hadamard_32x32 vpx_hadamard_32x32_c
+
+void vpx_hadamard_8x8_c(const int16_t* src_diff,
+                        ptrdiff_t src_stride,
+                        int16_t* coeff);
+#define vpx_hadamard_8x8 vpx_hadamard_8x8_c
+
+void vpx_he_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_he_predictor_4x4 vpx_he_predictor_4x4_c
+
+void vpx_idct16x16_10_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct16x16_10_add vpx_idct16x16_10_add_c
+
+void vpx_idct16x16_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct16x16_1_add vpx_idct16x16_1_add_c
+
+void vpx_idct16x16_256_add_c(const tran_low_t* input,
+                             uint8_t* dest,
+                             int stride);
+#define vpx_idct16x16_256_add vpx_idct16x16_256_add_c
+
+void vpx_idct16x16_38_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct16x16_38_add vpx_idct16x16_38_add_c
+
+void vpx_idct32x32_1024_add_c(const tran_low_t* input,
+                              uint8_t* dest,
+                              int stride);
+#define vpx_idct32x32_1024_add vpx_idct32x32_1024_add_c
+
+void vpx_idct32x32_135_add_c(const tran_low_t* input,
+                             uint8_t* dest,
+                             int stride);
+#define vpx_idct32x32_135_add vpx_idct32x32_135_add_c
+
+void vpx_idct32x32_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct32x32_1_add vpx_idct32x32_1_add_c
+
+void vpx_idct32x32_34_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct32x32_34_add vpx_idct32x32_34_add_c
+
+void vpx_idct4x4_16_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct4x4_16_add vpx_idct4x4_16_add_c
+
+void vpx_idct4x4_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct4x4_1_add vpx_idct4x4_1_add_c
+
+void vpx_idct8x8_12_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct8x8_12_add vpx_idct8x8_12_add_c
+
+void vpx_idct8x8_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct8x8_1_add vpx_idct8x8_1_add_c
+
+void vpx_idct8x8_64_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct8x8_64_add vpx_idct8x8_64_add_c
+
+int16_t vpx_int_pro_col_c(const uint8_t* ref, const int width);
+#define vpx_int_pro_col vpx_int_pro_col_c
+
+void vpx_int_pro_row_c(int16_t* hbuf,
+                       const uint8_t* ref,
+                       const int ref_stride,
+                       const int height);
+#define vpx_int_pro_row vpx_int_pro_row_c
+
+void vpx_iwht4x4_16_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_iwht4x4_16_add vpx_iwht4x4_16_add_c
+
+void vpx_iwht4x4_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_iwht4x4_1_add vpx_iwht4x4_1_add_c
+
+void vpx_lpf_horizontal_16_c(uint8_t* s,
+                             int pitch,
+                             const uint8_t* blimit,
+                             const uint8_t* limit,
+                             const uint8_t* thresh);
+#define vpx_lpf_horizontal_16 vpx_lpf_horizontal_16_c
+
+void vpx_lpf_horizontal_16_dual_c(uint8_t* s,
+                                  int pitch,
+                                  const uint8_t* blimit,
+                                  const uint8_t* limit,
+                                  const uint8_t* thresh);
+#define vpx_lpf_horizontal_16_dual vpx_lpf_horizontal_16_dual_c
+
+void vpx_lpf_horizontal_4_c(uint8_t* s,
+                            int pitch,
+                            const uint8_t* blimit,
+                            const uint8_t* limit,
+                            const uint8_t* thresh);
+#define vpx_lpf_horizontal_4 vpx_lpf_horizontal_4_c
+
+void vpx_lpf_horizontal_4_dual_c(uint8_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit0,
+                                 const uint8_t* limit0,
+                                 const uint8_t* thresh0,
+                                 const uint8_t* blimit1,
+                                 const uint8_t* limit1,
+                                 const uint8_t* thresh1);
+#define vpx_lpf_horizontal_4_dual vpx_lpf_horizontal_4_dual_c
+
+void vpx_lpf_horizontal_8_c(uint8_t* s,
+                            int pitch,
+                            const uint8_t* blimit,
+                            const uint8_t* limit,
+                            const uint8_t* thresh);
+#define vpx_lpf_horizontal_8 vpx_lpf_horizontal_8_c
+
+void vpx_lpf_horizontal_8_dual_c(uint8_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit0,
+                                 const uint8_t* limit0,
+                                 const uint8_t* thresh0,
+                                 const uint8_t* blimit1,
+                                 const uint8_t* limit1,
+                                 const uint8_t* thresh1);
+#define vpx_lpf_horizontal_8_dual vpx_lpf_horizontal_8_dual_c
+
+void vpx_lpf_vertical_16_c(uint8_t* s,
+                           int pitch,
+                           const uint8_t* blimit,
+                           const uint8_t* limit,
+                           const uint8_t* thresh);
+#define vpx_lpf_vertical_16 vpx_lpf_vertical_16_c
+
+void vpx_lpf_vertical_16_dual_c(uint8_t* s,
+                                int pitch,
+                                const uint8_t* blimit,
+                                const uint8_t* limit,
+                                const uint8_t* thresh);
+#define vpx_lpf_vertical_16_dual vpx_lpf_vertical_16_dual_c
+
+void vpx_lpf_vertical_4_c(uint8_t* s,
+                          int pitch,
+                          const uint8_t* blimit,
+                          const uint8_t* limit,
+                          const uint8_t* thresh);
+#define vpx_lpf_vertical_4 vpx_lpf_vertical_4_c
+
+void vpx_lpf_vertical_4_dual_c(uint8_t* s,
+                               int pitch,
+                               const uint8_t* blimit0,
+                               const uint8_t* limit0,
+                               const uint8_t* thresh0,
+                               const uint8_t* blimit1,
+                               const uint8_t* limit1,
+                               const uint8_t* thresh1);
+#define vpx_lpf_vertical_4_dual vpx_lpf_vertical_4_dual_c
+
+void vpx_lpf_vertical_8_c(uint8_t* s,
+                          int pitch,
+                          const uint8_t* blimit,
+                          const uint8_t* limit,
+                          const uint8_t* thresh);
+#define vpx_lpf_vertical_8 vpx_lpf_vertical_8_c
+
+void vpx_lpf_vertical_8_dual_c(uint8_t* s,
+                               int pitch,
+                               const uint8_t* blimit0,
+                               const uint8_t* limit0,
+                               const uint8_t* thresh0,
+                               const uint8_t* blimit1,
+                               const uint8_t* limit1,
+                               const uint8_t* thresh1);
+#define vpx_lpf_vertical_8_dual vpx_lpf_vertical_8_dual_c
+
+void vpx_mbpost_proc_across_ip_c(unsigned char* src,
+                                 int pitch,
+                                 int rows,
+                                 int cols,
+                                 int flimit);
+#define vpx_mbpost_proc_across_ip vpx_mbpost_proc_across_ip_c
+
+void vpx_mbpost_proc_down_c(unsigned char* dst,
+                            int pitch,
+                            int rows,
+                            int cols,
+                            int flimit);
+#define vpx_mbpost_proc_down vpx_mbpost_proc_down_c
+
+void vpx_minmax_8x8_c(const uint8_t* s,
+                      int p,
+                      const uint8_t* d,
+                      int dp,
+                      int* min,
+                      int* max);
+#define vpx_minmax_8x8 vpx_minmax_8x8_c
+
+unsigned int vpx_mse16x16_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride,
+                            unsigned int* sse);
+#define vpx_mse16x16 vpx_mse16x16_c
+
+unsigned int vpx_mse16x8_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride,
+                           unsigned int* sse);
+#define vpx_mse16x8 vpx_mse16x8_c
+
+unsigned int vpx_mse8x16_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride,
+                           unsigned int* sse);
+#define vpx_mse8x16 vpx_mse8x16_c
+
+unsigned int vpx_mse8x8_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride,
+                          unsigned int* sse);
+#define vpx_mse8x8 vpx_mse8x8_c
+
+void vpx_plane_add_noise_c(uint8_t* start,
+                           const int8_t* noise,
+                           int blackclamp,
+                           int whiteclamp,
+                           int width,
+                           int height,
+                           int pitch);
+#define vpx_plane_add_noise vpx_plane_add_noise_c
+
+void vpx_post_proc_down_and_across_mb_row_c(unsigned char* src,
+                                            unsigned char* dst,
+                                            int src_pitch,
+                                            int dst_pitch,
+                                            int cols,
+                                            unsigned char* flimits,
+                                            int size);
+#define vpx_post_proc_down_and_across_mb_row \
+  vpx_post_proc_down_and_across_mb_row_c
+
+void vpx_quantize_b_c(const tran_low_t* coeff_ptr,
+                      intptr_t n_coeffs,
+                      int skip_block,
+                      const int16_t* zbin_ptr,
+                      const int16_t* round_ptr,
+                      const int16_t* quant_ptr,
+                      const int16_t* quant_shift_ptr,
+                      tran_low_t* qcoeff_ptr,
+                      tran_low_t* dqcoeff_ptr,
+                      const int16_t* dequant_ptr,
+                      uint16_t* eob_ptr,
+                      const int16_t* scan,
+                      const int16_t* iscan);
+#define vpx_quantize_b vpx_quantize_b_c
+
+void vpx_quantize_b_32x32_c(const tran_low_t* coeff_ptr,
+                            intptr_t n_coeffs,
+                            int skip_block,
+                            const int16_t* zbin_ptr,
+                            const int16_t* round_ptr,
+                            const int16_t* quant_ptr,
+                            const int16_t* quant_shift_ptr,
+                            tran_low_t* qcoeff_ptr,
+                            tran_low_t* dqcoeff_ptr,
+                            const int16_t* dequant_ptr,
+                            uint16_t* eob_ptr,
+                            const int16_t* scan,
+                            const int16_t* iscan);
+#define vpx_quantize_b_32x32 vpx_quantize_b_32x32_c
+
+unsigned int vpx_sad16x16_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad16x16 vpx_sad16x16_c
+
+unsigned int vpx_sad16x16_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad16x16_avg vpx_sad16x16_avg_c
+
+void vpx_sad16x16x3_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* ref_ptr,
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad16x16x3 vpx_sad16x16x3_c
+
+void vpx_sad16x16x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad16x16x4d vpx_sad16x16x4d_c
+
+void vpx_sad16x16x8_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* ref_ptr,
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad16x16x8 vpx_sad16x16x8_c
+
+unsigned int vpx_sad16x32_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad16x32 vpx_sad16x32_c
+
+unsigned int vpx_sad16x32_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad16x32_avg vpx_sad16x32_avg_c
+
+void vpx_sad16x32x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad16x32x4d vpx_sad16x32x4d_c
+
+unsigned int vpx_sad16x8_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride);
+#define vpx_sad16x8 vpx_sad16x8_c
+
+unsigned int vpx_sad16x8_avg_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               const uint8_t* second_pred);
+#define vpx_sad16x8_avg vpx_sad16x8_avg_c
+
+void vpx_sad16x8x3_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad16x8x3 vpx_sad16x8x3_c
+
+void vpx_sad16x8x4d_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* const ref_array[],
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad16x8x4d vpx_sad16x8x4d_c
+
+void vpx_sad16x8x8_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad16x8x8 vpx_sad16x8x8_c
+
+unsigned int vpx_sad32x16_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad32x16 vpx_sad32x16_c
+
+unsigned int vpx_sad32x16_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad32x16_avg vpx_sad32x16_avg_c
+
+void vpx_sad32x16x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad32x16x4d vpx_sad32x16x4d_c
+
+unsigned int vpx_sad32x32_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad32x32 vpx_sad32x32_c
+
+unsigned int vpx_sad32x32_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad32x32_avg vpx_sad32x32_avg_c
+
+void vpx_sad32x32x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad32x32x4d vpx_sad32x32x4d_c
+
+void vpx_sad32x32x8_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* ref_ptr,
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad32x32x8 vpx_sad32x32x8_c
+
+unsigned int vpx_sad32x64_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad32x64 vpx_sad32x64_c
+
+unsigned int vpx_sad32x64_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad32x64_avg vpx_sad32x64_avg_c
+
+void vpx_sad32x64x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad32x64x4d vpx_sad32x64x4d_c
+
+unsigned int vpx_sad4x4_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad4x4 vpx_sad4x4_c
+
+unsigned int vpx_sad4x4_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad4x4_avg vpx_sad4x4_avg_c
+
+void vpx_sad4x4x3_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad4x4x3 vpx_sad4x4x3_c
+
+void vpx_sad4x4x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_array[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad4x4x4d vpx_sad4x4x4d_c
+
+void vpx_sad4x4x8_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad4x4x8 vpx_sad4x4x8_c
+
+unsigned int vpx_sad4x8_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad4x8 vpx_sad4x8_c
+
+unsigned int vpx_sad4x8_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad4x8_avg vpx_sad4x8_avg_c
+
+void vpx_sad4x8x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_array[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad4x8x4d vpx_sad4x8x4d_c
+
+unsigned int vpx_sad64x32_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad64x32 vpx_sad64x32_c
+
+unsigned int vpx_sad64x32_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad64x32_avg vpx_sad64x32_avg_c
+
+void vpx_sad64x32x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad64x32x4d vpx_sad64x32x4d_c
+
+unsigned int vpx_sad64x64_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad64x64 vpx_sad64x64_c
+
+unsigned int vpx_sad64x64_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad64x64_avg vpx_sad64x64_avg_c
+
+void vpx_sad64x64x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad64x64x4d vpx_sad64x64x4d_c
+
+unsigned int vpx_sad8x16_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride);
+#define vpx_sad8x16 vpx_sad8x16_c
+
+unsigned int vpx_sad8x16_avg_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               const uint8_t* second_pred);
+#define vpx_sad8x16_avg vpx_sad8x16_avg_c
+
+void vpx_sad8x16x3_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x16x3 vpx_sad8x16x3_c
+
+void vpx_sad8x16x4d_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* const ref_array[],
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad8x16x4d vpx_sad8x16x4d_c
+
+void vpx_sad8x16x8_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x16x8 vpx_sad8x16x8_c
+
+unsigned int vpx_sad8x4_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad8x4 vpx_sad8x4_c
+
+unsigned int vpx_sad8x4_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad8x4_avg vpx_sad8x4_avg_c
+
+void vpx_sad8x4x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_array[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x4x4d vpx_sad8x4x4d_c
+
+unsigned int vpx_sad8x8_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad8x8 vpx_sad8x8_c
+
+unsigned int vpx_sad8x8_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad8x8_avg vpx_sad8x8_avg_c
+
+void vpx_sad8x8x3_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad8x8x3 vpx_sad8x8x3_c
+
+void vpx_sad8x8x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_array[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x8x4d vpx_sad8x8x4d_c
+
+void vpx_sad8x8x8_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad8x8x8 vpx_sad8x8x8_c
+
+int vpx_satd_c(const int16_t* coeff, int length);
+#define vpx_satd vpx_satd_c
+
+void vpx_scaled_2d_c(const uint8_t* src,
+                     ptrdiff_t src_stride,
+                     uint8_t* dst,
+                     ptrdiff_t dst_stride,
+                     const InterpKernel* filter,
+                     int x0_q4,
+                     int x_step_q4,
+                     int y0_q4,
+                     int y_step_q4,
+                     int w,
+                     int h);
+#define vpx_scaled_2d vpx_scaled_2d_c
+
+void vpx_scaled_avg_2d_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const InterpKernel* filter,
+                         int x0_q4,
+                         int x_step_q4,
+                         int y0_q4,
+                         int y_step_q4,
+                         int w,
+                         int h);
+#define vpx_scaled_avg_2d vpx_scaled_avg_2d_c
+
+void vpx_scaled_avg_horiz_c(const uint8_t* src,
+                            ptrdiff_t src_stride,
+                            uint8_t* dst,
+                            ptrdiff_t dst_stride,
+                            const InterpKernel* filter,
+                            int x0_q4,
+                            int x_step_q4,
+                            int y0_q4,
+                            int y_step_q4,
+                            int w,
+                            int h);
+#define vpx_scaled_avg_horiz vpx_scaled_avg_horiz_c
+
+void vpx_scaled_avg_vert_c(const uint8_t* src,
+                           ptrdiff_t src_stride,
+                           uint8_t* dst,
+                           ptrdiff_t dst_stride,
+                           const InterpKernel* filter,
+                           int x0_q4,
+                           int x_step_q4,
+                           int y0_q4,
+                           int y_step_q4,
+                           int w,
+                           int h);
+#define vpx_scaled_avg_vert vpx_scaled_avg_vert_c
+
+void vpx_scaled_horiz_c(const uint8_t* src,
+                        ptrdiff_t src_stride,
+                        uint8_t* dst,
+                        ptrdiff_t dst_stride,
+                        const InterpKernel* filter,
+                        int x0_q4,
+                        int x_step_q4,
+                        int y0_q4,
+                        int y_step_q4,
+                        int w,
+                        int h);
+#define vpx_scaled_horiz vpx_scaled_horiz_c
+
+void vpx_scaled_vert_c(const uint8_t* src,
+                       ptrdiff_t src_stride,
+                       uint8_t* dst,
+                       ptrdiff_t dst_stride,
+                       const InterpKernel* filter,
+                       int x0_q4,
+                       int x_step_q4,
+                       int y0_q4,
+                       int y_step_q4,
+                       int w,
+                       int h);
+#define vpx_scaled_vert vpx_scaled_vert_c
+
+uint32_t vpx_sub_pixel_avg_variance16x16_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance16x16 vpx_sub_pixel_avg_variance16x16_c
+
+uint32_t vpx_sub_pixel_avg_variance16x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance16x32 vpx_sub_pixel_avg_variance16x32_c
+
+uint32_t vpx_sub_pixel_avg_variance16x8_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          int x_offset,
+                                          int y_offset,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          uint32_t* sse,
+                                          const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance16x8 vpx_sub_pixel_avg_variance16x8_c
+
+uint32_t vpx_sub_pixel_avg_variance32x16_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance32x16 vpx_sub_pixel_avg_variance32x16_c
+
+uint32_t vpx_sub_pixel_avg_variance32x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance32x32 vpx_sub_pixel_avg_variance32x32_c
+
+uint32_t vpx_sub_pixel_avg_variance32x64_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance32x64 vpx_sub_pixel_avg_variance32x64_c
+
+uint32_t vpx_sub_pixel_avg_variance4x4_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         int x_offset,
+                                         int y_offset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance4x4 vpx_sub_pixel_avg_variance4x4_c
+
+uint32_t vpx_sub_pixel_avg_variance4x8_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         int x_offset,
+                                         int y_offset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance4x8 vpx_sub_pixel_avg_variance4x8_c
+
+uint32_t vpx_sub_pixel_avg_variance64x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance64x32 vpx_sub_pixel_avg_variance64x32_c
+
+uint32_t vpx_sub_pixel_avg_variance64x64_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance64x64 vpx_sub_pixel_avg_variance64x64_c
+
+uint32_t vpx_sub_pixel_avg_variance8x16_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          int x_offset,
+                                          int y_offset,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          uint32_t* sse,
+                                          const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance8x16 vpx_sub_pixel_avg_variance8x16_c
+
+uint32_t vpx_sub_pixel_avg_variance8x4_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         int x_offset,
+                                         int y_offset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance8x4 vpx_sub_pixel_avg_variance8x4_c
+
+uint32_t vpx_sub_pixel_avg_variance8x8_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         int x_offset,
+                                         int y_offset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance8x8 vpx_sub_pixel_avg_variance8x8_c
+
+uint32_t vpx_sub_pixel_variance16x16_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance16x16 vpx_sub_pixel_variance16x16_c
+
+uint32_t vpx_sub_pixel_variance16x32_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance16x32 vpx_sub_pixel_variance16x32_c
+
+uint32_t vpx_sub_pixel_variance16x8_c(const uint8_t* src_ptr,
+                                      int src_stride,
+                                      int x_offset,
+                                      int y_offset,
+                                      const uint8_t* ref_ptr,
+                                      int ref_stride,
+                                      uint32_t* sse);
+#define vpx_sub_pixel_variance16x8 vpx_sub_pixel_variance16x8_c
+
+uint32_t vpx_sub_pixel_variance32x16_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance32x16 vpx_sub_pixel_variance32x16_c
+
+uint32_t vpx_sub_pixel_variance32x32_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance32x32 vpx_sub_pixel_variance32x32_c
+
+uint32_t vpx_sub_pixel_variance32x64_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance32x64 vpx_sub_pixel_variance32x64_c
+
+uint32_t vpx_sub_pixel_variance4x4_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     int x_offset,
+                                     int y_offset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance4x4 vpx_sub_pixel_variance4x4_c
+
+uint32_t vpx_sub_pixel_variance4x8_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     int x_offset,
+                                     int y_offset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance4x8 vpx_sub_pixel_variance4x8_c
+
+uint32_t vpx_sub_pixel_variance64x32_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance64x32 vpx_sub_pixel_variance64x32_c
+
+uint32_t vpx_sub_pixel_variance64x64_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance64x64 vpx_sub_pixel_variance64x64_c
+
+uint32_t vpx_sub_pixel_variance8x16_c(const uint8_t* src_ptr,
+                                      int src_stride,
+                                      int x_offset,
+                                      int y_offset,
+                                      const uint8_t* ref_ptr,
+                                      int ref_stride,
+                                      uint32_t* sse);
+#define vpx_sub_pixel_variance8x16 vpx_sub_pixel_variance8x16_c
+
+uint32_t vpx_sub_pixel_variance8x4_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     int x_offset,
+                                     int y_offset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance8x4 vpx_sub_pixel_variance8x4_c
+
+uint32_t vpx_sub_pixel_variance8x8_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     int x_offset,
+                                     int y_offset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance8x8 vpx_sub_pixel_variance8x8_c
+
+void vpx_subtract_block_c(int rows,
+                          int cols,
+                          int16_t* diff_ptr,
+                          ptrdiff_t diff_stride,
+                          const uint8_t* src_ptr,
+                          ptrdiff_t src_stride,
+                          const uint8_t* pred_ptr,
+                          ptrdiff_t pred_stride);
+#define vpx_subtract_block vpx_subtract_block_c
+
+uint64_t vpx_sum_squares_2d_i16_c(const int16_t* src, int stride, int size);
+#define vpx_sum_squares_2d_i16 vpx_sum_squares_2d_i16_c
+
+void vpx_tm_predictor_16x16_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_tm_predictor_16x16 vpx_tm_predictor_16x16_c
+
+void vpx_tm_predictor_32x32_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_tm_predictor_32x32 vpx_tm_predictor_32x32_c
+
+void vpx_tm_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_tm_predictor_4x4 vpx_tm_predictor_4x4_c
+
+void vpx_tm_predictor_8x8_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_tm_predictor_8x8 vpx_tm_predictor_8x8_c
+
+void vpx_v_predictor_16x16_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_v_predictor_16x16 vpx_v_predictor_16x16_c
+
+void vpx_v_predictor_32x32_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_v_predictor_32x32 vpx_v_predictor_32x32_c
+
+void vpx_v_predictor_4x4_c(uint8_t* dst,
+                           ptrdiff_t stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_v_predictor_4x4 vpx_v_predictor_4x4_c
+
+void vpx_v_predictor_8x8_c(uint8_t* dst,
+                           ptrdiff_t stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_v_predictor_8x8 vpx_v_predictor_8x8_c
+
+unsigned int vpx_variance16x16_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance16x16 vpx_variance16x16_c
+
+unsigned int vpx_variance16x32_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance16x32 vpx_variance16x32_c
+
+unsigned int vpx_variance16x8_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                unsigned int* sse);
+#define vpx_variance16x8 vpx_variance16x8_c
+
+unsigned int vpx_variance32x16_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance32x16 vpx_variance32x16_c
+
+unsigned int vpx_variance32x32_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance32x32 vpx_variance32x32_c
+
+unsigned int vpx_variance32x64_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance32x64 vpx_variance32x64_c
+
+unsigned int vpx_variance4x4_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+#define vpx_variance4x4 vpx_variance4x4_c
+
+unsigned int vpx_variance4x8_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+#define vpx_variance4x8 vpx_variance4x8_c
+
+unsigned int vpx_variance64x32_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance64x32 vpx_variance64x32_c
+
+unsigned int vpx_variance64x64_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance64x64 vpx_variance64x64_c
+
+unsigned int vpx_variance8x16_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                unsigned int* sse);
+#define vpx_variance8x16 vpx_variance8x16_c
+
+unsigned int vpx_variance8x4_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+#define vpx_variance8x4 vpx_variance8x4_c
+
+unsigned int vpx_variance8x8_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+#define vpx_variance8x8 vpx_variance8x8_c
+
+void vpx_ve_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_ve_predictor_4x4 vpx_ve_predictor_4x4_c
+
+int vpx_vector_var_c(const int16_t* ref, const int16_t* src, const int bwl);
+#define vpx_vector_var vpx_vector_var_c
+
+void vpx_dsp_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void) {}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_scale_rtcd.h b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_scale_rtcd.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_scale_rtcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64le/vpx_scale_rtcd.h	2025-06-06 11:59:28.000000000 +0800
@@ -0,0 +1,96 @@
+// This file is generated. Do not edit.
+#ifndef VPX_SCALE_RTCD_H_
+#define VPX_SCALE_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void vp8_horizontal_line_2_1_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define vp8_horizontal_line_2_1_scale vp8_horizontal_line_2_1_scale_c
+
+void vp8_horizontal_line_5_3_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define vp8_horizontal_line_5_3_scale vp8_horizontal_line_5_3_scale_c
+
+void vp8_horizontal_line_5_4_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define vp8_horizontal_line_5_4_scale vp8_horizontal_line_5_4_scale_c
+
+void vp8_vertical_band_2_1_scale_c(unsigned char* source,
+                                   unsigned int src_pitch,
+                                   unsigned char* dest,
+                                   unsigned int dest_pitch,
+                                   unsigned int dest_width);
+#define vp8_vertical_band_2_1_scale vp8_vertical_band_2_1_scale_c
+
+void vp8_vertical_band_2_1_scale_i_c(unsigned char* source,
+                                     unsigned int src_pitch,
+                                     unsigned char* dest,
+                                     unsigned int dest_pitch,
+                                     unsigned int dest_width);
+#define vp8_vertical_band_2_1_scale_i vp8_vertical_band_2_1_scale_i_c
+
+void vp8_vertical_band_5_3_scale_c(unsigned char* source,
+                                   unsigned int src_pitch,
+                                   unsigned char* dest,
+                                   unsigned int dest_pitch,
+                                   unsigned int dest_width);
+#define vp8_vertical_band_5_3_scale vp8_vertical_band_5_3_scale_c
+
+void vp8_vertical_band_5_4_scale_c(unsigned char* source,
+                                   unsigned int src_pitch,
+                                   unsigned char* dest,
+                                   unsigned int dest_pitch,
+                                   unsigned int dest_width);
+#define vp8_vertical_band_5_4_scale vp8_vertical_band_5_4_scale_c
+
+void vp8_yv12_copy_frame_c(const struct yv12_buffer_config* src_ybc,
+                           struct yv12_buffer_config* dst_ybc);
+#define vp8_yv12_copy_frame vp8_yv12_copy_frame_c
+
+void vp8_yv12_extend_frame_borders_c(struct yv12_buffer_config* ybf);
+#define vp8_yv12_extend_frame_borders vp8_yv12_extend_frame_borders_c
+
+void vpx_extend_frame_borders_c(struct yv12_buffer_config* ybf);
+#define vpx_extend_frame_borders vpx_extend_frame_borders_c
+
+void vpx_extend_frame_inner_borders_c(struct yv12_buffer_config* ybf);
+#define vpx_extend_frame_inner_borders vpx_extend_frame_inner_borders_c
+
+void vpx_yv12_copy_frame_c(const struct yv12_buffer_config* src_ybc,
+                           struct yv12_buffer_config* dst_ybc);
+#define vpx_yv12_copy_frame vpx_yv12_copy_frame_c
+
+void vpx_yv12_copy_y_c(const struct yv12_buffer_config* src_ybc,
+                       struct yv12_buffer_config* dst_ybc);
+#define vpx_yv12_copy_y vpx_yv12_copy_y_c
+
+void vpx_scale_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void) {}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/libvpx/build/make/rtcd.pl b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/libvpx/build/make/rtcd.pl
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/libvpx/build/make/rtcd.pl	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/libvpx/build/make/rtcd.pl	2025-05-30 15:28:03.000000000 +0800
@@ -460,8 +460,9 @@
   &require("neon");
   arm;
 } elsif ($opts{arch} =~ /^ppc/ ) {
-  @ALL_ARCHS = filter(qw/vsx/);
-  ppc;
+  #@ALL_ARCHS = filter(qw/vsx/);
+  #ppc;
+  unoptimized;
 } else {
   unoptimized;
 }
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/libvpx/vpx_ports/ppc_cpudetect.c b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/libvpx/vpx_ports/ppc_cpudetect.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/libvpx/vpx_ports/ppc_cpudetect.c	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/libvpx/source/libvpx/vpx_ports/ppc_cpudetect.c	2025-06-05 19:20:02.000000000 +0800
@@ -15,7 +15,9 @@
 #include <linux/auxvec.h>
 
 #include "./vpx_config.h"
+#if defined(__powerpc64__)
 #include "vpx_ports/ppc.h"
+#endif
 
 #if CONFIG_RUNTIME_CPU_DETECT
 static int cpu_env_flags(int *flags) {
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h b/qtwebengine/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h	2025-05-30 15:26:20.000000000 +0800
@@ -3947,7 +3947,7 @@
       LSS_REG(2, buf);
       LSS_BODY(void*, mmap2, "0"(__r2));
     }
-#else
+#elif !defined(__powerpc64__) /* ppc64 doesn't have mmap2 */
     #define __NR__mmap2 __NR_mmap2
     LSS_INLINE _syscall6(void*, _mmap2,            void*, s,
                          size_t,                   l, int,               p,
@@ -4058,7 +4058,7 @@
   #if defined(__i386__) ||                                                    \
       defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) ||                     \
      (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) ||                   \
-      defined(__PPC__) ||                                                     \
+     (defined(__PPC__) && !defined(__powerpc64__)) ||                                                     \
      (defined(__s390__) && !defined(__s390x__))
     /* On these architectures, implement mmap() with mmap2(). */
     LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,
-#endif  // CORE_V2_INTERNAL_OFFLINE_SERVICE_CONTROLLER_H_
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/pffft/BUILD.gn b/qtwebengine/src/3rdparty/chromium/third_party/pffft/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/third_party/pffft/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/pffft/BUILD.gn	2025-06-05 15:08:57.000000000 +0800
@@ -16,7 +16,7 @@
 
   # PFFFT doesn't support SIMD on some cpus, so build a scalar version.
   if ((current_cpu == "arm" && !arm_use_neon) || current_cpu == "mipsel" ||
-      current_cpu == "mips64el" || current_cpu == "ppc64" ||
+      current_cpu == "mips64el" || current_cpu == "ppc64" || current_cpu == "ppc64le" ||
       current_cpu == "s390x") {
     defines = [ "PFFFT_SIMD_DISABLE" ]
   }
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/pffft/src/pffft.c b/qtwebengine/src/3rdparty/chromium/third_party/pffft/src/pffft.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/pffft/src/pffft.c	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/pffft/src/pffft.c	2025-05-30 15:26:20.000000000 +0800
@@ -100,6 +100,7 @@
    Altivec support macros 
 */
 #if !defined(PFFFT_SIMD_DISABLE) && (defined(__ppc__) || defined(__ppc64__))
+#include <altivec.h>
 typedef vector float v4sf;
 #  define SIMD_SZ 4
 #  define VZERO() ((vector float) vec_splat_u8(0))
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/BUILD.gn b/qtwebengine/src/3rdparty/chromium/third_party/skia/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/BUILD.gn	2025-06-05 15:30:22.000000000 +0800
@@ -132,7 +132,8 @@
 is_x86 = current_cpu == "x64" || current_cpu == "x86"
 
 opts("none") {
-  enabled = !is_x86 && current_cpu != "arm" && current_cpu != "arm64"
+  enabled = (!is_x86 && current_cpu != "arm" && current_cpu != "arm64" &&
+      current_cpu != "ppc64" && current_cpu != "ppc64le")
   sources = skia_opts.none_sources
   cflags = []
 }
@@ -221,6 +222,11 @@
   }
 }
 
+opts("vsx") {
+  enabled = (current_cpu == "ppc64" || current_cpu == "ppc64le")
+  sources = skia_opts.vsx_sources
+}
+
 opts("skx") {
   enabled = is_x86
   sources = skia_opts.skx_sources
@@ -1170,6 +1176,7 @@
     ":sse41",
     ":sse42",
     ":ssse3",
+    ":vsx",
     ":webp_decode",
     ":webp_encode",
     ":wuffs",
@@ -1341,6 +1348,7 @@
     ":sse41",
     ":sse42",
     ":ssse3",
+    ":vsx",
   ]
 
   # This file (and all GN files in Skia) are designed to work with an
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/gn/BUILD.gn b/qtwebengine/src/3rdparty/chromium/third_party/skia/gn/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/gn/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/gn/BUILD.gn	2025-06-05 15:11:05.000000000 +0800
@@ -155,6 +155,8 @@
       "-mfpmath=sse",
     ]
     ldflags += [ "-m32" ]
+  } else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
+    cflags += [ "-mcpu=power9", "-mtune=power9" ]
   }
 
   if (malloc != "" && !is_win) {
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/gn/shared_sources.gni b/qtwebengine/src/3rdparty/chromium/third_party/skia/gn/shared_sources.gni
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/gn/shared_sources.gni	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/gn/shared_sources.gni	2025-06-03 10:02:01.000000000 +0800
@@ -26,5 +26,6 @@
   sse42_sources = sse42
   avx_sources = avx
   hsw_sources = hsw
+  vsx_sources = ssse3
   skx_sources = skx
 }
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/include/core/SkTypes.h b/qtwebengine/src/3rdparty/chromium/third_party/skia/include/core/SkTypes.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/include/core/SkTypes.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/include/core/SkTypes.h	2025-06-03 10:02:01.000000000 +0800
@@ -169,6 +169,42 @@
     #define SK_ARM_HAS_CRC32
 #endif
 
+//////////////////////////////////////////////////////////////////////
+// PPC defines
+
+#if defined(__powerpc64__) || defined(__PPC64__)
+    #define SK_CPU_PPC64
+#endif
+
+// Newer versions of clang and gcc for ppc64 ship with wrappers that translate
+// Intel vector intrinsics into PPC VSX instrinsics, so we can pretend to have
+// to be Intel. Currently, full API support for SSSE3 on POWER8 and later
+// processors.
+#if defined(__POWER8_VECTOR__) && defined(__has_include) && \
+  !defined(SK_CPU_SSE_LEVEL)
+
+    // Clang ships both Intel and PPC headers in its PPC version, storing the
+    // PPC compatibility in a subdirectory that the compiler will include before
+    // its standard library include directory.
+    #if (__has_include(<tmmintrin.h>) && !defined(__clang__)) || \
+         __has_include(<ppc_wrappers/tmmintrin.h>)
+        #define SK_CPU_SSE_LEVEL    SK_CPU_SSE_LEVEL_SSSE3
+    #elif (__has_include(<emmintrin.h>) && !defined(__clang__)) || \
+           __has_include(<ppc_wrappers/emmintrin.h>)
+        #define SK_CPU_SSE_LEVEL    SK_CPU_SSE_LEVEL_SSE2
+    #endif
+
+    #ifdef SK_CPU_SSE_LEVEL
+        #define SK_PPC64_HAS_SSE_COMPAT
+        #ifndef NO_WARN_X86_INTRINSICS
+            #define NO_WARN_X86_INTRINSICS
+        #endif
+        #if defined(__clang__)
+            #define SK_PPC64_CLANG_MFPPR_BUG
+        #endif
+    #endif
+#endif
+
 
 // DLL/.so exports.
 #if !defined(SKIA_IMPLEMENTATION)
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/include/private/SkVx.h b/qtwebengine/src/3rdparty/chromium/third_party/skia/include/private/SkVx.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/include/private/SkVx.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/include/private/SkVx.h	2025-06-03 10:02:01.000000000 +0800
@@ -30,6 +30,15 @@
     #include <immintrin.h>
 #elif defined(__ARM_NEON)
     #include <arm_neon.h>
+#elif defined(__POWER8_VECTOR__) && defined(__has_include)
+    #if (__has_include(<emmintrin.h>) && !defined(__clang__)) || \
+         __has_include(<ppc_wrappers/emmintrin.h>)
+        #define HAS_PPC64_SSE_COMPAT
+        #ifndef NO_WARN_X86_INTRINSICS
+            #define NO_WARN_X86_INTRINSICS
+        #endif
+        #include <emmintrin.h>
+    #endif
 #elif defined(__wasm_simd128__)
     #include <wasm_simd128.h>
 #endif
@@ -552,7 +561,7 @@
         return unchecked_bit_pun<Vec<N,int>>(_mm256_cvtps_epi32(unchecked_bit_pun<__m256>(x)));
     }
 #endif
-#if defined(__SSE__)
+#if defined(__SSE__) || defined(HAS_PPC64_SSE_COMPAT)
     if /*constexpr*/ (N == 4) {
         return unchecked_bit_pun<Vec<N,int>>(_mm_cvtps_epi32(unchecked_bit_pun<__m128>(x)));
     }
@@ -733,5 +742,6 @@
 #undef SINT
 #undef SIT
 #undef SI
+#undef HAS_PPC64_SSE_COMPAT
 
 #endif//SKVX_DEFINED
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/src/core/SkSpinlock.cpp b/qtwebengine/src/3rdparty/chromium/third_party/skia/src/core/SkSpinlock.cpp
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/src/core/SkSpinlock.cpp	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/src/core/SkSpinlock.cpp	2025-06-03 10:02:01.000000000 +0800
@@ -31,7 +31,8 @@
 #endif
 
 // Renamed from "pause" to avoid conflict with function defined in unistd.h
-#if SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSE2
+#if SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSE2 && \
+    !defined(SK_PPC64_CLANG_MFPPR_BUG)
     #include <emmintrin.h>
     static void do_pause() { _mm_pause(); }
 #else
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkBitmapProcState_opts.h b/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkBitmapProcState_opts.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkBitmapProcState_opts.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkBitmapProcState_opts.h	2025-06-03 10:02:01.000000000 +0800
@@ -21,7 +21,9 @@
 // The rest are scattershot at the moment but I want to get them
 // all migrated to be normal code inside SkBitmapProcState.cpp.
 
-#if SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSE2
+#if defined(SK_PPC64_HAS_SSE_COMPAT)
+    #include <emmintrin.h>
+#elif SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSE2
     #include <immintrin.h>
 #elif defined(SK_ARM_HAS_NEON)
     #include <arm_neon.h>
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkBlitRow_opts.h b/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkBlitRow_opts.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkBlitRow_opts.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkBlitRow_opts.h	2025-06-03 10:02:01.000000000 +0800
@@ -100,7 +100,7 @@
 #endif
 
 #if SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSE2
-    #include <immintrin.h>
+    #include <emmintrin.h>
 
     static inline __m128i SkPMSrcOver_SSE2(const __m128i& src, const __m128i& dst) {
         __m128i scale = _mm_sub_epi32(_mm_set1_epi32(256),
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkRasterPipeline_opts.h b/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkRasterPipeline_opts.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkRasterPipeline_opts.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkRasterPipeline_opts.h	2025-06-03 10:02:01.000000000 +0800
@@ -68,6 +68,8 @@
     #define JUMPER_IS_SCALAR
 #elif defined(SK_ARM_HAS_NEON)
     #define JUMPER_IS_NEON
+#elif defined(SK_PPC64_HAS_SSE_COMPAT)
+    #define JUMPER_IS_VSX
 #elif SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SKX
     #define JUMPER_IS_SKX
 #elif SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_AVX2
@@ -100,6 +102,8 @@
     #include <math.h>
 #elif defined(JUMPER_IS_NEON)
     #include <arm_neon.h>
+#elif defined(JUMPER_IS_VSX)
+    #include <emmintrin.h>
 #else
     #include <immintrin.h>
 #endif
@@ -671,7 +675,8 @@
         }
     }
 
-#elif defined(JUMPER_IS_SSE2) || defined(JUMPER_IS_SSE41)
+#elif defined(JUMPER_IS_SSE2) || defined(JUMPER_IS_SSE41) || \
+  defined(JUMPER_IS_VSX)
     template <typename T> using V = T __attribute__((ext_vector_type(4)));
     using F   = V<float   >;
     using I32 = V< int32_t>;
@@ -712,6 +717,8 @@
     SI F floor_(F v) {
     #if defined(JUMPER_IS_SSE41)
         return _mm_floor_ps(v);
+    #elif defined(JUMPER_IS_VSX)
+        return vec_floor(v);
     #else
         F roundtrip = _mm_cvtepi32_ps(_mm_cvttps_epi32(v));
         return roundtrip - if_then_else(roundtrip > v, 1, 0);
@@ -990,6 +997,12 @@
 #elif defined(JUMPER_IS_HSW) || defined(JUMPER_IS_SKX)
     return _mm256_cvtph_ps(h);
 
+#elif defined(JUMPER_IS_VSX) && __has_builtin(__builtin_vsx_xvcvhpsp)
+    #if defined(SK_CPU_LENDIAN)
+        return __builtin_vsx_xvcvhpsp({h[0], 0, h[1], 0, h[2], 0, h[3], 0});
+    #else
+        return __builtin_vsx_xvcvhpsp({0, h[0], 0, h[1], 0, h[2], 0, h[3]});
+    #endif
 #else
     // Remember, a half is 1-5-10 (sign-exponent-mantissa) with 15 exponent bias.
     U32 sem = expand(h),
@@ -1017,6 +1030,13 @@
 #elif defined(JUMPER_IS_HSW) || defined(JUMPER_IS_SKX)
     return _mm256_cvtps_ph(f, _MM_FROUND_CUR_DIRECTION);
 
+#elif defined(JUMPER_IS_VSX) && __has_builtin(__builtin_vsx_xvcvsphp)
+    __vector unsigned short v = __builtin_vsx_xvcvsphp(f);
+    #if defined(SK_CPU_LENDIAN)
+        return U16{v[0], v[2], v[4], v[6]};
+    #else
+        return U16{v[1], v[3], v[5], v[7]};
+    #endif
 #else
     // Remember, a float is 1-8-23 (sign-exponent-mantissa) with 127 exponent bias.
     U32 sem = sk_bit_cast<U32>(f),
@@ -1055,7 +1075,7 @@
     // instead of {b,a} on the stack.  Narrow stages work best for __vectorcall.
     #define ABI __vectorcall
     #define JUMPER_NARROW_STAGES 1
-#elif defined(__x86_64__) || defined(SK_CPU_ARM64)
+#elif defined(__x86_64__) || defined(SK_CPU_ARM64) || defined(SK_CPU_PPC64)
     // These platforms are ideal for wider stages, and their default ABI is ideal.
     #define ABI
     #define JUMPER_NARROW_STAGES 0
@@ -3170,10 +3190,16 @@
     __m256 lo,hi;
     split(x, &lo,&hi);
     return join<F>(_mm256_floor_ps(lo), _mm256_floor_ps(hi));
-#elif defined(JUMPER_IS_SSE41) || defined(JUMPER_IS_AVX)
+#elif defined(JUMPER_IS_SSE41) || \
+  defined(JUMPER_IS_AVX)
+
     __m128 lo,hi;
     split(x, &lo,&hi);
     return join<F>(_mm_floor_ps(lo), _mm_floor_ps(hi));
+#elif defined(JUMPER_IS_VSX)
+    __m128 lo,hi;
+    split(x, &lo,&hi);
+    return join<F>(vec_floor(lo), vec_floor(hi));
 #else
     F roundtrip = cast<F>(cast<I32>(x));
     return roundtrip - if_then_else(roundtrip > x, F(1), F(0));
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkSwizzler_opts.h b/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkSwizzler_opts.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkSwizzler_opts.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/src/opts/SkSwizzler_opts.h	2025-06-03 10:02:01.000000000 +0800
@@ -12,7 +12,9 @@
 #include "include/private/SkVx.h"
 #include <utility>
 
-#if SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSSE3
+#if defined(SK_PPC64_HAS_SSE_COMPAT)
+    #include <emmintrin.h>
+#elif SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSSE3
     #include <immintrin.h>
 #elif defined(SK_ARM_HAS_NEON)
     #include <arm_neon.h>
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/src/sksl/SkSLString.cpp b/qtwebengine/src/3rdparty/chromium/third_party/skia/src/sksl/SkSLString.cpp
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/src/sksl/SkSLString.cpp	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/src/sksl/SkSLString.cpp	2025-06-03 10:56:35.000000000 +0800
@@ -226,7 +226,12 @@
     if (needsDotZero) {
         buffer << ".0";
     }
-    return String(buffer.str().c_str());
+
+    std::string ret(buffer.str());
+    if (signbit(value) && ret[0] == '.') {
+        ret[0] = '-';
+    }
+    return String(ret.c_str());
 }
 
 SKSL_INT stoi(const String& s) {
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc b/qtwebengine/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc	2025-06-03 10:02:01.000000000 +0800
@@ -30,6 +30,8 @@
         #include <avx512fintrin.h>
         #include <avx512dqintrin.h>
     #endif
+#elif defined(__POWER8_VECTOR__)
+    #include <altivec.h>
 #endif
 
 static bool runtime_cpu_detection = true;
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/skia/third_party/skcms/src/Transform_inl.h b/qtwebengine/src/3rdparty/chromium/third_party/skia/third_party/skcms/src/Transform_inl.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/skia/third_party/skcms/src/Transform_inl.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/skia/third_party/skcms/src/Transform_inl.h	2025-06-03 10:02:01.000000000 +0800
@@ -44,6 +44,9 @@
 #if !defined(USING_AVX512F)  && N == 16 && defined(__AVX512F__)
     #define  USING_AVX512F
 #endif
+#if !defined(USING_VSX)      && defined(__POWER8_VECTOR__)
+    #define  USING_VSX
+#endif
 
 // Similar to the AVX+ features, we define USING_NEON and USING_NEON_F16C.
 // This is more for organizational clarity... skcms.cc doesn't force these.
@@ -161,6 +164,22 @@
 #elif defined(USING_AVX_F16C)
     typedef int16_t __attribute__((vector_size(16))) I16;
     return __builtin_ia32_vcvtph2ps256((I16)half);
+#elif defined(USING_VSX) && __has_builtin(__builtin_vsx_xvcvhpsp)
+    #if defined(__LITTLE_ENDIAN__)
+        return __builtin_vsx_xvcvhpsp({
+            half[0], 0,
+            half[1], 0,
+            half[2], 0,
+            half[3], 0
+        });
+    #else
+        return __builtin_vsx_xvcvhpsp({
+            0, half[0],
+            0, half[1],
+            0, half[2],
+            0, half[3]
+        });
+    #endif
 #else
     U32 wide = cast<U32>(half);
     // A half is 1-5-10 sign-exponent-mantissa, with 15 exponent bias.
@@ -189,6 +208,13 @@
     return (U16)_mm512_cvtps_ph((__m512 )f, _MM_FROUND_CUR_DIRECTION );
 #elif defined(USING_AVX_F16C)
     return (U16)__builtin_ia32_vcvtps2ph256(f, 0x04/*_MM_FROUND_CUR_DIRECTION*/);
+#elif defined(JUMPER_IS_VSX) && __has_builtin(__builtin_vsx_xvcvsphp)
+    __vector unsigned short v = __builtin_vsx_xvcvsphp(f);
+    #if defined(__LITTLE_ENDIAN__)
+        return U16{v[0], v[2], v[4], v[6]};
+    #else
+        return U16{v[1], v[3], v[5], v[7]};
+    #endif
 #else
     // A float is 1-8-23 sign-exponent-mantissa, with 127 exponent bias.
     U32 sem = bit_pun<U32>(f),
@@ -245,6 +271,8 @@
     return __builtin_ia32_roundps256(x, 0x01/*_MM_FROUND_FLOOR*/);
 #elif defined(__SSE4_1__)
     return _mm_floor_ps(x);
+#elif defined(USING_VSX)
+    return vec_floor(x);
 #else
     // Round trip through integers with a truncating cast.
     F roundtrip = cast<F>(cast<I32>(x));
@@ -1543,5 +1571,8 @@
 #if defined(USING_NEON_FP16)
     #undef  USING_NEON_FP16
 #endif
+#if defined(USING_VSX)
+    #undef  USING_VSX
+#endif
 
 #undef FALLTHROUGH
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/amalgamation/sqlite3.c b/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/amalgamation/sqlite3.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/amalgamation/sqlite3.c	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/amalgamation/sqlite3.c	2025-05-30 15:28:03.000000000 +0800
@@ -14467,7 +14467,8 @@
 # if defined(i386)      || defined(__i386__)      || defined(_M_IX86) ||    \
      defined(__x86_64)  || defined(__x86_64__)    || defined(_M_X64)  ||    \
      defined(_M_AMD64)  || defined(_M_ARM)        || defined(__x86)   ||    \
-     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)
+     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64) ||   \
+     defined(__powerpc64__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
 #   define SQLITE_BYTEORDER    1234
 # elif defined(sparc)     || defined(__ppc__) || \
        defined(__ARMEB__) || defined(__AARCH64EB__)
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/amalgamation_dev/sqlite3.c b/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/amalgamation_dev/sqlite3.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/amalgamation_dev/sqlite3.c	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/amalgamation_dev/sqlite3.c	2025-05-30 15:28:03.000000000 +0800
@@ -14480,7 +14480,8 @@
 # if defined(i386)      || defined(__i386__)      || defined(_M_IX86) ||    \
      defined(__x86_64)  || defined(__x86_64__)    || defined(_M_X64)  ||    \
      defined(_M_AMD64)  || defined(_M_ARM)        || defined(__x86)   ||    \
-     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)
+     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64) ||   \
+     defined(__powerpc64__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
 #   define SQLITE_BYTEORDER    1234
 # elif defined(sparc)     || defined(__ppc__) || \
        defined(__ARMEB__) || defined(__AARCH64EB__)
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/ext/rtree/rtree.c b/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/ext/rtree/rtree.c
--- a/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/ext/rtree/rtree.c	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/ext/rtree/rtree.c	2025-05-30 15:28:03.000000000 +0800
@@ -474,7 +474,7 @@
 #if defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \
     defined(__x86_64) || defined(__x86_64__) || defined(_M_X64)  ||    \
     defined(_M_AMD64) || defined(_M_ARM)     || defined(__x86)   ||    \
-    defined(__arm__)
+    defined(__arm__)  || defined(__powerpc64__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
 # define SQLITE_BYTEORDER    1234
 #elif defined(sparc)    || defined(__ppc__)
 # define SQLITE_BYTEORDER    4321
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/src/sqliteInt.h b/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/src/sqliteInt.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/src/sqliteInt.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/sqlite/src/src/sqliteInt.h	2025-05-30 15:28:03.000000000 +0800
@@ -898,7 +898,8 @@
 # if defined(i386)      || defined(__i386__)      || defined(_M_IX86) ||    \
      defined(__x86_64)  || defined(__x86_64__)    || defined(_M_X64)  ||    \
      defined(_M_AMD64)  || defined(_M_ARM)        || defined(__x86)   ||    \
-     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)
+     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64) ||   \
+     defined(__powerpc64__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
 #   define SQLITE_BYTEORDER    1234
 # elif defined(sparc)     || defined(__ppc__) || \
        defined(__ARMEB__) || defined(__AARCH64EB__)
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/swiftshader/src/Reactor/BUILD.gn b/qtwebengine/src/3rdparty/chromium/third_party/swiftshader/src/Reactor/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/third_party/swiftshader/src/Reactor/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/swiftshader/src/Reactor/BUILD.gn	2025-06-05 15:12:00.000000000 +0800
@@ -18,7 +18,7 @@
   # Subzero produces smaller binaries, but doesn't support ARM64, MIPS64, and
   # PPC64.
   use_swiftshader_with_subzero =
-      current_cpu != "arm64" && current_cpu != "mips64el" && current_cpu != "ppc64"
+      current_cpu != "arm64" && current_cpu != "mips64el" && current_cpu != "ppc64" && current_cpu != "ppc64le" 
   supports_llvm = is_linux || is_chromeos || is_fuchsia || is_win || is_android || is_mac
 }
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn b/qtwebengine/src/3rdparty/chromium/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn	2025-06-05 15:13:25.000000000 +0800
@@ -145,7 +145,7 @@
     deps += [ ":swiftshader_llvm_arm" ]
   } else if (current_cpu == "mipsel" || current_cpu == "mips64el") {
     deps += [ ":swiftshader_llvm_mips" ]
-  } else if (current_cpu == "ppc64") {
+  } else if (current_cpu == "ppc64" || current_cpu == "ppc64le" ) {
     deps += [ ":swiftshader_llvm_ppc" ]
   } else if (current_cpu == "x86" || current_cpu == "x64") {
     deps += [ ":swiftshader_llvm_x86" ]
@@ -574,6 +574,7 @@
     "llvm/lib/MC/MCAsmInfoCOFF.cpp",
     "llvm/lib/MC/MCAsmInfoDarwin.cpp",
     "llvm/lib/MC/MCAsmInfoELF.cpp",
+    "llvm/lib/MC/MCAsmInfoXCOFF.cpp",
     "llvm/lib/MC/MCAsmMacro.cpp",
     "llvm/lib/MC/MCAsmStreamer.cpp",
     "llvm/lib/MC/MCAssembler.cpp",
@@ -629,6 +630,7 @@
     "llvm/lib/MC/MCWinCOFFStreamer.cpp",
     "llvm/lib/MC/MCWinEH.cpp",
     "llvm/lib/MC/MCXCOFFStreamer.cpp",
+    "llvm/lib/MC/MCXCOFFObjectTargetWriter.cpp",
     "llvm/lib/MC/MachObjectWriter.cpp",
     "llvm/lib/MC/StringTableBuilder.cpp",
     "llvm/lib/MC/SubtargetFeature.cpp",
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/webrtc/modules/desktop_capture/differ_block.cc b/qtwebengine/src/3rdparty/chromium/third_party/webrtc/modules/desktop_capture/differ_block.cc
--- a/qtwebengine/src/3rdparty/chromium/third_party/webrtc/modules/desktop_capture/differ_block.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/webrtc/modules/desktop_capture/differ_block.cc	2025-05-30 15:28:03.000000000 +0800
@@ -30,11 +30,7 @@
   static bool (*diff_proc)(const uint8_t*, const uint8_t*) = nullptr;
 
   if (!diff_proc) {
-#if defined(WEBRTC_ARCH_ARM_FAMILY) || defined(WEBRTC_ARCH_MIPS_FAMILY)
-    // For ARM and MIPS processors, always use C version.
-    // TODO(hclam): Implement a NEON version.
-    diff_proc = &VectorDifference_C;
-#else
+#if defined(WEBRTC_ARCH_X86_FAMILY)
     bool have_sse2 = GetCPUInfo(kSSE2) != 0;
     // For x86 processors, check if SSE2 is supported.
     if (have_sse2 && kBlockSize == 32) {
@@ -44,6 +40,10 @@
     } else {
       diff_proc = &VectorDifference_C;
     }
+#else
+    // For other processors, always use C version.
+    // TODO(hclam): Implement a NEON version.
+    diff_proc = &VectorDifference_C;
 #endif
   }
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/third_party/webrtc/rtc_base/system/arch.h b/qtwebengine/src/3rdparty/chromium/third_party/webrtc/rtc_base/system/arch.h
--- a/qtwebengine/src/3rdparty/chromium/third_party/webrtc/rtc_base/system/arch.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/third_party/webrtc/rtc_base/system/arch.h	2025-06-03 14:19:56.000000000 +0800
@@ -50,6 +50,18 @@
 #elif defined(__EMSCRIPTEN__)
 #define WEBRTC_ARCH_32_BITS
 #define WEBRTC_ARCH_LITTLE_ENDIAN
+#elif defined(__PPC__)
+#define WEBRTC_ARCH_PPC_FAMILY
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+#define WEBRTC_ARCH_LITTLE_ENDIAN
+#else
+#define WEBRTC_ARCH_BIG_ENDIAN
+#endif
+#if defined(__LP64__)
+#define WEBRTC_ARCH_64_BITS
+#else
+#define WEBRTC_ARCH_32_BITS
+#endif
 #else
 #error Please add support for your architecture in rtc_base/system/arch.h
 #endif
diff -Naur a/qtwebengine/src/3rdparty/chromium/tools/md_browser/base.css b/qtwebengine/src/3rdparty/chromium/tools/md_browser/base.css
--- a/qtwebengine/src/3rdparty/chromium/tools/md_browser/base.css	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/tools/md_browser/base.css	2025-06-03 10:48:24.000000000 +0800
@@ -16,8 +16,7 @@
 
 /* Common styles and definitions. */
 
-@import "//fonts.googleapis.com/css?family=Open+Sans:300,400,700&subset=latin,cyrillic-ext,greek-ext,cyrillic,greek,vietnamese,latin-ext";
-@import "//fonts.googleapis.com/css?family=Source+Code+Pro";
+@import "chrome://resources/css/roboto.css";
 *,
 *::after,
 *::before {
@@ -72,7 +71,7 @@
   user-select: none;
 }
 .u-monospace {
-  font-family: 'Source Code Pro', monospace;
+  font-family: monospace;
 }
 
 /* Common.soy */
@@ -82,7 +81,7 @@
   color: #000;
   display: -ms-flexbox;
   display: flex;
-  font: 14px/1.54 'Open Sans', sans-serif;
+  font: 14px/1.54 'Roboto', sans-serif;
   min-height: 100vh;
   -ms-flex-direction: column;
   flex-direction: column;
diff -Naur a/qtwebengine/src/3rdparty/chromium/tools/metrics/histograms/enums.xml b/qtwebengine/src/3rdparty/chromium/tools/metrics/histograms/enums.xml
--- a/qtwebengine/src/3rdparty/chromium/tools/metrics/histograms/enums.xml	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/tools/metrics/histograms/enums.xml	2025-06-03 09:58:08.000000000 +0800
@@ -71860,7 +71860,6 @@
   <int value="3" label="kRestoreOnStartup"/>
   <int value="4" label="kURLsToRestoreOnStartup"/>
   <int value="5" label="extensions::pref_names::kExtensions"/>
-  <int value="6" label="kGoogleServicesLastUsername"/>
   <int value="7" label="kSearchProviderOverrides"/>
   <int value="8" label="kDefaultSearchProviderSearchURL (Obsolete 12/2016)"/>
   <int value="9" label="kDefaultSearchProviderKeyword (Obsolete 12/2016)"/>
@@ -71875,10 +71874,7 @@
   <int value="18" label="kSafeBrowsingIncidentsSent"/>
   <int value="19" label="kSwReporterPromptVersion"/>
   <int value="20" label="kSwReporterPromptReason"/>
-  <int value="21" label="kGoogleServicesUsername (Obsolete 9/2019)"/>
   <int value="22" label="kSwReporterPromptSeed"/>
-  <int value="23" label="kGoogleServicesAccountId"/>
-  <int value="24" label="kGoogleServicesLastAccountId"/>
   <int value="25" label="kSettingsResetPromptPromptWave"/>
   <int value="26" label="kSettingsResetPromptLastTriggeredForDefaultSearch"/>
   <int value="27" label="kSettingsResetPromptLastTriggeredForStartupUrls"/>
diff -Naur a/qtwebengine/src/3rdparty/chromium/ui/accessibility/extensions/chromevoxclassic/chromevox/background/prefs.js b/qtwebengine/src/3rdparty/chromium/ui/accessibility/extensions/chromevoxclassic/chromevox/background/prefs.js
--- a/qtwebengine/src/3rdparty/chromium/ui/accessibility/extensions/chromevoxclassic/chromevox/background/prefs.js	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/ui/accessibility/extensions/chromevoxclassic/chromevox/background/prefs.js	2025-06-03 10:27:05.000000000 +0800
@@ -72,9 +72,9 @@
   'outputContextFirst': false,
   'position': '{}',
   'siteSpecificScriptBase':
-      'https://ssl.gstatic.com/accessibility/javascript/ext/',
+      'trk:242:https://ssl.gstatic.com/accessibility/javascript/ext/',
   'siteSpecificScriptLoader':
-      'https://ssl.gstatic.com/accessibility/javascript/ext/loader.js',
+      'trk:243:https://ssl.gstatic.com/accessibility/javascript/ext/loader.js',
   'sticky': false,
   'typingEcho': 0,
   'useIBeamCursor': cvox.ChromeVox.isMac,
diff -Naur a/qtwebengine/src/3rdparty/chromium/ui/accessibility/extensions/chromevoxclassic/host/chrome/host.js b/qtwebengine/src/3rdparty/chromium/ui/accessibility/extensions/chromevoxclassic/host/chrome/host.js
--- a/qtwebengine/src/3rdparty/chromium/ui/accessibility/extensions/chromevoxclassic/host/chrome/host.js	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/ui/accessibility/extensions/chromevoxclassic/host/chrome/host.js	2025-06-03 10:27:05.000000000 +0800
@@ -96,9 +96,9 @@
           (!cvox.ApiImplementation.siteSpecificScriptLoader ||
            !cvox.ApiImplementation.siteSpecificScriptBase);
       cvox.ApiImplementation.siteSpecificScriptLoader =
-          'https://ssl.gstatic.com/accessibility/javascript/ext/loader.js';
+          'trk:244:https://ssl.gstatic.com/accessibility/javascript/ext/loader.js';
       cvox.ApiImplementation.siteSpecificScriptBase =
-          'https://ssl.gstatic.com/accessibility/javascript/ext/';
+          'trk:245:https://ssl.gstatic.com/accessibility/javascript/ext/';
       if (apiPrefsChanged) {
         var searchInit = prefs['siteSpecificEnhancements'] === 'true' ?
             cvox.SearchLoader.init :
diff -Naur a/qtwebengine/src/3rdparty/chromium/ui/views/examples/webview_example.cc b/qtwebengine/src/3rdparty/chromium/ui/views/examples/webview_example.cc
--- a/qtwebengine/src/3rdparty/chromium/ui/views/examples/webview_example.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/ui/views/examples/webview_example.cc	2025-06-03 10:27:05.000000000 +0800
@@ -29,7 +29,7 @@
   webview_->GetWebContents()->SetDelegate(this);
   container->SetLayoutManager(std::make_unique<FillLayout>());
 
-  webview_->LoadInitialURL(GURL("http://www.google.com/"));
+  webview_->LoadInitialURL(GURL("trk:174:http://www.google.com/"));
   webview_->GetWebContents()->Focus();
 }
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/url/url_constants.cc b/qtwebengine/src/3rdparty/chromium/url/url_constants.cc
--- a/qtwebengine/src/3rdparty/chromium/url/url_constants.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/url/url_constants.cc	2025-06-03 10:48:03.000000000 +0800
@@ -28,6 +28,7 @@
 // See also: https://www.iana.org/assignments/uri-schemes/prov/quic-transport
 const char kQuicTransportScheme[] = "quic-transport";
 const char kTelScheme[] = "tel";
+const char kTraceScheme[] = "trk";
 const char kWsScheme[] = "ws";
 const char kWssScheme[] = "wss";
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/url/url_constants.h b/qtwebengine/src/3rdparty/chromium/url/url_constants.h
--- a/qtwebengine/src/3rdparty/chromium/url/url_constants.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/url/url_constants.h	2025-06-03 10:48:03.000000000 +0800
@@ -32,6 +32,7 @@
 COMPONENT_EXPORT(URL) extern const char kMailToScheme[];
 COMPONENT_EXPORT(URL) extern const char kQuicTransportScheme[];
 COMPONENT_EXPORT(URL) extern const char kTelScheme[];
+COMPONENT_EXPORT(URL) extern const char kTraceScheme[];
 COMPONENT_EXPORT(URL) extern const char kWsScheme[];
 COMPONENT_EXPORT(URL) extern const char kWssScheme[];
 
diff -Naur a/qtwebengine/src/3rdparty/chromium/url/url_util.cc b/qtwebengine/src/3rdparty/chromium/url/url_util.cc
--- a/qtwebengine/src/3rdparty/chromium/url/url_util.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/url/url_util.cc	2025-06-03 10:48:03.000000000 +0800
@@ -63,7 +63,7 @@
 
   // Schemes that do not trigger mixed content warning.
   std::vector<std::string> secure_schemes = {
-      kHttpsScheme, kAboutScheme, kDataScheme, kQuicTransportScheme, kWssScheme,
+      kHttpsScheme, kAboutScheme, kDataScheme, kTraceScheme, kQuicTransportScheme, kWssScheme,
   };
 
   // Schemes that normal pages cannot link to or access (i.e., with the same
@@ -78,6 +78,7 @@
       kAboutScheme,
       kJavaScriptScheme,
       kDataScheme,
+      kTraceScheme,
   };
 
   // Schemes that can be sent CORS requests.
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/BUILD.gn b/qtwebengine/src/3rdparty/chromium/v8/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/v8/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/BUILD.gn	2025-06-05 15:15:00.000000000 +0800
@@ -193,7 +193,7 @@
 
   v8_enable_gdbjit = ((v8_current_cpu == "x86" || v8_current_cpu == "x64") &&
                       (is_linux || is_chromeos || is_mac)) ||
-                     (v8_current_cpu == "ppc64" && (is_linux || is_chromeos))
+                     (v8_current_cpu == "ppc64" || v8_current_cpu == "ppc64le"&& (is_linux || is_chromeos))
 
   # Temporary flag to allow embedders to update their microtasks scopes
   # while rolling in a new version of V8.
@@ -794,15 +794,25 @@
       cflags += [ "-march=z196" ]
     }
   }
-  if (v8_current_cpu == "ppc" || v8_current_cpu == "ppc64") {
+  if (v8_current_cpu == "ppc" || v8_current_cpu == "ppc64" || v8_current_cpu == "ppc64le") {
     if (v8_current_cpu == "ppc") {
       defines += [ "V8_TARGET_ARCH_PPC" ]
     } else if (v8_current_cpu == "ppc64") {
       defines += [ "V8_TARGET_ARCH_PPC64" ]
+    } else if (v8_current_cpu == "ppc64le") {
+      defines += [ "V8_TARGET_ARCH_PPC64" ]
     }
     if (host_byteorder == "little") {
+      defines += [ "V8_TARGET_ARCH_PPC64_LE" ]
       defines += [ "V8_TARGET_ARCH_PPC_LE" ]
+        cflags += [
+        # Enable usage of AltiVec, VSX, and other POWER8 and higher features
+        "-mcpu=power9",
+        "-maltivec",
+        "-mvsx",
+      ]
     } else if (host_byteorder == "big") {
+      defines += [ "V8_TARGET_ARCH_PPC64_BE" ]
       defines += [ "V8_TARGET_ARCH_PPC_BE" ]
       if (current_os == "aix") {
         cflags += [
@@ -1878,7 +1888,7 @@
       ### gcmole(arch:ppc) ###
       "src/builtins/ppc/builtins-ppc.cc",
     ]
-  } else if (v8_current_cpu == "ppc64") {
+  } else if (v8_current_cpu == "ppc64" || v8_current_cpu == "ppc64le") {
     sources += [
       ### gcmole(arch:ppc64) ###
       "src/builtins/ppc/builtins-ppc.cc",
@@ -3702,7 +3712,7 @@
       "src/regexp/ppc/regexp-macro-assembler-ppc.h",
       "src/wasm/baseline/ppc/liftoff-assembler-ppc.h",
     ]
-  } else if (v8_current_cpu == "ppc64") {
+  } else if (v8_current_cpu == "ppc64" || v8_current_cpu == "ppc64le" ) {
     sources += [  ### gcmole(arch:ppc64) ###
       "src/codegen/ppc/assembler-ppc-inl.h",
       "src/codegen/ppc/assembler-ppc.cc",
@@ -3861,7 +3871,7 @@
   # to implement atomic memory access
   if (v8_current_cpu == "mips" || v8_current_cpu == "mipsel" ||
       v8_current_cpu == "mips64" || v8_current_cpu == "mips64el" ||
-      v8_current_cpu == "ppc" || v8_current_cpu == "ppc64" ||
+      v8_current_cpu == "ppc" || v8_current_cpu == "ppc64" ||  v8_current_cpu == "ppc64le" ||
       v8_current_cpu == "s390" || v8_current_cpu == "s390x") {
     libs += [ "atomic" ]
   }
@@ -4320,7 +4330,7 @@
       sources += [ "src/heap/base/asm/arm/push_registers_asm.cc" ]
     } else if (current_cpu == "arm64") {
       sources += [ "src/heap/base/asm/arm64/push_registers_asm.cc" ]
-    } else if (current_cpu == "ppc64") {
+    } else if (current_cpu == "ppc64" || current_cpu == "ppc64le") {
       sources += [ "src/heap/base/asm/ppc/push_registers_asm.cc" ]
     } else if (current_cpu == "s390x") {
       sources += [ "src/heap/base/asm/s390/push_registers_asm.cc" ]
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/base/build_config.h b/qtwebengine/src/3rdparty/chromium/v8/src/base/build_config.h
--- a/qtwebengine/src/3rdparty/chromium/v8/src/base/build_config.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/base/build_config.h	2025-06-03 15:00:30.000000000 +0800
@@ -35,6 +35,7 @@
 #define V8_HOST_ARCH_32_BIT 1
 #elif defined(__PPC64__) || defined(_ARCH_PPC64)
 #define V8_HOST_ARCH_PPC64 1
+#define V8_HOST_ARCH_PPC64_LE 1
 #define V8_HOST_ARCH_64_BIT 1
 #elif defined(__PPC__) || defined(_ARCH_PPC)
 #define V8_HOST_ARCH_PPC 1
@@ -180,6 +181,8 @@
 #endif
 #elif __BIG_ENDIAN__  // FOR PPCGR on AIX
 #define V8_TARGET_BIG_ENDIAN 1
+#elif V8_TARGET_ARCH_PPC64_LE
+#define V8_TARGET_LITTLE_ENDIAN 1
 #elif V8_TARGET_ARCH_PPC_LE
 #define V8_TARGET_LITTLE_ENDIAN 1
 #elif V8_TARGET_ARCH_PPC_BE
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/assembler-ppc.cc b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/assembler-ppc.cc
--- a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/assembler-ppc.cc	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/assembler-ppc.cc	2025-06-04 10:11:01.000000000 +0800
@@ -0,0 +1,1995 @@
+// Copyright (c) 1994-2006 Sun Microsystems Inc.
+// All Rights Reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+//
+// - Redistributions of source code must retain the above copyright notice,
+// this list of conditions and the following disclaimer.
+//
+// - Redistribution in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the
+// distribution.
+//
+// - Neither the name of Sun Microsystems or the names of contributors may
+// be used to endorse or promote products derived from this software without
+// specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+// OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// The original source code covered by the above license above has been
+// modified significantly by Google Inc.
+// Copyright 2014 the V8 project authors. All rights reserved.
+
+#include "src/codegen/ppc/assembler-ppc.h"
+
+#if V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
+
+#include "src/base/bits.h"
+#include "src/base/cpu.h"
+#include "src/codegen/macro-assembler.h"
+#include "src/codegen/ppc/assembler-ppc-inl.h"
+#include "src/codegen/string-constants.h"
+#include "src/deoptimizer/deoptimizer.h"
+
+namespace v8 {
+namespace internal {
+
+// Get the CPU features enabled by the build.
+static unsigned CpuFeaturesImpliedByCompiler() {
+  unsigned answer = 0;
+  return answer;
+}
+
+void CpuFeatures::ProbeImpl(bool cross_compile) {
+  supported_ |= CpuFeaturesImpliedByCompiler();
+  icache_line_size_ = 128;
+
+  // Only use statically determined features for cross compile (snapshot).
+  if (cross_compile) return;
+
+// Detect whether frim instruction is supported (POWER5+)
+// For now we will just check for processors we know do not
+// support it
+#ifndef USE_SIMULATOR
+  // Probe for additional features at runtime.
+  base::CPU cpu;
+  if (cpu.part() == base::CPU::PPC_POWER9) {
+    supported_ |= (1u << MODULO);
+  }
+#if V8_TARGET_ARCH_PPC64
+  if (cpu.part() == base::CPU::PPC_POWER8) {
+    supported_ |= (1u << FPR_GPR_MOV);
+  }
+#endif
+  if (cpu.part() == base::CPU::PPC_POWER6 ||
+      cpu.part() == base::CPU::PPC_POWER7 ||
+      cpu.part() == base::CPU::PPC_POWER8) {
+    supported_ |= (1u << LWSYNC);
+  }
+  if (cpu.part() == base::CPU::PPC_POWER7 ||
+      cpu.part() == base::CPU::PPC_POWER8) {
+    supported_ |= (1u << ISELECT);
+    supported_ |= (1u << VSX);
+  }
+#if V8_OS_LINUX
+  if (!(cpu.part() == base::CPU::PPC_G5 || cpu.part() == base::CPU::PPC_G4)) {
+    // Assume support
+    supported_ |= (1u << FPU);
+  }
+  if (cpu.icache_line_size() != base::CPU::UNKNOWN_CACHE_LINE_SIZE) {
+    icache_line_size_ = cpu.icache_line_size();
+  }
+#elif V8_OS_AIX
+  // Assume support FP support and default cache line size
+  supported_ |= (1u << FPU);
+#endif
+#else  // Simulator
+  supported_ |= (1u << FPU);
+  supported_ |= (1u << LWSYNC);
+  supported_ |= (1u << ISELECT);
+  supported_ |= (1u << VSX);
+  supported_ |= (1u << MODULO);
+#if V8_TARGET_ARCH_PPC64
+  supported_ |= (1u << FPR_GPR_MOV);
+#endif
+#endif
+}
+
+void CpuFeatures::PrintTarget() {
+  const char* ppc_arch = nullptr;
+
+#if V8_TARGET_ARCH_PPC64
+  ppc_arch = "ppc64";
+#else
+  ppc_arch = "ppc";
+#endif
+
+  printf("target %s\n", ppc_arch);
+}
+
+void CpuFeatures::PrintFeatures() {
+  printf("FPU=%d\n", CpuFeatures::IsSupported(FPU));
+  printf("FPR_GPR_MOV=%d\n", CpuFeatures::IsSupported(FPR_GPR_MOV));
+  printf("LWSYNC=%d\n", CpuFeatures::IsSupported(LWSYNC));
+  printf("ISELECT=%d\n", CpuFeatures::IsSupported(ISELECT));
+  printf("VSX=%d\n", CpuFeatures::IsSupported(VSX));
+  printf("MODULO=%d\n", CpuFeatures::IsSupported(MODULO));
+}
+
+Register ToRegister(int num) {
+  DCHECK(num >= 0 && num < kNumRegisters);
+  const Register kRegisters[] = {r0,  sp,  r2,  r3,  r4,  r5,  r6,  r7,
+                                 r8,  r9,  r10, r11, ip,  r13, r14, r15,
+                                 r16, r17, r18, r19, r20, r21, r22, r23,
+                                 r24, r25, r26, r27, r28, r29, r30, fp};
+  return kRegisters[num];
+}
+
+// -----------------------------------------------------------------------------
+// Implementation of RelocInfo
+
+const int RelocInfo::kApplyMask =
+    RelocInfo::ModeMask(RelocInfo::INTERNAL_REFERENCE) |
+    RelocInfo::ModeMask(RelocInfo::INTERNAL_REFERENCE_ENCODED);
+
+bool RelocInfo::IsCodedSpecially() {
+  // The deserializer needs to know whether a pointer is specially
+  // coded.  Being specially coded on PPC means that it is a lis/ori
+  // instruction sequence or is a constant pool entry, and these are
+  // always the case inside code objects.
+  return true;
+}
+
+bool RelocInfo::IsInConstantPool() {
+  if (FLAG_enable_embedded_constant_pool && constant_pool_ != kNullAddress) {
+    return Assembler::IsConstantPoolLoadStart(pc_);
+  }
+  return false;
+}
+
+uint32_t RelocInfo::wasm_call_tag() const {
+  DCHECK(rmode_ == WASM_CALL || rmode_ == WASM_STUB_CALL);
+  return static_cast<uint32_t>(
+      Assembler::target_address_at(pc_, constant_pool_));
+}
+
+// -----------------------------------------------------------------------------
+// Implementation of Operand and MemOperand
+// See assembler-ppc-inl.h for inlined constructors
+
+Operand::Operand(Handle<HeapObject> handle) {
+  rm_ = no_reg;
+  value_.immediate = static_cast<intptr_t>(handle.address());
+  rmode_ = RelocInfo::FULL_EMBEDDED_OBJECT;
+}
+
+Operand Operand::EmbeddedNumber(double value) {
+  int32_t smi;
+  if (DoubleToSmiInteger(value, &smi)) return Operand(Smi::FromInt(smi));
+  Operand result(0, RelocInfo::FULL_EMBEDDED_OBJECT);
+  result.is_heap_object_request_ = true;
+  result.value_.heap_object_request = HeapObjectRequest(value);
+  return result;
+}
+
+Operand Operand::EmbeddedStringConstant(const StringConstantBase* str) {
+  Operand result(0, RelocInfo::FULL_EMBEDDED_OBJECT);
+  result.is_heap_object_request_ = true;
+  result.value_.heap_object_request = HeapObjectRequest(str);
+  return result;
+}
+
+MemOperand::MemOperand(Register rn, int32_t offset)
+    : ra_(rn), offset_(offset), rb_(no_reg) {}
+
+MemOperand::MemOperand(Register ra, Register rb)
+    : ra_(ra), offset_(0), rb_(rb) {}
+
+void Assembler::AllocateAndInstallRequestedHeapObjects(Isolate* isolate) {
+  DCHECK_IMPLIES(isolate == nullptr, heap_object_requests_.empty());
+  for (auto& request : heap_object_requests_) {
+    Handle<HeapObject> object;
+    switch (request.kind()) {
+      case HeapObjectRequest::kHeapNumber: {
+        object = isolate->factory()->NewHeapNumber<AllocationType::kOld>(
+            request.heap_number());
+        break;
+      }
+      case HeapObjectRequest::kStringConstant: {
+        const StringConstantBase* str = request.string();
+        CHECK_NOT_NULL(str);
+        object = str->AllocateStringConstant(isolate);
+        break;
+      }
+    }
+    Address pc = reinterpret_cast<Address>(buffer_start_) + request.offset();
+    Address constant_pool = kNullAddress;
+    set_target_address_at(pc, constant_pool, object.address(),
+                          SKIP_ICACHE_FLUSH);
+  }
+}
+
+// -----------------------------------------------------------------------------
+// Specific instructions, constants, and masks.
+
+Assembler::Assembler(const AssemblerOptions& options,
+                     std::unique_ptr<AssemblerBuffer> buffer)
+    : AssemblerBase(options, std::move(buffer)),
+      scratch_register_list_(ip.bit()),
+      constant_pool_builder_(kLoadPtrMaxReachBits, kLoadDoubleMaxReachBits) {
+  reloc_info_writer.Reposition(buffer_start_ + buffer_->size(), pc_);
+
+  no_trampoline_pool_before_ = 0;
+  trampoline_pool_blocked_nesting_ = 0;
+  constant_pool_entry_sharing_blocked_nesting_ = 0;
+  next_trampoline_check_ = kMaxInt;
+  internal_trampoline_exception_ = false;
+  last_bound_pos_ = 0;
+  optimizable_cmpi_pos_ = -1;
+  trampoline_emitted_ = FLAG_force_long_branches;
+  tracked_branch_count_ = 0;
+  relocations_.reserve(128);
+}
+
+void Assembler::GetCode(Isolate* isolate, CodeDesc* desc,
+                        SafepointTableBuilder* safepoint_table_builder,
+                        int handler_table_offset) {
+  // Emit constant pool if necessary.
+  int constant_pool_size = EmitConstantPool();
+
+  EmitRelocations();
+
+  int code_comments_size = WriteCodeComments();
+
+  AllocateAndInstallRequestedHeapObjects(isolate);
+
+  // Set up code descriptor.
+  // TODO(jgruber): Reconsider how these offsets and sizes are maintained up to
+  // this point to make CodeDesc initialization less fiddly.
+
+  const int instruction_size = pc_offset();
+  const int code_comments_offset = instruction_size - code_comments_size;
+  const int constant_pool_offset = code_comments_offset - constant_pool_size;
+  const int handler_table_offset2 = (handler_table_offset == kNoHandlerTable)
+                                        ? constant_pool_offset
+                                        : handler_table_offset;
+  const int safepoint_table_offset =
+      (safepoint_table_builder == kNoSafepointTable)
+          ? handler_table_offset2
+          : safepoint_table_builder->GetCodeOffset();
+  const int reloc_info_offset =
+      static_cast<int>(reloc_info_writer.pos() - buffer_->start());
+  CodeDesc::Initialize(desc, this, safepoint_table_offset,
+                       handler_table_offset2, constant_pool_offset,
+                       code_comments_offset, reloc_info_offset);
+}
+
+void Assembler::Align(int m) {
+  DCHECK(m >= 4 && base::bits::IsPowerOfTwo(m));
+  DCHECK_EQ(pc_offset() & (kInstrSize - 1), 0);
+  while ((pc_offset() & (m - 1)) != 0) {
+    nop();
+  }
+}
+
+void Assembler::CodeTargetAlign() { Align(8); }
+
+Condition Assembler::GetCondition(Instr instr) {
+  switch (instr & kCondMask) {
+    case BT:
+      return eq;
+    case BF:
+      return ne;
+    default:
+      UNIMPLEMENTED();
+  }
+  return al;
+}
+
+bool Assembler::IsLis(Instr instr) {
+  return ((instr & kOpcodeMask) == ADDIS) && GetRA(instr) == r0;
+}
+
+bool Assembler::IsLi(Instr instr) {
+  return ((instr & kOpcodeMask) == ADDI) && GetRA(instr) == r0;
+}
+
+bool Assembler::IsAddic(Instr instr) { return (instr & kOpcodeMask) == ADDIC; }
+
+bool Assembler::IsOri(Instr instr) { return (instr & kOpcodeMask) == ORI; }
+
+bool Assembler::IsBranch(Instr instr) { return ((instr & kOpcodeMask) == BCX); }
+
+Register Assembler::GetRA(Instr instr) {
+  return Register::from_code(Instruction::RAValue(instr));
+}
+
+Register Assembler::GetRB(Instr instr) {
+  return Register::from_code(Instruction::RBValue(instr));
+}
+
+#if V8_TARGET_ARCH_PPC64
+// This code assumes a FIXED_SEQUENCE for 64bit loads (lis/ori)
+bool Assembler::Is64BitLoadIntoR12(Instr instr1, Instr instr2, Instr instr3,
+                                   Instr instr4, Instr instr5) {
+  // Check the instructions are indeed a five part load (into r12)
+  // 3d800000       lis     r12, 0
+  // 618c0000       ori     r12, r12, 0
+  // 798c07c6       rldicr  r12, r12, 32, 31
+  // 658c00c3       oris    r12, r12, 195
+  // 618ccd40       ori     r12, r12, 52544
+  return (((instr1 >> 16) == 0x3D80) && ((instr2 >> 16) == 0x618C) &&
+          (instr3 == 0x798C07C6) && ((instr4 >> 16) == 0x658C) &&
+          ((instr5 >> 16) == 0x618C));
+}
+#else
+// This code assumes a FIXED_SEQUENCE for 32bit loads (lis/ori)
+bool Assembler::Is32BitLoadIntoR12(Instr instr1, Instr instr2) {
+  // Check the instruction is indeed a two part load (into r12)
+  // 3d802553       lis     r12, 9555
+  // 618c5000       ori   r12, r12, 20480
+  return (((instr1 >> 16) == 0x3D80) && ((instr2 >> 16) == 0x618C));
+}
+#endif
+
+bool Assembler::IsCmpRegister(Instr instr) {
+  return (((instr & kOpcodeMask) == EXT2) &&
+          ((EXT2 | (instr & kExt2OpcodeMask)) == CMP));
+}
+
+bool Assembler::IsRlwinm(Instr instr) {
+  return ((instr & kOpcodeMask) == RLWINMX);
+}
+
+bool Assembler::IsAndi(Instr instr) { return ((instr & kOpcodeMask) == ANDIx); }
+
+#if V8_TARGET_ARCH_PPC64
+bool Assembler::IsRldicl(Instr instr) {
+  return (((instr & kOpcodeMask) == EXT5) &&
+          ((EXT5 | (instr & kExt5OpcodeMask)) == RLDICL));
+}
+#endif
+
+bool Assembler::IsCmpImmediate(Instr instr) {
+  return ((instr & kOpcodeMask) == CMPI);
+}
+
+bool Assembler::IsCrSet(Instr instr) {
+  return (((instr & kOpcodeMask) == EXT1) &&
+          ((EXT1 | (instr & kExt1OpcodeMask)) == CREQV));
+}
+
+Register Assembler::GetCmpImmediateRegister(Instr instr) {
+  DCHECK(IsCmpImmediate(instr));
+  return GetRA(instr);
+}
+
+int Assembler::GetCmpImmediateRawImmediate(Instr instr) {
+  DCHECK(IsCmpImmediate(instr));
+  return instr & kOff16Mask;
+}
+
+// Labels refer to positions in the (to be) generated code.
+// There are bound, linked, and unused labels.
+//
+// Bound labels refer to known positions in the already
+// generated code. pos() is the position the label refers to.
+//
+// Linked labels refer to unknown positions in the code
+// to be generated; pos() is the position of the last
+// instruction using the label.
+
+// The link chain is terminated by a negative code position (must be aligned)
+const int kEndOfChain = -4;
+
+// Dummy opcodes for unbound label mov instructions or jump table entries.
+enum {
+  kUnboundMovLabelOffsetOpcode = 0 << 26,
+  kUnboundAddLabelOffsetOpcode = 1 << 26,
+  kUnboundAddLabelLongOffsetOpcode = 2 << 26,
+  kUnboundMovLabelAddrOpcode = 3 << 26,
+  kUnboundJumpTableEntryOpcode = 4 << 26
+};
+
+int Assembler::target_at(int pos) {
+  Instr instr = instr_at(pos);
+  // check which type of branch this is 16 or 26 bit offset
+  uint32_t opcode = instr & kOpcodeMask;
+  int link;
+  switch (opcode) {
+    case BX:
+      link = SIGN_EXT_IMM26(instr & kImm26Mask);
+      link &= ~(kAAMask | kLKMask);  // discard AA|LK bits if present
+      break;
+    case BCX:
+      link = SIGN_EXT_IMM16((instr & kImm16Mask));
+      link &= ~(kAAMask | kLKMask);  // discard AA|LK bits if present
+      break;
+    case kUnboundMovLabelOffsetOpcode:
+    case kUnboundAddLabelOffsetOpcode:
+    case kUnboundAddLabelLongOffsetOpcode:
+    case kUnboundMovLabelAddrOpcode:
+    case kUnboundJumpTableEntryOpcode:
+      link = SIGN_EXT_IMM26(instr & kImm26Mask);
+      link <<= 2;
+      break;
+    default:
+      DCHECK(false);
+      return -1;
+  }
+
+  if (link == 0) return kEndOfChain;
+  return pos + link;
+}
+
+void Assembler::target_at_put(int pos, int target_pos, bool* is_branch) {
+  Instr instr = instr_at(pos);
+  uint32_t opcode = instr & kOpcodeMask;
+
+  if (is_branch != nullptr) {
+    *is_branch = (opcode == BX || opcode == BCX);
+  }
+
+  switch (opcode) {
+    case BX: {
+      int imm26 = target_pos - pos;
+      CHECK(is_int26(imm26) && (imm26 & (kAAMask | kLKMask)) == 0);
+      if (imm26 == kInstrSize && !(instr & kLKMask)) {
+        // Branch to next instr without link.
+        instr = ORI;  // nop: ori, 0,0,0
+      } else {
+        instr &= ((~kImm26Mask) | kAAMask | kLKMask);
+        instr |= (imm26 & kImm26Mask);
+      }
+      instr_at_put(pos, instr);
+      break;
+    }
+    case BCX: {
+      int imm16 = target_pos - pos;
+      CHECK(is_int16(imm16) && (imm16 & (kAAMask | kLKMask)) == 0);
+      if (imm16 == kInstrSize && !(instr & kLKMask)) {
+        // Branch to next instr without link.
+        instr = ORI;  // nop: ori, 0,0,0
+      } else {
+        instr &= ((~kImm16Mask) | kAAMask | kLKMask);
+        instr |= (imm16 & kImm16Mask);
+      }
+      instr_at_put(pos, instr);
+      break;
+    }
+    case kUnboundMovLabelOffsetOpcode: {
+      // Load the position of the label relative to the generated code object
+      // pointer in a register.
+      Register dst = Register::from_code(instr_at(pos + kInstrSize));
+      int32_t offset = target_pos + (Code::kHeaderSize - kHeapObjectTag);
+      PatchingAssembler patcher(
+          options(), reinterpret_cast<byte*>(buffer_start_ + pos), 2);
+      patcher.bitwise_mov32(dst, offset);
+      break;
+    }
+    case kUnboundAddLabelLongOffsetOpcode:
+    case kUnboundAddLabelOffsetOpcode: {
+      // dst = base + position + immediate
+      Instr operands = instr_at(pos + kInstrSize);
+      Register dst = Register::from_code((operands >> 27) & 0x1F);
+      Register base = Register::from_code((operands >> 22) & 0x1F);
+      int32_t delta = (opcode == kUnboundAddLabelLongOffsetOpcode)
+                          ? static_cast<int32_t>(instr_at(pos + 2 * kInstrSize))
+                          : (SIGN_EXT_IMM22(operands & kImm22Mask));
+      int32_t offset = target_pos + delta;
+      PatchingAssembler patcher(
+          options(), reinterpret_cast<byte*>(buffer_start_ + pos),
+          2 + static_cast<int32_t>(opcode == kUnboundAddLabelLongOffsetOpcode));
+      patcher.bitwise_add32(dst, base, offset);
+      if (opcode == kUnboundAddLabelLongOffsetOpcode) patcher.nop();
+      break;
+    }
+    case kUnboundMovLabelAddrOpcode: {
+      // Load the address of the label in a register.
+      Register dst = Register::from_code(instr_at(pos + kInstrSize));
+      PatchingAssembler patcher(options(),
+                                reinterpret_cast<byte*>(buffer_start_ + pos),
+                                kMovInstructionsNoConstantPool);
+      // Keep internal references relative until EmitRelocations.
+      patcher.bitwise_mov(dst, target_pos);
+      break;
+    }
+    case kUnboundJumpTableEntryOpcode: {
+      PatchingAssembler patcher(options(),
+                                reinterpret_cast<byte*>(buffer_start_ + pos),
+                                kSystemPointerSize / kInstrSize);
+      // Keep internal references relative until EmitRelocations.
+      patcher.dp(target_pos);
+      break;
+    }
+    default:
+      DCHECK(false);
+      break;
+  }
+}
+
+int Assembler::max_reach_from(int pos) {
+  Instr instr = instr_at(pos);
+  uint32_t opcode = instr & kOpcodeMask;
+
+  // check which type of branch this is 16 or 26 bit offset
+  switch (opcode) {
+    case BX:
+      return 26;
+    case BCX:
+      return 16;
+    case kUnboundMovLabelOffsetOpcode:
+    case kUnboundAddLabelOffsetOpcode:
+    case kUnboundMovLabelAddrOpcode:
+    case kUnboundJumpTableEntryOpcode:
+      return 0;  // no limit on reach
+  }
+
+  DCHECK(false);
+  return 0;
+}
+
+void Assembler::bind_to(Label* L, int pos) {
+  DCHECK(0 <= pos && pos <= pc_offset());  // must have a valid binding position
+  int32_t trampoline_pos = kInvalidSlotPos;
+  bool is_branch = false;
+  while (L->is_linked()) {
+    int fixup_pos = L->pos();
+    int32_t offset = pos - fixup_pos;
+    int maxReach = max_reach_from(fixup_pos);
+    next(L);  // call next before overwriting link with target at fixup_pos
+    if (maxReach && is_intn(offset, maxReach) == false) {
+      if (trampoline_pos == kInvalidSlotPos) {
+        trampoline_pos = get_trampoline_entry();
+        CHECK_NE(trampoline_pos, kInvalidSlotPos);
+        target_at_put(trampoline_pos, pos);
+      }
+      target_at_put(fixup_pos, trampoline_pos);
+    } else {
+      target_at_put(fixup_pos, pos, &is_branch);
+    }
+  }
+  L->bind_to(pos);
+
+  if (!trampoline_emitted_ && is_branch) {
+    UntrackBranch();
+  }
+
+  // Keep track of the last bound label so we don't eliminate any instructions
+  // before a bound label.
+  if (pos > last_bound_pos_) last_bound_pos_ = pos;
+}
+
+void Assembler::bind(Label* L) {
+  DCHECK(!L->is_bound());  // label can only be bound once
+  bind_to(L, pc_offset());
+}
+
+void Assembler::next(Label* L) {
+  DCHECK(L->is_linked());
+  int link = target_at(L->pos());
+  if (link == kEndOfChain) {
+    L->Unuse();
+  } else {
+    DCHECK_GE(link, 0);
+    L->link_to(link);
+  }
+}
+
+bool Assembler::is_near(Label* L, Condition cond) {
+  DCHECK(L->is_bound());
+  if (L->is_bound() == false) return false;
+
+  int maxReach = ((cond == al) ? 26 : 16);
+  int offset = L->pos() - pc_offset();
+
+  return is_intn(offset, maxReach);
+}
+
+void Assembler::a_form(Instr instr, DoubleRegister frt, DoubleRegister fra,
+                       DoubleRegister frb, RCBit r) {
+  emit(instr | frt.code() * B21 | fra.code() * B16 | frb.code() * B11 | r);
+}
+
+void Assembler::d_form(Instr instr, Register rt, Register ra,
+                       const intptr_t val, bool signed_disp) {
+  if (signed_disp) {
+    if (!is_int16(val)) {
+      PrintF("val = %" V8PRIdPTR ", 0x%" V8PRIxPTR "\n", val, val);
+    }
+    CHECK(is_int16(val));
+  } else {
+    if (!is_uint16(val)) {
+      PrintF("val = %" V8PRIdPTR ", 0x%" V8PRIxPTR
+             ", is_unsigned_imm16(val)=%d, kImm16Mask=0x%x\n",
+             val, val, is_uint16(val), kImm16Mask);
+    }
+    CHECK(is_uint16(val));
+  }
+  emit(instr | rt.code() * B21 | ra.code() * B16 | (kImm16Mask & val));
+}
+
+void Assembler::xo_form(Instr instr, Register rt, Register ra, Register rb,
+                        OEBit o, RCBit r) {
+  emit(instr | rt.code() * B21 | ra.code() * B16 | rb.code() * B11 | o | r);
+}
+
+void Assembler::md_form(Instr instr, Register ra, Register rs, int shift,
+                        int maskbit, RCBit r) {
+  int sh0_4 = shift & 0x1F;
+  int sh5 = (shift >> 5) & 0x1;
+  int m0_4 = maskbit & 0x1F;
+  int m5 = (maskbit >> 5) & 0x1;
+
+  emit(instr | rs.code() * B21 | ra.code() * B16 | sh0_4 * B11 | m0_4 * B6 |
+       m5 * B5 | sh5 * B1 | r);
+}
+
+void Assembler::mds_form(Instr instr, Register ra, Register rs, Register rb,
+                         int maskbit, RCBit r) {
+  int m0_4 = maskbit & 0x1F;
+  int m5 = (maskbit >> 5) & 0x1;
+
+  emit(instr | rs.code() * B21 | ra.code() * B16 | rb.code() * B11 | m0_4 * B6 |
+       m5 * B5 | r);
+}
+
+// Returns the next free trampoline entry.
+int32_t Assembler::get_trampoline_entry() {
+  int32_t trampoline_entry = kInvalidSlotPos;
+
+  if (!internal_trampoline_exception_) {
+    trampoline_entry = trampoline_.take_slot();
+
+    if (kInvalidSlotPos == trampoline_entry) {
+      internal_trampoline_exception_ = true;
+    }
+  }
+  return trampoline_entry;
+}
+
+int Assembler::link(Label* L) {
+  int position;
+  if (L->is_bound()) {
+    position = L->pos();
+  } else {
+    if (L->is_linked()) {
+      position = L->pos();  // L's link
+    } else {
+      // was: target_pos = kEndOfChain;
+      // However, using self to mark the first reference
+      // should avoid most instances of branch offset overflow.  See
+      // target_at() for where this is converted back to kEndOfChain.
+      position = pc_offset();
+    }
+    L->link_to(pc_offset());
+  }
+
+  return position;
+}
+
+// Branch instructions.
+
+void Assembler::bclr(BOfield bo, int condition_bit, LKBit lk) {
+  emit(EXT1 | bo | condition_bit * B16 | BCLRX | lk);
+}
+
+void Assembler::bcctr(BOfield bo, int condition_bit, LKBit lk) {
+  emit(EXT1 | bo | condition_bit * B16 | BCCTRX | lk);
+}
+
+// Pseudo op - branch to link register
+void Assembler::blr() { bclr(BA, 0, LeaveLK); }
+
+// Pseudo op - branch to count register -- used for "jump"
+void Assembler::bctr() { bcctr(BA, 0, LeaveLK); }
+
+void Assembler::bctrl() { bcctr(BA, 0, SetLK); }
+
+void Assembler::bc(int branch_offset, BOfield bo, int condition_bit, LKBit lk) {
+  int imm16 = branch_offset;
+  CHECK(is_int16(imm16) && (imm16 & (kAAMask | kLKMask)) == 0);
+  emit(BCX | bo | condition_bit * B16 | (imm16 & kImm16Mask) | lk);
+}
+
+void Assembler::b(int branch_offset, LKBit lk) {
+  int imm26 = branch_offset;
+  CHECK(is_int26(imm26) && (imm26 & (kAAMask | kLKMask)) == 0);
+  emit(BX | (imm26 & kImm26Mask) | lk);
+}
+
+void Assembler::xori(Register dst, Register src, const Operand& imm) {
+  d_form(XORI, src, dst, imm.immediate(), false);
+}
+
+void Assembler::xoris(Register ra, Register rs, const Operand& imm) {
+  d_form(XORIS, rs, ra, imm.immediate(), false);
+}
+
+void Assembler::rlwinm(Register ra, Register rs, int sh, int mb, int me,
+                       RCBit rc) {
+  sh &= 0x1F;
+  mb &= 0x1F;
+  me &= 0x1F;
+  emit(RLWINMX | rs.code() * B21 | ra.code() * B16 | sh * B11 | mb * B6 |
+       me << 1 | rc);
+}
+
+void Assembler::rlwnm(Register ra, Register rs, Register rb, int mb, int me,
+                      RCBit rc) {
+  mb &= 0x1F;
+  me &= 0x1F;
+  emit(RLWNMX | rs.code() * B21 | ra.code() * B16 | rb.code() * B11 | mb * B6 |
+       me << 1 | rc);
+}
+
+void Assembler::rlwimi(Register ra, Register rs, int sh, int mb, int me,
+                       RCBit rc) {
+  sh &= 0x1F;
+  mb &= 0x1F;
+  me &= 0x1F;
+  emit(RLWIMIX | rs.code() * B21 | ra.code() * B16 | sh * B11 | mb * B6 |
+       me << 1 | rc);
+}
+
+void Assembler::slwi(Register dst, Register src, const Operand& val, RCBit rc) {
+  DCHECK((32 > val.immediate()) && (val.immediate() >= 0));
+  rlwinm(dst, src, val.immediate(), 0, 31 - val.immediate(), rc);
+}
+
+void Assembler::srwi(Register dst, Register src, const Operand& val, RCBit rc) {
+  DCHECK((32 > val.immediate()) && (val.immediate() >= 0));
+  rlwinm(dst, src, 32 - val.immediate(), val.immediate(), 31, rc);
+}
+
+void Assembler::clrrwi(Register dst, Register src, const Operand& val,
+                       RCBit rc) {
+  DCHECK((32 > val.immediate()) && (val.immediate() >= 0));
+  rlwinm(dst, src, 0, 0, 31 - val.immediate(), rc);
+}
+
+void Assembler::clrlwi(Register dst, Register src, const Operand& val,
+                       RCBit rc) {
+  DCHECK((32 > val.immediate()) && (val.immediate() >= 0));
+  rlwinm(dst, src, 0, val.immediate(), 31, rc);
+}
+
+void Assembler::rotlw(Register ra, Register rs, Register rb, RCBit r) {
+  rlwnm(ra, rs, rb, 0, 31, r);
+}
+
+void Assembler::rotlwi(Register ra, Register rs, int sh, RCBit r) {
+  rlwinm(ra, rs, sh, 0, 31, r);
+}
+
+void Assembler::rotrwi(Register ra, Register rs, int sh, RCBit r) {
+  rlwinm(ra, rs, 32 - sh, 0, 31, r);
+}
+
+void Assembler::subi(Register dst, Register src, const Operand& imm) {
+  addi(dst, src, Operand(-(imm.immediate())));
+}
+
+void Assembler::addc(Register dst, Register src1, Register src2, OEBit o,
+                     RCBit r) {
+  xo_form(EXT2 | ADDCX, dst, src1, src2, o, r);
+}
+
+void Assembler::adde(Register dst, Register src1, Register src2, OEBit o,
+                     RCBit r) {
+  xo_form(EXT2 | ADDEX, dst, src1, src2, o, r);
+}
+
+void Assembler::addze(Register dst, Register src1, OEBit o, RCBit r) {
+  // a special xo_form
+  emit(EXT2 | ADDZEX | dst.code() * B21 | src1.code() * B16 | o | r);
+}
+
+void Assembler::sub(Register dst, Register src1, Register src2, OEBit o,
+                    RCBit r) {
+  xo_form(EXT2 | SUBFX, dst, src2, src1, o, r);
+}
+
+void Assembler::subc(Register dst, Register src1, Register src2, OEBit o,
+                     RCBit r) {
+  xo_form(EXT2 | SUBFCX, dst, src2, src1, o, r);
+}
+
+void Assembler::sube(Register dst, Register src1, Register src2, OEBit o,
+                     RCBit r) {
+  xo_form(EXT2 | SUBFEX, dst, src2, src1, o, r);
+}
+
+void Assembler::subfic(Register dst, Register src, const Operand& imm) {
+  d_form(SUBFIC, dst, src, imm.immediate(), true);
+}
+
+void Assembler::add(Register dst, Register src1, Register src2, OEBit o,
+                    RCBit r) {
+  xo_form(EXT2 | ADDX, dst, src1, src2, o, r);
+}
+
+// Multiply low word
+void Assembler::mullw(Register dst, Register src1, Register src2, OEBit o,
+                      RCBit r) {
+  xo_form(EXT2 | MULLW, dst, src1, src2, o, r);
+}
+
+// Multiply hi word
+void Assembler::mulhw(Register dst, Register src1, Register src2, RCBit r) {
+  xo_form(EXT2 | MULHWX, dst, src1, src2, LeaveOE, r);
+}
+
+// Multiply hi word unsigned
+void Assembler::mulhwu(Register dst, Register src1, Register src2, RCBit r) {
+  xo_form(EXT2 | MULHWUX, dst, src1, src2, LeaveOE, r);
+}
+
+// Divide word
+void Assembler::divw(Register dst, Register src1, Register src2, OEBit o,
+                     RCBit r) {
+  xo_form(EXT2 | DIVW, dst, src1, src2, o, r);
+}
+
+// Divide word unsigned
+void Assembler::divwu(Register dst, Register src1, Register src2, OEBit o,
+                      RCBit r) {
+  xo_form(EXT2 | DIVWU, dst, src1, src2, o, r);
+}
+
+void Assembler::addi(Register dst, Register src, const Operand& imm) {
+  DCHECK(src != r0);  // use li instead to show intent
+  d_form(ADDI, dst, src, imm.immediate(), true);
+}
+
+void Assembler::addis(Register dst, Register src, const Operand& imm) {
+  DCHECK(src != r0);  // use lis instead to show intent
+  d_form(ADDIS, dst, src, imm.immediate(), true);
+}
+
+void Assembler::addic(Register dst, Register src, const Operand& imm) {
+  d_form(ADDIC, dst, src, imm.immediate(), true);
+}
+
+void Assembler::andi(Register ra, Register rs, const Operand& imm) {
+  d_form(ANDIx, rs, ra, imm.immediate(), false);
+}
+
+void Assembler::andis(Register ra, Register rs, const Operand& imm) {
+  d_form(ANDISx, rs, ra, imm.immediate(), false);
+}
+
+void Assembler::ori(Register ra, Register rs, const Operand& imm) {
+  d_form(ORI, rs, ra, imm.immediate(), false);
+}
+
+void Assembler::oris(Register dst, Register src, const Operand& imm) {
+  d_form(ORIS, src, dst, imm.immediate(), false);
+}
+
+void Assembler::cmpi(Register src1, const Operand& src2, CRegister cr) {
+  intptr_t imm16 = src2.immediate();
+#if V8_TARGET_ARCH_PPC64
+  int L = 1;
+#else
+  int L = 0;
+#endif
+  DCHECK(is_int16(imm16));
+  DCHECK(cr.code() >= 0 && cr.code() <= 7);
+  imm16 &= kImm16Mask;
+  emit(CMPI | cr.code() * B23 | L * B21 | src1.code() * B16 | imm16);
+}
+
+void Assembler::cmpli(Register src1, const Operand& src2, CRegister cr) {
+  uintptr_t uimm16 = src2.immediate();
+#if V8_TARGET_ARCH_PPC64
+  int L = 1;
+#else
+  int L = 0;
+#endif
+  DCHECK(is_uint16(uimm16));
+  DCHECK(cr.code() >= 0 && cr.code() <= 7);
+  uimm16 &= kImm16Mask;
+  emit(CMPLI | cr.code() * B23 | L * B21 | src1.code() * B16 | uimm16);
+}
+
+void Assembler::cmpwi(Register src1, const Operand& src2, CRegister cr) {
+  intptr_t imm16 = src2.immediate();
+  int L = 0;
+  int pos = pc_offset();
+  DCHECK(is_int16(imm16));
+  DCHECK(cr.code() >= 0 && cr.code() <= 7);
+  imm16 &= kImm16Mask;
+
+  // For cmpwi against 0, save postition and cr for later examination
+  // of potential optimization.
+  if (imm16 == 0 && pos > 0 && last_bound_pos_ != pos) {
+    optimizable_cmpi_pos_ = pos;
+    cmpi_cr_ = cr;
+  }
+  emit(CMPI | cr.code() * B23 | L * B21 | src1.code() * B16 | imm16);
+}
+
+void Assembler::cmplwi(Register src1, const Operand& src2, CRegister cr) {
+  uintptr_t uimm16 = src2.immediate();
+  int L = 0;
+  DCHECK(is_uint16(uimm16));
+  DCHECK(cr.code() >= 0 && cr.code() <= 7);
+  uimm16 &= kImm16Mask;
+  emit(CMPLI | cr.code() * B23 | L * B21 | src1.code() * B16 | uimm16);
+}
+
+void Assembler::isel(Register rt, Register ra, Register rb, int cb) {
+  emit(EXT2 | ISEL | rt.code() * B21 | ra.code() * B16 | rb.code() * B11 |
+       cb * B6);
+}
+
+// Pseudo op - load immediate
+void Assembler::li(Register dst, const Operand& imm) {
+  d_form(ADDI, dst, r0, imm.immediate(), true);
+}
+
+void Assembler::lis(Register dst, const Operand& imm) {
+  d_form(ADDIS, dst, r0, imm.immediate(), true);
+}
+
+// Pseudo op - move register
+void Assembler::mr(Register dst, Register src) {
+  // actually or(dst, src, src)
+  orx(dst, src, src);
+}
+
+void Assembler::lbz(Register dst, const MemOperand& src) {
+  DCHECK(src.ra_ != r0);
+  d_form(LBZ, dst, src.ra(), src.offset(), true);
+}
+
+void Assembler::lhz(Register dst, const MemOperand& src) {
+  DCHECK(src.ra_ != r0);
+  d_form(LHZ, dst, src.ra(), src.offset(), true);
+}
+
+void Assembler::lwz(Register dst, const MemOperand& src) {
+  DCHECK(src.ra_ != r0);
+  d_form(LWZ, dst, src.ra(), src.offset(), true);
+}
+
+void Assembler::lwzu(Register dst, const MemOperand& src) {
+  DCHECK(src.ra_ != r0);
+  d_form(LWZU, dst, src.ra(), src.offset(), true);
+}
+
+void Assembler::lha(Register dst, const MemOperand& src) {
+  DCHECK(src.ra_ != r0);
+  d_form(LHA, dst, src.ra(), src.offset(), true);
+}
+
+void Assembler::lwa(Register dst, const MemOperand& src) {
+#if V8_TARGET_ARCH_PPC64
+  int offset = src.offset();
+  DCHECK(src.ra_ != r0);
+  CHECK(!(offset & 3) && is_int16(offset));
+  offset = kImm16Mask & offset;
+  emit(LD | dst.code() * B21 | src.ra().code() * B16 | offset | 2);
+#else
+  lwz(dst, src);
+#endif
+}
+
+void Assembler::stb(Register dst, const MemOperand& src) {
+  DCHECK(src.ra_ != r0);
+  d_form(STB, dst, src.ra(), src.offset(), true);
+}
+
+void Assembler::sth(Register dst, const MemOperand& src) {
+  DCHECK(src.ra_ != r0);
+  d_form(STH, dst, src.ra(), src.offset(), true);
+}
+
+void Assembler::stw(Register dst, const MemOperand& src) {
+  DCHECK(src.ra_ != r0);
+  d_form(STW, dst, src.ra(), src.offset(), true);
+}
+
+void Assembler::stwu(Register dst, const MemOperand& src) {
+  DCHECK(src.ra_ != r0);
+  d_form(STWU, dst, src.ra(), src.offset(), true);
+}
+
+void Assembler::neg(Register rt, Register ra, OEBit o, RCBit r) {
+  emit(EXT2 | NEGX | rt.code() * B21 | ra.code() * B16 | o | r);
+}
+
+#if V8_TARGET_ARCH_PPC64
+// 64bit specific instructions
+void Assembler::ld(Register rd, const MemOperand& src) {
+  int offset = src.offset();
+  DCHECK(src.ra_ != r0);
+  CHECK(!(offset & 3) && is_int16(offset));
+  offset = kImm16Mask & offset;
+  emit(LD | rd.code() * B21 | src.ra().code() * B16 | offset);
+}
+
+void Assembler::ldu(Register rd, const MemOperand& src) {
+  int offset = src.offset();
+  DCHECK(src.ra_ != r0);
+  CHECK(!(offset & 3) && is_int16(offset));
+  offset = kImm16Mask & offset;
+  emit(LD | rd.code() * B21 | src.ra().code() * B16 | offset | 1);
+}
+
+void Assembler::std(Register rs, const MemOperand& src) {
+  int offset = src.offset();
+  DCHECK(src.ra_ != r0);
+  CHECK(!(offset & 3) && is_int16(offset));
+  offset = kImm16Mask & offset;
+  emit(STD | rs.code() * B21 | src.ra().code() * B16 | offset);
+}
+
+void Assembler::stdu(Register rs, const MemOperand& src) {
+  int offset = src.offset();
+  DCHECK(src.ra_ != r0);
+  CHECK(!(offset & 3) && is_int16(offset));
+  offset = kImm16Mask & offset;
+  emit(STD | rs.code() * B21 | src.ra().code() * B16 | offset | 1);
+}
+
+void Assembler::rldic(Register ra, Register rs, int sh, int mb, RCBit r) {
+  md_form(EXT5 | RLDIC, ra, rs, sh, mb, r);
+}
+
+void Assembler::rldicl(Register ra, Register rs, int sh, int mb, RCBit r) {
+  md_form(EXT5 | RLDICL, ra, rs, sh, mb, r);
+}
+
+void Assembler::rldcl(Register ra, Register rs, Register rb, int mb, RCBit r) {
+  mds_form(EXT5 | RLDCL, ra, rs, rb, mb, r);
+}
+
+void Assembler::rldicr(Register ra, Register rs, int sh, int me, RCBit r) {
+  md_form(EXT5 | RLDICR, ra, rs, sh, me, r);
+}
+
+void Assembler::sldi(Register dst, Register src, const Operand& val, RCBit rc) {
+  DCHECK((64 > val.immediate()) && (val.immediate() >= 0));
+  rldicr(dst, src, val.immediate(), 63 - val.immediate(), rc);
+}
+
+void Assembler::srdi(Register dst, Register src, const Operand& val, RCBit rc) {
+  DCHECK((64 > val.immediate()) && (val.immediate() >= 0));
+  rldicl(dst, src, 64 - val.immediate(), val.immediate(), rc);
+}
+
+void Assembler::clrrdi(Register dst, Register src, const Operand& val,
+                       RCBit rc) {
+  DCHECK((64 > val.immediate()) && (val.immediate() >= 0));
+  rldicr(dst, src, 0, 63 - val.immediate(), rc);
+}
+
+void Assembler::clrldi(Register dst, Register src, const Operand& val,
+                       RCBit rc) {
+  DCHECK((64 > val.immediate()) && (val.immediate() >= 0));
+  rldicl(dst, src, 0, val.immediate(), rc);
+}
+
+void Assembler::rldimi(Register ra, Register rs, int sh, int mb, RCBit r) {
+  md_form(EXT5 | RLDIMI, ra, rs, sh, mb, r);
+}
+
+void Assembler::sradi(Register ra, Register rs, int sh, RCBit r) {
+  int sh0_4 = sh & 0x1F;
+  int sh5 = (sh >> 5) & 0x1;
+
+  emit(EXT2 | SRADIX | rs.code() * B21 | ra.code() * B16 | sh0_4 * B11 |
+       sh5 * B1 | r);
+}
+
+void Assembler::rotld(Register ra, Register rs, Register rb, RCBit r) {
+  rldcl(ra, rs, rb, 0, r);
+}
+
+void Assembler::rotldi(Register ra, Register rs, int sh, RCBit r) {
+  rldicl(ra, rs, sh, 0, r);
+}
+
+void Assembler::rotrdi(Register ra, Register rs, int sh, RCBit r) {
+  rldicl(ra, rs, 64 - sh, 0, r);
+}
+
+void Assembler::mulld(Register dst, Register src1, Register src2, OEBit o,
+                      RCBit r) {
+  xo_form(EXT2 | MULLD, dst, src1, src2, o, r);
+}
+
+void Assembler::divd(Register dst, Register src1, Register src2, OEBit o,
+                     RCBit r) {
+  xo_form(EXT2 | DIVD, dst, src1, src2, o, r);
+}
+
+void Assembler::divdu(Register dst, Register src1, Register src2, OEBit o,
+                      RCBit r) {
+  xo_form(EXT2 | DIVDU, dst, src1, src2, o, r);
+}
+#endif
+
+int Assembler::instructions_required_for_mov(Register dst,
+                                             const Operand& src) const {
+  bool canOptimize =
+      !(src.must_output_reloc_info(this) || is_trampoline_pool_blocked());
+  if (use_constant_pool_for_mov(dst, src, canOptimize)) {
+    if (ConstantPoolAccessIsInOverflow()) {
+      return kMovInstructionsConstantPool + 1;
+    }
+    return kMovInstructionsConstantPool;
+  }
+  DCHECK(!canOptimize);
+  return kMovInstructionsNoConstantPool;
+}
+
+bool Assembler::use_constant_pool_for_mov(Register dst, const Operand& src,
+                                          bool canOptimize) const {
+  if (!FLAG_enable_embedded_constant_pool || !is_constant_pool_available()) {
+    // If there is no constant pool available, we must use a mov
+    // immediate sequence.
+    return false;
+  }
+  intptr_t value = src.immediate();
+#if V8_TARGET_ARCH_PPC64
+  bool allowOverflow = !((canOptimize && is_int32(value)) || dst == r0);
+#else
+  bool allowOverflow = !(canOptimize || dst == r0);
+#endif
+  if (canOptimize && is_int16(value)) {
+    // Prefer a single-instruction load-immediate.
+    return false;
+  }
+  if (!allowOverflow && ConstantPoolAccessIsInOverflow()) {
+    // Prefer non-relocatable two-instruction bitwise-mov32 over
+    // overflow sequence.
+    return false;
+  }
+
+  return true;
+}
+
+void Assembler::EnsureSpaceFor(int space_needed) {
+  if (buffer_space() <= (kGap + space_needed)) {
+    GrowBuffer(space_needed);
+  }
+}
+
+bool Operand::must_output_reloc_info(const Assembler* assembler) const {
+  if (rmode_ == RelocInfo::EXTERNAL_REFERENCE) {
+    if (assembler != nullptr && assembler->predictable_code_size()) return true;
+    return assembler->options().record_reloc_info_for_serialization;
+  } else if (RelocInfo::IsNone(rmode_)) {
+    return false;
+  }
+  return true;
+}
+
+// Primarily used for loading constants
+// This should really move to be in macro-assembler as it
+// is really a pseudo instruction
+// Some usages of this intend for a FIXED_SEQUENCE to be used
+// Todo - break this dependency so we can optimize mov() in general
+// and only use the generic version when we require a fixed sequence
+void Assembler::mov(Register dst, const Operand& src) {
+  intptr_t value;
+  if (src.IsHeapObjectRequest()) {
+    RequestHeapObject(src.heap_object_request());
+    value = 0;
+  } else {
+    value = src.immediate();
+  }
+  bool relocatable = src.must_output_reloc_info(this);
+  bool canOptimize;
+
+  canOptimize =
+      !(relocatable || (is_trampoline_pool_blocked() && !is_int16(value)));
+
+  if (!src.IsHeapObjectRequest() &&
+      use_constant_pool_for_mov(dst, src, canOptimize)) {
+    DCHECK(is_constant_pool_available());
+    if (relocatable) {
+      RecordRelocInfo(src.rmode_);
+    }
+    ConstantPoolEntry::Access access = ConstantPoolAddEntry(src.rmode_, value);
+#if V8_TARGET_ARCH_PPC64
+    if (access == ConstantPoolEntry::OVERFLOWED) {
+      addis(dst, kConstantPoolRegister, Operand::Zero());
+      ld(dst, MemOperand(dst, 0));
+    } else {
+      ld(dst, MemOperand(kConstantPoolRegister, 0));
+    }
+#else
+    if (access == ConstantPoolEntry::OVERFLOWED) {
+      addis(dst, kConstantPoolRegister, Operand::Zero());
+      lwz(dst, MemOperand(dst, 0));
+    } else {
+      lwz(dst, MemOperand(kConstantPoolRegister, 0));
+    }
+#endif
+    return;
+  }
+
+  if (canOptimize) {
+    if (is_int16(value)) {
+      li(dst, Operand(value));
+    } else {
+      uint16_t u16;
+#if V8_TARGET_ARCH_PPC64
+      if (is_int32(value)) {
+#endif
+        lis(dst, Operand(value >> 16));
+#if V8_TARGET_ARCH_PPC64
+      } else {
+        if (is_int48(value)) {
+          li(dst, Operand(value >> 32));
+        } else {
+          lis(dst, Operand(value >> 48));
+          u16 = ((value >> 32) & 0xFFFF);
+          if (u16) {
+            ori(dst, dst, Operand(u16));
+          }
+        }
+        sldi(dst, dst, Operand(32));
+        u16 = ((value >> 16) & 0xFFFF);
+        if (u16) {
+          oris(dst, dst, Operand(u16));
+        }
+      }
+#endif
+      u16 = (value & 0xFFFF);
+      if (u16) {
+        ori(dst, dst, Operand(u16));
+      }
+    }
+    return;
+  }
+
+  DCHECK(!canOptimize);
+  if (relocatable) {
+    RecordRelocInfo(src.rmode_);
+  }
+  bitwise_mov(dst, value);
+}
+
+void Assembler::bitwise_mov(Register dst, intptr_t value) {
+  BlockTrampolinePoolScope block_trampoline_pool(this);
+#if V8_TARGET_ARCH_PPC64
+  int32_t hi_32 = static_cast<int32_t>(value >> 32);
+  int32_t lo_32 = static_cast<int32_t>(value);
+  int hi_word = static_cast<int>(hi_32 >> 16);
+  int lo_word = static_cast<int>(hi_32 & 0xFFFF);
+  lis(dst, Operand(SIGN_EXT_IMM16(hi_word)));
+  ori(dst, dst, Operand(lo_word));
+  sldi(dst, dst, Operand(32));
+  hi_word = static_cast<int>(((lo_32 >> 16) & 0xFFFF));
+  lo_word = static_cast<int>(lo_32 & 0xFFFF);
+  oris(dst, dst, Operand(hi_word));
+  ori(dst, dst, Operand(lo_word));
+#else
+  int hi_word = static_cast<int>(value >> 16);
+  int lo_word = static_cast<int>(value & 0xFFFF);
+  lis(dst, Operand(SIGN_EXT_IMM16(hi_word)));
+  ori(dst, dst, Operand(lo_word));
+#endif
+}
+
+void Assembler::bitwise_mov32(Register dst, int32_t value) {
+  BlockTrampolinePoolScope block_trampoline_pool(this);
+  int hi_word = static_cast<int>(value >> 16);
+  int lo_word = static_cast<int>(value & 0xFFFF);
+  lis(dst, Operand(SIGN_EXT_IMM16(hi_word)));
+  ori(dst, dst, Operand(lo_word));
+}
+
+void Assembler::bitwise_add32(Register dst, Register src, int32_t value) {
+  BlockTrampolinePoolScope block_trampoline_pool(this);
+  if (is_int16(value)) {
+    addi(dst, src, Operand(value));
+    nop();
+  } else {
+    int hi_word = static_cast<int>(value >> 16);
+    int lo_word = static_cast<int>(value & 0xFFFF);
+    if (lo_word & 0x8000) hi_word++;
+    addis(dst, src, Operand(SIGN_EXT_IMM16(hi_word)));
+    addic(dst, dst, Operand(SIGN_EXT_IMM16(lo_word)));
+  }
+}
+
+void Assembler::mov_label_offset(Register dst, Label* label) {
+  int position = link(label);
+  if (label->is_bound()) {
+    // Load the position of the label relative to the generated code object.
+    mov(dst, Operand(position + Code::kHeaderSize - kHeapObjectTag));
+  } else {
+    // Encode internal reference to unbound label. We use a dummy opcode
+    // such that it won't collide with any opcode that might appear in the
+    // label's chain.  Encode the destination register in the 2nd instruction.
+    int link = position - pc_offset();
+    DCHECK_EQ(0, link & 3);
+    link >>= 2;
+    DCHECK(is_int26(link));
+
+    // When the label is bound, these instructions will be patched
+    // with a 2 instruction mov sequence that will load the
+    // destination register with the position of the label from the
+    // beginning of the code.
+    //
+    // target_at extracts the link and target_at_put patches the instructions.
+    BlockTrampolinePoolScope block_trampoline_pool(this);
+    emit(kUnboundMovLabelOffsetOpcode | (link & kImm26Mask));
+    emit(dst.code());
+  }
+}
+
+void Assembler::add_label_offset(Register dst, Register base, Label* label,
+                                 int delta) {
+  int position = link(label);
+  if (label->is_bound()) {
+    // dst = base + position + delta
+    position += delta;
+    bitwise_add32(dst, base, position);
+  } else {
+    // Encode internal reference to unbound label. We use a dummy opcode
+    // such that it won't collide with any opcode that might appear in the
+    // label's chain.  Encode the operands in the 2nd instruction.
+    int link = position - pc_offset();
+    DCHECK_EQ(0, link & 3);
+    link >>= 2;
+    DCHECK(is_int26(link));
+    BlockTrampolinePoolScope block_trampoline_pool(this);
+
+    emit((is_int22(delta) ? kUnboundAddLabelOffsetOpcode
+                          : kUnboundAddLabelLongOffsetOpcode) |
+         (link & kImm26Mask));
+    emit(dst.code() * B27 | base.code() * B22 | (delta & kImm22Mask));
+
+    if (!is_int22(delta)) {
+      emit(delta);
+    }
+  }
+}
+
+void Assembler::mov_label_addr(Register dst, Label* label) {
+  CheckBuffer();
+  RecordRelocInfo(RelocInfo::INTERNAL_REFERENCE_ENCODED);
+  int position = link(label);
+  if (label->is_bound()) {
+    // Keep internal references relative until EmitRelocations.
+    bitwise_mov(dst, position);
+  } else {
+    // Encode internal reference to unbound label. We use a dummy opcode
+    // such that it won't collide with any opcode that might appear in the
+    // label's chain.  Encode the destination register in the 2nd instruction.
+    int link = position - pc_offset();
+    DCHECK_EQ(0, link & 3);
+    link >>= 2;
+    DCHECK(is_int26(link));
+
+    // When the label is bound, these instructions will be patched
+    // with a multi-instruction mov sequence that will load the
+    // destination register with the address of the label.
+    //
+    // target_at extracts the link and target_at_put patches the instructions.
+    BlockTrampolinePoolScope block_trampoline_pool(this);
+    emit(kUnboundMovLabelAddrOpcode | (link & kImm26Mask));
+    emit(dst.code());
+    DCHECK_GE(kMovInstructionsNoConstantPool, 2);
+    for (int i = 0; i < kMovInstructionsNoConstantPool - 2; i++) nop();
+  }
+}
+
+void Assembler::emit_label_addr(Label* label) {
+  CheckBuffer();
+  RecordRelocInfo(RelocInfo::INTERNAL_REFERENCE);
+  int position = link(label);
+  if (label->is_bound()) {
+    // Keep internal references relative until EmitRelocations.
+    dp(position);
+  } else {
+    // Encode internal reference to unbound label. We use a dummy opcode
+    // such that it won't collide with any opcode that might appear in the
+    // label's chain.
+    int link = position - pc_offset();
+    DCHECK_EQ(0, link & 3);
+    link >>= 2;
+    DCHECK(is_int26(link));
+
+    // When the label is bound, the instruction(s) will be patched
+    // as a jump table entry containing the label address.  target_at extracts
+    // the link and target_at_put patches the instruction(s).
+    BlockTrampolinePoolScope block_trampoline_pool(this);
+    emit(kUnboundJumpTableEntryOpcode | (link & kImm26Mask));
+#if V8_TARGET_ARCH_PPC64
+    nop();
+#endif
+  }
+}
+
+// Special register instructions
+void Assembler::crxor(int bt, int ba, int bb) {
+  emit(EXT1 | CRXOR | bt * B21 | ba * B16 | bb * B11);
+}
+
+void Assembler::creqv(int bt, int ba, int bb) {
+  emit(EXT1 | CREQV | bt * B21 | ba * B16 | bb * B11);
+}
+
+void Assembler::mflr(Register dst) {
+  emit(EXT2 | MFSPR | dst.code() * B21 | 256 << 11);  // Ignore RC bit
+}
+
+void Assembler::mtlr(Register src) {
+  emit(EXT2 | MTSPR | src.code() * B21 | 256 << 11);  // Ignore RC bit
+}
+
+void Assembler::mtctr(Register src) {
+  emit(EXT2 | MTSPR | src.code() * B21 | 288 << 11);  // Ignore RC bit
+}
+
+void Assembler::mtxer(Register src) {
+  emit(EXT2 | MTSPR | src.code() * B21 | 32 << 11);
+}
+
+void Assembler::mcrfs(CRegister cr, FPSCRBit bit) {
+  DCHECK_LT(static_cast<int>(bit), 32);
+  int bf = cr.code();
+  int bfa = bit / CRWIDTH;
+  emit(EXT4 | MCRFS | bf * B23 | bfa * B18);
+}
+
+void Assembler::mfcr(Register dst) { emit(EXT2 | MFCR | dst.code() * B21); }
+
+#if V8_TARGET_ARCH_PPC64
+void Assembler::mffprd(Register dst, DoubleRegister src) {
+  emit(EXT2 | MFVSRD | src.code() * B21 | dst.code() * B16);
+}
+
+void Assembler::mffprwz(Register dst, DoubleRegister src) {
+  emit(EXT2 | MFVSRWZ | src.code() * B21 | dst.code() * B16);
+}
+
+void Assembler::mtfprd(DoubleRegister dst, Register src) {
+  emit(EXT2 | MTVSRD | dst.code() * B21 | src.code() * B16);
+}
+
+void Assembler::mtfprwz(DoubleRegister dst, Register src) {
+  emit(EXT2 | MTVSRWZ | dst.code() * B21 | src.code() * B16);
+}
+
+void Assembler::mtfprwa(DoubleRegister dst, Register src) {
+  emit(EXT2 | MTVSRWA | dst.code() * B21 | src.code() * B16);
+}
+#endif
+
+// Exception-generating instructions and debugging support.
+// Stops with a non-negative code less than kNumOfWatchedStops support
+// enabling/disabling and a counter feature. See simulator-ppc.h .
+void Assembler::stop(Condition cond, int32_t code, CRegister cr) {
+  if (cond != al) {
+    Label skip;
+    b(NegateCondition(cond), &skip, cr);
+    bkpt(0);
+    bind(&skip);
+  } else {
+    bkpt(0);
+  }
+}
+
+void Assembler::bkpt(uint32_t imm16) { emit(0x7D821008); }
+
+void Assembler::dcbf(Register ra, Register rb) {
+  emit(EXT2 | DCBF | ra.code() * B16 | rb.code() * B11);
+}
+
+void Assembler::sync() { emit(EXT2 | SYNC); }
+
+void Assembler::lwsync() { emit(EXT2 | SYNC | 1 * B21); }
+
+void Assembler::icbi(Register ra, Register rb) {
+  emit(EXT2 | ICBI | ra.code() * B16 | rb.code() * B11);
+}
+
+void Assembler::isync() { emit(EXT1 | ISYNC); }
+
+// Floating point support
+
+void Assembler::lfd(const DoubleRegister frt, const MemOperand& src) {
+  int offset = src.offset();
+  Register ra = src.ra();
+  DCHECK(ra != r0);
+  CHECK(is_int16(offset));
+  int imm16 = offset & kImm16Mask;
+  // could be x_form instruction with some casting magic
+  emit(LFD | frt.code() * B21 | ra.code() * B16 | imm16);
+}
+
+void Assembler::lfdu(const DoubleRegister frt, const MemOperand& src) {
+  int offset = src.offset();
+  Register ra = src.ra();
+  DCHECK(ra != r0);
+  CHECK(is_int16(offset));
+  int imm16 = offset & kImm16Mask;
+  // could be x_form instruction with some casting magic
+  emit(LFDU | frt.code() * B21 | ra.code() * B16 | imm16);
+}
+
+void Assembler::lfs(const DoubleRegister frt, const MemOperand& src) {
+  int offset = src.offset();
+  Register ra = src.ra();
+  CHECK(is_int16(offset));
+  DCHECK(ra != r0);
+  int imm16 = offset & kImm16Mask;
+  // could be x_form instruction with some casting magic
+  emit(LFS | frt.code() * B21 | ra.code() * B16 | imm16);
+}
+
+void Assembler::lfsu(const DoubleRegister frt, const MemOperand& src) {
+  int offset = src.offset();
+  Register ra = src.ra();
+  CHECK(is_int16(offset));
+  DCHECK(ra != r0);
+  int imm16 = offset & kImm16Mask;
+  // could be x_form instruction with some casting magic
+  emit(LFSU | frt.code() * B21 | ra.code() * B16 | imm16);
+}
+
+void Assembler::stfd(const DoubleRegister frs, const MemOperand& src) {
+  int offset = src.offset();
+  Register ra = src.ra();
+  CHECK(is_int16(offset));
+  DCHECK(ra != r0);
+  int imm16 = offset & kImm16Mask;
+  // could be x_form instruction with some casting magic
+  emit(STFD | frs.code() * B21 | ra.code() * B16 | imm16);
+}
+
+void Assembler::stfdu(const DoubleRegister frs, const MemOperand& src) {
+  int offset = src.offset();
+  Register ra = src.ra();
+  CHECK(is_int16(offset));
+  DCHECK(ra != r0);
+  int imm16 = offset & kImm16Mask;
+  // could be x_form instruction with some casting magic
+  emit(STFDU | frs.code() * B21 | ra.code() * B16 | imm16);
+}
+
+void Assembler::stfs(const DoubleRegister frs, const MemOperand& src) {
+  int offset = src.offset();
+  Register ra = src.ra();
+  CHECK(is_int16(offset));
+  DCHECK(ra != r0);
+  int imm16 = offset & kImm16Mask;
+  // could be x_form instruction with some casting magic
+  emit(STFS | frs.code() * B21 | ra.code() * B16 | imm16);
+}
+
+void Assembler::stfsu(const DoubleRegister frs, const MemOperand& src) {
+  int offset = src.offset();
+  Register ra = src.ra();
+  CHECK(is_int16(offset));
+  DCHECK(ra != r0);
+  int imm16 = offset & kImm16Mask;
+  // could be x_form instruction with some casting magic
+  emit(STFSU | frs.code() * B21 | ra.code() * B16 | imm16);
+}
+
+void Assembler::fsub(const DoubleRegister frt, const DoubleRegister fra,
+                     const DoubleRegister frb, RCBit rc) {
+  a_form(EXT4 | FSUB, frt, fra, frb, rc);
+}
+
+void Assembler::fadd(const DoubleRegister frt, const DoubleRegister fra,
+                     const DoubleRegister frb, RCBit rc) {
+  a_form(EXT4 | FADD, frt, fra, frb, rc);
+}
+
+void Assembler::fmul(const DoubleRegister frt, const DoubleRegister fra,
+                     const DoubleRegister frc, RCBit rc) {
+  emit(EXT4 | FMUL | frt.code() * B21 | fra.code() * B16 | frc.code() * B6 |
+       rc);
+}
+
+void Assembler::fdiv(const DoubleRegister frt, const DoubleRegister fra,
+                     const DoubleRegister frb, RCBit rc) {
+  a_form(EXT4 | FDIV, frt, fra, frb, rc);
+}
+
+void Assembler::fcmpu(const DoubleRegister fra, const DoubleRegister frb,
+                      CRegister cr) {
+  DCHECK(cr.code() >= 0 && cr.code() <= 7);
+  emit(EXT4 | FCMPU | cr.code() * B23 | fra.code() * B16 | frb.code() * B11);
+}
+
+void Assembler::fmr(const DoubleRegister frt, const DoubleRegister frb,
+                    RCBit rc) {
+  emit(EXT4 | FMR | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::fctiwz(const DoubleRegister frt, const DoubleRegister frb) {
+  emit(EXT4 | FCTIWZ | frt.code() * B21 | frb.code() * B11);
+}
+
+void Assembler::fctiw(const DoubleRegister frt, const DoubleRegister frb) {
+  emit(EXT4 | FCTIW | frt.code() * B21 | frb.code() * B11);
+}
+
+void Assembler::fctiwuz(const DoubleRegister frt, const DoubleRegister frb) {
+  emit(EXT4 | FCTIWUZ | frt.code() * B21 | frb.code() * B11);
+}
+
+void Assembler::frin(const DoubleRegister frt, const DoubleRegister frb,
+                     RCBit rc) {
+  emit(EXT4 | FRIN | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::friz(const DoubleRegister frt, const DoubleRegister frb,
+                     RCBit rc) {
+  emit(EXT4 | FRIZ | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::frip(const DoubleRegister frt, const DoubleRegister frb,
+                     RCBit rc) {
+  emit(EXT4 | FRIP | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::frim(const DoubleRegister frt, const DoubleRegister frb,
+                     RCBit rc) {
+  emit(EXT4 | FRIM | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::frsp(const DoubleRegister frt, const DoubleRegister frb,
+                     RCBit rc) {
+  emit(EXT4 | FRSP | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::fcfid(const DoubleRegister frt, const DoubleRegister frb,
+                      RCBit rc) {
+  emit(EXT4 | FCFID | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::fcfidu(const DoubleRegister frt, const DoubleRegister frb,
+                       RCBit rc) {
+  emit(EXT4 | FCFIDU | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::fcfidus(const DoubleRegister frt, const DoubleRegister frb,
+                        RCBit rc) {
+  emit(EXT3 | FCFIDUS | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::fcfids(const DoubleRegister frt, const DoubleRegister frb,
+                       RCBit rc) {
+  emit(EXT3 | FCFIDS | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::fctid(const DoubleRegister frt, const DoubleRegister frb,
+                      RCBit rc) {
+  emit(EXT4 | FCTID | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::fctidz(const DoubleRegister frt, const DoubleRegister frb,
+                       RCBit rc) {
+  emit(EXT4 | FCTIDZ | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::fctidu(const DoubleRegister frt, const DoubleRegister frb,
+                       RCBit rc) {
+  emit(EXT4 | FCTIDU | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::fctiduz(const DoubleRegister frt, const DoubleRegister frb,
+                        RCBit rc) {
+  emit(EXT4 | FCTIDUZ | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::fsel(const DoubleRegister frt, const DoubleRegister fra,
+                     const DoubleRegister frc, const DoubleRegister frb,
+                     RCBit rc) {
+  emit(EXT4 | FSEL | frt.code() * B21 | fra.code() * B16 | frb.code() * B11 |
+       frc.code() * B6 | rc);
+}
+
+void Assembler::fneg(const DoubleRegister frt, const DoubleRegister frb,
+                     RCBit rc) {
+  emit(EXT4 | FNEG | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::mtfsb0(FPSCRBit bit, RCBit rc) {
+  DCHECK_LT(static_cast<int>(bit), 32);
+  int bt = bit;
+  emit(EXT4 | MTFSB0 | bt * B21 | rc);
+}
+
+void Assembler::mtfsb1(FPSCRBit bit, RCBit rc) {
+  DCHECK_LT(static_cast<int>(bit), 32);
+  int bt = bit;
+  emit(EXT4 | MTFSB1 | bt * B21 | rc);
+}
+
+void Assembler::mtfsfi(int bf, int immediate, RCBit rc) {
+  emit(EXT4 | MTFSFI | bf * B23 | immediate * B12 | rc);
+}
+
+void Assembler::mffs(const DoubleRegister frt, RCBit rc) {
+  emit(EXT4 | MFFS | frt.code() * B21 | rc);
+}
+
+void Assembler::mtfsf(const DoubleRegister frb, bool L, int FLM, bool W,
+                      RCBit rc) {
+  emit(EXT4 | MTFSF | frb.code() * B11 | W * B16 | FLM * B17 | L * B25 | rc);
+}
+
+void Assembler::fsqrt(const DoubleRegister frt, const DoubleRegister frb,
+                      RCBit rc) {
+  emit(EXT4 | FSQRT | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::fabs(const DoubleRegister frt, const DoubleRegister frb,
+                     RCBit rc) {
+  emit(EXT4 | FABS | frt.code() * B21 | frb.code() * B11 | rc);
+}
+
+void Assembler::fmadd(const DoubleRegister frt, const DoubleRegister fra,
+                      const DoubleRegister frc, const DoubleRegister frb,
+                      RCBit rc) {
+  emit(EXT4 | FMADD | frt.code() * B21 | fra.code() * B16 | frb.code() * B11 |
+       frc.code() * B6 | rc);
+}
+
+void Assembler::fmsub(const DoubleRegister frt, const DoubleRegister fra,
+                      const DoubleRegister frc, const DoubleRegister frb,
+                      RCBit rc) {
+  emit(EXT4 | FMSUB | frt.code() * B21 | fra.code() * B16 | frb.code() * B11 |
+       frc.code() * B6 | rc);
+}
+
+// Vector instructions
+void Assembler::mfvsrd(const Register ra, const Simd128Register rs) {
+  int SX = 1;
+  emit(MFVSRD | rs.code() * B21 | ra.code() * B16 | SX);
+}
+
+void Assembler::mfvsrwz(const Register ra, const Simd128Register rs) {
+  int SX = 1;
+  emit(MFVSRWZ | rs.code() * B21 | ra.code() * B16 | SX);
+}
+
+void Assembler::mtvsrd(const Simd128Register rt, const Register ra) {
+  int TX = 1;
+  emit(MTVSRD | rt.code() * B21 | ra.code() * B16 | TX);
+}
+
+void Assembler::lxvd(const Simd128Register rt, const MemOperand& src) {
+  int TX = 1;
+  emit(LXVD | rt.code() * B21 | src.ra().code() * B16 | src.rb().code() * B11 |
+       TX);
+}
+
+void Assembler::stxvd(const Simd128Register rt, const MemOperand& dst) {
+  int SX = 1;
+  emit(STXVD | rt.code() * B21 | dst.ra().code() * B16 | dst.rb().code() * B11 |
+       SX);
+}
+
+// Pseudo instructions.
+void Assembler::nop(int type) {
+  Register reg = r0;
+  switch (type) {
+    case NON_MARKING_NOP:
+      reg = r0;
+      break;
+    case GROUP_ENDING_NOP:
+      reg = r2;
+      break;
+    case DEBUG_BREAK_NOP:
+      reg = r3;
+      break;
+    default:
+      UNIMPLEMENTED();
+  }
+
+  ori(reg, reg, Operand::Zero());
+}
+
+bool Assembler::IsNop(Instr instr, int type) {
+  int reg = 0;
+  switch (type) {
+    case NON_MARKING_NOP:
+      reg = 0;
+      break;
+    case GROUP_ENDING_NOP:
+      reg = 2;
+      break;
+    case DEBUG_BREAK_NOP:
+      reg = 3;
+      break;
+    default:
+      UNIMPLEMENTED();
+  }
+  return instr == (ORI | reg * B21 | reg * B16);
+}
+
+void Assembler::GrowBuffer(int needed) {
+  DCHECK_EQ(buffer_start_, buffer_->start());
+
+  // Compute new buffer size.
+  int old_size = buffer_->size();
+  int new_size = std::min(2 * old_size, old_size + 1 * MB);
+  int space = buffer_space() + (new_size - old_size);
+  new_size += (space < needed) ? needed - space : 0;
+
+  // Some internal data structures overflow for very large buffers,
+  // they must ensure that kMaximalBufferSize is not too large.
+  if (new_size > kMaximalBufferSize) {
+    V8::FatalProcessOutOfMemory(nullptr, "Assembler::GrowBuffer");
+  }
+
+  // Set up new buffer.
+  std::unique_ptr<AssemblerBuffer> new_buffer = buffer_->Grow(new_size);
+  DCHECK_EQ(new_size, new_buffer->size());
+  byte* new_start = new_buffer->start();
+
+  // Copy the data.
+  intptr_t pc_delta = new_start - buffer_start_;
+  intptr_t rc_delta = (new_start + new_size) - (buffer_start_ + old_size);
+  size_t reloc_size = (buffer_start_ + old_size) - reloc_info_writer.pos();
+  MemMove(new_start, buffer_start_, pc_offset());
+  MemMove(reloc_info_writer.pos() + rc_delta, reloc_info_writer.pos(),
+          reloc_size);
+
+  // Switch buffers.
+  buffer_ = std::move(new_buffer);
+  buffer_start_ = new_start;
+  pc_ += pc_delta;
+  reloc_info_writer.Reposition(reloc_info_writer.pos() + rc_delta,
+                               reloc_info_writer.last_pc() + pc_delta);
+
+  // None of our relocation types are pc relative pointing outside the code
+  // buffer nor pc absolute pointing inside the code buffer, so there is no need
+  // to relocate any emitted relocation entries.
+}
+
+void Assembler::db(uint8_t data) {
+  CheckBuffer();
+  *reinterpret_cast<uint8_t*>(pc_) = data;
+  pc_ += sizeof(uint8_t);
+}
+
+void Assembler::dd(uint32_t data) {
+  CheckBuffer();
+  *reinterpret_cast<uint32_t*>(pc_) = data;
+  pc_ += sizeof(uint32_t);
+}
+
+void Assembler::dq(uint64_t value) {
+  CheckBuffer();
+  *reinterpret_cast<uint64_t*>(pc_) = value;
+  pc_ += sizeof(uint64_t);
+}
+
+void Assembler::dp(uintptr_t data) {
+  CheckBuffer();
+  *reinterpret_cast<uintptr_t*>(pc_) = data;
+  pc_ += sizeof(uintptr_t);
+}
+
+void Assembler::RecordRelocInfo(RelocInfo::Mode rmode, intptr_t data) {
+  if (!ShouldRecordRelocInfo(rmode)) return;
+  DeferredRelocInfo rinfo(pc_offset(), rmode, data);
+  relocations_.push_back(rinfo);
+}
+
+void Assembler::EmitRelocations() {
+  EnsureSpaceFor(relocations_.size() * kMaxRelocSize);
+
+  for (std::vector<DeferredRelocInfo>::iterator it = relocations_.begin();
+       it != relocations_.end(); it++) {
+    RelocInfo::Mode rmode = it->rmode();
+    Address pc = reinterpret_cast<Address>(buffer_start_) + it->position();
+    RelocInfo rinfo(pc, rmode, it->data(), Code());
+
+    // Fix up internal references now that they are guaranteed to be bound.
+    if (RelocInfo::IsInternalReference(rmode)) {
+      // Jump table entry
+      intptr_t pos = static_cast<intptr_t>(Memory<Address>(pc));
+      Memory<Address>(pc) = reinterpret_cast<Address>(buffer_start_) + pos;
+    } else if (RelocInfo::IsInternalReferenceEncoded(rmode)) {
+      // mov sequence
+      intptr_t pos = static_cast<intptr_t>(target_address_at(pc, kNullAddress));
+      set_target_address_at(pc, 0,
+                            reinterpret_cast<Address>(buffer_start_) + pos,
+                            SKIP_ICACHE_FLUSH);
+    }
+
+    reloc_info_writer.Write(&rinfo);
+  }
+}
+
+void Assembler::BlockTrampolinePoolFor(int instructions) {
+  BlockTrampolinePoolBefore(pc_offset() + instructions * kInstrSize);
+}
+
+void Assembler::CheckTrampolinePool() {
+  // Some small sequences of instructions must not be broken up by the
+  // insertion of a trampoline pool; such sequences are protected by setting
+  // either trampoline_pool_blocked_nesting_ or no_trampoline_pool_before_,
+  // which are both checked here. Also, recursive calls to CheckTrampolinePool
+  // are blocked by trampoline_pool_blocked_nesting_.
+  if (trampoline_pool_blocked_nesting_ > 0) return;
+  if (pc_offset() < no_trampoline_pool_before_) {
+    next_trampoline_check_ = no_trampoline_pool_before_;
+    return;
+  }
+
+  DCHECK(!trampoline_emitted_);
+  if (tracked_branch_count_ > 0) {
+    int size = tracked_branch_count_ * kInstrSize;
+
+    // As we are only going to emit trampoline once, we need to prevent any
+    // further emission.
+    trampoline_emitted_ = true;
+    next_trampoline_check_ = kMaxInt;
+
+    // First we emit jump, then we emit trampoline pool.
+    b(size + kInstrSize, LeaveLK);
+    for (int i = size; i > 0; i -= kInstrSize) {
+      b(i, LeaveLK);
+    }
+
+    trampoline_ = Trampoline(pc_offset() - size, tracked_branch_count_);
+  }
+}
+
+PatchingAssembler::PatchingAssembler(const AssemblerOptions& options,
+                                     byte* address, int instructions)
+    : Assembler(options, ExternalAssemblerBuffer(
+                             address, instructions * kInstrSize + kGap)) {
+  DCHECK_EQ(reloc_info_writer.pos(), buffer_start_ + buffer_->size());
+}
+
+PatchingAssembler::~PatchingAssembler() {
+  // Check that the code was patched as expected.
+  DCHECK_EQ(pc_, buffer_start_ + buffer_->size() - kGap);
+  DCHECK_EQ(reloc_info_writer.pos(), buffer_start_ + buffer_->size());
+}
+
+UseScratchRegisterScope::UseScratchRegisterScope(Assembler* assembler)
+    : assembler_(assembler),
+      old_available_(*assembler->GetScratchRegisterList()) {}
+
+UseScratchRegisterScope::~UseScratchRegisterScope() {
+  *assembler_->GetScratchRegisterList() = old_available_;
+}
+
+Register UseScratchRegisterScope::Acquire() {
+  RegList* available = assembler_->GetScratchRegisterList();
+  DCHECK_NOT_NULL(available);
+  DCHECK_NE(*available, 0);
+  int index = static_cast<int>(base::bits::CountTrailingZeros32(*available));
+  Register reg = Register::from_code(index);
+  *available &= ~reg.bit();
+  return reg;
+}
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/assembler-ppc.h b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/assembler-ppc.h
--- a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/assembler-ppc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/assembler-ppc.h	2025-06-04 10:11:01.000000000 +0800
@@ -0,0 +1,1438 @@
+// Copyright (c) 1994-2006 Sun Microsystems Inc.
+// All Rights Reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+//
+// - Redistributions of source code must retain the above copyright notice,
+// this list of conditions and the following disclaimer.
+//
+// - Redistribution in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the
+// distribution.
+//
+// - Neither the name of Sun Microsystems or the names of contributors may
+// be used to endorse or promote products derived from this software without
+// specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+// OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// The original source code covered by the above license above has been
+// modified significantly by Google Inc.
+// Copyright 2014 the V8 project authors. All rights reserved.
+
+// A light-weight PPC Assembler
+// Generates user mode instructions for the PPC architecture up
+
+#ifndef V8_CODEGEN_PPC_ASSEMBLER_PPC_H_
+#define V8_CODEGEN_PPC_ASSEMBLER_PPC_H_
+
+#include <stdio.h>
+#include <memory>
+#include <vector>
+
+#include "src/codegen/assembler.h"
+#include "src/codegen/constant-pool.h"
+#include "src/codegen/external-reference.h"
+#include "src/codegen/label.h"
+#include "src/codegen/ppc/constants-ppc.h"
+#include "src/codegen/ppc/register-ppc.h"
+#include "src/numbers/double.h"
+#include "src/objects/smi.h"
+
+namespace v8 {
+namespace internal {
+
+class SafepointTableBuilder;
+
+// -----------------------------------------------------------------------------
+// Machine instruction Operands
+
+// Class Operand represents a shifter operand in data processing instructions
+class V8_EXPORT_PRIVATE Operand {
+ public:
+  // immediate
+  V8_INLINE explicit Operand(intptr_t immediate,
+                             RelocInfo::Mode rmode = RelocInfo::NONE)
+      : rmode_(rmode) {
+    value_.immediate = immediate;
+  }
+  V8_INLINE static Operand Zero() { return Operand(static_cast<intptr_t>(0)); }
+  V8_INLINE explicit Operand(const ExternalReference& f)
+      : rmode_(RelocInfo::EXTERNAL_REFERENCE) {
+    value_.immediate = static_cast<intptr_t>(f.address());
+  }
+  explicit Operand(Handle<HeapObject> handle);
+  V8_INLINE explicit Operand(Smi value) : rmode_(RelocInfo::NONE) {
+    value_.immediate = static_cast<intptr_t>(value.ptr());
+  }
+  // rm
+  V8_INLINE explicit Operand(Register rm);
+
+  static Operand EmbeddedNumber(double number);  // Smi or HeapNumber.
+  static Operand EmbeddedStringConstant(const StringConstantBase* str);
+
+  // Return true if this is a register operand.
+  V8_INLINE bool is_reg() const { return rm_.is_valid(); }
+
+  bool must_output_reloc_info(const Assembler* assembler) const;
+
+  inline intptr_t immediate() const {
+    DCHECK(IsImmediate());
+    DCHECK(!IsHeapObjectRequest());
+    return value_.immediate;
+  }
+  bool IsImmediate() const { return !rm_.is_valid(); }
+
+  HeapObjectRequest heap_object_request() const {
+    DCHECK(IsHeapObjectRequest());
+    return value_.heap_object_request;
+  }
+
+  Register rm() const { return rm_; }
+
+  bool IsHeapObjectRequest() const {
+    DCHECK_IMPLIES(is_heap_object_request_, IsImmediate());
+    DCHECK_IMPLIES(is_heap_object_request_,
+                   rmode_ == RelocInfo::FULL_EMBEDDED_OBJECT ||
+                       rmode_ == RelocInfo::CODE_TARGET);
+    return is_heap_object_request_;
+  }
+
+ private:
+  Register rm_ = no_reg;
+  union Value {
+    Value() {}
+    HeapObjectRequest heap_object_request;  // if is_heap_object_request_
+    intptr_t immediate;                     // otherwise
+  } value_;                                 // valid if rm_ == no_reg
+  bool is_heap_object_request_ = false;
+
+  RelocInfo::Mode rmode_;
+
+  friend class Assembler;
+  friend class MacroAssembler;
+};
+
+// Class MemOperand represents a memory operand in load and store instructions
+// On PowerPC we have base register + 16bit signed value
+// Alternatively we can have a 16bit signed value immediate
+class V8_EXPORT_PRIVATE MemOperand {
+ public:
+  explicit MemOperand(Register rn, int32_t offset = 0);
+
+  explicit MemOperand(Register ra, Register rb);
+
+  int32_t offset() const { return offset_; }
+
+  // PowerPC - base register
+  Register ra() const { return ra_; }
+
+  Register rb() const { return rb_; }
+
+ private:
+  Register ra_;     // base
+  int32_t offset_;  // offset
+  Register rb_;     // index
+
+  friend class Assembler;
+};
+
+class DeferredRelocInfo {
+ public:
+  DeferredRelocInfo() {}
+  DeferredRelocInfo(int position, RelocInfo::Mode rmode, intptr_t data)
+      : position_(position), rmode_(rmode), data_(data) {}
+
+  int position() const { return position_; }
+  RelocInfo::Mode rmode() const { return rmode_; }
+  intptr_t data() const { return data_; }
+
+ private:
+  int position_;
+  RelocInfo::Mode rmode_;
+  intptr_t data_;
+};
+
+class Assembler : public AssemblerBase {
+ public:
+  // Create an assembler. Instructions and relocation information are emitted
+  // into a buffer, with the instructions starting from the beginning and the
+  // relocation information starting from the end of the buffer. See CodeDesc
+  // for a detailed comment on the layout (globals.h).
+  //
+  // If the provided buffer is nullptr, the assembler allocates and grows its
+  // own buffer. Otherwise it takes ownership of the provided buffer.
+  explicit Assembler(const AssemblerOptions&,
+                     std::unique_ptr<AssemblerBuffer> = {});
+
+  virtual ~Assembler() {}
+
+  // GetCode emits any pending (non-emitted) code and fills the descriptor desc.
+  static constexpr int kNoHandlerTable = 0;
+  static constexpr SafepointTableBuilder* kNoSafepointTable = nullptr;
+  void GetCode(Isolate* isolate, CodeDesc* desc,
+               SafepointTableBuilder* safepoint_table_builder,
+               int handler_table_offset);
+
+  // Convenience wrapper for code without safepoint or handler tables.
+  void GetCode(Isolate* isolate, CodeDesc* desc) {
+    GetCode(isolate, desc, kNoSafepointTable, kNoHandlerTable);
+  }
+
+  void MaybeEmitOutOfLineConstantPool() { EmitConstantPool(); }
+
+  // Label operations & relative jumps (PPUM Appendix D)
+  //
+  // Takes a branch opcode (cc) and a label (L) and generates
+  // either a backward branch or a forward branch and links it
+  // to the label fixup chain. Usage:
+  //
+  // Label L;    // unbound label
+  // j(cc, &L);  // forward branch to unbound label
+  // bind(&L);   // bind label to the current pc
+  // j(cc, &L);  // backward branch to bound label
+  // bind(&L);   // illegal: a label may be bound only once
+  //
+  // Note: The same Label can be used for forward and backward branches
+  // but it may be bound only once.
+
+  void bind(Label* L);  // binds an unbound label L to the current code position
+
+  // Links a label at the current pc_offset().  If already bound, returns the
+  // bound position.  If already linked, returns the position of the prior link.
+  // Otherwise, returns the current pc_offset().
+  int link(Label* L);
+
+  // Determines if Label is bound and near enough so that a single
+  // branch instruction can be used to reach it.
+  bool is_near(Label* L, Condition cond);
+
+  // Returns the branch offset to the given label from the current code position
+  // Links the label to the current position if it is still unbound
+  int branch_offset(Label* L) {
+    if (L->is_unused() && !trampoline_emitted_) {
+      TrackBranch();
+    }
+    return link(L) - pc_offset();
+  }
+
+  V8_INLINE static bool IsConstantPoolLoadStart(
+      Address pc, ConstantPoolEntry::Access* access = nullptr);
+  V8_INLINE static bool IsConstantPoolLoadEnd(
+      Address pc, ConstantPoolEntry::Access* access = nullptr);
+  V8_INLINE static int GetConstantPoolOffset(Address pc,
+                                             ConstantPoolEntry::Access access,
+                                             ConstantPoolEntry::Type type);
+  V8_INLINE void PatchConstantPoolAccessInstruction(
+      int pc_offset, int offset, ConstantPoolEntry::Access access,
+      ConstantPoolEntry::Type type);
+
+  // Return the address in the constant pool of the code target address used by
+  // the branch/call instruction at pc, or the object in a mov.
+  V8_INLINE static Address target_constant_pool_address_at(
+      Address pc, Address constant_pool, ConstantPoolEntry::Access access,
+      ConstantPoolEntry::Type type);
+
+  // Read/Modify the code target address in the branch/call instruction at pc.
+  // The isolate argument is unused (and may be nullptr) when skipping flushing.
+  V8_INLINE static Address target_address_at(Address pc, Address constant_pool);
+  V8_INLINE static void set_target_address_at(
+      Address pc, Address constant_pool, Address target,
+      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);
+
+  // Read/Modify the code target address in the branch/call instruction at pc.
+  inline static Tagged_t target_compressed_address_at(Address pc,
+                                                      Address constant_pool);
+  inline static void set_target_compressed_address_at(
+      Address pc, Address constant_pool, Tagged_t target,
+      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);
+
+  inline Handle<Object> code_target_object_handle_at(Address pc,
+                                                     Address constant_pool);
+  inline Handle<HeapObject> compressed_embedded_object_handle_at(
+      Address pc, Address constant_pool);
+
+  // This sets the branch destination.
+  // This is for calls and branches within generated code.
+  inline static void deserialization_set_special_target_at(
+      Address instruction_payload, Code code, Address target);
+
+  // Get the size of the special target encoded at 'instruction_payload'.
+  inline static int deserialization_special_target_size(
+      Address instruction_payload);
+
+  // This sets the internal reference at the pc.
+  inline static void deserialization_set_target_internal_reference_at(
+      Address pc, Address target,
+      RelocInfo::Mode mode = RelocInfo::INTERNAL_REFERENCE);
+
+  // Here we are patching the address in the LUI/ORI instruction pair.
+  // These values are used in the serialization process and must be zero for
+  // PPC platform, as Code, Embedded Object or External-reference pointers
+  // are split across two consecutive instructions and don't exist separately
+  // in the code, so the serializer should not step forwards in memory after
+  // a target is resolved and written.
+  static constexpr int kSpecialTargetSize = 0;
+
+// Number of instructions to load an address via a mov sequence.
+#if V8_TARGET_ARCH_PPC64
+  static constexpr int kMovInstructionsConstantPool = 1;
+  static constexpr int kMovInstructionsNoConstantPool = 5;
+#if defined(V8_PPC_TAGGING_OPT)
+  static constexpr int kTaggedLoadInstructions = 1;
+#else
+  static constexpr int kTaggedLoadInstructions = 2;
+#endif
+#else
+  static constexpr int kMovInstructionsConstantPool = 1;
+  static constexpr int kMovInstructionsNoConstantPool = 2;
+  static constexpr int kTaggedLoadInstructions = 1;
+#endif
+  static constexpr int kMovInstructions = FLAG_enable_embedded_constant_pool
+                                              ? kMovInstructionsConstantPool
+                                              : kMovInstructionsNoConstantPool;
+
+  static inline int encode_crbit(const CRegister& cr, enum CRBit crbit) {
+    return ((cr.code() * CRWIDTH) + crbit);
+  }
+
+#define DECLARE_PPC_X_INSTRUCTIONS_A_FORM(name, instr_name, instr_value)    \
+  inline void name(const Register rt, const Register ra, const Register rb, \
+                   const RCBit rc = LeaveRC) {                              \
+    x_form(instr_name, rt, ra, rb, rc);                                     \
+  }
+
+#define DECLARE_PPC_X_INSTRUCTIONS_B_FORM(name, instr_name, instr_value)    \
+  inline void name(const Register ra, const Register rs, const Register rb, \
+                   const RCBit rc = LeaveRC) {                              \
+    x_form(instr_name, rs, ra, rb, rc);                                     \
+  }
+
+#define DECLARE_PPC_X_INSTRUCTIONS_C_FORM(name, instr_name, instr_value) \
+  inline void name(const Register dst, const Register src,               \
+                   const RCBit rc = LeaveRC) {                           \
+    x_form(instr_name, src, dst, r0, rc);                                \
+  }
+
+#define DECLARE_PPC_X_INSTRUCTIONS_D_FORM(name, instr_name, instr_value) \
+  template <class R>                                                     \
+  inline void name(const R rt, const Register ra, const Register rb,     \
+                   const RCBit rc = LeaveRC) {                           \
+    x_form(instr_name, rt.code(), ra.code(), rb.code(), rc);             \
+  }                                                                      \
+  template <class R>                                                     \
+  inline void name(const R dst, const MemOperand& src) {                 \
+    name(dst, src.ra(), src.rb());                                       \
+  }
+
+#define DECLARE_PPC_X_INSTRUCTIONS_E_FORM(name, instr_name, instr_value) \
+  inline void name(const Register dst, const Register src, const int sh, \
+                   const RCBit rc = LeaveRC) {                           \
+    x_form(instr_name, src.code(), dst.code(), sh, rc);                  \
+  }
+
+#define DECLARE_PPC_X_INSTRUCTIONS_F_FORM(name, instr_name, instr_value)    \
+  inline void name(const Register src1, const Register src2,                \
+                   const CRegister cr = cr7, const RCBit rc = LeaveRC) {    \
+    x_form(instr_name, cr, src1, src2, rc);                                 \
+  }                                                                         \
+  inline void name##w(const Register src1, const Register src2,             \
+                      const CRegister cr = cr7, const RCBit rc = LeaveRC) { \
+    x_form(instr_name, cr.code() * B2, src1.code(), src2.code(), LeaveRC);  \
+  }
+
+#define DECLARE_PPC_X_INSTRUCTIONS_EH_S_FORM(name, instr_name, instr_value) \
+  inline void name(const Register dst, const MemOperand& src) {             \
+    x_form(instr_name, src.ra(), dst, src.rb(), SetEH);                     \
+  }
+#define DECLARE_PPC_X_INSTRUCTIONS_EH_L_FORM(name, instr_name, instr_value) \
+  inline void name(const Register dst, const MemOperand& src) {             \
+    DCHECK(src.ra_ != r0);                                                  \
+    x_form(instr_name, src.ra(), dst, src.rb(), SetEH);                     \
+  }
+
+  inline void x_form(Instr instr, int f1, int f2, int f3, int rc) {
+    emit(instr | f1 * B21 | f2 * B16 | f3 * B11 | rc);
+  }
+  inline void x_form(Instr instr, Register rs, Register ra, Register rb,
+                     RCBit rc) {
+    emit(instr | rs.code() * B21 | ra.code() * B16 | rb.code() * B11 | rc);
+  }
+  inline void x_form(Instr instr, Register ra, Register rs, Register rb,
+                     EHBit eh = SetEH) {
+    emit(instr | rs.code() * B21 | ra.code() * B16 | rb.code() * B11 | eh);
+  }
+  inline void x_form(Instr instr, CRegister cr, Register s1, Register s2,
+                     RCBit rc) {
+#if V8_TARGET_ARCH_PPC64
+    int L = 1;
+#else
+    int L = 0;
+#endif
+    emit(instr | cr.code() * B23 | L * B21 | s1.code() * B16 | s2.code() * B11 |
+         rc);
+  }
+
+  PPC_X_OPCODE_A_FORM_LIST(DECLARE_PPC_X_INSTRUCTIONS_A_FORM)
+  PPC_X_OPCODE_B_FORM_LIST(DECLARE_PPC_X_INSTRUCTIONS_B_FORM)
+  PPC_X_OPCODE_C_FORM_LIST(DECLARE_PPC_X_INSTRUCTIONS_C_FORM)
+  PPC_X_OPCODE_D_FORM_LIST(DECLARE_PPC_X_INSTRUCTIONS_D_FORM)
+  PPC_X_OPCODE_E_FORM_LIST(DECLARE_PPC_X_INSTRUCTIONS_E_FORM)
+  PPC_X_OPCODE_F_FORM_LIST(DECLARE_PPC_X_INSTRUCTIONS_F_FORM)
+  PPC_X_OPCODE_EH_S_FORM_LIST(DECLARE_PPC_X_INSTRUCTIONS_EH_S_FORM)
+  PPC_X_OPCODE_EH_L_FORM_LIST(DECLARE_PPC_X_INSTRUCTIONS_EH_L_FORM)
+
+  inline void notx(Register dst, Register src, RCBit rc = LeaveRC) {
+    nor(dst, src, src, rc);
+  }
+  inline void lwax(Register rt, const MemOperand& src) {
+#if V8_TARGET_ARCH_PPC64
+    Register ra = src.ra();
+    Register rb = src.rb();
+    DCHECK(ra != r0);
+    x_form(LWAX, rt, ra, rb, LeaveRC);
+#else
+    lwzx(rt, src);
+#endif
+  }
+  inline void extsw(Register rs, Register ra, RCBit rc = LeaveRC) {
+#if V8_TARGET_ARCH_PPC64
+    emit(EXT2 | EXTSW | ra.code() * B21 | rs.code() * B16 | rc);
+#else
+    // nop on 32-bit
+    DCHECK(rs == ra && rc == LeaveRC);
+#endif
+  }
+
+#undef DECLARE_PPC_X_INSTRUCTIONS_A_FORM
+#undef DECLARE_PPC_X_INSTRUCTIONS_B_FORM
+#undef DECLARE_PPC_X_INSTRUCTIONS_C_FORM
+#undef DECLARE_PPC_X_INSTRUCTIONS_D_FORM
+#undef DECLARE_PPC_X_INSTRUCTIONS_E_FORM
+#undef DECLARE_PPC_X_INSTRUCTIONS_F_FORM
+#undef DECLARE_PPC_X_INSTRUCTIONS_EH_S_FORM
+#undef DECLARE_PPC_X_INSTRUCTIONS_EH_L_FORM
+
+#define DECLARE_PPC_XX2_INSTRUCTIONS(name, instr_name, instr_value)      \
+  inline void name(const Simd128Register rt, const Simd128Register rb) { \
+    xx2_form(instr_name, rt, rb);                                        \
+  }
+
+  inline void xx2_form(Instr instr, Simd128Register t, Simd128Register b) {
+    // Using VR (high VSR) registers.
+    int BX = 1;
+    int TX = 1;
+
+    emit(instr | (t.code() & 0x1F) * B21 | (b.code() & 0x1F) * B11 | BX * B1 |
+         TX);
+  }
+
+  PPC_XX2_OPCODE_A_FORM_LIST(DECLARE_PPC_XX2_INSTRUCTIONS)
+#undef DECLARE_PPC_XX2_INSTRUCTIONS
+
+#define DECLARE_PPC_XX3_INSTRUCTIONS(name, instr_name, instr_value)  \
+  inline void name(const DoubleRegister rt, const DoubleRegister ra, \
+                   const DoubleRegister rb) {                        \
+    xx3_form(instr_name, rt, ra, rb);                                \
+  }
+
+  inline void xx3_form(Instr instr, DoubleRegister t, DoubleRegister a,
+                       DoubleRegister b) {
+    // Using VR (high VSR) registers.
+    int AX = 1;
+    int BX = 1;
+    int TX = 1;
+
+    emit(instr | (t.code() & 0x1F) * B21 | (a.code() & 0x1F) * B16 |
+         (b.code() & 0x1F) * B11 | AX * B2 | BX * B1 | TX);
+  }
+
+  PPC_XX3_OPCODE_LIST(DECLARE_PPC_XX3_INSTRUCTIONS)
+#undef DECLARE_PPC_XX3_INSTRUCTIONS
+
+#define DECLARE_PPC_VX_INSTRUCTIONS_A_FORM(name, instr_name, instr_value) \
+  inline void name(const Simd128Register rt, const Simd128Register rb,    \
+                   const Operand& imm) {                                  \
+    vx_form(instr_name, rt, rb, imm);                                     \
+  }
+#define DECLARE_PPC_VX_INSTRUCTIONS_B_FORM(name, instr_name, instr_value) \
+  inline void name(const Simd128Register rt, const Simd128Register ra,    \
+                   const Simd128Register rb) {                            \
+    vx_form(instr_name, rt, ra, rb);                                      \
+  }
+#define DECLARE_PPC_VX_INSTRUCTIONS_C_FORM(name, instr_name, instr_value) \
+  inline void name(const Simd128Register rt, const Simd128Register rb) {  \
+    vx_form(instr_name, rt, rb);                                          \
+  }
+
+  inline void vx_form(Instr instr, Simd128Register rt, Simd128Register rb,
+                      const Operand& imm) {
+    emit(instr | rt.code() * B21 | imm.immediate() * B16 | rb.code() * B11);
+  }
+  inline void vx_form(Instr instr, Simd128Register rt, Simd128Register ra,
+                      Simd128Register rb) {
+    emit(instr | rt.code() * B21 | ra.code() * B16 | rb.code() * B11);
+  }
+  inline void vx_form(Instr instr, Simd128Register rt, Simd128Register rb) {
+    emit(instr | rt.code() * B21 | rb.code() * B11);
+  }
+
+  PPC_VX_OPCODE_A_FORM_LIST(DECLARE_PPC_VX_INSTRUCTIONS_A_FORM)
+  PPC_VX_OPCODE_B_FORM_LIST(DECLARE_PPC_VX_INSTRUCTIONS_B_FORM)
+  PPC_VX_OPCODE_C_FORM_LIST(DECLARE_PPC_VX_INSTRUCTIONS_C_FORM)
+#undef DECLARE_PPC_VX_INSTRUCTIONS_A_FORM
+#undef DECLARE_PPC_VX_INSTRUCTIONS_B_FORM
+#undef DECLARE_PPC_VX_INSTRUCTIONS_C_FORM
+
+#define DECLARE_PPC_VA_INSTRUCTIONS_A_FORM(name, instr_name, instr_value) \
+  inline void name(const Simd128Register rt, const Simd128Register ra,    \
+                   const Simd128Register rb, const Simd128Register rc) {  \
+    va_form(instr_name, rt, ra, rb, rc);                                  \
+  }
+
+  inline void va_form(Instr instr, Simd128Register rt, Simd128Register ra,
+                      Simd128Register rb, Simd128Register rc) {
+    emit(instr | rt.code() * B21 | ra.code() * B16 | rb.code() * B11 |
+         rc.code() * B6);
+  }
+
+  PPC_VA_OPCODE_A_FORM_LIST(DECLARE_PPC_VA_INSTRUCTIONS_A_FORM)
+#undef DECLARE_PPC_VA_INSTRUCTIONS_A_FORM
+
+#define DECLARE_PPC_VC_INSTRUCTIONS(name, instr_name, instr_value)       \
+  inline void name(const Simd128Register rt, const Simd128Register ra,   \
+                   const Simd128Register rb, const RCBit rc = LeaveRC) { \
+    vc_form(instr_name, rt, ra, rb, rc);                                 \
+  }
+
+  inline void vc_form(Instr instr, Simd128Register rt, Simd128Register ra,
+                      Simd128Register rb, int rc) {
+    emit(instr | rt.code() * B21 | ra.code() * B16 | rb.code() * B11 |
+         rc * B10);
+  }
+
+  PPC_VC_OPCODE_LIST(DECLARE_PPC_VC_INSTRUCTIONS)
+#undef DECLARE_PPC_VC_INSTRUCTIONS
+
+  RegList* GetScratchRegisterList() { return &scratch_register_list_; }
+  // ---------------------------------------------------------------------------
+  // Code generation
+
+  // Insert the smallest number of nop instructions
+  // possible to align the pc offset to a multiple
+  // of m. m must be a power of 2 (>= 4).
+  void Align(int m);
+  // Insert the smallest number of zero bytes possible to align the pc offset
+  // to a mulitple of m. m must be a power of 2 (>= 2).
+  void DataAlign(int m);
+  // Aligns code to something that's optimal for a jump target for the platform.
+  void CodeTargetAlign();
+
+  // Branch instructions
+  void bclr(BOfield bo, int condition_bit, LKBit lk);
+  void blr();
+  void bc(int branch_offset, BOfield bo, int condition_bit, LKBit lk = LeaveLK);
+  void b(int branch_offset, LKBit lk);
+
+  void bcctr(BOfield bo, int condition_bit, LKBit lk);
+  void bctr();
+  void bctrl();
+
+  // Convenience branch instructions using labels
+  void b(Label* L, LKBit lk = LeaveLK) { b(branch_offset(L), lk); }
+
+  inline CRegister cmpi_optimization(CRegister cr) {
+    // Check whether the branch is preceded by an optimizable cmpi against 0.
+    // The cmpi can be deleted if it is also preceded by an instruction that
+    // sets the register used by the compare and supports a dot form.
+    unsigned int sradi_mask = kOpcodeMask | kExt2OpcodeVariant2Mask;
+    unsigned int srawi_mask = kOpcodeMask | kExt2OpcodeMask;
+    int pos = pc_offset();
+    int cmpi_pos = pc_offset() - kInstrSize;
+
+    if (cmpi_pos > 0 && optimizable_cmpi_pos_ == cmpi_pos &&
+        cmpi_cr_.code() == cr.code() && last_bound_pos_ != pos) {
+      int xpos = cmpi_pos - kInstrSize;
+      int xinstr = instr_at(xpos);
+      int cmpi_ra = (instr_at(cmpi_pos) & 0x1f0000) >> 16;
+      // ra is at the same bit position for the three cases below.
+      int ra = (xinstr & 0x1f0000) >> 16;
+      if (cmpi_ra == ra) {
+        if ((xinstr & sradi_mask) == (EXT2 | SRADIX)) {
+          cr = cr0;
+          instr_at_put(xpos, xinstr | SetRC);
+          pc_ -= kInstrSize;
+        } else if ((xinstr & srawi_mask) == (EXT2 | SRAWIX)) {
+          cr = cr0;
+          instr_at_put(xpos, xinstr | SetRC);
+          pc_ -= kInstrSize;
+        } else if ((xinstr & kOpcodeMask) == ANDIx) {
+          cr = cr0;
+          pc_ -= kInstrSize;
+          // nothing to do here since andi. records.
+        }
+        // didn't match one of the above, must keep cmpwi.
+      }
+    }
+    return cr;
+  }
+
+  void bc_short(Condition cond, Label* L, CRegister cr = cr7,
+                LKBit lk = LeaveLK) {
+    DCHECK(cond != al);
+    DCHECK(cr.code() >= 0 && cr.code() <= 7);
+
+    cr = cmpi_optimization(cr);
+
+    int b_offset = branch_offset(L);
+
+    switch (cond) {
+      case eq:
+        bc(b_offset, BT, encode_crbit(cr, CR_EQ), lk);
+        break;
+      case ne:
+        bc(b_offset, BF, encode_crbit(cr, CR_EQ), lk);
+        break;
+      case gt:
+        bc(b_offset, BT, encode_crbit(cr, CR_GT), lk);
+        break;
+      case le:
+        bc(b_offset, BF, encode_crbit(cr, CR_GT), lk);
+        break;
+      case lt:
+        bc(b_offset, BT, encode_crbit(cr, CR_LT), lk);
+        break;
+      case ge:
+        bc(b_offset, BF, encode_crbit(cr, CR_LT), lk);
+        break;
+      case unordered:
+        bc(b_offset, BT, encode_crbit(cr, CR_FU), lk);
+        break;
+      case ordered:
+        bc(b_offset, BF, encode_crbit(cr, CR_FU), lk);
+        break;
+      case overflow:
+        bc(b_offset, BT, encode_crbit(cr, CR_SO), lk);
+        break;
+      case nooverflow:
+        bc(b_offset, BF, encode_crbit(cr, CR_SO), lk);
+        break;
+      default:
+        UNIMPLEMENTED();
+    }
+  }
+
+  void bclr(Condition cond, CRegister cr = cr7, LKBit lk = LeaveLK) {
+    DCHECK(cond != al);
+    DCHECK(cr.code() >= 0 && cr.code() <= 7);
+
+    cr = cmpi_optimization(cr);
+
+    switch (cond) {
+      case eq:
+        bclr(BT, encode_crbit(cr, CR_EQ), lk);
+        break;
+      case ne:
+        bclr(BF, encode_crbit(cr, CR_EQ), lk);
+        break;
+      case gt:
+        bclr(BT, encode_crbit(cr, CR_GT), lk);
+        break;
+      case le:
+        bclr(BF, encode_crbit(cr, CR_GT), lk);
+        break;
+      case lt:
+        bclr(BT, encode_crbit(cr, CR_LT), lk);
+        break;
+      case ge:
+        bclr(BF, encode_crbit(cr, CR_LT), lk);
+        break;
+      case unordered:
+        bclr(BT, encode_crbit(cr, CR_FU), lk);
+        break;
+      case ordered:
+        bclr(BF, encode_crbit(cr, CR_FU), lk);
+        break;
+      case overflow:
+        bclr(BT, encode_crbit(cr, CR_SO), lk);
+        break;
+      case nooverflow:
+        bclr(BF, encode_crbit(cr, CR_SO), lk);
+        break;
+      default:
+        UNIMPLEMENTED();
+    }
+  }
+
+  void isel(Register rt, Register ra, Register rb, int cb);
+  void isel(Condition cond, Register rt, Register ra, Register rb,
+            CRegister cr = cr7) {
+    DCHECK(cond != al);
+    DCHECK(cr.code() >= 0 && cr.code() <= 7);
+
+    cr = cmpi_optimization(cr);
+
+    switch (cond) {
+      case eq:
+        isel(rt, ra, rb, encode_crbit(cr, CR_EQ));
+        break;
+      case ne:
+        isel(rt, rb, ra, encode_crbit(cr, CR_EQ));
+        break;
+      case gt:
+        isel(rt, ra, rb, encode_crbit(cr, CR_GT));
+        break;
+      case le:
+        isel(rt, rb, ra, encode_crbit(cr, CR_GT));
+        break;
+      case lt:
+        isel(rt, ra, rb, encode_crbit(cr, CR_LT));
+        break;
+      case ge:
+        isel(rt, rb, ra, encode_crbit(cr, CR_LT));
+        break;
+      case unordered:
+        isel(rt, ra, rb, encode_crbit(cr, CR_FU));
+        break;
+      case ordered:
+        isel(rt, rb, ra, encode_crbit(cr, CR_FU));
+        break;
+      case overflow:
+        isel(rt, ra, rb, encode_crbit(cr, CR_SO));
+        break;
+      case nooverflow:
+        isel(rt, rb, ra, encode_crbit(cr, CR_SO));
+        break;
+      default:
+        UNIMPLEMENTED();
+    }
+  }
+
+  void b(Condition cond, Label* L, CRegister cr = cr7, LKBit lk = LeaveLK) {
+    if (cond == al) {
+      b(L, lk);
+      return;
+    }
+
+    if ((L->is_bound() && is_near(L, cond)) || !is_trampoline_emitted()) {
+      bc_short(cond, L, cr, lk);
+      return;
+    }
+
+    Label skip;
+    Condition neg_cond = NegateCondition(cond);
+    bc_short(neg_cond, &skip, cr);
+    b(L, lk);
+    bind(&skip);
+  }
+
+  void bne(Label* L, CRegister cr = cr7, LKBit lk = LeaveLK) {
+    b(ne, L, cr, lk);
+  }
+  void beq(Label* L, CRegister cr = cr7, LKBit lk = LeaveLK) {
+    b(eq, L, cr, lk);
+  }
+  void blt(Label* L, CRegister cr = cr7, LKBit lk = LeaveLK) {
+    b(lt, L, cr, lk);
+  }
+  void bge(Label* L, CRegister cr = cr7, LKBit lk = LeaveLK) {
+    b(ge, L, cr, lk);
+  }
+  void ble(Label* L, CRegister cr = cr7, LKBit lk = LeaveLK) {
+    b(le, L, cr, lk);
+  }
+  void bgt(Label* L, CRegister cr = cr7, LKBit lk = LeaveLK) {
+    b(gt, L, cr, lk);
+  }
+  void bunordered(Label* L, CRegister cr = cr7, LKBit lk = LeaveLK) {
+    b(unordered, L, cr, lk);
+  }
+  void bordered(Label* L, CRegister cr = cr7, LKBit lk = LeaveLK) {
+    b(ordered, L, cr, lk);
+  }
+  void boverflow(Label* L, CRegister cr = cr0, LKBit lk = LeaveLK) {
+    b(overflow, L, cr, lk);
+  }
+  void bnooverflow(Label* L, CRegister cr = cr0, LKBit lk = LeaveLK) {
+    b(nooverflow, L, cr, lk);
+  }
+
+  // Decrement CTR; branch if CTR != 0
+  void bdnz(Label* L, LKBit lk = LeaveLK) {
+    bc(branch_offset(L), DCBNZ, 0, lk);
+  }
+
+  // Data-processing instructions
+
+  void sub(Register dst, Register src1, Register src2, OEBit s = LeaveOE,
+           RCBit r = LeaveRC);
+
+  void subc(Register dst, Register src1, Register src2, OEBit s = LeaveOE,
+            RCBit r = LeaveRC);
+  void sube(Register dst, Register src1, Register src2, OEBit s = LeaveOE,
+            RCBit r = LeaveRC);
+
+  void subfic(Register dst, Register src, const Operand& imm);
+
+  void add(Register dst, Register src1, Register src2, OEBit s = LeaveOE,
+           RCBit r = LeaveRC);
+
+  void addc(Register dst, Register src1, Register src2, OEBit o = LeaveOE,
+            RCBit r = LeaveRC);
+  void adde(Register dst, Register src1, Register src2, OEBit o = LeaveOE,
+            RCBit r = LeaveRC);
+  void addze(Register dst, Register src1, OEBit o = LeaveOE, RCBit r = LeaveRC);
+
+  void mullw(Register dst, Register src1, Register src2, OEBit o = LeaveOE,
+             RCBit r = LeaveRC);
+
+  void mulhw(Register dst, Register src1, Register src2, RCBit r = LeaveRC);
+  void mulhwu(Register dst, Register src1, Register src2, RCBit r = LeaveRC);
+
+  void divw(Register dst, Register src1, Register src2, OEBit o = LeaveOE,
+            RCBit r = LeaveRC);
+  void divwu(Register dst, Register src1, Register src2, OEBit o = LeaveOE,
+             RCBit r = LeaveRC);
+
+  void addi(Register dst, Register src, const Operand& imm);
+  void addis(Register dst, Register src, const Operand& imm);
+  void addic(Register dst, Register src, const Operand& imm);
+
+  void andi(Register ra, Register rs, const Operand& imm);
+  void andis(Register ra, Register rs, const Operand& imm);
+  void ori(Register dst, Register src, const Operand& imm);
+  void oris(Register dst, Register src, const Operand& imm);
+  void xori(Register dst, Register src, const Operand& imm);
+  void xoris(Register ra, Register rs, const Operand& imm);
+  void cmpi(Register src1, const Operand& src2, CRegister cr = cr7);
+  void cmpli(Register src1, const Operand& src2, CRegister cr = cr7);
+  void cmpwi(Register src1, const Operand& src2, CRegister cr = cr7);
+  void cmplwi(Register src1, const Operand& src2, CRegister cr = cr7);
+  void li(Register dst, const Operand& src);
+  void lis(Register dst, const Operand& imm);
+  void mr(Register dst, Register src);
+
+  void lbz(Register dst, const MemOperand& src);
+  void lhz(Register dst, const MemOperand& src);
+  void lha(Register dst, const MemOperand& src);
+  void lwz(Register dst, const MemOperand& src);
+  void lwzu(Register dst, const MemOperand& src);
+  void lwa(Register dst, const MemOperand& src);
+  void stb(Register dst, const MemOperand& src);
+  void sth(Register dst, const MemOperand& src);
+  void stw(Register dst, const MemOperand& src);
+  void stwu(Register dst, const MemOperand& src);
+  void neg(Register rt, Register ra, OEBit o = LeaveOE, RCBit c = LeaveRC);
+
+#if V8_TARGET_ARCH_PPC64
+  void ld(Register rd, const MemOperand& src);
+  void ldu(Register rd, const MemOperand& src);
+  void std(Register rs, const MemOperand& src);
+  void stdu(Register rs, const MemOperand& src);
+  void rldic(Register dst, Register src, int sh, int mb, RCBit r = LeaveRC);
+  void rldicl(Register dst, Register src, int sh, int mb, RCBit r = LeaveRC);
+  void rldcl(Register ra, Register rs, Register rb, int mb, RCBit r = LeaveRC);
+  void rldicr(Register dst, Register src, int sh, int me, RCBit r = LeaveRC);
+  void rldimi(Register dst, Register src, int sh, int mb, RCBit r = LeaveRC);
+  void sldi(Register dst, Register src, const Operand& val, RCBit rc = LeaveRC);
+  void srdi(Register dst, Register src, const Operand& val, RCBit rc = LeaveRC);
+  void clrrdi(Register dst, Register src, const Operand& val,
+              RCBit rc = LeaveRC);
+  void clrldi(Register dst, Register src, const Operand& val,
+              RCBit rc = LeaveRC);
+  void sradi(Register ra, Register rs, int sh, RCBit r = LeaveRC);
+  void rotld(Register ra, Register rs, Register rb, RCBit r = LeaveRC);
+  void rotldi(Register ra, Register rs, int sh, RCBit r = LeaveRC);
+  void rotrdi(Register ra, Register rs, int sh, RCBit r = LeaveRC);
+  void mulld(Register dst, Register src1, Register src2, OEBit o = LeaveOE,
+             RCBit r = LeaveRC);
+  void divd(Register dst, Register src1, Register src2, OEBit o = LeaveOE,
+            RCBit r = LeaveRC);
+  void divdu(Register dst, Register src1, Register src2, OEBit o = LeaveOE,
+             RCBit r = LeaveRC);
+#endif
+
+  void rlwinm(Register ra, Register rs, int sh, int mb, int me,
+              RCBit rc = LeaveRC);
+  void rlwimi(Register ra, Register rs, int sh, int mb, int me,
+              RCBit rc = LeaveRC);
+  void rlwnm(Register ra, Register rs, Register rb, int mb, int me,
+             RCBit rc = LeaveRC);
+  void slwi(Register dst, Register src, const Operand& val, RCBit rc = LeaveRC);
+  void srwi(Register dst, Register src, const Operand& val, RCBit rc = LeaveRC);
+  void clrrwi(Register dst, Register src, const Operand& val,
+              RCBit rc = LeaveRC);
+  void clrlwi(Register dst, Register src, const Operand& val,
+              RCBit rc = LeaveRC);
+  void rotlw(Register ra, Register rs, Register rb, RCBit r = LeaveRC);
+  void rotlwi(Register ra, Register rs, int sh, RCBit r = LeaveRC);
+  void rotrwi(Register ra, Register rs, int sh, RCBit r = LeaveRC);
+
+  void subi(Register dst, Register src1, const Operand& src2);
+
+  void mov(Register dst, const Operand& src);
+  void bitwise_mov(Register dst, intptr_t value);
+  void bitwise_mov32(Register dst, int32_t value);
+  void bitwise_add32(Register dst, Register src, int32_t value);
+
+  // Load the position of the label relative to the generated code object
+  // pointer in a register.
+  void mov_label_offset(Register dst, Label* label);
+
+  // dst = base + label position + delta
+  void add_label_offset(Register dst, Register base, Label* label,
+                        int delta = 0);
+
+  // Load the address of the label in a register and associate with an
+  // internal reference relocation.
+  void mov_label_addr(Register dst, Label* label);
+
+  // Emit the address of the label (i.e. a jump table entry) and associate with
+  // an internal reference relocation.
+  void emit_label_addr(Label* label);
+
+  // Multiply instructions
+  void mul(Register dst, Register src1, Register src2, OEBit s = LeaveOE,
+           RCBit r = LeaveRC);
+
+  // Miscellaneous arithmetic instructions
+
+  // Special register access
+  void crxor(int bt, int ba, int bb);
+  void crclr(int bt) { crxor(bt, bt, bt); }
+  void creqv(int bt, int ba, int bb);
+  void crset(int bt) { creqv(bt, bt, bt); }
+  void mflr(Register dst);
+  void mtlr(Register src);
+  void mtctr(Register src);
+  void mtxer(Register src);
+  void mcrfs(CRegister cr, FPSCRBit bit);
+  void mfcr(Register dst);
+#if V8_TARGET_ARCH_PPC64
+  void mffprd(Register dst, DoubleRegister src);
+  void mffprwz(Register dst, DoubleRegister src);
+  void mtfprd(DoubleRegister dst, Register src);
+  void mtfprwz(DoubleRegister dst, Register src);
+  void mtfprwa(DoubleRegister dst, Register src);
+#endif
+
+  // Exception-generating instructions and debugging support
+  void stop(Condition cond = al, int32_t code = kDefaultStopCode,
+            CRegister cr = cr7);
+
+  void bkpt(uint32_t imm16);  // v5 and above
+
+  void dcbf(Register ra, Register rb);
+  void sync();
+  void lwsync();
+  void icbi(Register ra, Register rb);
+  void isync();
+
+  // Support for floating point
+  void lfd(const DoubleRegister frt, const MemOperand& src);
+  void lfdu(const DoubleRegister frt, const MemOperand& src);
+  void lfs(const DoubleRegister frt, const MemOperand& src);
+  void lfsu(const DoubleRegister frt, const MemOperand& src);
+  void stfd(const DoubleRegister frs, const MemOperand& src);
+  void stfdu(const DoubleRegister frs, const MemOperand& src);
+  void stfs(const DoubleRegister frs, const MemOperand& src);
+  void stfsu(const DoubleRegister frs, const MemOperand& src);
+
+  void fadd(const DoubleRegister frt, const DoubleRegister fra,
+            const DoubleRegister frb, RCBit rc = LeaveRC);
+  void fsub(const DoubleRegister frt, const DoubleRegister fra,
+            const DoubleRegister frb, RCBit rc = LeaveRC);
+  void fdiv(const DoubleRegister frt, const DoubleRegister fra,
+            const DoubleRegister frb, RCBit rc = LeaveRC);
+  void fmul(const DoubleRegister frt, const DoubleRegister fra,
+            const DoubleRegister frc, RCBit rc = LeaveRC);
+  void fcmpu(const DoubleRegister fra, const DoubleRegister frb,
+             CRegister cr = cr7);
+  void fmr(const DoubleRegister frt, const DoubleRegister frb,
+           RCBit rc = LeaveRC);
+  void fctiwz(const DoubleRegister frt, const DoubleRegister frb);
+  void fctiw(const DoubleRegister frt, const DoubleRegister frb);
+  void fctiwuz(const DoubleRegister frt, const DoubleRegister frb);
+  void frin(const DoubleRegister frt, const DoubleRegister frb,
+            RCBit rc = LeaveRC);
+  void friz(const DoubleRegister frt, const DoubleRegister frb,
+            RCBit rc = LeaveRC);
+  void frip(const DoubleRegister frt, const DoubleRegister frb,
+            RCBit rc = LeaveRC);
+  void frim(const DoubleRegister frt, const DoubleRegister frb,
+            RCBit rc = LeaveRC);
+  void frsp(const DoubleRegister frt, const DoubleRegister frb,
+            RCBit rc = LeaveRC);
+  void fcfid(const DoubleRegister frt, const DoubleRegister frb,
+             RCBit rc = LeaveRC);
+  void fcfidu(const DoubleRegister frt, const DoubleRegister frb,
+              RCBit rc = LeaveRC);
+  void fcfidus(const DoubleRegister frt, const DoubleRegister frb,
+               RCBit rc = LeaveRC);
+  void fcfids(const DoubleRegister frt, const DoubleRegister frb,
+              RCBit rc = LeaveRC);
+  void fctid(const DoubleRegister frt, const DoubleRegister frb,
+             RCBit rc = LeaveRC);
+  void fctidz(const DoubleRegister frt, const DoubleRegister frb,
+              RCBit rc = LeaveRC);
+  void fctidu(const DoubleRegister frt, const DoubleRegister frb,
+              RCBit rc = LeaveRC);
+  void fctiduz(const DoubleRegister frt, const DoubleRegister frb,
+               RCBit rc = LeaveRC);
+  void fsel(const DoubleRegister frt, const DoubleRegister fra,
+            const DoubleRegister frc, const DoubleRegister frb,
+            RCBit rc = LeaveRC);
+  void fneg(const DoubleRegister frt, const DoubleRegister frb,
+            RCBit rc = LeaveRC);
+  void mtfsb0(FPSCRBit bit, RCBit rc = LeaveRC);
+  void mtfsb1(FPSCRBit bit, RCBit rc = LeaveRC);
+  void mtfsfi(int bf, int immediate, RCBit rc = LeaveRC);
+  void mffs(const DoubleRegister frt, RCBit rc = LeaveRC);
+  void mtfsf(const DoubleRegister frb, bool L = 1, int FLM = 0, bool W = 0,
+             RCBit rc = LeaveRC);
+  void fsqrt(const DoubleRegister frt, const DoubleRegister frb,
+             RCBit rc = LeaveRC);
+  void fabs(const DoubleRegister frt, const DoubleRegister frb,
+            RCBit rc = LeaveRC);
+  void fmadd(const DoubleRegister frt, const DoubleRegister fra,
+             const DoubleRegister frc, const DoubleRegister frb,
+             RCBit rc = LeaveRC);
+  void fmsub(const DoubleRegister frt, const DoubleRegister fra,
+             const DoubleRegister frc, const DoubleRegister frb,
+             RCBit rc = LeaveRC);
+
+  // Vector instructions
+  void mfvsrd(const Register ra, const Simd128Register r);
+  void mfvsrwz(const Register ra, const Simd128Register r);
+  void mtvsrd(const Simd128Register rt, const Register ra);
+  void lxvd(const Simd128Register rt, const MemOperand& src);
+  void stxvd(const Simd128Register rt, const MemOperand& src);
+
+  // Pseudo instructions
+
+  // Different nop operations are used by the code generator to detect certain
+  // states of the generated code.
+  enum NopMarkerTypes {
+    NON_MARKING_NOP = 0,
+    GROUP_ENDING_NOP,
+    DEBUG_BREAK_NOP,
+    // IC markers.
+    PROPERTY_ACCESS_INLINED,
+    PROPERTY_ACCESS_INLINED_CONTEXT,
+    PROPERTY_ACCESS_INLINED_CONTEXT_DONT_DELETE,
+    // Helper values.
+    LAST_CODE_MARKER,
+    FIRST_IC_MARKER = PROPERTY_ACCESS_INLINED
+  };
+
+  void nop(int type = 0);  // 0 is the default non-marking type.
+
+  void push(Register src) {
+#if V8_TARGET_ARCH_PPC64
+    stdu(src, MemOperand(sp, -kSystemPointerSize));
+#else
+    stwu(src, MemOperand(sp, -kSystemPointerSize));
+#endif
+  }
+
+  void pop(Register dst) {
+#if V8_TARGET_ARCH_PPC64
+    ld(dst, MemOperand(sp));
+#else
+    lwz(dst, MemOperand(sp));
+#endif
+    addi(sp, sp, Operand(kSystemPointerSize));
+  }
+
+  void pop() { addi(sp, sp, Operand(kSystemPointerSize)); }
+
+  // Jump unconditionally to given label.
+  void jmp(Label* L) { b(L); }
+
+  // Check the code size generated from label to here.
+  int SizeOfCodeGeneratedSince(Label* label) {
+    return pc_offset() - label->pos();
+  }
+
+  // Check the number of instructions generated from label to here.
+  int InstructionsGeneratedSince(Label* label) {
+    return SizeOfCodeGeneratedSince(label) / kInstrSize;
+  }
+
+  // Class for scoping postponing the trampoline pool generation.
+  class BlockTrampolinePoolScope {
+   public:
+    explicit BlockTrampolinePoolScope(Assembler* assem) : assem_(assem) {
+      assem_->StartBlockTrampolinePool();
+    }
+    ~BlockTrampolinePoolScope() { assem_->EndBlockTrampolinePool(); }
+
+   private:
+    Assembler* assem_;
+
+    DISALLOW_IMPLICIT_CONSTRUCTORS(BlockTrampolinePoolScope);
+  };
+
+  // Class for scoping disabling constant pool entry merging
+  class BlockConstantPoolEntrySharingScope {
+   public:
+    explicit BlockConstantPoolEntrySharingScope(Assembler* assem)
+        : assem_(assem) {
+      assem_->StartBlockConstantPoolEntrySharing();
+    }
+    ~BlockConstantPoolEntrySharingScope() {
+      assem_->EndBlockConstantPoolEntrySharing();
+    }
+
+   private:
+    Assembler* assem_;
+
+    DISALLOW_IMPLICIT_CONSTRUCTORS(BlockConstantPoolEntrySharingScope);
+  };
+
+  // Record a deoptimization reason that can be used by a log or cpu profiler.
+  // Use --trace-deopt to enable.
+  void RecordDeoptReason(DeoptimizeReason reason, SourcePosition position,
+                         int id);
+
+  // Writes a single byte or word of data in the code stream.  Used
+  // for inline tables, e.g., jump-tables.
+  void db(uint8_t data);
+  void dd(uint32_t data);
+  void dq(uint64_t data);
+  void dp(uintptr_t data);
+
+  // Read/patch instructions
+  Instr instr_at(int pos) {
+    return *reinterpret_cast<Instr*>(buffer_start_ + pos);
+  }
+  void instr_at_put(int pos, Instr instr) {
+    *reinterpret_cast<Instr*>(buffer_start_ + pos) = instr;
+  }
+  static Instr instr_at(Address pc) { return *reinterpret_cast<Instr*>(pc); }
+  static void instr_at_put(Address pc, Instr instr) {
+    *reinterpret_cast<Instr*>(pc) = instr;
+  }
+  static Condition GetCondition(Instr instr);
+
+  static bool IsLis(Instr instr);
+  static bool IsLi(Instr instr);
+  static bool IsAddic(Instr instr);
+  static bool IsOri(Instr instr);
+
+  static bool IsBranch(Instr instr);
+  static Register GetRA(Instr instr);
+  static Register GetRB(Instr instr);
+#if V8_TARGET_ARCH_PPC64
+  static bool Is64BitLoadIntoR12(Instr instr1, Instr instr2, Instr instr3,
+                                 Instr instr4, Instr instr5);
+#else
+  static bool Is32BitLoadIntoR12(Instr instr1, Instr instr2);
+#endif
+
+  static bool IsCmpRegister(Instr instr);
+  static bool IsCmpImmediate(Instr instr);
+  static bool IsRlwinm(Instr instr);
+  static bool IsAndi(Instr instr);
+#if V8_TARGET_ARCH_PPC64
+  static bool IsRldicl(Instr instr);
+#endif
+  static bool IsCrSet(Instr instr);
+  static Register GetCmpImmediateRegister(Instr instr);
+  static int GetCmpImmediateRawImmediate(Instr instr);
+  static bool IsNop(Instr instr, int type = NON_MARKING_NOP);
+
+  // Postpone the generation of the trampoline pool for the specified number of
+  // instructions.
+  void BlockTrampolinePoolFor(int instructions);
+  void CheckTrampolinePool();
+
+  // For mov.  Return the number of actual instructions required to
+  // load the operand into a register.  This can be anywhere from
+  // one (constant pool small section) to five instructions (full
+  // 64-bit sequence).
+  //
+  // The value returned is only valid as long as no entries are added to the
+  // constant pool between this call and the actual instruction being emitted.
+  int instructions_required_for_mov(Register dst, const Operand& src) const;
+
+  // Decide between using the constant pool vs. a mov immediate sequence.
+  bool use_constant_pool_for_mov(Register dst, const Operand& src,
+                                 bool canOptimize) const;
+
+  // The code currently calls CheckBuffer() too often. This has the side
+  // effect of randomly growing the buffer in the middle of multi-instruction
+  // sequences.
+  //
+  // This function allows outside callers to check and grow the buffer
+  void EnsureSpaceFor(int space_needed);
+
+  int EmitConstantPool() { return constant_pool_builder_.Emit(this); }
+
+  bool ConstantPoolAccessIsInOverflow() const {
+    return constant_pool_builder_.NextAccess(ConstantPoolEntry::INTPTR) ==
+           ConstantPoolEntry::OVERFLOWED;
+  }
+
+  Label* ConstantPoolPosition() {
+    return constant_pool_builder_.EmittedPosition();
+  }
+
+  void EmitRelocations();
+
+ protected:
+  int buffer_space() const { return reloc_info_writer.pos() - pc_; }
+
+  // Decode instruction(s) at pos and return backchain to previous
+  // label reference or kEndOfChain.
+  int target_at(int pos);
+
+  // Patch instruction(s) at pos to target target_pos (e.g. branch)
+  void target_at_put(int pos, int target_pos, bool* is_branch = nullptr);
+
+  // Record reloc info for current pc_
+  void RecordRelocInfo(RelocInfo::Mode rmode, intptr_t data = 0);
+  ConstantPoolEntry::Access ConstantPoolAddEntry(RelocInfo::Mode rmode,
+                                                 intptr_t value) {
+    bool sharing_ok =
+        RelocInfo::IsNone(rmode) ||
+        (!options().record_reloc_info_for_serialization &&
+         RelocInfo::IsShareableRelocMode(rmode) &&
+         !is_constant_pool_entry_sharing_blocked() &&
+         // TODO(johnyan): make the following rmode shareable
+         !RelocInfo::IsWasmCall(rmode) && !RelocInfo::IsWasmStubCall(rmode));
+    return constant_pool_builder_.AddEntry(pc_offset(), value, sharing_ok);
+  }
+  ConstantPoolEntry::Access ConstantPoolAddEntry(Double value) {
+    return constant_pool_builder_.AddEntry(pc_offset(), value);
+  }
+
+  // Block the emission of the trampoline pool before pc_offset.
+  void BlockTrampolinePoolBefore(int pc_offset) {
+    if (no_trampoline_pool_before_ < pc_offset)
+      no_trampoline_pool_before_ = pc_offset;
+  }
+
+  void StartBlockTrampolinePool() { trampoline_pool_blocked_nesting_++; }
+  void EndBlockTrampolinePool() {
+    int count = --trampoline_pool_blocked_nesting_;
+    if (count == 0) CheckTrampolinePoolQuick();
+  }
+  bool is_trampoline_pool_blocked() const {
+    return trampoline_pool_blocked_nesting_ > 0;
+  }
+
+  void StartBlockConstantPoolEntrySharing() {
+    constant_pool_entry_sharing_blocked_nesting_++;
+  }
+  void EndBlockConstantPoolEntrySharing() {
+    constant_pool_entry_sharing_blocked_nesting_--;
+  }
+  bool is_constant_pool_entry_sharing_blocked() const {
+    return constant_pool_entry_sharing_blocked_nesting_ > 0;
+  }
+
+  bool has_exception() const { return internal_trampoline_exception_; }
+
+  bool is_trampoline_emitted() const { return trampoline_emitted_; }
+
+  // Code generation
+  // The relocation writer's position is at least kGap bytes below the end of
+  // the generated instructions. This is so that multi-instruction sequences do
+  // not have to check for overflow. The same is true for writes of large
+  // relocation info entries.
+  static constexpr int kGap = 32;
+  STATIC_ASSERT(AssemblerBase::kMinimalBufferSize >= 2 * kGap);
+
+  RelocInfoWriter reloc_info_writer;
+
+ private:
+  // Avoid overflows for displacements etc.
+  static const int kMaximalBufferSize = 512 * MB;
+
+  // Repeated checking whether the trampoline pool should be emitted is rather
+  // expensive. By default we only check again once a number of instructions
+  // has been generated.
+  int next_trampoline_check_;  // pc offset of next buffer check.
+
+  // Emission of the trampoline pool may be blocked in some code sequences.
+  int trampoline_pool_blocked_nesting_;  // Block emission if this is not zero.
+  int no_trampoline_pool_before_;  // Block emission before this pc offset.
+
+  // Do not share constant pool entries.
+  int constant_pool_entry_sharing_blocked_nesting_;
+
+  // Relocation info generation
+  // Each relocation is encoded as a variable size value
+  static constexpr int kMaxRelocSize = RelocInfoWriter::kMaxSize;
+  std::vector<DeferredRelocInfo> relocations_;
+
+  // Scratch registers available for use by the Assembler.
+  RegList scratch_register_list_;
+
+  // The bound position, before this we cannot do instruction elimination.
+  int last_bound_pos_;
+  // Optimizable cmpi information.
+  int optimizable_cmpi_pos_;
+  CRegister cmpi_cr_ = CRegister::no_reg();
+
+  ConstantPoolBuilder constant_pool_builder_;
+
+  void CheckBuffer() {
+    if (buffer_space() <= kGap) {
+      GrowBuffer();
+    }
+  }
+
+  void GrowBuffer(int needed = 0);
+  // Code emission
+  void emit(Instr x) {
+    CheckBuffer();
+    *reinterpret_cast<Instr*>(pc_) = x;
+    pc_ += kInstrSize;
+    CheckTrampolinePoolQuick();
+  }
+  void TrackBranch() {
+    DCHECK(!trampoline_emitted_);
+    int count = tracked_branch_count_++;
+    if (count == 0) {
+      // We leave space (kMaxBlockTrampolineSectionSize)
+      // for BlockTrampolinePoolScope buffer.
+      next_trampoline_check_ =
+          pc_offset() + kMaxCondBranchReach - kMaxBlockTrampolineSectionSize;
+    } else {
+      next_trampoline_check_ -= kTrampolineSlotsSize;
+    }
+  }
+
+  inline void UntrackBranch();
+  void CheckTrampolinePoolQuick() {
+    if (pc_offset() >= next_trampoline_check_) {
+      CheckTrampolinePool();
+    }
+  }
+
+  // Instruction generation
+  void a_form(Instr instr, DoubleRegister frt, DoubleRegister fra,
+              DoubleRegister frb, RCBit r);
+  void d_form(Instr instr, Register rt, Register ra, const intptr_t val,
+              bool signed_disp);
+  void xo_form(Instr instr, Register rt, Register ra, Register rb, OEBit o,
+               RCBit r);
+  void md_form(Instr instr, Register ra, Register rs, int shift, int maskbit,
+               RCBit r);
+  void mds_form(Instr instr, Register ra, Register rs, Register rb, int maskbit,
+                RCBit r);
+
+  // Labels
+  void print(Label* L);
+  int max_reach_from(int pos);
+  void bind_to(Label* L, int pos);
+  void next(Label* L);
+
+  class Trampoline {
+   public:
+    Trampoline() {
+      next_slot_ = 0;
+      free_slot_count_ = 0;
+    }
+    Trampoline(int start, int slot_count) {
+      next_slot_ = start;
+      free_slot_count_ = slot_count;
+    }
+    int take_slot() {
+      int trampoline_slot = kInvalidSlotPos;
+      if (free_slot_count_ <= 0) {
+        // We have run out of space on trampolines.
+        // Make sure we fail in debug mode, so we become aware of each case
+        // when this happens.
+        DCHECK(0);
+        // Internal exception will be caught.
+      } else {
+        trampoline_slot = next_slot_;
+        free_slot_count_--;
+        next_slot_ += kTrampolineSlotsSize;
+      }
+      return trampoline_slot;
+    }
+
+   private:
+    int next_slot_;
+    int free_slot_count_;
+  };
+
+  int32_t get_trampoline_entry();
+  int tracked_branch_count_;
+  // If trampoline is emitted, generated code is becoming large. As
+  // this is already a slow case which can possibly break our code
+  // generation for the extreme case, we use this information to
+  // trigger different mode of branch instruction generation, where we
+  // no longer use a single branch instruction.
+  bool trampoline_emitted_;
+  static constexpr int kTrampolineSlotsSize = kInstrSize;
+  static constexpr int kMaxCondBranchReach = (1 << (16 - 1)) - 1;
+  static constexpr int kMaxBlockTrampolineSectionSize = 64 * kInstrSize;
+  static constexpr int kInvalidSlotPos = -1;
+
+  Trampoline trampoline_;
+  bool internal_trampoline_exception_;
+
+  void AllocateAndInstallRequestedHeapObjects(Isolate* isolate);
+
+  int WriteCodeComments();
+
+  friend class RegExpMacroAssemblerPPC;
+  friend class RelocInfo;
+  friend class BlockTrampolinePoolScope;
+  friend class EnsureSpace;
+  friend class UseScratchRegisterScope;
+};
+
+class EnsureSpace {
+ public:
+  explicit EnsureSpace(Assembler* assembler) { assembler->CheckBuffer(); }
+};
+
+class PatchingAssembler : public Assembler {
+ public:
+  PatchingAssembler(const AssemblerOptions& options, byte* address,
+                    int instructions);
+  ~PatchingAssembler();
+};
+
+class V8_EXPORT_PRIVATE UseScratchRegisterScope {
+ public:
+  explicit UseScratchRegisterScope(Assembler* assembler);
+  ~UseScratchRegisterScope();
+
+  Register Acquire();
+
+  // Check if we have registers available to acquire.
+  bool CanAcquire() const { return *assembler_->GetScratchRegisterList() != 0; }
+
+ private:
+  friend class Assembler;
+  friend class TurboAssembler;
+
+  Assembler* assembler_;
+  RegList old_available_;
+};
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_PPC_ASSEMBLER_PPC_H_
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/assembler-ppc-inl.h b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/assembler-ppc-inl.h
--- a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/assembler-ppc-inl.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/assembler-ppc-inl.h	2025-06-04 10:11:01.000000000 +0800
@@ -0,0 +1,517 @@
+// Copyright (c) 1994-2006 Sun Microsystems Inc.
+// All Rights Reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+//
+// - Redistributions of source code must retain the above copyright notice,
+// this list of conditions and the following disclaimer.
+//
+// - Redistribution in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the
+// distribution.
+//
+// - Neither the name of Sun Microsystems or the names of contributors may
+// be used to endorse or promote products derived from this software without
+// specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+// OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// The original source code covered by the above license above has been modified
+// significantly by Google Inc.
+// Copyright 2014 the V8 project authors. All rights reserved.
+
+#ifndef V8_CODEGEN_PPC_ASSEMBLER_PPC_INL_H_
+#define V8_CODEGEN_PPC_ASSEMBLER_PPC_INL_H_
+
+#include "src/codegen/ppc/assembler-ppc.h"
+
+#include "src/codegen/assembler.h"
+#include "src/debug/debug.h"
+#include "src/objects/objects-inl.h"
+
+namespace v8 {
+namespace internal {
+
+bool CpuFeatures::SupportsOptimizer() { return true; }
+
+bool CpuFeatures::SupportsWasmSimd128() { return false; }
+
+void RelocInfo::apply(intptr_t delta) {
+  // absolute code pointer inside code object moves with the code object.
+  if (IsInternalReference(rmode_)) {
+    // Jump table entry
+    Address target = Memory<Address>(pc_);
+    Memory<Address>(pc_) = target + delta;
+  } else {
+    // mov sequence
+    DCHECK(IsInternalReferenceEncoded(rmode_));
+    Address target = Assembler::target_address_at(pc_, constant_pool_);
+    Assembler::set_target_address_at(pc_, constant_pool_, target + delta,
+                                     SKIP_ICACHE_FLUSH);
+  }
+}
+
+Address RelocInfo::target_internal_reference() {
+  if (IsInternalReference(rmode_)) {
+    // Jump table entry
+    return Memory<Address>(pc_);
+  } else {
+    // mov sequence
+    DCHECK(IsInternalReferenceEncoded(rmode_));
+    return Assembler::target_address_at(pc_, constant_pool_);
+  }
+}
+
+Address RelocInfo::target_internal_reference_address() {
+  DCHECK(IsInternalReference(rmode_) || IsInternalReferenceEncoded(rmode_));
+  return pc_;
+}
+
+Address RelocInfo::target_address() {
+  DCHECK(IsCodeTarget(rmode_) || IsRuntimeEntry(rmode_) || IsWasmCall(rmode_));
+  return Assembler::target_address_at(pc_, constant_pool_);
+}
+
+Address RelocInfo::target_address_address() {
+  DCHECK(HasTargetAddressAddress());
+
+  if (FLAG_enable_embedded_constant_pool &&
+      Assembler::IsConstantPoolLoadStart(pc_)) {
+    // We return the PC for embedded constant pool since this function is used
+    // by the serializer and expects the address to reside within the code
+    // object.
+    return pc_;
+  }
+
+  // Read the address of the word containing the target_address in an
+  // instruction stream.
+  // The only architecture-independent user of this function is the serializer.
+  // The serializer uses it to find out how many raw bytes of instruction to
+  // output before the next target.
+  // For an instruction like LIS/ORI where the target bits are mixed into the
+  // instruction bits, the size of the target will be zero, indicating that the
+  // serializer should not step forward in memory after a target is resolved
+  // and written.
+  return pc_;
+}
+
+Address RelocInfo::constant_pool_entry_address() {
+  if (FLAG_enable_embedded_constant_pool) {
+    DCHECK(constant_pool_);
+    ConstantPoolEntry::Access access;
+    if (Assembler::IsConstantPoolLoadStart(pc_, &access))
+      return Assembler::target_constant_pool_address_at(
+          pc_, constant_pool_, access, ConstantPoolEntry::INTPTR);
+  }
+  UNREACHABLE();
+}
+
+void Assembler::set_target_compressed_address_at(
+    Address pc, Address constant_pool, Tagged_t target,
+    ICacheFlushMode icache_flush_mode) {
+  Assembler::set_target_address_at(
+      pc, constant_pool, static_cast<Address>(target), icache_flush_mode);
+}
+
+int RelocInfo::target_address_size() {
+  if (IsCodedSpecially()) {
+    return Assembler::kSpecialTargetSize;
+  } else {
+    return kSystemPointerSize;
+  }
+}
+
+Tagged_t Assembler::target_compressed_address_at(Address pc,
+                                                 Address constant_pool) {
+  return static_cast<Tagged_t>(target_address_at(pc, constant_pool));
+}
+
+Handle<Object> Assembler::code_target_object_handle_at(Address pc,
+                                                       Address constant_pool) {
+  int index =
+      static_cast<int>(target_address_at(pc, constant_pool)) & 0xFFFFFFFF;
+  return GetCodeTarget(index);
+}
+
+HeapObject RelocInfo::target_object() {
+  DCHECK(IsCodeTarget(rmode_) || IsEmbeddedObjectMode(rmode_));
+  if (IsCompressedEmbeddedObject(rmode_)) {
+    return HeapObject::cast(Object(DecompressTaggedAny(
+        host_.address(),
+        Assembler::target_compressed_address_at(pc_, constant_pool_))));
+  } else {
+    return HeapObject::cast(
+        Object(Assembler::target_address_at(pc_, constant_pool_)));
+  }
+}
+
+HeapObject RelocInfo::target_object_no_host(Isolate* isolate) {
+  if (IsCompressedEmbeddedObject(rmode_)) {
+    return HeapObject::cast(Object(DecompressTaggedAny(
+        isolate,
+        Assembler::target_compressed_address_at(pc_, constant_pool_))));
+  } else {
+    return target_object();
+  }
+}
+
+Handle<HeapObject> Assembler::compressed_embedded_object_handle_at(
+    Address pc, Address const_pool) {
+  return GetEmbeddedObject(target_compressed_address_at(pc, const_pool));
+}
+
+Handle<HeapObject> RelocInfo::target_object_handle(Assembler* origin) {
+  DCHECK(IsCodeTarget(rmode_) || IsEmbeddedObjectMode(rmode_));
+  if (IsCodeTarget(rmode_)) {
+    return Handle<HeapObject>::cast(
+        origin->code_target_object_handle_at(pc_, constant_pool_));
+  } else {
+    if (IsCompressedEmbeddedObject(rmode_)) {
+      return origin->compressed_embedded_object_handle_at(pc_, constant_pool_);
+    }
+    return Handle<HeapObject>(reinterpret_cast<Address*>(
+        Assembler::target_address_at(pc_, constant_pool_)));
+  }
+}
+
+void RelocInfo::set_target_object(Heap* heap, HeapObject target,
+                                  WriteBarrierMode write_barrier_mode,
+                                  ICacheFlushMode icache_flush_mode) {
+  DCHECK(IsCodeTarget(rmode_) || IsEmbeddedObjectMode(rmode_));
+  if (IsCompressedEmbeddedObject(rmode_)) {
+    Assembler::set_target_compressed_address_at(
+        pc_, constant_pool_, CompressTagged(target.ptr()), icache_flush_mode);
+  } else {
+    DCHECK(IsFullEmbeddedObject(rmode_));
+    Assembler::set_target_address_at(pc_, constant_pool_, target.ptr(),
+                                     icache_flush_mode);
+  }
+  if (write_barrier_mode == UPDATE_WRITE_BARRIER && !host().is_null() &&
+      !FLAG_disable_write_barriers) {
+    WriteBarrierForCode(host(), this, target);
+  }
+}
+
+Address RelocInfo::target_external_reference() {
+  DCHECK(rmode_ == EXTERNAL_REFERENCE);
+  return Assembler::target_address_at(pc_, constant_pool_);
+}
+
+void RelocInfo::set_target_external_reference(
+    Address target, ICacheFlushMode icache_flush_mode) {
+  DCHECK(rmode_ == RelocInfo::EXTERNAL_REFERENCE);
+  Assembler::set_target_address_at(pc_, constant_pool_, target,
+                                   icache_flush_mode);
+}
+
+Address RelocInfo::target_runtime_entry(Assembler* origin) {
+  DCHECK(IsRuntimeEntry(rmode_));
+  return target_address();
+}
+
+void RelocInfo::set_target_runtime_entry(Address target,
+                                         WriteBarrierMode write_barrier_mode,
+                                         ICacheFlushMode icache_flush_mode) {
+  DCHECK(IsRuntimeEntry(rmode_));
+  if (target_address() != target)
+    set_target_address(target, write_barrier_mode, icache_flush_mode);
+}
+
+Address RelocInfo::target_off_heap_target() {
+  DCHECK(IsOffHeapTarget(rmode_));
+  return Assembler::target_address_at(pc_, constant_pool_);
+}
+
+void RelocInfo::WipeOut() {
+  DCHECK(IsEmbeddedObjectMode(rmode_) || IsCodeTarget(rmode_) ||
+         IsRuntimeEntry(rmode_) || IsExternalReference(rmode_) ||
+         IsInternalReference(rmode_) || IsInternalReferenceEncoded(rmode_) ||
+         IsOffHeapTarget(rmode_));
+  if (IsInternalReference(rmode_)) {
+    // Jump table entry
+    Memory<Address>(pc_) = kNullAddress;
+  } else if (IsCompressedEmbeddedObject(rmode_)) {
+    Assembler::set_target_compressed_address_at(pc_, constant_pool_,
+                                                kNullAddress);
+  } else if (IsInternalReferenceEncoded(rmode_) || IsOffHeapTarget(rmode_)) {
+    // mov sequence
+    // Currently used only by deserializer, no need to flush.
+    Assembler::set_target_address_at(pc_, constant_pool_, kNullAddress,
+                                     SKIP_ICACHE_FLUSH);
+  } else {
+    Assembler::set_target_address_at(pc_, constant_pool_, kNullAddress);
+  }
+}
+
+Operand::Operand(Register rm) : rm_(rm), rmode_(RelocInfo::NONE) {}
+
+void Assembler::UntrackBranch() {
+  DCHECK(!trampoline_emitted_);
+  DCHECK_GT(tracked_branch_count_, 0);
+  int count = --tracked_branch_count_;
+  if (count == 0) {
+    // Reset
+    next_trampoline_check_ = kMaxInt;
+  } else {
+    next_trampoline_check_ += kTrampolineSlotsSize;
+  }
+}
+
+// Fetch the 32bit value from the FIXED_SEQUENCE lis/ori
+Address Assembler::target_address_at(Address pc, Address constant_pool) {
+  if (FLAG_enable_embedded_constant_pool && constant_pool) {
+    ConstantPoolEntry::Access access;
+    if (IsConstantPoolLoadStart(pc, &access))
+      return Memory<Address>(target_constant_pool_address_at(
+          pc, constant_pool, access, ConstantPoolEntry::INTPTR));
+  }
+
+  Instr instr1 = instr_at(pc);
+  Instr instr2 = instr_at(pc + kInstrSize);
+  // Interpret 2 instructions generated by lis/ori
+  if (IsLis(instr1) && IsOri(instr2)) {
+#if V8_TARGET_ARCH_PPC64
+    Instr instr4 = instr_at(pc + (3 * kInstrSize));
+    Instr instr5 = instr_at(pc + (4 * kInstrSize));
+    // Assemble the 64 bit value.
+    uint64_t hi = (static_cast<uint32_t>((instr1 & kImm16Mask) << 16) |
+                   static_cast<uint32_t>(instr2 & kImm16Mask));
+    uint64_t lo = (static_cast<uint32_t>((instr4 & kImm16Mask) << 16) |
+                   static_cast<uint32_t>(instr5 & kImm16Mask));
+    return static_cast<Address>((hi << 32) | lo);
+#else
+    // Assemble the 32 bit value.
+    return static_cast<Address>(((instr1 & kImm16Mask) << 16) |
+                                (instr2 & kImm16Mask));
+#endif
+  }
+
+  UNREACHABLE();
+}
+
+#if V8_TARGET_ARCH_PPC64
+const uint32_t kLoadIntptrOpcode = LD;
+#else
+const uint32_t kLoadIntptrOpcode = LWZ;
+#endif
+
+// Constant pool load sequence detection:
+// 1) REGULAR access:
+//    load <dst>, kConstantPoolRegister + <offset>
+//
+// 2) OVERFLOWED access:
+//    addis <scratch>, kConstantPoolRegister, <offset_high>
+//    load <dst>, <scratch> + <offset_low>
+bool Assembler::IsConstantPoolLoadStart(Address pc,
+                                        ConstantPoolEntry::Access* access) {
+  Instr instr = instr_at(pc);
+  uint32_t opcode = instr & kOpcodeMask;
+  if (GetRA(instr) != kConstantPoolRegister) return false;
+  bool overflowed = (opcode == ADDIS);
+#ifdef DEBUG
+  if (overflowed) {
+    opcode = instr_at(pc + kInstrSize) & kOpcodeMask;
+  }
+  DCHECK(opcode == kLoadIntptrOpcode || opcode == LFD);
+#endif
+  if (access) {
+    *access = (overflowed ? ConstantPoolEntry::OVERFLOWED
+                          : ConstantPoolEntry::REGULAR);
+  }
+  return true;
+}
+
+bool Assembler::IsConstantPoolLoadEnd(Address pc,
+                                      ConstantPoolEntry::Access* access) {
+  Instr instr = instr_at(pc);
+  uint32_t opcode = instr & kOpcodeMask;
+  bool overflowed = false;
+  if (!(opcode == kLoadIntptrOpcode || opcode == LFD)) return false;
+  if (GetRA(instr) != kConstantPoolRegister) {
+    instr = instr_at(pc - kInstrSize);
+    opcode = instr & kOpcodeMask;
+    if ((opcode != ADDIS) || GetRA(instr) != kConstantPoolRegister) {
+      return false;
+    }
+    overflowed = true;
+  }
+  if (access) {
+    *access = (overflowed ? ConstantPoolEntry::OVERFLOWED
+                          : ConstantPoolEntry::REGULAR);
+  }
+  return true;
+}
+
+int Assembler::GetConstantPoolOffset(Address pc,
+                                     ConstantPoolEntry::Access access,
+                                     ConstantPoolEntry::Type type) {
+  bool overflowed = (access == ConstantPoolEntry::OVERFLOWED);
+#ifdef DEBUG
+  ConstantPoolEntry::Access access_check =
+      static_cast<ConstantPoolEntry::Access>(-1);
+  DCHECK(IsConstantPoolLoadStart(pc, &access_check));
+  DCHECK(access_check == access);
+#endif
+  int offset;
+  if (overflowed) {
+    offset = (instr_at(pc) & kImm16Mask) << 16;
+    offset += SIGN_EXT_IMM16(instr_at(pc + kInstrSize) & kImm16Mask);
+    DCHECK(!is_int16(offset));
+  } else {
+    offset = SIGN_EXT_IMM16((instr_at(pc) & kImm16Mask));
+  }
+  return offset;
+}
+
+void Assembler::PatchConstantPoolAccessInstruction(
+    int pc_offset, int offset, ConstantPoolEntry::Access access,
+    ConstantPoolEntry::Type type) {
+  Address pc = reinterpret_cast<Address>(buffer_start_) + pc_offset;
+  bool overflowed = (access == ConstantPoolEntry::OVERFLOWED);
+  CHECK(overflowed != is_int16(offset));
+#ifdef DEBUG
+  ConstantPoolEntry::Access access_check =
+      static_cast<ConstantPoolEntry::Access>(-1);
+  DCHECK(IsConstantPoolLoadStart(pc, &access_check));
+  DCHECK(access_check == access);
+#endif
+  if (overflowed) {
+    int hi_word = static_cast<int>(offset >> 16);
+    int lo_word = static_cast<int>(offset & 0xffff);
+    if (lo_word & 0x8000) hi_word++;
+
+    Instr instr1 = instr_at(pc);
+    Instr instr2 = instr_at(pc + kInstrSize);
+    instr1 &= ~kImm16Mask;
+    instr1 |= (hi_word & kImm16Mask);
+    instr2 &= ~kImm16Mask;
+    instr2 |= (lo_word & kImm16Mask);
+    instr_at_put(pc, instr1);
+    instr_at_put(pc + kInstrSize, instr2);
+  } else {
+    Instr instr = instr_at(pc);
+    instr &= ~kImm16Mask;
+    instr |= (offset & kImm16Mask);
+    instr_at_put(pc, instr);
+  }
+}
+
+Address Assembler::target_constant_pool_address_at(
+    Address pc, Address constant_pool, ConstantPoolEntry::Access access,
+    ConstantPoolEntry::Type type) {
+  Address addr = constant_pool;
+  DCHECK(addr);
+  addr += GetConstantPoolOffset(pc, access, type);
+  return addr;
+}
+
+// This sets the branch destination (which gets loaded at the call address).
+// This is for calls and branches within generated code.  The serializer
+// has already deserialized the mov instructions etc.
+// There is a FIXED_SEQUENCE assumption here
+void Assembler::deserialization_set_special_target_at(
+    Address instruction_payload, Code code, Address target) {
+  set_target_address_at(instruction_payload,
+                        !code.is_null() ? code.constant_pool() : kNullAddress,
+                        target);
+}
+
+int Assembler::deserialization_special_target_size(
+    Address instruction_payload) {
+  return kSpecialTargetSize;
+}
+
+void Assembler::deserialization_set_target_internal_reference_at(
+    Address pc, Address target, RelocInfo::Mode mode) {
+  if (RelocInfo::IsInternalReferenceEncoded(mode)) {
+    set_target_address_at(pc, kNullAddress, target, SKIP_ICACHE_FLUSH);
+  } else {
+    Memory<Address>(pc) = target;
+  }
+}
+
+// This code assumes the FIXED_SEQUENCE of lis/ori
+void Assembler::set_target_address_at(Address pc, Address constant_pool,
+                                      Address target,
+                                      ICacheFlushMode icache_flush_mode) {
+  if (FLAG_enable_embedded_constant_pool && constant_pool) {
+    ConstantPoolEntry::Access access;
+    if (IsConstantPoolLoadStart(pc, &access)) {
+      Memory<Address>(target_constant_pool_address_at(
+          pc, constant_pool, access, ConstantPoolEntry::INTPTR)) = target;
+      return;
+    }
+  }
+
+  Instr instr1 = instr_at(pc);
+  Instr instr2 = instr_at(pc + kInstrSize);
+  // Interpret 2 instructions generated by lis/ori
+  if (IsLis(instr1) && IsOri(instr2)) {
+#if V8_TARGET_ARCH_PPC64
+    Instr instr4 = instr_at(pc + (3 * kInstrSize));
+    Instr instr5 = instr_at(pc + (4 * kInstrSize));
+    // Needs to be fixed up when mov changes to handle 64-bit values.
+    uint32_t* p = reinterpret_cast<uint32_t*>(pc);
+    uintptr_t itarget = static_cast<uintptr_t>(target);
+
+    instr5 &= ~kImm16Mask;
+    instr5 |= itarget & kImm16Mask;
+    itarget = itarget >> 16;
+
+    instr4 &= ~kImm16Mask;
+    instr4 |= itarget & kImm16Mask;
+    itarget = itarget >> 16;
+
+    instr2 &= ~kImm16Mask;
+    instr2 |= itarget & kImm16Mask;
+    itarget = itarget >> 16;
+
+    instr1 &= ~kImm16Mask;
+    instr1 |= itarget & kImm16Mask;
+    itarget = itarget >> 16;
+
+    *p = instr1;
+    *(p + 1) = instr2;
+    *(p + 3) = instr4;
+    *(p + 4) = instr5;
+    if (icache_flush_mode != SKIP_ICACHE_FLUSH) {
+      FlushInstructionCache(p, 5 * kInstrSize);
+    }
+#else
+    uint32_t* p = reinterpret_cast<uint32_t*>(pc);
+    uint32_t itarget = static_cast<uint32_t>(target);
+    int lo_word = itarget & kImm16Mask;
+    int hi_word = itarget >> 16;
+    instr1 &= ~kImm16Mask;
+    instr1 |= hi_word;
+    instr2 &= ~kImm16Mask;
+    instr2 |= lo_word;
+
+    *p = instr1;
+    *(p + 1) = instr2;
+    if (icache_flush_mode != SKIP_ICACHE_FLUSH) {
+      FlushInstructionCache(p, 2 * kInstrSize);
+    }
+#endif
+    return;
+  }
+  UNREACHABLE();
+}
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_PPC_ASSEMBLER_PPC_INL_H_
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/constants-ppc.cc b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/constants-ppc.cc
--- a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/constants-ppc.cc	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/constants-ppc.cc	2025-06-04 10:11:01.000000000 +0800
@@ -0,0 +1,49 @@
+// Copyright 2014 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#if V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
+
+#include "src/codegen/ppc/constants-ppc.h"
+
+namespace v8 {
+namespace internal {
+
+// These register names are defined in a way to match the native disassembler
+// formatting. See for example the command "objdump -d <binary file>".
+const char* Registers::names_[kNumRegisters] = {
+    "r0",  "sp",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",  "r8",  "r9",  "r10",
+    "r11", "ip",  "r13", "r14", "r15", "r16", "r17", "r18", "r19", "r20", "r21",
+    "r22", "r23", "r24", "r25", "r26", "r27", "r28", "r29", "r30", "fp"};
+
+const char* DoubleRegisters::names_[kNumDoubleRegisters] = {
+    "d0",  "d1",  "d2",  "d3",  "d4",  "d5",  "d6",  "d7",  "d8",  "d9",  "d10",
+    "d11", "d12", "d13", "d14", "d15", "d16", "d17", "d18", "d19", "d20", "d21",
+    "d22", "d23", "d24", "d25", "d26", "d27", "d28", "d29", "d30", "d31"};
+
+int DoubleRegisters::Number(const char* name) {
+  for (int i = 0; i < kNumDoubleRegisters; i++) {
+    if (strcmp(names_[i], name) == 0) {
+      return i;
+    }
+  }
+
+  // No register with the requested name found.
+  return kNoRegister;
+}
+
+int Registers::Number(const char* name) {
+  // Look through the canonical names.
+  for (int i = 0; i < kNumRegisters; i++) {
+    if (strcmp(names_[i], name) == 0) {
+      return i;
+    }
+  }
+
+  // No register with the requested name found.
+  return kNoRegister;
+}
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/constants-ppc.h b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/constants-ppc.h
--- a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/constants-ppc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/constants-ppc.h	2025-06-04 10:11:01.000000000 +0800
@@ -0,0 +1,3027 @@
+// Copyright 2014 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_PPC_CONSTANTS_PPC_H_
+#define V8_CODEGEN_PPC_CONSTANTS_PPC_H_
+
+#include <stdint.h>
+
+#include "src/base/logging.h"
+#include "src/base/macros.h"
+#include "src/common/globals.h"
+
+// UNIMPLEMENTED_ macro for PPC.
+#ifdef DEBUG
+#define UNIMPLEMENTED_PPC()                                                \
+  v8::internal::PrintF("%s, \tline %d: \tfunction %s not implemented. \n", \
+                       __FILE__, __LINE__, __func__)
+#else
+#define UNIMPLEMENTED_PPC()
+#endif
+
+#if (V8_HOST_ARCH_PPC || V8_HOST_ARCH_PPC64) &&                    \
+    (V8_OS_AIX || (V8_TARGET_ARCH_PPC64 && V8_TARGET_BIG_ENDIAN && \
+                   (!defined(_CALL_ELF) || _CALL_ELF == 1)))
+#define ABI_USES_FUNCTION_DESCRIPTORS 1
+#else
+#define ABI_USES_FUNCTION_DESCRIPTORS 0
+#endif
+
+#if !(V8_HOST_ARCH_PPC || V8_HOST_ARCH_PPC64) || V8_OS_AIX || \
+    V8_TARGET_ARCH_PPC64
+#define ABI_PASSES_HANDLES_IN_REGS 1
+#else
+#define ABI_PASSES_HANDLES_IN_REGS 0
+#endif
+
+#if !(V8_HOST_ARCH_PPC || V8_HOST_ARCH_PPC64) || !V8_TARGET_ARCH_PPC64 || \
+    V8_TARGET_LITTLE_ENDIAN || (defined(_CALL_ELF) && _CALL_ELF == 2)
+#define ABI_RETURNS_OBJECT_PAIRS_IN_REGS 1
+#else
+#define ABI_RETURNS_OBJECT_PAIRS_IN_REGS 0
+#endif
+
+#if !(V8_HOST_ARCH_PPC || V8_HOST_ARCH_PPC64) || \
+    (V8_TARGET_ARCH_PPC64 &&                     \
+     (V8_TARGET_LITTLE_ENDIAN || (defined(_CALL_ELF) && _CALL_ELF == 2)))
+#define ABI_CALL_VIA_IP 1
+#else
+#define ABI_CALL_VIA_IP 0
+#endif
+
+#if !(V8_HOST_ARCH_PPC || V8_HOST_ARCH_PPC64) || V8_OS_AIX || \
+    V8_TARGET_ARCH_PPC64
+#define ABI_TOC_REGISTER 2
+#else
+#define ABI_TOC_REGISTER 13
+#endif
+namespace v8 {
+namespace internal {
+
+// TODO(sigurds): Change this value once we use relative jumps.
+constexpr size_t kMaxPCRelativeCodeRangeInMB = 0;
+
+// Used to encode a boolean value when emitting 32 bit
+// opcodes which will indicate the presence of function descriptors
+constexpr int kHasFunctionDescriptorBitShift = 9;
+constexpr int kHasFunctionDescriptorBitMask = 1
+                                              << kHasFunctionDescriptorBitShift;
+
+// Number of registers
+const int kNumRegisters = 32;
+
+// FP support.
+const int kNumDoubleRegisters = 32;
+
+const int kNoRegister = -1;
+
+// Used in embedded constant pool builder - max reach in bits for
+// various load instructions (one less due to unsigned)
+const int kLoadPtrMaxReachBits = 15;
+const int kLoadDoubleMaxReachBits = 15;
+
+// Actual value of root register is offset from the root array's start
+// to take advantage of negative displacement values.
+// TODO(sigurds): Choose best value.
+constexpr int kRootRegisterBias = 128;
+
+// sign-extend the least significant 16-bits of value <imm>
+#define SIGN_EXT_IMM16(imm) ((static_cast<int>(imm) << 16) >> 16)
+
+// sign-extend the least significant 22-bits of value <imm>
+#define SIGN_EXT_IMM22(imm) ((static_cast<int>(imm) << 10) >> 10)
+
+// sign-extend the least significant 26-bits of value <imm>
+#define SIGN_EXT_IMM26(imm) ((static_cast<int>(imm) << 6) >> 6)
+
+// -----------------------------------------------------------------------------
+// Conditions.
+
+// Defines constants and accessor classes to assemble, disassemble and
+// simulate PPC instructions.
+//
+// Section references in the code refer to the "PowerPC Microprocessor
+// Family: The Programmer.s Reference Guide" from 10/95
+// https://www-01.ibm.com/chips/techlib/techlib.nsf/techdocs/852569B20050FF778525699600741775/$file/prg.pdf
+//
+
+// Constants for specific fields are defined in their respective named enums.
+// General constants are in an anonymous enum in class Instr.
+enum Condition {
+  kNoCondition = -1,
+  eq = 0,         // Equal.
+  ne = 1,         // Not equal.
+  ge = 2,         // Greater or equal.
+  lt = 3,         // Less than.
+  gt = 4,         // Greater than.
+  le = 5,         // Less then or equal
+  unordered = 6,  // Floating-point unordered
+  ordered = 7,
+  overflow = 8,  // Summary overflow
+  nooverflow = 9,
+  al = 10  // Always.
+};
+
+inline Condition NegateCondition(Condition cond) {
+  DCHECK(cond != al);
+  return static_cast<Condition>(cond ^ ne);
+}
+
+// -----------------------------------------------------------------------------
+// Instructions encoding.
+
+// Instr is merely used by the Assembler to distinguish 32bit integers
+// representing instructions from usual 32 bit values.
+// Instruction objects are pointers to 32bit values, and provide methods to
+// access the various ISA fields.
+using Instr = uint32_t;
+
+#define PPC_XX3_OPCODE_LIST(V)                                                \
+  /* VSX Scalar Add Double-Precision */                                       \
+  V(xsadddp, XSADDDP, 0xF0000100)                                             \
+  /* VSX Scalar Add Single-Precision */                                       \
+  V(xsaddsp, XSADDSP, 0xF0000000)                                             \
+  /* VSX Scalar Compare Ordered Double-Precision */                           \
+  V(xscmpodp, XSCMPODP, 0xF0000158)                                           \
+  /* VSX Scalar Compare Unordered Double-Precision */                         \
+  V(xscmpudp, XSCMPUDP, 0xF0000118)                                           \
+  /* VSX Scalar Copy Sign Double-Precision */                                 \
+  V(xscpsgndp, XSCPSGNDP, 0xF0000580)                                         \
+  /* VSX Scalar Divide Double-Precision */                                    \
+  V(xsdivdp, XSDIVDP, 0xF00001C0)                                             \
+  /* VSX Scalar Divide Single-Precision */                                    \
+  V(xsdivsp, XSDIVSP, 0xF00000C0)                                             \
+  /* VSX Scalar Multiply-Add Type-A Double-Precision */                       \
+  V(xsmaddadp, XSMADDADP, 0xF0000108)                                         \
+  /* VSX Scalar Multiply-Add Type-A Single-Precision */                       \
+  V(xsmaddasp, XSMADDASP, 0xF0000008)                                         \
+  /* VSX Scalar Multiply-Add Type-M Double-Precision */                       \
+  V(xsmaddmdp, XSMADDMDP, 0xF0000148)                                         \
+  /* VSX Scalar Multiply-Add Type-M Single-Precision */                       \
+  V(xsmaddmsp, XSMADDMSP, 0xF0000048)                                         \
+  /* VSX Scalar Maximum Double-Precision */                                   \
+  V(xsmaxdp, XSMAXDP, 0xF0000500)                                             \
+  /* VSX Scalar Minimum Double-Precision */                                   \
+  V(xsmindp, XSMINDP, 0xF0000540)                                             \
+  /* VSX Scalar Multiply-Subtract Type-A Double-Precision */                  \
+  V(xsmsubadp, XSMSUBADP, 0xF0000188)                                         \
+  /* VSX Scalar Multiply-Subtract Type-A Single-Precision */                  \
+  V(xsmsubasp, XSMSUBASP, 0xF0000088)                                         \
+  /* VSX Scalar Multiply-Subtract Type-M Double-Precision */                  \
+  V(xsmsubmdp, XSMSUBMDP, 0xF00001C8)                                         \
+  /* VSX Scalar Multiply-Subtract Type-M Single-Precision */                  \
+  V(xsmsubmsp, XSMSUBMSP, 0xF00000C8)                                         \
+  /* VSX Scalar Multiply Double-Precision */                                  \
+  V(xsmuldp, XSMULDP, 0xF0000180)                                             \
+  /* VSX Scalar Multiply Single-Precision */                                  \
+  V(xsmulsp, XSMULSP, 0xF0000080)                                             \
+  /* VSX Scalar Negative Multiply-Add Type-A Double-Precision */              \
+  V(xsnmaddadp, XSNMADDADP, 0xF0000508)                                       \
+  /* VSX Scalar Negative Multiply-Add Type-A Single-Precision */              \
+  V(xsnmaddasp, XSNMADDASP, 0xF0000408)                                       \
+  /* VSX Scalar Negative Multiply-Add Type-M Double-Precision */              \
+  V(xsnmaddmdp, XSNMADDMDP, 0xF0000548)                                       \
+  /* VSX Scalar Negative Multiply-Add Type-M Single-Precision */              \
+  V(xsnmaddmsp, XSNMADDMSP, 0xF0000448)                                       \
+  /* VSX Scalar Negative Multiply-Subtract Type-A Double-Precision */         \
+  V(xsnmsubadp, XSNMSUBADP, 0xF0000588)                                       \
+  /* VSX Scalar Negative Multiply-Subtract Type-A Single-Precision */         \
+  V(xsnmsubasp, XSNMSUBASP, 0xF0000488)                                       \
+  /* VSX Scalar Negative Multiply-Subtract Type-M Double-Precision */         \
+  V(xsnmsubmdp, XSNMSUBMDP, 0xF00005C8)                                       \
+  /* VSX Scalar Negative Multiply-Subtract Type-M Single-Precision */         \
+  V(xsnmsubmsp, XSNMSUBMSP, 0xF00004C8)                                       \
+  /* VSX Scalar Reciprocal Estimate Double-Precision */                       \
+  V(xsredp, XSREDP, 0xF0000168)                                               \
+  /* VSX Scalar Subtract Double-Precision */                                  \
+  V(xssubdp, XSSUBDP, 0xF0000140)                                             \
+  /* VSX Scalar Subtract Single-Precision */                                  \
+  V(xssubsp, XSSUBSP, 0xF0000040)                                             \
+  /* VSX Scalar Test for software Divide Double-Precision */                  \
+  V(xstdivdp, XSTDIVDP, 0xF00001E8)                                           \
+  /* VSX Vector Add Double-Precision */                                       \
+  V(xvadddp, XVADDDP, 0xF0000300)                                             \
+  /* VSX Vector Add Single-Precision */                                       \
+  V(xvaddsp, XVADDSP, 0xF0000200)                                             \
+  /* VSX Vector Compare Equal To Double-Precision */                          \
+  V(xvcmpeqdp, XVCMPEQDP, 0xF0000318)                                         \
+  /* VSX Vector Compare Equal To Double-Precision & record CR6 */             \
+  V(xvcmpeqdpx, XVCMPEQDPx, 0xF0000718)                                       \
+  /* VSX Vector Compare Equal To Single-Precision */                          \
+  V(xvcmpeqsp, XVCMPEQSP, 0xF0000218)                                         \
+  /* VSX Vector Compare Equal To Single-Precision & record CR6 */             \
+  V(xvcmpeqspx, XVCMPEQSPx, 0xF0000618)                                       \
+  /* VSX Vector Compare Greater Than or Equal To Double-Precision */          \
+  V(xvcmpgedp, XVCMPGEDP, 0xF0000398)                                         \
+  /* VSX Vector Compare Greater Than or Equal To Double-Precision & record */ \
+  /* CR6 */                                                                   \
+  V(xvcmpgedpx, XVCMPGEDPx, 0xF0000798)                                       \
+  /* VSX Vector Compare Greater Than or Equal To Single-Precision */          \
+  V(xvcmpgesp, XVCMPGESP, 0xF0000298)                                         \
+  /* VSX Vector Compare Greater Than or Equal To Single-Precision & record */ \
+  /* CR6 */                                                                   \
+  V(xvcmpgespx, XVCMPGESPx, 0xF0000698)                                       \
+  /* VSX Vector Compare Greater Than Double-Precision */                      \
+  V(xvcmpgtdp, XVCMPGTDP, 0xF0000358)                                         \
+  /* VSX Vector Compare Greater Than Double-Precision & record CR6 */         \
+  V(xvcmpgtdpx, XVCMPGTDPx, 0xF0000758)                                       \
+  /* VSX Vector Compare Greater Than Single-Precision */                      \
+  V(xvcmpgtsp, XVCMPGTSP, 0xF0000258)                                         \
+  /* VSX Vector Compare Greater Than Single-Precision & record CR6 */         \
+  V(xvcmpgtspx, XVCMPGTSPx, 0xF0000658)                                       \
+  /* VSX Vector Copy Sign Double-Precision */                                 \
+  V(xvcpsgndp, XVCPSGNDP, 0xF0000780)                                         \
+  /* VSX Vector Copy Sign Single-Precision */                                 \
+  V(xvcpsgnsp, XVCPSGNSP, 0xF0000680)                                         \
+  /* VSX Vector Divide Double-Precision */                                    \
+  V(xvdivdp, XVDIVDP, 0xF00003C0)                                             \
+  /* VSX Vector Divide Single-Precision */                                    \
+  V(xvdivsp, XVDIVSP, 0xF00002C0)                                             \
+  /* VSX Vector Multiply-Add Type-A Double-Precision */                       \
+  V(xvmaddadp, XVMADDADP, 0xF0000308)                                         \
+  /* VSX Vector Multiply-Add Type-A Single-Precision */                       \
+  V(xvmaddasp, XVMADDASP, 0xF0000208)                                         \
+  /* VSX Vector Multiply-Add Type-M Double-Precision */                       \
+  V(xvmaddmdp, XVMADDMDP, 0xF0000348)                                         \
+  /* VSX Vector Multiply-Add Type-M Single-Precision */                       \
+  V(xvmaddmsp, XVMADDMSP, 0xF0000248)                                         \
+  /* VSX Vector Maximum Double-Precision */                                   \
+  V(xvmaxdp, XVMAXDP, 0xF0000700)                                             \
+  /* VSX Vector Maximum Single-Precision */                                   \
+  V(xvmaxsp, XVMAXSP, 0xF0000600)                                             \
+  /* VSX Vector Minimum Double-Precision */                                   \
+  V(xvmindp, XVMINDP, 0xF0000740)                                             \
+  /* VSX Vector Minimum Single-Precision */                                   \
+  V(xvminsp, XVMINSP, 0xF0000640)                                             \
+  /* VSX Vector Multiply-Subtract Type-A Double-Precision */                  \
+  V(xvmsubadp, XVMSUBADP, 0xF0000388)                                         \
+  /* VSX Vector Multiply-Subtract Type-A Single-Precision */                  \
+  V(xvmsubasp, XVMSUBASP, 0xF0000288)                                         \
+  /* VSX Vector Multiply-Subtract Type-M Double-Precision */                  \
+  V(xvmsubmdp, XVMSUBMDP, 0xF00003C8)                                         \
+  /* VSX Vector Multiply-Subtract Type-M Single-Precision */                  \
+  V(xvmsubmsp, XVMSUBMSP, 0xF00002C8)                                         \
+  /* VSX Vector Multiply Double-Precision */                                  \
+  V(xvmuldp, XVMULDP, 0xF0000380)                                             \
+  /* VSX Vector Multiply Single-Precision */                                  \
+  V(xvmulsp, XVMULSP, 0xF0000280)                                             \
+  /* VSX Vector Negative Multiply-Add Type-A Double-Precision */              \
+  V(xvnmaddadp, XVNMADDADP, 0xF0000708)                                       \
+  /* VSX Vector Negative Multiply-Add Type-A Single-Precision */              \
+  V(xvnmaddasp, XVNMADDASP, 0xF0000608)                                       \
+  /* VSX Vector Negative Multiply-Add Type-M Double-Precision */              \
+  V(xvnmaddmdp, XVNMADDMDP, 0xF0000748)                                       \
+  /* VSX Vector Negative Multiply-Add Type-M Single-Precision */              \
+  V(xvnmaddmsp, XVNMADDMSP, 0xF0000648)                                       \
+  /* VSX Vector Negative Multiply-Subtract Type-A Double-Precision */         \
+  V(xvnmsubadp, XVNMSUBADP, 0xF0000788)                                       \
+  /* VSX Vector Negative Multiply-Subtract Type-A Single-Precision */         \
+  V(xvnmsubasp, XVNMSUBASP, 0xF0000688)                                       \
+  /* VSX Vector Negative Multiply-Subtract Type-M Double-Precision */         \
+  V(xvnmsubmdp, XVNMSUBMDP, 0xF00007C8)                                       \
+  /* VSX Vector Negative Multiply-Subtract Type-M Single-Precision */         \
+  V(xvnmsubmsp, XVNMSUBMSP, 0xF00006C8)                                       \
+  /* VSX Vector Reciprocal Estimate Double-Precision */                       \
+  V(xvredp, XVREDP, 0xF0000368)                                               \
+  /* VSX Vector Subtract Double-Precision */                                  \
+  V(xvsubdp, XVSUBDP, 0xF0000340)                                             \
+  /* VSX Vector Subtract Single-Precision */                                  \
+  V(xvsubsp, XVSUBSP, 0xF0000240)                                             \
+  /* VSX Vector Test for software Divide Double-Precision */                  \
+  V(xvtdivdp, XVTDIVDP, 0xF00003E8)                                           \
+  /* VSX Vector Test for software Divide Single-Precision */                  \
+  V(xvtdivsp, XVTDIVSP, 0xF00002E8)                                           \
+  /* VSX Logical AND */                                                       \
+  V(xxland, XXLAND, 0xF0000410)                                               \
+  /* VSX Logical AND with Complement */                                       \
+  V(xxlandc, XXLANDC, 0xF0000450)                                             \
+  /* VSX Logical Equivalence */                                               \
+  V(xxleqv, XXLEQV, 0xF00005D0)                                               \
+  /* VSX Logical NAND */                                                      \
+  V(xxlnand, XXLNAND, 0xF0000590)                                             \
+  /* VSX Logical NOR */                                                       \
+  V(xxlnor, XXLNOR, 0xF0000510)                                               \
+  /* VSX Logical OR */                                                        \
+  V(xxlor, XXLOR, 0xF0000490)                                                 \
+  /* VSX Logical OR with Complement */                                        \
+  V(xxlorc, XXLORC, 0xF0000550)                                               \
+  /* VSX Logical XOR */                                                       \
+  V(xxlxor, XXLXOR, 0xF00004D0)                                               \
+  /* VSX Merge High Word */                                                   \
+  V(xxmrghw, XXMRGHW, 0xF0000090)                                             \
+  /* VSX Merge Low Word */                                                    \
+  V(xxmrglw, XXMRGLW, 0xF0000190)                                             \
+  /* VSX Permute Doubleword Immediate */                                      \
+  V(xxpermdi, XXPERMDI, 0xF0000050)                                           \
+  /* VSX Shift Left Double by Word Immediate */                               \
+  V(xxsldwi, XXSLDWI, 0xF0000010)                                             \
+  /* VSX Splat Word */                                                        \
+  V(xxspltw, XXSPLTW, 0xF0000290)
+
+#define PPC_Z23_OPCODE_LIST(V)                                    \
+  /* Decimal Quantize */                                          \
+  V(dqua, DQUA, 0xEC000006)                                       \
+  /* Decimal Quantize Immediate */                                \
+  V(dquai, DQUAI, 0xEC000086)                                     \
+  /* Decimal Quantize Immediate Quad */                           \
+  V(dquaiq, DQUAIQ, 0xFC000086)                                   \
+  /* Decimal Quantize Quad */                                     \
+  V(dquaq, DQUAQ, 0xFC000006)                                     \
+  /* Decimal Floating Round To FP Integer Without Inexact */      \
+  V(drintn, DRINTN, 0xEC0001C6)                                   \
+  /* Decimal Floating Round To FP Integer Without Inexact Quad */ \
+  V(drintnq, DRINTNQ, 0xFC0001C6)                                 \
+  /* Decimal Floating Round To FP Integer With Inexact */         \
+  V(drintx, DRINTX, 0xEC0000C6)                                   \
+  /* Decimal Floating Round To FP Integer With Inexact Quad */    \
+  V(drintxq, DRINTXQ, 0xFC0000C6)                                 \
+  /* Decimal Floating Reround */                                  \
+  V(drrnd, DRRND, 0xEC000046)                                     \
+  /* Decimal Floating Reround Quad */                             \
+  V(drrndq, DRRNDQ, 0xFC000046)
+
+#define PPC_Z22_OPCODE_LIST(V)                                  \
+  /* Decimal Floating Shift Coefficient Left Immediate */       \
+  V(dscli, DSCLI, 0xEC000084)                                   \
+  /* Decimal Floating Shift Coefficient Left Immediate Quad */  \
+  V(dscliq, DSCLIQ, 0xFC000084)                                 \
+  /* Decimal Floating Shift Coefficient Right Immediate */      \
+  V(dscri, DSCRI, 0xEC0000C4)                                   \
+  /* Decimal Floating Shift Coefficient Right Immediate Quad */ \
+  V(dscriq, DSCRIQ, 0xFC0000C4)                                 \
+  /* Decimal Floating Test Data Class */                        \
+  V(dtstdc, DTSTDC, 0xEC000184)                                 \
+  /* Decimal Floating Test Data Class Quad */                   \
+  V(dtstdcq, DTSTDCQ, 0xFC000184)                               \
+  /* Decimal Floating Test Data Group */                        \
+  V(dtstdg, DTSTDG, 0xEC0001C4)                                 \
+  /* Decimal Floating Test Data Group Quad */                   \
+  V(dtstdgq, DTSTDGQ, 0xFC0001C4)
+
+#define PPC_XX2_OPCODE_A_FORM_LIST(V)                                    \
+  /* VSX Vector Absolute Value Double-Precision */                       \
+  V(xvabsdp, XVABSDP, 0xF0000764)                                        \
+  /* VSX Vector Negate Double-Precision */                               \
+  V(xvnegdp, XVNEGDP, 0xF00007E4)                                        \
+  /* VSX Vector Square Root Double-Precision */                          \
+  V(xvsqrtdp, XVSQRTDP, 0xF000032C)                                      \
+  /* VSX Vector Absolute Value Single-Precision */                       \
+  V(xvabssp, XVABSSP, 0xF0000664)                                        \
+  /* VSX Vector Negate Single-Precision */                               \
+  V(xvnegsp, XVNEGSP, 0xF00006E4)                                        \
+  /* VSX Vector Reciprocal Estimate Single-Precision */                  \
+  V(xvresp, XVRESP, 0xF0000268)                                          \
+  /* VSX Vector Reciprocal Square Root Estimate Single-Precision */      \
+  V(xvrsqrtesp, XVRSQRTESP, 0xF0000228)                                  \
+  /* VSX Vector Square Root Single-Precision */                          \
+  V(xvsqrtsp, XVSQRTSP, 0xF000022C)                                      \
+  /* VSX Vector Convert Single-Precision to Signed Fixed-Point Word */   \
+  /* Saturate */                                                         \
+  V(xvcvspsxws, XVCVSPSXWS, 0xF0000260)                                  \
+  /* VSX Vector Convert Single-Precision to Unsigned Fixed-Point Word */ \
+  /* Saturate */                                                         \
+  V(xvcvspuxws, XVCVSPUXWS, 0xF0000220)                                  \
+  /* VSX Vector Convert Signed Fixed-Point Word to Single-Precision */   \
+  V(xvcvsxwsp, XVCVSXWSP, 0xF00002E0)                                    \
+  /* VSX Vector Convert Unsigned Fixed-Point Word to Single-Precision */ \
+  V(xvcvuxwsp, XVCVUXWSP, 0xF00002A0)                                    \
+  /* VSX Vector Round to Double-Precision Integer toward +Infinity */    \
+  V(xvrdpip, XVRDPIP, 0xF00003A4)                                        \
+  /* VSX Vector Round to Double-Precision Integer toward -Infinity */    \
+  V(xvrdpim, XVRDPIM, 0xF00003E4)                                        \
+  /* VSX Vector Round to Double-Precision Integer toward Zero */         \
+  V(xvrdpiz, XVRDPIZ, 0xF0000364)                                        \
+  /* VSX Vector Round to Double-Precision Integer */                     \
+  V(xvrdpi, XVRDPI, 0xF0000324)                                          \
+  /* VSX Vector Round to Single-Precision Integer toward +Infinity */    \
+  V(xvrspip, XVRSPIP, 0xF00002A4)                                        \
+  /* VSX Vector Round to Single-Precision Integer toward -Infinity */    \
+  V(xvrspim, XVRSPIM, 0xF00002E4)                                        \
+  /* VSX Vector Round to Single-Precision Integer toward Zero */         \
+  V(xvrspiz, XVRSPIZ, 0xF0000264)                                        \
+  /* VSX Vector Round to Single-Precision Integer */                     \
+  V(xvrspi, XVRSPI, 0xF0000224)
+
+#define PPC_XX2_OPCODE_UNUSED_LIST(V)                                        \
+  /* VSX Scalar Square Root Double-Precision */                              \
+  V(xssqrtdp, XSSQRTDP, 0xF000012C)                                          \
+  /* VSX Scalar Reciprocal Estimate Single-Precision */                      \
+  V(xsresp, XSRESP, 0xF0000068)                                              \
+  /* VSX Scalar Reciprocal Square Root Estimate Single-Precision */          \
+  V(xsrsqrtesp, XSRSQRTESP, 0xF0000028)                                      \
+  /* VSX Scalar Square Root Single-Precision */                              \
+  V(xssqrtsp, XSSQRTSP, 0xF000002C)                                          \
+  /* Move To VSR Doubleword */                                               \
+  V(mtvsrd, MTVSRD, 0x7C000166)                                              \
+  /* Move To VSR Word Algebraic */                                           \
+  V(mtvsrwa, MTVSRWA, 0x7C0001A6)                                            \
+  /* Move To VSR Word and Zero */                                            \
+  V(mtvsrwz, MTVSRWZ, 0x7C0001E6)                                            \
+  /* VSX Scalar Absolute Value Double-Precision */                           \
+  V(xsabsdp, XSABSDP, 0xF0000564)                                            \
+  /* VSX Scalar Convert Double-Precision to Single-Precision */              \
+  V(xscvdpsp, XSCVDPSP, 0xF0000424)                                          \
+  /* VSX Scalar Convert Double-Precision to Single-Precision format Non- */  \
+  /* signalling */                                                           \
+  V(xscvdpspn, XSCVDPSPN, 0xF000042C)                                        \
+  /* VSX Scalar Convert Double-Precision to Signed Fixed-Point Doubleword */ \
+  /* Saturate */                                                             \
+  V(xscvdpsxds, XSCVDPSXDS, 0xF0000560)                                      \
+  /* VSX Scalar Convert Double-Precision to Signed Fixed-Point Word */       \
+  /* Saturate */                                                             \
+  V(xscvdpsxws, XSCVDPSXWS, 0xF0000160)                                      \
+  /* VSX Scalar Convert Double-Precision to Unsigned Fixed-Point */          \
+  /* Doubleword Saturate */                                                  \
+  V(xscvdpuxds, XSCVDPUXDS, 0xF0000520)                                      \
+  /* VSX Scalar Convert Double-Precision to Unsigned Fixed-Point Word */     \
+  /* Saturate */                                                             \
+  V(xscvdpuxws, XSCVDPUXWS, 0xF0000120)                                      \
+  /* VSX Scalar Convert Single-Precision to Double-Precision (p=1) */        \
+  V(xscvspdp, XSCVSPDP, 0xF0000524)                                          \
+  /* Scalar Convert Single-Precision to Double-Precision format Non- */      \
+  /* signalling */                                                           \
+  V(xscvspdpn, XSCVSPDPN, 0xF000052C)                                        \
+  /* VSX Scalar Convert Signed Fixed-Point Doubleword to Double-Precision */ \
+  V(xscvsxddp, XSCVSXDDP, 0xF00005E0)                                        \
+  /* VSX Scalar Convert Signed Fixed-Point Doubleword to Single-Precision */ \
+  V(xscvsxdsp, XSCVSXDSP, 0xF00004E0)                                        \
+  /* VSX Scalar Convert Unsigned Fixed-Point Doubleword to Double- */        \
+  /* Precision */                                                            \
+  V(xscvuxddp, XSCVUXDDP, 0xF00005A0)                                        \
+  /* VSX Scalar Convert Unsigned Fixed-Point Doubleword to Single- */        \
+  /* Precision */                                                            \
+  V(xscvuxdsp, XSCVUXDSP, 0xF00004A0)                                        \
+  /* VSX Scalar Negative Absolute Value Double-Precision */                  \
+  V(xsnabsdp, XSNABSDP, 0xF00005A4)                                          \
+  /* VSX Scalar Negate Double-Precision */                                   \
+  V(xsnegdp, XSNEGDP, 0xF00005E4)                                            \
+  /* VSX Scalar Round to Double-Precision Integer */                         \
+  V(xsrdpi, XSRDPI, 0xF0000124)                                              \
+  /* VSX Scalar Round to Double-Precision Integer using Current rounding */  \
+  /* mode */                                                                 \
+  V(xsrdpic, XSRDPIC, 0xF00001AC)                                            \
+  /* VSX Scalar Round to Double-Precision Integer toward -Infinity */        \
+  V(xsrdpim, XSRDPIM, 0xF00001E4)                                            \
+  /* VSX Scalar Round to Double-Precision Integer toward +Infinity */        \
+  V(xsrdpip, XSRDPIP, 0xF00001A4)                                            \
+  /* VSX Scalar Round to Double-Precision Integer toward Zero */             \
+  V(xsrdpiz, XSRDPIZ, 0xF0000164)                                            \
+  /* VSX Scalar Round to Single-Precision */                                 \
+  V(xsrsp, XSRSP, 0xF0000464)                                                \
+  /* VSX Scalar Reciprocal Square Root Estimate Double-Precision */          \
+  V(xsrsqrtedp, XSRSQRTEDP, 0xF0000128)                                      \
+  /* VSX Scalar Test for software Square Root Double-Precision */            \
+  V(xstsqrtdp, XSTSQRTDP, 0xF00001A8)                                        \
+  /* VSX Vector Convert Double-Precision to Single-Precision */              \
+  V(xvcvdpsp, XVCVDPSP, 0xF0000624)                                          \
+  /* VSX Vector Convert Double-Precision to Signed Fixed-Point Doubleword */ \
+  /* Saturate */                                                             \
+  V(xvcvdpsxds, XVCVDPSXDS, 0xF0000760)                                      \
+  /* VSX Vector Convert Double-Precision to Signed Fixed-Point Word */       \
+  /* Saturate */                                                             \
+  V(xvcvdpsxws, XVCVDPSXWS, 0xF0000360)                                      \
+  /* VSX Vector Convert Double-Precision to Unsigned Fixed-Point */          \
+  /* Doubleword Saturate */                                                  \
+  V(xvcvdpuxds, XVCVDPUXDS, 0xF0000720)                                      \
+  /* VSX Vector Convert Double-Precision to Unsigned Fixed-Point Word */     \
+  /* Saturate */                                                             \
+  V(xvcvdpuxws, XVCVDPUXWS, 0xF0000320)                                      \
+  /* VSX Vector Convert Single-Precision to Double-Precision */              \
+  V(xvcvspdp, XVCVSPDP, 0xF0000724)                                          \
+  /* VSX Vector Convert Single-Precision to Signed Fixed-Point Doubleword */ \
+  /* Saturate */                                                             \
+  V(xvcvspsxds, XVCVSPSXDS, 0xF0000660)                                      \
+  /* VSX Vector Convert Single-Precision to Unsigned Fixed-Point */          \
+  /* Doubleword Saturate */                                                  \
+  V(xvcvspuxds, XVCVSPUXDS, 0xF0000620)                                      \
+  /* VSX Vector Convert Signed Fixed-Point Doubleword to Double-Precision */ \
+  V(xvcvsxddp, XVCVSXDDP, 0xF00007E0)                                        \
+  /* VSX Vector Convert Signed Fixed-Point Doubleword to Single-Precision */ \
+  V(xvcvsxdsp, XVCVSXDSP, 0xF00006E0)                                        \
+  /* VSX Vector Convert Signed Fixed-Point Word to Double-Precision */       \
+  V(xvcvsxwdp, XVCVSXWDP, 0xF00003E0)                                        \
+  /* VSX Vector Convert Unsigned Fixed-Point Doubleword to Double- */        \
+  /* Precision */                                                            \
+  V(xvcvuxddp, XVCVUXDDP, 0xF00007A0)                                        \
+  /* VSX Vector Convert Unsigned Fixed-Point Doubleword to Single- */        \
+  /* Precision */                                                            \
+  V(xvcvuxdsp, XVCVUXDSP, 0xF00006A0)                                        \
+  /* VSX Vector Convert Unsigned Fixed-Point Word to Double-Precision */     \
+  V(xvcvuxwdp, XVCVUXWDP, 0xF00003A0)                                        \
+  /* VSX Vector Negative Absolute Value Double-Precision */                  \
+  V(xvnabsdp, XVNABSDP, 0xF00007A4)                                          \
+  /* VSX Vector Negative Absolute Value Single-Precision */                  \
+  V(xvnabssp, XVNABSSP, 0xF00006A4)                                          \
+  /* VSX Vector Round to Double-Precision Integer using Current rounding */  \
+  /* mode */                                                                 \
+  V(xvrdpic, XVRDPIC, 0xF00003AC)                                            \
+  /* VSX Vector Round to Single-Precision Integer using Current rounding */  \
+  /* mode */                                                                 \
+  V(xvrspic, XVRSPIC, 0xF00002AC)                                            \
+  /* VSX Vector Reciprocal Square Root Estimate Double-Precision */          \
+  V(xvrsqrtedp, XVRSQRTEDP, 0xF0000328)                                      \
+  /* VSX Vector Test for software Square Root Double-Precision */            \
+  V(xvtsqrtdp, XVTSQRTDP, 0xF00003A8)                                        \
+  /* VSX Vector Test for software Square Root Single-Precision */            \
+  V(xvtsqrtsp, XVTSQRTSP, 0xF00002A8)
+
+#define PPC_XX2_OPCODE_LIST(V)  \
+  PPC_XX2_OPCODE_A_FORM_LIST(V) \
+  PPC_XX2_OPCODE_UNUSED_LIST(V)
+
+#define PPC_EVX_OPCODE_LIST(V)                                                \
+  /* Vector Load Double Word into Double Word by External PID Indexed */      \
+  V(evlddepx, EVLDDEPX, 0x7C00063E)                                           \
+  /* Vector Store Double of Double by External PID Indexed */                 \
+  V(evstddepx, EVSTDDEPX, 0x7C00073E)                                         \
+  /* Bit Reversed Increment */                                                \
+  V(brinc, BRINC, 0x1000020F)                                                 \
+  /* Vector Absolute Value */                                                 \
+  V(evabs, EVABS, 0x10000208)                                                 \
+  /* Vector Add Immediate Word */                                             \
+  V(evaddiw, EVADDIW, 0x10000202)                                             \
+  /* Vector Add Signed, Modulo, Integer to Accumulator Word */                \
+  V(evaddsmiaaw, EVADDSMIAAW, 0x100004C9)                                     \
+  /* Vector Add Signed, Saturate, Integer to Accumulator Word */              \
+  V(evaddssiaaw, EVADDSSIAAW, 0x100004C1)                                     \
+  /* Vector Add Unsigned, Modulo, Integer to Accumulator Word */              \
+  V(evaddumiaaw, EVADDUMIAAW, 0x100004C8)                                     \
+  /* Vector Add Unsigned, Saturate, Integer to Accumulator Word */            \
+  V(evaddusiaaw, EVADDUSIAAW, 0x100004C0)                                     \
+  /* Vector Add Word */                                                       \
+  V(evaddw, EVADDW, 0x10000200)                                               \
+  /* Vector AND */                                                            \
+  V(evand, EVAND, 0x10000211)                                                 \
+  /* Vector AND with Complement */                                            \
+  V(evandc, EVANDC, 0x10000212)                                               \
+  /* Vector Compare Equal */                                                  \
+  V(evcmpeq, EVCMPEQ, 0x10000234)                                             \
+  /* Vector Compare Greater Than Signed */                                    \
+  V(evcmpgts, EVCMPGTS, 0x10000231)                                           \
+  /* Vector Compare Greater Than Unsigned */                                  \
+  V(evcmpgtu, EVCMPGTU, 0x10000230)                                           \
+  /* Vector Compare Less Than Signed */                                       \
+  V(evcmplts, EVCMPLTS, 0x10000233)                                           \
+  /* Vector Compare Less Than Unsigned */                                     \
+  V(evcmpltu, EVCMPLTU, 0x10000232)                                           \
+  /* Vector Count Leading Signed Bits Word */                                 \
+  V(evcntlsw, EVCNTLSW, 0x1000020E)                                           \
+  /* Vector Count Leading Zeros Word */                                       \
+  V(evcntlzw, EVCNTLZW, 0x1000020D)                                           \
+  /* Vector Divide Word Signed */                                             \
+  V(evdivws, EVDIVWS, 0x100004C6)                                             \
+  /* Vector Divide Word Unsigned */                                           \
+  V(evdivwu, EVDIVWU, 0x100004C7)                                             \
+  /* Vector Equivalent */                                                     \
+  V(eveqv, EVEQV, 0x10000219)                                                 \
+  /* Vector Extend Sign Byte */                                               \
+  V(evextsb, EVEXTSB, 0x1000020A)                                             \
+  /* Vector Extend Sign Half Word */                                          \
+  V(evextsh, EVEXTSH, 0x1000020B)                                             \
+  /* Vector Load Double Word into Double Word */                              \
+  V(evldd, EVLDD, 0x10000301)                                                 \
+  /* Vector Load Double Word into Double Word Indexed */                      \
+  V(evlddx, EVLDDX, 0x10000300)                                               \
+  /* Vector Load Double into Four Half Words */                               \
+  V(evldh, EVLDH, 0x10000305)                                                 \
+  /* Vector Load Double into Four Half Words Indexed */                       \
+  V(evldhx, EVLDHX, 0x10000304)                                               \
+  /* Vector Load Double into Two Words */                                     \
+  V(evldw, EVLDW, 0x10000303)                                                 \
+  /* Vector Load Double into Two Words Indexed */                             \
+  V(evldwx, EVLDWX, 0x10000302)                                               \
+  /* Vector Load Half Word into Half Words Even and Splat */                  \
+  V(evlhhesplat, EVLHHESPLAT, 0x10000309)                                     \
+  /* Vector Load Half Word into Half Words Even and Splat Indexed */          \
+  V(evlhhesplatx, EVLHHESPLATX, 0x10000308)                                   \
+  /* Vector Load Half Word into Half Word Odd Signed and Splat */             \
+  V(evlhhossplat, EVLHHOSSPLAT, 0x1000030F)                                   \
+  /* Vector Load Half Word into Half Word Odd Signed and Splat Indexed */     \
+  V(evlhhossplatx, EVLHHOSSPLATX, 0x1000030E)                                 \
+  /* Vector Load Half Word into Half Word Odd Unsigned and Splat */           \
+  V(evlhhousplat, EVLHHOUSPLAT, 0x1000030D)                                   \
+  /* Vector Load Half Word into Half Word Odd Unsigned and Splat Indexed */   \
+  V(evlhhousplatx, EVLHHOUSPLATX, 0x1000030C)                                 \
+  /* Vector Load Word into Two Half Words Even */                             \
+  V(evlwhe, EVLWHE, 0x10000311)                                               \
+  /* Vector Load Word into Two Half Words Odd Signed (with sign extension) */ \
+  V(evlwhos, EVLWHOS, 0x10000317)                                             \
+  /* Vector Load Word into Two Half Words Odd Signed Indexed (with sign */    \
+  /* extension) */                                                            \
+  V(evlwhosx, EVLWHOSX, 0x10000316)                                           \
+  /* Vector Load Word into Two Half Words Odd Unsigned (zero-extended) */     \
+  V(evlwhou, EVLWHOU, 0x10000315)                                             \
+  /* Vector Load Word into Two Half Words Odd Unsigned Indexed (zero- */      \
+  /* extended) */                                                             \
+  V(evlwhoux, EVLWHOUX, 0x10000314)                                           \
+  /* Vector Load Word into Two Half Words and Splat */                        \
+  V(evlwhsplat, EVLWHSPLAT, 0x1000031D)                                       \
+  /* Vector Load Word into Two Half Words and Splat Indexed */                \
+  V(evlwhsplatx, EVLWHSPLATX, 0x1000031C)                                     \
+  /* Vector Load Word into Word and Splat */                                  \
+  V(evlwwsplat, EVLWWSPLAT, 0x10000319)                                       \
+  /* Vector Load Word into Word and Splat Indexed */                          \
+  V(evlwwsplatx, EVLWWSPLATX, 0x10000318)                                     \
+  /* Vector Merge High */                                                     \
+  V(evmergehi, EVMERGEHI, 0x1000022C)                                         \
+  /* Vector Merge High/Low */                                                 \
+  V(evmergehilo, EVMERGEHILO, 0x1000022E)                                     \
+  /* Vector Merge Low */                                                      \
+  V(evmergelo, EVMERGELO, 0x1000022D)                                         \
+  /* Vector Merge Low/High */                                                 \
+  V(evmergelohi, EVMERGELOHI, 0x1000022F)                                     \
+  /* Vector Multiply Half Words, Even, Guarded, Signed, Modulo, Fractional */ \
+  /* and Accumulate */                                                        \
+  V(evmhegsmfaa, EVMHEGSMFAA, 0x1000052B)                                     \
+  /* Vector Multiply Half Words, Even, Guarded, Signed, Modulo, Fractional */ \
+  /* and Accumulate Negative */                                               \
+  V(evmhegsmfan, EVMHEGSMFAN, 0x100005AB)                                     \
+  /* Vector Multiply Half Words, Even, Guarded, Signed, Modulo, Integer */    \
+  /* and Accumulate */                                                        \
+  V(evmhegsmiaa, EVMHEGSMIAA, 0x10000529)                                     \
+  /* Vector Multiply Half Words, Even, Guarded, Signed, Modulo, Integer */    \
+  /* and Accumulate Negative */                                               \
+  V(evmhegsmian, EVMHEGSMIAN, 0x100005A9)                                     \
+  /* Vector Multiply Half Words, Even, Guarded, Unsigned, Modulo, Integer */  \
+  /* and Accumulate */                                                        \
+  V(evmhegumiaa, EVMHEGUMIAA, 0x10000528)                                     \
+  /* Vector Multiply Half Words, Even, Guarded, Unsigned, Modulo, Integer */  \
+  /* and Accumulate Negative */                                               \
+  V(evmhegumian, EVMHEGUMIAN, 0x100005A8)                                     \
+  /* Vector Multiply Half Words, Even, Signed, Modulo, Fractional */          \
+  V(evmhesmf, EVMHESMF, 0x1000040B)                                           \
+  /* Vector Multiply Half Words, Even, Signed, Modulo, Fractional to */       \
+  /* Accumulator */                                                           \
+  V(evmhesmfa, EVMHESMFA, 0x1000042B)                                         \
+  /* Vector Multiply Half Words, Even, Signed, Modulo, Fractional and */      \
+  /* Accumulate into Words */                                                 \
+  V(evmhesmfaaw, EVMHESMFAAW, 0x1000050B)                                     \
+  /* Vector Multiply Half Words, Even, Signed, Modulo, Fractional and */      \
+  /* Accumulate Negative into Words */                                        \
+  V(evmhesmfanw, EVMHESMFANW, 0x1000058B)                                     \
+  /* Vector Multiply Half Words, Even, Signed, Modulo, Integer */             \
+  V(evmhesmi, EVMHESMI, 0x10000409)                                           \
+  /* Vector Multiply Half Words, Even, Signed, Modulo, Integer to */          \
+  /* Accumulator */                                                           \
+  V(evmhesmia, EVMHESMIA, 0x10000429)                                         \
+  /* Vector Multiply Half Words, Even, Signed, Modulo, Integer and */         \
+  /* Accumulate into Words */                                                 \
+  V(evmhesmiaaw, EVMHESMIAAW, 0x10000509)                                     \
+  /* Vector Multiply Half Words, Even, Signed, Modulo, Integer and */         \
+  /* Accumulate Negative into Words */                                        \
+  V(evmhesmianw, EVMHESMIANW, 0x10000589)                                     \
+  /* Vector Multiply Half Words, Even, Signed, Saturate, Fractional */        \
+  V(evmhessf, EVMHESSF, 0x10000403)                                           \
+  /* Vector Multiply Half Words, Even, Signed, Saturate, Fractional to */     \
+  /* Accumulator */                                                           \
+  V(evmhessfa, EVMHESSFA, 0x10000423)                                         \
+  /* Vector Multiply Half Words, Even, Signed, Saturate, Fractional and */    \
+  /* Accumulate into Words */                                                 \
+  V(evmhessfaaw, EVMHESSFAAW, 0x10000503)                                     \
+  /* Vector Multiply Half Words, Even, Signed, Saturate, Fractional and */    \
+  /* Accumulate Negative into Words */                                        \
+  V(evmhessfanw, EVMHESSFANW, 0x10000583)                                     \
+  /* Vector Multiply Half Words, Even, Signed, Saturate, Integer and */       \
+  /* Accumulate into Words */                                                 \
+  V(evmhessiaaw, EVMHESSIAAW, 0x10000501)                                     \
+  /* Vector Multiply Half Words, Even, Signed, Saturate, Integer and */       \
+  /* Accumulate Negative into Words */                                        \
+  V(evmhessianw, EVMHESSIANW, 0x10000581)                                     \
+  /* Vector Multiply Half Words, Even, Unsigned, Modulo, Integer */           \
+  V(evmheumi, EVMHEUMI, 0x10000408)                                           \
+  /* Vector Multiply Half Words, Even, Unsigned, Modulo, Integer to */        \
+  /* Accumulator */                                                           \
+  V(evmheumia, EVMHEUMIA, 0x10000428)                                         \
+  /* Vector Multiply Half Words, Even, Unsigned, Modulo, Integer and */       \
+  /* Accumulate into Words */                                                 \
+  V(evmheumiaaw, EVMHEUMIAAW, 0x10000508)                                     \
+  /* Vector Multiply Half Words, Even, Unsigned, Modulo, Integer and */       \
+  /* Accumulate Negative into Words */                                        \
+  V(evmheumianw, EVMHEUMIANW, 0x10000588)                                     \
+  /* Vector Multiply Half Words, Even, Unsigned, Saturate, Integer and */     \
+  /* Accumulate into Words */                                                 \
+  V(evmheusiaaw, EVMHEUSIAAW, 0x10000500)                                     \
+  /* Vector Multiply Half Words, Even, Unsigned, Saturate, Integer and */     \
+  /* Accumulate Negative into Words */                                        \
+  V(evmheusianw, EVMHEUSIANW, 0x10000580)                                     \
+  /* Vector Multiply Half Words, Odd, Guarded, Signed, Modulo, Fractional */  \
+  /* and Accumulate */                                                        \
+  V(evmhogsmfaa, EVMHOGSMFAA, 0x1000052F)                                     \
+  /* Vector Multiply Half Words, Odd, Guarded, Signed, Modulo, Fractional */  \
+  /* and Accumulate Negative */                                               \
+  V(evmhogsmfan, EVMHOGSMFAN, 0x100005AF)                                     \
+  /* Vector Multiply Half Words, Odd, Guarded, Signed, Modulo, Integer, */    \
+  /* and Accumulate */                                                        \
+  V(evmhogsmiaa, EVMHOGSMIAA, 0x1000052D)                                     \
+  /* Vector Multiply Half Words, Odd, Guarded, Signed, Modulo, Integer and */ \
+  /* Accumulate Negative */                                                   \
+  V(evmhogsmian, EVMHOGSMIAN, 0x100005AD)                                     \
+  /* Vector Multiply Half Words, Odd, Guarded, Unsigned, Modulo, Integer */   \
+  /* and Accumulate */                                                        \
+  V(evmhogumiaa, EVMHOGUMIAA, 0x1000052C)                                     \
+  /* Vector Multiply Half Words, Odd, Guarded, Unsigned, Modulo, Integer */   \
+  /* and Accumulate Negative */                                               \
+  V(evmhogumian, EVMHOGUMIAN, 0x100005AC)                                     \
+  /* Vector Multiply Half Words, Odd, Signed, Modulo, Fractional */           \
+  V(evmhosmf, EVMHOSMF, 0x1000040F)                                           \
+  /* Vector Multiply Half Words, Odd, Signed, Modulo, Fractional to */        \
+  /* Accumulator */                                                           \
+  V(evmhosmfa, EVMHOSMFA, 0x1000042F)                                         \
+  /* Vector Multiply Half Words, Odd, Signed, Modulo, Fractional and */       \
+  /* Accumulate into Words */                                                 \
+  V(evmhosmfaaw, EVMHOSMFAAW, 0x1000050F)                                     \
+  /* Vector Multiply Half Words, Odd, Signed, Modulo, Fractional and */       \
+  /* Accumulate Negative into Words */                                        \
+  V(evmhosmfanw, EVMHOSMFANW, 0x1000058F)                                     \
+  /* Vector Multiply Half Words, Odd, Signed, Modulo, Integer */              \
+  V(evmhosmi, EVMHOSMI, 0x1000040D)                                           \
+  /* Vector Multiply Half Words, Odd, Signed, Modulo, Integer to */           \
+  /* Accumulator */                                                           \
+  V(evmhosmia, EVMHOSMIA, 0x1000042D)                                         \
+  /* Vector Multiply Half Words, Odd, Signed, Modulo, Integer and */          \
+  /* Accumulate into Words */                                                 \
+  V(evmhosmiaaw, EVMHOSMIAAW, 0x1000050D)                                     \
+  /* Vector Multiply Half Words, Odd, Signed, Modulo, Integer and */          \
+  /* Accumulate Negative into Words */                                        \
+  V(evmhosmianw, EVMHOSMIANW, 0x1000058D)                                     \
+  /* Vector Multiply Half Words, Odd, Signed, Saturate, Fractional */         \
+  V(evmhossf, EVMHOSSF, 0x10000407)                                           \
+  /* Vector Multiply Half Words, Odd, Signed, Saturate, Fractional to */      \
+  /* Accumulator */                                                           \
+  V(evmhossfa, EVMHOSSFA, 0x10000427)                                         \
+  /* Vector Multiply Half Words, Odd, Signed, Saturate, Fractional and */     \
+  /* Accumulate into Words */                                                 \
+  V(evmhossfaaw, EVMHOSSFAAW, 0x10000507)                                     \
+  /* Vector Multiply Half Words, Odd, Signed, Saturate, Fractional and */     \
+  /* Accumulate Negative into Words */                                        \
+  V(evmhossfanw, EVMHOSSFANW, 0x10000587)                                     \
+  /* Vector Multiply Half Words, Odd, Signed, Saturate, Integer and */        \
+  /* Accumulate into Words */                                                 \
+  V(evmhossiaaw, EVMHOSSIAAW, 0x10000505)                                     \
+  /* Vector Multiply Half Words, Odd, Signed, Saturate, Integer and */        \
+  /* Accumulate Negative into Words */                                        \
+  V(evmhossianw, EVMHOSSIANW, 0x10000585)                                     \
+  /* Vector Multiply Half Words, Odd, Unsigned, Modulo, Integer */            \
+  V(evmhoumi, EVMHOUMI, 0x1000040C)                                           \
+  /* Vector Multiply Half Words, Odd, Unsigned, Modulo, Integer to */         \
+  /* Accumulator */                                                           \
+  V(evmhoumia, EVMHOUMIA, 0x1000042C)                                         \
+  /* Vector Multiply Half Words, Odd, Unsigned, Modulo, Integer and */        \
+  /* Accumulate into Words */                                                 \
+  V(evmhoumiaaw, EVMHOUMIAAW, 0x1000050C)                                     \
+  /* Vector Multiply Half Words, Odd, Unsigned, Modulo, Integer and */        \
+  /* Accumulate Negative into Words */                                        \
+  V(evmhoumianw, EVMHOUMIANW, 0x1000058C)                                     \
+  /* Vector Multiply Half Words, Odd, Unsigned, Saturate, Integer and */      \
+  /* Accumulate into Words */                                                 \
+  V(evmhousiaaw, EVMHOUSIAAW, 0x10000504)                                     \
+  /* Vector Multiply Half Words, Odd, Unsigned, Saturate, Integer and */      \
+  /* Accumulate Negative into Words */                                        \
+  V(evmhousianw, EVMHOUSIANW, 0x10000584)                                     \
+  /* Initialize Accumulator */                                                \
+  V(evmra, EVMRA, 0x100004C4)                                                 \
+  /* Vector Multiply Word High Signed, Modulo, Fractional */                  \
+  V(evmwhsmf, EVMWHSMF, 0x1000044F)                                           \
+  /* Vector Multiply Word High Signed, Modulo, Fractional to Accumulator */   \
+  V(evmwhsmfa, EVMWHSMFA, 0x1000046F)                                         \
+  /* Vector Multiply Word High Signed, Modulo, Integer */                     \
+  V(evmwhsmi, EVMWHSMI, 0x1000044D)                                           \
+  /* Vector Multiply Word High Signed, Modulo, Integer to Accumulator */      \
+  V(evmwhsmia, EVMWHSMIA, 0x1000046D)                                         \
+  /* Vector Multiply Word High Signed, Saturate, Fractional */                \
+  V(evmwhssf, EVMWHSSF, 0x10000447)                                           \
+  /* Vector Multiply Word High Signed, Saturate, Fractional to Accumulator */ \
+  V(evmwhssfa, EVMWHSSFA, 0x10000467)                                         \
+  /* Vector Multiply Word High Unsigned, Modulo, Integer */                   \
+  V(evmwhumi, EVMWHUMI, 0x1000044C)                                           \
+  /* Vector Multiply Word High Unsigned, Modulo, Integer to Accumulator */    \
+  V(evmwhumia, EVMWHUMIA, 0x1000046C)                                         \
+  /* Vector Multiply Word Low Signed, Modulo, Integer and Accumulate in */    \
+  /* Words */                                                                 \
+  V(evmwlsmiaaw, EVMWLSMIAAW, 0x10000549)                                     \
+  /* Vector Multiply Word Low Signed, Modulo, Integer and Accumulate */       \
+  /* Negative in Words */                                                     \
+  V(evmwlsmianw, EVMWLSMIANW, 0x100005C9)                                     \
+  /* Vector Multiply Word Low Signed, Saturate, Integer and Accumulate in */  \
+  /* Words */                                                                 \
+  V(evmwlssiaaw, EVMWLSSIAAW, 0x10000541)                                     \
+  /* Vector Multiply Word Low Signed, Saturate, Integer and Accumulate */     \
+  /* Negative in Words */                                                     \
+  V(evmwlssianw, EVMWLSSIANW, 0x100005C1)                                     \
+  /* Vector Multiply Word Low Unsigned, Modulo, Integer */                    \
+  V(evmwlumi, EVMWLUMI, 0x10000448)                                           \
+  /* Vector Multiply Word Low Unsigned, Modulo, Integer to Accumulator */     \
+  V(evmwlumia, EVMWLUMIA, 0x10000468)                                         \
+  /* Vector Multiply Word Low Unsigned, Modulo, Integer and Accumulate in */  \
+  /* Words */                                                                 \
+  V(evmwlumiaaw, EVMWLUMIAAW, 0x10000548)                                     \
+  /* Vector Multiply Word Low Unsigned, Modulo, Integer and Accumulate */     \
+  /* Negative in Words */                                                     \
+  V(evmwlumianw, EVMWLUMIANW, 0x100005C8)                                     \
+  /* Vector Multiply Word Low Unsigned, Saturate, Integer and Accumulate */   \
+  /* in Words */                                                              \
+  V(evmwlusiaaw, EVMWLUSIAAW, 0x10000540)                                     \
+  /* Vector Multiply Word Low Unsigned, Saturate, Integer and Accumulate */   \
+  /* Negative in Words */                                                     \
+  V(evmwlusianw, EVMWLUSIANW, 0x100005C0)                                     \
+  /* Vector Multiply Word Signed, Modulo, Fractional */                       \
+  V(evmwsmf, EVMWSMF, 0x1000045B)                                             \
+  /* Vector Multiply Word Signed, Modulo, Fractional to Accumulator */        \
+  V(evmwsmfa, EVMWSMFA, 0x1000047B)                                           \
+  /* Vector Multiply Word Signed, Modulo, Fractional and Accumulate */        \
+  V(evmwsmfaa, EVMWSMFAA, 0x1000055B)                                         \
+  /* Vector Multiply Word Signed, Modulo, Fractional and Accumulate */        \
+  /* Negative */                                                              \
+  V(evmwsmfan, EVMWSMFAN, 0x100005DB)                                         \
+  /* Vector Multiply Word Signed, Modulo, Integer */                          \
+  V(evmwsmi, EVMWSMI, 0x10000459)                                             \
+  /* Vector Multiply Word Signed, Modulo, Integer to Accumulator */           \
+  V(evmwsmia, EVMWSMIA, 0x10000479)                                           \
+  /* Vector Multiply Word Signed, Modulo, Integer and Accumulate */           \
+  V(evmwsmiaa, EVMWSMIAA, 0x10000559)                                         \
+  /* Vector Multiply Word Signed, Modulo, Integer and Accumulate Negative */  \
+  V(evmwsmian, EVMWSMIAN, 0x100005D9)                                         \
+  /* Vector Multiply Word Signed, Saturate, Fractional */                     \
+  V(evmwssf, EVMWSSF, 0x10000453)                                             \
+  /* Vector Multiply Word Signed, Saturate, Fractional to Accumulator */      \
+  V(evmwssfa, EVMWSSFA, 0x10000473)                                           \
+  /* Vector Multiply Word Signed, Saturate, Fractional and Accumulate */      \
+  V(evmwssfaa, EVMWSSFAA, 0x10000553)                                         \
+  /* Vector Multiply Word Signed, Saturate, Fractional and Accumulate */      \
+  /* Negative */                                                              \
+  V(evmwssfan, EVMWSSFAN, 0x100005D3)                                         \
+  /* Vector Multiply Word Unsigned, Modulo, Integer */                        \
+  V(evmwumi, EVMWUMI, 0x10000458)                                             \
+  /* Vector Multiply Word Unsigned, Modulo, Integer to Accumulator */         \
+  V(evmwumia, EVMWUMIA, 0x10000478)                                           \
+  /* Vector Multiply Word Unsigned, Modulo, Integer and Accumulate */         \
+  V(evmwumiaa, EVMWUMIAA, 0x10000558)                                         \
+  /* Vector Multiply Word Unsigned, Modulo, Integer and Accumulate */         \
+  /* Negative */                                                              \
+  V(evmwumian, EVMWUMIAN, 0x100005D8)                                         \
+  /* Vector NAND */                                                           \
+  V(evnand, EVNAND, 0x1000021E)                                               \
+  /* Vector Negate */                                                         \
+  V(evneg, EVNEG, 0x10000209)                                                 \
+  /* Vector NOR */                                                            \
+  V(evnor, EVNOR, 0x10000218)                                                 \
+  /* Vector OR */                                                             \
+  V(evor, EVOR, 0x10000217)                                                   \
+  /* Vector OR with Complement */                                             \
+  V(evorc, EVORC, 0x1000021B)                                                 \
+  /* Vector Rotate Left Word */                                               \
+  V(evrlw, EVRLW, 0x10000228)                                                 \
+  /* Vector Rotate Left Word Immediate */                                     \
+  V(evrlwi, EVRLWI, 0x1000022A)                                               \
+  /* Vector Round Word */                                                     \
+  V(evrndw, EVRNDW, 0x1000020C)                                               \
+  /* Vector Shift Left Word */                                                \
+  V(evslw, EVSLW, 0x10000224)                                                 \
+  /* Vector Shift Left Word Immediate */                                      \
+  V(evslwi, EVSLWI, 0x10000226)                                               \
+  /* Vector Splat Fractional Immediate */                                     \
+  V(evsplatfi, EVSPLATFI, 0x1000022B)                                         \
+  /* Vector Splat Immediate */                                                \
+  V(evsplati, EVSPLATI, 0x10000229)                                           \
+  /* Vector Shift Right Word Immediate Signed */                              \
+  V(evsrwis, EVSRWIS, 0x10000223)                                             \
+  /* Vector Shift Right Word Immediate Unsigned */                            \
+  V(evsrwiu, EVSRWIU, 0x10000222)                                             \
+  /* Vector Shift Right Word Signed */                                        \
+  V(evsrws, EVSRWS, 0x10000221)                                               \
+  /* Vector Shift Right Word Unsigned */                                      \
+  V(evsrwu, EVSRWU, 0x10000220)                                               \
+  /* Vector Store Double of Double */                                         \
+  V(evstdd, EVSTDD, 0x10000321)                                               \
+  /* Vector Store Double of Double Indexed */                                 \
+  V(evstddx, EVSTDDX, 0x10000320)                                             \
+  /* Vector Store Double of Four Half Words */                                \
+  V(evstdh, EVSTDH, 0x10000325)                                               \
+  /* Vector Store Double of Four Half Words Indexed */                        \
+  V(evstdhx, EVSTDHX, 0x10000324)                                             \
+  /* Vector Store Double of Two Words */                                      \
+  V(evstdw, EVSTDW, 0x10000323)                                               \
+  /* Vector Store Double of Two Words Indexed */                              \
+  V(evstdwx, EVSTDWX, 0x10000322)                                             \
+  /* Vector Store Word of Two Half Words from Even */                         \
+  V(evstwhe, EVSTWHE, 0x10000331)                                             \
+  /* Vector Store Word of Two Half Words from Even Indexed */                 \
+  V(evstwhex, EVSTWHEX, 0x10000330)                                           \
+  /* Vector Store Word of Two Half Words from Odd */                          \
+  V(evstwho, EVSTWHO, 0x10000335)                                             \
+  /* Vector Store Word of Two Half Words from Odd Indexed */                  \
+  V(evstwhox, EVSTWHOX, 0x10000334)                                           \
+  /* Vector Store Word of Word from Even */                                   \
+  V(evstwwe, EVSTWWE, 0x10000339)                                             \
+  /* Vector Store Word of Word from Even Indexed */                           \
+  V(evstwwex, EVSTWWEX, 0x10000338)                                           \
+  /* Vector Store Word of Word from Odd */                                    \
+  V(evstwwo, EVSTWWO, 0x1000033D)                                             \
+  /* Vector Store Word of Word from Odd Indexed */                            \
+  V(evstwwox, EVSTWWOX, 0x1000033C)                                           \
+  /* Vector Subtract Signed, Modulo, Integer to Accumulator Word */           \
+  V(evsubfsmiaaw, EVSUBFSMIAAW, 0x100004CB)                                   \
+  /* Vector Subtract Signed, Saturate, Integer to Accumulator Word */         \
+  V(evsubfssiaaw, EVSUBFSSIAAW, 0x100004C3)                                   \
+  /* Vector Subtract Unsigned, Modulo, Integer to Accumulator Word */         \
+  V(evsubfumiaaw, EVSUBFUMIAAW, 0x100004CA)                                   \
+  /* Vector Subtract Unsigned, Saturate, Integer to Accumulator Word */       \
+  V(evsubfusiaaw, EVSUBFUSIAAW, 0x100004C2)                                   \
+  /* Vector Subtract from Word */                                             \
+  V(evsubfw, EVSUBFW, 0x10000204)                                             \
+  /* Vector Subtract Immediate from Word */                                   \
+  V(evsubifw, EVSUBIFW, 0x10000206)                                           \
+  /* Vector XOR */                                                            \
+  V(evxor, EVXOR, 0x10000216)                                                 \
+  /* Floating-Point Double-Precision Absolute Value */                        \
+  V(efdabs, EFDABS, 0x100002E4)                                               \
+  /* Floating-Point Double-Precision Add */                                   \
+  V(efdadd, EFDADD, 0x100002E0)                                               \
+  /* Floating-Point Double-Precision Convert from Single-Precision */         \
+  V(efdcfs, EFDCFS, 0x100002EF)                                               \
+  /* Convert Floating-Point Double-Precision from Signed Fraction */          \
+  V(efdcfsf, EFDCFSF, 0x100002F3)                                             \
+  /* Convert Floating-Point Double-Precision from Signed Integer */           \
+  V(efdcfsi, EFDCFSI, 0x100002F1)                                             \
+  /* Convert Floating-Point Double-Precision from Signed Integer */           \
+  /* Doubleword */                                                            \
+  V(efdcfsid, EFDCFSID, 0x100002E3)                                           \
+  /* Convert Floating-Point Double-Precision from Unsigned Fraction */        \
+  V(efdcfuf, EFDCFUF, 0x100002F2)                                             \
+  /* Convert Floating-Point Double-Precision from Unsigned Integer */         \
+  V(efdcfui, EFDCFUI, 0x100002F0)                                             \
+  /* Convert Floating-Point Double-Precision fromUnsigned Integer */          \
+  /* Doubleword */                                                            \
+  V(efdcfuid, EFDCFUID, 0x100002E2)                                           \
+  /* Floating-Point Double-Precision Compare Equal */                         \
+  V(efdcmpeq, EFDCMPEQ, 0x100002EE)                                           \
+  /* Floating-Point Double-Precision Compare Greater Than */                  \
+  V(efdcmpgt, EFDCMPGT, 0x100002EC)                                           \
+  /* Floating-Point Double-Precision Compare Less Than */                     \
+  V(efdcmplt, EFDCMPLT, 0x100002ED)                                           \
+  /* Convert Floating-Point Double-Precision to Signed Fraction */            \
+  V(efdctsf, EFDCTSF, 0x100002F7)                                             \
+  /* Convert Floating-Point Double-Precision to Signed Integer */             \
+  V(efdctsi, EFDCTSI, 0x100002F5)                                             \
+  /* Convert Floating-Point Double-Precision to Signed Integer Doubleword */  \
+  /* with Round toward Zero */                                                \
+  V(efdctsidz, EFDCTSIDZ, 0x100002EB)                                         \
+  /* Convert Floating-Point Double-Precision to Signed Integer with Round */  \
+  /* toward Zero */                                                           \
+  V(efdctsiz, EFDCTSIZ, 0x100002FA)                                           \
+  /* Convert Floating-Point Double-Precision to Unsigned Fraction */          \
+  V(efdctuf, EFDCTUF, 0x100002F6)                                             \
+  /* Convert Floating-Point Double-Precision to Unsigned Integer */           \
+  V(efdctui, EFDCTUI, 0x100002F4)                                             \
+  /* Convert Floating-Point Double-Precision to Unsigned Integer */           \
+  /* Doubleword with Round toward Zero */                                     \
+  V(efdctuidz, EFDCTUIDZ, 0x100002EA)                                         \
+  /* Convert Floating-Point Double-Precision to Unsigned Integer with */      \
+  /* Round toward Zero */                                                     \
+  V(efdctuiz, EFDCTUIZ, 0x100002F8)                                           \
+  /* Floating-Point Double-Precision Divide */                                \
+  V(efddiv, EFDDIV, 0x100002E9)                                               \
+  /* Floating-Point Double-Precision Multiply */                              \
+  V(efdmul, EFDMUL, 0x100002E8)                                               \
+  /* Floating-Point Double-Precision Negative Absolute Value */               \
+  V(efdnabs, EFDNABS, 0x100002E5)                                             \
+  /* Floating-Point Double-Precision Negate */                                \
+  V(efdneg, EFDNEG, 0x100002E6)                                               \
+  /* Floating-Point Double-Precision Subtract */                              \
+  V(efdsub, EFDSUB, 0x100002E1)                                               \
+  /* Floating-Point Double-Precision Test Equal */                            \
+  V(efdtsteq, EFDTSTEQ, 0x100002FE)                                           \
+  /* Floating-Point Double-Precision Test Greater Than */                     \
+  V(efdtstgt, EFDTSTGT, 0x100002FC)                                           \
+  /* Floating-Point Double-Precision Test Less Than */                        \
+  V(efdtstlt, EFDTSTLT, 0x100002FD)                                           \
+  /* Floating-Point Single-Precision Convert from Double-Precision */         \
+  V(efscfd, EFSCFD, 0x100002CF)                                               \
+  /* Floating-Point Absolute Value */                                         \
+  V(efsabs, EFSABS, 0x100002C4)                                               \
+  /* Floating-Point Add */                                                    \
+  V(efsadd, EFSADD, 0x100002C0)                                               \
+  /* Convert Floating-Point from Signed Fraction */                           \
+  V(efscfsf, EFSCFSF, 0x100002D3)                                             \
+  /* Convert Floating-Point from Signed Integer */                            \
+  V(efscfsi, EFSCFSI, 0x100002D1)                                             \
+  /* Convert Floating-Point from Unsigned Fraction */                         \
+  V(efscfuf, EFSCFUF, 0x100002D2)                                             \
+  /* Convert Floating-Point from Unsigned Integer */                          \
+  V(efscfui, EFSCFUI, 0x100002D0)                                             \
+  /* Floating-Point Compare Equal */                                          \
+  V(efscmpeq, EFSCMPEQ, 0x100002CE)                                           \
+  /* Floating-Point Compare Greater Than */                                   \
+  V(efscmpgt, EFSCMPGT, 0x100002CC)                                           \
+  /* Floating-Point Compare Less Than */                                      \
+  V(efscmplt, EFSCMPLT, 0x100002CD)                                           \
+  /* Convert Floating-Point to Signed Fraction */                             \
+  V(efsctsf, EFSCTSF, 0x100002D7)                                             \
+  /* Convert Floating-Point to Signed Integer */                              \
+  V(efsctsi, EFSCTSI, 0x100002D5)                                             \
+  /* Convert Floating-Point to Signed Integer with Round toward Zero */       \
+  V(efsctsiz, EFSCTSIZ, 0x100002DA)                                           \
+  /* Convert Floating-Point to Unsigned Fraction */                           \
+  V(efsctuf, EFSCTUF, 0x100002D6)                                             \
+  /* Convert Floating-Point to Unsigned Integer */                            \
+  V(efsctui, EFSCTUI, 0x100002D4)                                             \
+  /* Convert Floating-Point to Unsigned Integer with Round toward Zero */     \
+  V(efsctuiz, EFSCTUIZ, 0x100002D8)                                           \
+  /* Floating-Point Divide */                                                 \
+  V(efsdiv, EFSDIV, 0x100002C9)                                               \
+  /* Floating-Point Multiply */                                               \
+  V(efsmul, EFSMUL, 0x100002C8)                                               \
+  /* Floating-Point Negative Absolute Value */                                \
+  V(efsnabs, EFSNABS, 0x100002C5)                                             \
+  /* Floating-Point Negate */                                                 \
+  V(efsneg, EFSNEG, 0x100002C6)                                               \
+  /* Floating-Point Subtract */                                               \
+  V(efssub, EFSSUB, 0x100002C1)                                               \
+  /* Floating-Point Test Equal */                                             \
+  V(efststeq, EFSTSTEQ, 0x100002DE)                                           \
+  /* Floating-Point Test Greater Than */                                      \
+  V(efststgt, EFSTSTGT, 0x100002DC)                                           \
+  /* Floating-Point Test Less Than */                                         \
+  V(efststlt, EFSTSTLT, 0x100002DD)                                           \
+  /* Vector Floating-Point Absolute Value */                                  \
+  V(evfsabs, EVFSABS, 0x10000284)                                             \
+  /* Vector Floating-Point Add */                                             \
+  V(evfsadd, EVFSADD, 0x10000280)                                             \
+  /* Vector Convert Floating-Point from Signed Fraction */                    \
+  V(evfscfsf, EVFSCFSF, 0x10000293)                                           \
+  /* Vector Convert Floating-Point from Signed Integer */                     \
+  V(evfscfsi, EVFSCFSI, 0x10000291)                                           \
+  /* Vector Convert Floating-Point from Unsigned Fraction */                  \
+  V(evfscfuf, EVFSCFUF, 0x10000292)                                           \
+  /* Vector Convert Floating-Point from Unsigned Integer */                   \
+  V(evfscfui, EVFSCFUI, 0x10000290)                                           \
+  /* Vector Floating-Point Compare Equal */                                   \
+  V(evfscmpeq, EVFSCMPEQ, 0x1000028E)                                         \
+  /* Vector Floating-Point Compare Greater Than */                            \
+  V(evfscmpgt, EVFSCMPGT, 0x1000028C)                                         \
+  /* Vector Floating-Point Compare Less Than */                               \
+  V(evfscmplt, EVFSCMPLT, 0x1000028D)                                         \
+  /* Vector Convert Floating-Point to Signed Fraction */                      \
+  V(evfsctsf, EVFSCTSF, 0x10000297)                                           \
+  /* Vector Convert Floating-Point to Signed Integer */                       \
+  V(evfsctsi, EVFSCTSI, 0x10000295)                                           \
+  /* Vector Convert Floating-Point to Signed Integer with Round toward */     \
+  /* Zero */                                                                  \
+  V(evfsctsiz, EVFSCTSIZ, 0x1000029A)                                         \
+  /* Vector Convert Floating-Point to Unsigned Fraction */                    \
+  V(evfsctuf, EVFSCTUF, 0x10000296)                                           \
+  /* Vector Convert Floating-Point to Unsigned Integer */                     \
+  V(evfsctui, EVFSCTUI, 0x10000294)                                           \
+  /* Vector Convert Floating-Point to Unsigned Integer with Round toward */   \
+  /* Zero */                                                                  \
+  V(evfsctuiz, EVFSCTUIZ, 0x10000298)                                         \
+  /* Vector Floating-Point Divide */                                          \
+  V(evfsdiv, EVFSDIV, 0x10000289)                                             \
+  /* Vector Floating-Point Multiply */                                        \
+  V(evfsmul, EVFSMUL, 0x10000288)                                             \
+  /* Vector Floating-Point Negative Absolute Value */                         \
+  V(evfsnabs, EVFSNABS, 0x10000285)                                           \
+  /* Vector Floating-Point Negate */                                          \
+  V(evfsneg, EVFSNEG, 0x10000286)                                             \
+  /* Vector Floating-Point Subtract */                                        \
+  V(evfssub, EVFSSUB, 0x10000281)                                             \
+  /* Vector Floating-Point Test Equal */                                      \
+  V(evfststeq, EVFSTSTEQ, 0x1000029E)                                         \
+  /* Vector Floating-Point Test Greater Than */                               \
+  V(evfststgt, EVFSTSTGT, 0x1000029C)                                         \
+  /* Vector Floating-Point Test Less Than */                                  \
+  V(evfststlt, EVFSTSTLT, 0x1000029D)
+
+#define PPC_VC_OPCODE_LIST(V)                                    \
+  /* Vector Compare Bounds Single-Precision */                   \
+  V(vcmpbfp, VCMPBFP, 0x100003C6)                                \
+  /* Vector Compare Equal To Single-Precision */                 \
+  V(vcmpeqfp, VCMPEQFP, 0x100000C6)                              \
+  /* Vector Compare Equal To Unsigned Byte */                    \
+  V(vcmpequb, VCMPEQUB, 0x10000006)                              \
+  /* Vector Compare Equal To Unsigned Doubleword */              \
+  V(vcmpequd, VCMPEQUD, 0x100000C7)                              \
+  /* Vector Compare Equal To Unsigned Halfword */                \
+  V(vcmpequh, VCMPEQUH, 0x10000046)                              \
+  /* Vector Compare Equal To Unsigned Word */                    \
+  V(vcmpequw, VCMPEQUW, 0x10000086)                              \
+  /* Vector Compare Greater Than or Equal To Single-Precision */ \
+  V(vcmpgefp, VCMPGEFP, 0x100001C6)                              \
+  /* Vector Compare Greater Than Single-Precision */             \
+  V(vcmpgtfp, VCMPGTFP, 0x100002C6)                              \
+  /* Vector Compare Greater Than Signed Byte */                  \
+  V(vcmpgtsb, VCMPGTSB, 0x10000306)                              \
+  /* Vector Compare Greater Than Signed Doubleword */            \
+  V(vcmpgtsd, VCMPGTSD, 0x100003C7)                              \
+  /* Vector Compare Greater Than Signed Halfword */              \
+  V(vcmpgtsh, VCMPGTSH, 0x10000346)                              \
+  /* Vector Compare Greater Than Signed Word */                  \
+  V(vcmpgtsw, VCMPGTSW, 0x10000386)                              \
+  /* Vector Compare Greater Than Unsigned Byte */                \
+  V(vcmpgtub, VCMPGTUB, 0x10000206)                              \
+  /* Vector Compare Greater Than Unsigned Doubleword */          \
+  V(vcmpgtud, VCMPGTUD, 0x100002C7)                              \
+  /* Vector Compare Greater Than Unsigned Halfword */            \
+  V(vcmpgtuh, VCMPGTUH, 0x10000246)                              \
+  /* Vector Compare Greater Than Unsigned Word */                \
+  V(vcmpgtuw, VCMPGTUW, 0x10000286)
+
+#define PPC_X_OPCODE_A_FORM_LIST(V) \
+  /* Modulo Signed Dword */         \
+  V(modsd, MODSD, 0x7C000612)       \
+  /*  Modulo Unsigned Dword */      \
+  V(modud, MODUD, 0x7C000212)       \
+  /* Modulo Signed Word */          \
+  V(modsw, MODSW, 0x7C000616)       \
+  /* Modulo Unsigned Word */        \
+  V(moduw, MODUW, 0x7C000216)
+
+#define PPC_X_OPCODE_B_FORM_LIST(V)      \
+  /* XOR */                              \
+  V(xor_, XORX, 0x7C000278)              \
+  /* AND */                              \
+  V(and_, ANDX, 0x7C000038)              \
+  /* AND with Complement */              \
+  V(andc, ANDCX, 0x7C000078)             \
+  /* OR */                               \
+  V(orx, ORX, 0x7C000378)                \
+  /* OR with Complement */               \
+  V(orc, ORC, 0x7C000338)                \
+  /* NOR */                              \
+  V(nor, NORX, 0x7C0000F8)               \
+  /* Shift Right Word */                 \
+  V(srw, SRWX, 0x7C000430)               \
+  /* Shift Left Word */                  \
+  V(slw, SLWX, 0x7C000030)               \
+  /* Shift Right Algebraic Word */       \
+  V(sraw, SRAW, 0x7C000630)              \
+  /* Shift Left Doubleword */            \
+  V(sld, SLDX, 0x7C000036)               \
+  /* Shift Right Algebraic Doubleword */ \
+  V(srad, SRAD, 0x7C000634)              \
+  /* Shift Right Doubleword */           \
+  V(srd, SRDX, 0x7C000436)
+
+#define PPC_X_OPCODE_C_FORM_LIST(V)    \
+  /* Count Leading Zeros Word */       \
+  V(cntlzw, CNTLZWX, 0x7C000034)       \
+  /* Count Leading Zeros Doubleword */ \
+  V(cntlzd, CNTLZDX, 0x7C000074)       \
+  /* Population Count Byte-wise */     \
+  V(popcntb, POPCNTB, 0x7C0000F4)      \
+  /* Population Count Words */         \
+  V(popcntw, POPCNTW, 0x7C0002F4)      \
+  /* Population Count Doubleword */    \
+  V(popcntd, POPCNTD, 0x7C0003F4)      \
+  /* Extend Sign Byte */               \
+  V(extsb, EXTSB, 0x7C000774)          \
+  /* Extend Sign Halfword */           \
+  V(extsh, EXTSH, 0x7C000734)
+
+#define PPC_X_OPCODE_D_FORM_LIST(V)                     \
+  /* Load Halfword Byte-Reverse Indexed */              \
+  V(lhbrx, LHBRX, 0x7C00062C)                           \
+  /* Load Word Byte-Reverse Indexed */                  \
+  V(lwbrx, LWBRX, 0x7C00042C)                           \
+  /* Load Doubleword Byte-Reverse Indexed */            \
+  V(ldbrx, LDBRX, 0x7C000428)                           \
+  /* Load Byte and Zero Indexed */                      \
+  V(lbzx, LBZX, 0x7C0000AE)                             \
+  /* Load Byte and Zero with Update Indexed */          \
+  V(lbzux, LBZUX, 0x7C0000EE)                           \
+  /* Load Halfword and Zero Indexed */                  \
+  V(lhzx, LHZX, 0x7C00022E)                             \
+  /* Load Halfword and Zero with Update Indexed */      \
+  V(lhzux, LHZUX, 0x7C00026E)                           \
+  /* Load Halfword Algebraic Indexed */                 \
+  V(lhax, LHAX, 0x7C0002AE)                             \
+  /* Load Word and Zero Indexed */                      \
+  V(lwzx, LWZX, 0x7C00002E)                             \
+  /* Load Word and Zero with Update Indexed */          \
+  V(lwzux, LWZUX, 0x7C00006E)                           \
+  /* Load Doubleword Indexed */                         \
+  V(ldx, LDX, 0x7C00002A)                               \
+  /* Load Doubleword with Update Indexed */             \
+  V(ldux, LDUX, 0x7C00006A)                             \
+  /* Load Floating-Point Double Indexed */              \
+  V(lfdx, LFDX, 0x7C0004AE)                             \
+  /* Load Floating-Point Single Indexed */              \
+  V(lfsx, LFSX, 0x7C00042E)                             \
+  /* Load Floating-Point Double with Update Indexed */  \
+  V(lfdux, LFDUX, 0x7C0004EE)                           \
+  /* Load Floating-Point Single with Update Indexed */  \
+  V(lfsux, LFSUX, 0x7C00046E)                           \
+  /* Store Byte with Update Indexed */                  \
+  V(stbux, STBUX, 0x7C0001EE)                           \
+  /* Store Byte Indexed */                              \
+  V(stbx, STBX, 0x7C0001AE)                             \
+  /* Store Halfword with Update Indexed */              \
+  V(sthux, STHUX, 0x7C00036E)                           \
+  /* Store Halfword Indexed */                          \
+  V(sthx, STHX, 0x7C00032E)                             \
+  /* Store Word with Update Indexed */                  \
+  V(stwux, STWUX, 0x7C00016E)                           \
+  /* Store Word Indexed */                              \
+  V(stwx, STWX, 0x7C00012E)                             \
+  /* Store Doubleword with Update Indexed */            \
+  V(stdux, STDUX, 0x7C00016A)                           \
+  /* Store Doubleword Indexed */                        \
+  V(stdx, STDX, 0x7C00012A)                             \
+  /* Store Floating-Point Double with Update Indexed */ \
+  V(stfdux, STFDUX, 0x7C0005EE)                         \
+  /* Store Floating-Point Double Indexed */             \
+  V(stfdx, STFDX, 0x7C0005AE)                           \
+  /* Store Floating-Point Single with Update Indexed */ \
+  V(stfsux, STFSUX, 0x7C00056E)                         \
+  /* Store Floating-Point Single Indexed */             \
+  V(stfsx, STFSX, 0x7C00052E)                           \
+  /* Load Vector Indexed */                             \
+  V(lvx, LVX, 0x7C0000CE)                               \
+  /* Store Vector Indexed */                            \
+  V(stvx, STVX, 0x7C0001CE)
+
+#define PPC_X_OPCODE_E_FORM_LIST(V)          \
+  /* Shift Right Algebraic Word Immediate */ \
+  V(srawi, SRAWIX, 0x7C000670)
+
+#define PPC_X_OPCODE_F_FORM_LIST(V) \
+  /* Compare */                     \
+  V(cmp, CMP, 0x7C000000)           \
+  /* Compare Logical */             \
+  V(cmpl, CMPL, 0x7C000040)
+
+#define PPC_X_OPCODE_EH_S_FORM_LIST(V)                    \
+  /* Store Byte Conditional Indexed */                    \
+  V(stbcx, STBCX, 0x7C00056D)                             \
+  /* Store Halfword Conditional Indexed Xform */          \
+  V(sthcx, STHCX, 0x7C0005AD)                             \
+  /* Store Word Conditional Indexed & record CR0 */       \
+  V(stwcx, STWCX, 0x7C00012D)                             \
+  /* Store Doubleword Conditional Indexed & record CR0 */ \
+  V(stdcx, STDCX, 0x7C0001AD)
+
+#define PPC_X_OPCODE_EH_L_FORM_LIST(V)          \
+  /* Load Byte And Reserve Indexed */           \
+  V(lbarx, LBARX, 0x7C000068)                   \
+  /* Load Halfword And Reserve Indexed Xform */ \
+  V(lharx, LHARX, 0x7C0000E8)                   \
+  /* Load Word and Reserve Indexed */           \
+  V(lwarx, LWARX, 0x7C000028)                   \
+  /* Load Doubleword And Reserve Indexed */     \
+  V(ldarx, LDARX, 0x7C0000A8)
+
+#define PPC_X_OPCODE_UNUSED_LIST(V)                                           \
+  /* Bit Permute Doubleword */                                                \
+  V(bpermd, BPERMD, 0x7C0001F8)                                               \
+  /* Extend Sign Word */                                                      \
+  V(extsw, EXTSW, 0x7C0007B4)                                                 \
+  /* Load Word Algebraic with Update Indexed */                               \
+  V(lwaux, LWAUX, 0x7C0002EA)                                                 \
+  /* Load Word Algebraic Indexed */                                           \
+  V(lwax, LWAX, 0x7C0002AA)                                                   \
+  /* Parity Doubleword */                                                     \
+  V(prtyd, PRTYD, 0x7C000174)                                                 \
+  /* Store Doubleword Byte-Reverse Indexed */                                 \
+  V(stdbrx, STDBRX, 0x7C000528)                                               \
+  /* Trap Doubleword */                                                       \
+  V(td, TD, 0x7C000088)                                                       \
+  /* Branch Conditional to Branch Target Address Register */                  \
+  V(bctar, BCTAR, 0x4C000460)                                                 \
+  /* Compare Byte */                                                          \
+  V(cmpb, CMPB, 0x7C0003F8)                                                   \
+  /* Data Cache Block Flush */                                                \
+  V(dcbf, DCBF, 0x7C0000AC)                                                   \
+  /* Data Cache Block Store */                                                \
+  V(dcbst, DCBST, 0x7C00006C)                                                 \
+  /* Data Cache Block Touch */                                                \
+  V(dcbt, DCBT, 0x7C00022C)                                                   \
+  /* Data Cache Block Touch for Store */                                      \
+  V(dcbtst, DCBTST, 0x7C0001EC)                                               \
+  /* Data Cache Block Zero */                                                 \
+  V(dcbz, DCBZ, 0x7C0007EC)                                                   \
+  /* Equivalent */                                                            \
+  V(eqv, EQV, 0x7C000238)                                                     \
+  /* Instruction Cache Block Invalidate */                                    \
+  V(icbi, ICBI, 0x7C0007AC)                                                   \
+  /* NAND */                                                                  \
+  V(nand, NAND, 0x7C0003B8)                                                   \
+  /* Parity Word */                                                           \
+  V(prtyw, PRTYW, 0x7C000134)                                                 \
+  /* Store Halfword Byte-Reverse Indexed */                                   \
+  V(sthbrx, STHBRX, 0x7C00072C)                                               \
+  /* Store Word Byte-Reverse Indexed */                                       \
+  V(stwbrx, STWBRX, 0x7C00052C)                                               \
+  /* Synchronize */                                                           \
+  V(sync, SYNC, 0x7C0004AC)                                                   \
+  /* Trap Word */                                                             \
+  V(tw, TW, 0x7C000008)                                                       \
+  /* ExecuExecuted No Operation */                                            \
+  V(xnop, XNOP, 0x68000000)                                                   \
+  /* Convert Binary Coded Decimal To Declets */                               \
+  V(cbcdtd, CBCDTD, 0x7C000274)                                               \
+  /* Convert Declets To Binary Coded Decimal */                               \
+  V(cdtbcd, CDTBCD, 0x7C000234)                                               \
+  /* Decimal Floating Add */                                                  \
+  V(dadd, DADD, 0xEC000004)                                                   \
+  /* Decimal Floating Add Quad */                                             \
+  V(daddq, DADDQ, 0xFC000004)                                                 \
+  /* Decimal Floating Convert From Fixed */                                   \
+  V(dcffix, DCFFIX, 0xEC000644)                                               \
+  /* Decimal Floating Convert From Fixed Quad */                              \
+  V(dcffixq, DCFFIXQ, 0xFC000644)                                             \
+  /* Decimal Floating Compare Ordered */                                      \
+  V(dcmpo, DCMPO, 0xEC000104)                                                 \
+  /* Decimal Floating Compare Ordered Quad */                                 \
+  V(dcmpoq, DCMPOQ, 0xFC000104)                                               \
+  /* Decimal Floating Compare Unordered */                                    \
+  V(dcmpu, DCMPU, 0xEC000504)                                                 \
+  /* Decimal Floating Compare Unordered Quad */                               \
+  V(dcmpuq, DCMPUQ, 0xFC000504)                                               \
+  /* Decimal Floating Convert To DFP Long */                                  \
+  V(dctdp, DCTDP, 0xEC000204)                                                 \
+  /* Decimal Floating Convert To Fixed */                                     \
+  V(dctfix, DCTFIX, 0xEC000244)                                               \
+  /* Decimal Floating Convert To Fixed Quad */                                \
+  V(dctfixq, DCTFIXQ, 0xFC000244)                                             \
+  /* Decimal Floating Convert To DFP Extended */                              \
+  V(dctqpq, DCTQPQ, 0xFC000204)                                               \
+  /* Decimal Floating Decode DPD To BCD */                                    \
+  V(ddedpd, DDEDPD, 0xEC000284)                                               \
+  /* Decimal Floating Decode DPD To BCD Quad */                               \
+  V(ddedpdq, DDEDPDQ, 0xFC000284)                                             \
+  /* Decimal Floating Divide */                                               \
+  V(ddiv, DDIV, 0xEC000444)                                                   \
+  /* Decimal Floating Divide Quad */                                          \
+  V(ddivq, DDIVQ, 0xFC000444)                                                 \
+  /* Decimal Floating Encode BCD To DPD */                                    \
+  V(denbcd, DENBCD, 0xEC000684)                                               \
+  /* Decimal Floating Encode BCD To DPD Quad */                               \
+  V(denbcdq, DENBCDQ, 0xFC000684)                                             \
+  /* Decimal Floating Insert Exponent */                                      \
+  V(diex, DIEX, 0xEC0006C4)                                                   \
+  /* Decimal Floating Insert Exponent Quad */                                 \
+  V(diexq, DIEXQ, 0xFC0006C4)                                                 \
+  /* Decimal Floating Multiply */                                             \
+  V(dmul, DMUL, 0xEC000044)                                                   \
+  /* Decimal Floating Multiply Quad */                                        \
+  V(dmulq, DMULQ, 0xFC000044)                                                 \
+  /* Decimal Floating Round To DFP Long */                                    \
+  V(drdpq, DRDPQ, 0xFC000604)                                                 \
+  /* Decimal Floating Round To DFP Short */                                   \
+  V(drsp, DRSP, 0xEC000604)                                                   \
+  /* Decimal Floating Subtract */                                             \
+  V(dsub, DSUB, 0xEC000404)                                                   \
+  /* Decimal Floating Subtract Quad */                                        \
+  V(dsubq, DSUBQ, 0xFC000404)                                                 \
+  /* Decimal Floating Test Exponent */                                        \
+  V(dtstex, DTSTEX, 0xEC000144)                                               \
+  /* Decimal Floating Test Exponent Quad */                                   \
+  V(dtstexq, DTSTEXQ, 0xFC000144)                                             \
+  /* Decimal Floating Test Significance */                                    \
+  V(dtstsf, DTSTSF, 0xEC000544)                                               \
+  /* Decimal Floating Test Significance Quad */                               \
+  V(dtstsfq, DTSTSFQ, 0xFC000544)                                             \
+  /* Decimal Floating Extract Exponent */                                     \
+  V(dxex, DXEX, 0xEC0002C4)                                                   \
+  /* Decimal Floating Extract Exponent Quad */                                \
+  V(dxexq, DXEXQ, 0xFC0002C4)                                                 \
+  /* Decorated Storage Notify */                                              \
+  V(dsn, DSN, 0x7C0003C6)                                                     \
+  /* Load Byte with Decoration Indexed */                                     \
+  V(lbdx, LBDX, 0x7C000406)                                                   \
+  /* Load Doubleword with Decoration Indexed */                               \
+  V(lddx, LDDX, 0x7C0004C6)                                                   \
+  /* Load Floating Doubleword with Decoration Indexed */                      \
+  V(lfddx, LFDDX, 0x7C000646)                                                 \
+  /* Load Halfword with Decoration Indexed */                                 \
+  V(lhdx, LHDX, 0x7C000446)                                                   \
+  /* Load Word with Decoration Indexed */                                     \
+  V(lwdx, LWDX, 0x7C000486)                                                   \
+  /* Store Byte with Decoration Indexed */                                    \
+  V(stbdx, STBDX, 0x7C000506)                                                 \
+  /* Store Doubleword with Decoration Indexed */                              \
+  V(stddx, STDDX, 0x7C0005C6)                                                 \
+  /* Store Floating Doubleword with Decoration Indexed */                     \
+  V(stfddx, STFDDX, 0x7C000746)                                               \
+  /* Store Halfword with Decoration Indexed */                                \
+  V(sthdx, STHDX, 0x7C000546)                                                 \
+  /* Store Word with Decoration Indexed */                                    \
+  V(stwdx, STWDX, 0x7C000586)                                                 \
+  /* Data Cache Block Allocate */                                             \
+  V(dcba, DCBA, 0x7C0005EC)                                                   \
+  /* Data Cache Block Invalidate */                                           \
+  V(dcbi, DCBI, 0x7C0003AC)                                                   \
+  /* Instruction Cache Block Touch */                                         \
+  V(icbt, ICBT, 0x7C00002C)                                                   \
+  /* Move to Condition Register from XER */                                   \
+  V(mcrxr, MCRXR, 0x7C000400)                                                 \
+  /* TLB Invalidate Local Indexed */                                          \
+  V(tlbilx, TLBILX, 0x7C000024)                                               \
+  /* TLB Invalidate Virtual Address Indexed */                                \
+  V(tlbivax, TLBIVAX, 0x7C000624)                                             \
+  /* TLB Read Entry */                                                        \
+  V(tlbre, TLBRE, 0x7C000764)                                                 \
+  /* TLB Search Indexed */                                                    \
+  V(tlbsx, TLBSX, 0x7C000724)                                                 \
+  /* TLB Write Entry */                                                       \
+  V(tlbwe, TLBWE, 0x7C0007A4)                                                 \
+  /* Write External Enable */                                                 \
+  V(wrtee, WRTEE, 0x7C000106)                                                 \
+  /* Write External Enable Immediate */                                       \
+  V(wrteei, WRTEEI, 0x7C000146)                                               \
+  /* Data Cache Read */                                                       \
+  V(dcread, DCREAD, 0x7C00028C)                                               \
+  /* Instruction Cache Read */                                                \
+  V(icread, ICREAD, 0x7C0007CC)                                               \
+  /* Data Cache Invalidate */                                                 \
+  V(dci, DCI, 0x7C00038C)                                                     \
+  /* Instruction Cache Invalidate */                                          \
+  V(ici, ICI, 0x7C00078C)                                                     \
+  /* Move From Device Control Register User Mode Indexed */                   \
+  V(mfdcrux, MFDCRUX, 0x7C000246)                                             \
+  /* Move From Device Control Register Indexed */                             \
+  V(mfdcrx, MFDCRX, 0x7C000206)                                               \
+  /* Move To Device Control Register User Mode Indexed */                     \
+  V(mtdcrux, MTDCRUX, 0x7C000346)                                             \
+  /* Move To Device Control Register Indexed */                               \
+  V(mtdcrx, MTDCRX, 0x7C000306)                                               \
+  /* Return From Debug Interrupt */                                           \
+  V(rfdi, RFDI, 0x4C00004E)                                                   \
+  /* Data Cache Block Flush by External PID */                                \
+  V(dcbfep, DCBFEP, 0x7C0000FE)                                               \
+  /* Data Cache Block Store by External PID */                                \
+  V(dcbstep, DCBSTEP, 0x7C00007E)                                             \
+  /* Data Cache Block Touch by External PID */                                \
+  V(dcbtep, DCBTEP, 0x7C00027E)                                               \
+  /* Data Cache Block Touch for Store by External PID */                      \
+  V(dcbtstep, DCBTSTEP, 0x7C0001FE)                                           \
+  /* Data Cache Block Zero by External PID */                                 \
+  V(dcbzep, DCBZEP, 0x7C0007FE)                                               \
+  /* Instruction Cache Block Invalidate by External PID */                    \
+  V(icbiep, ICBIEP, 0x7C0007BE)                                               \
+  /* Load Byte and Zero by External PID Indexed */                            \
+  V(lbepx, LBEPX, 0x7C0000BE)                                                 \
+  /* Load Floating-Point Double by External PID Indexed */                    \
+  V(lfdepx, LFDEPX, 0x7C0004BE)                                               \
+  /* Load Halfword and Zero by External PID Indexed */                        \
+  V(lhepx, LHEPX, 0x7C00023E)                                                 \
+  /* Load Vector by External PID Indexed */                                   \
+  V(lvepx, LVEPX, 0x7C00024E)                                                 \
+  /* Load Vector by External PID Indexed Last */                              \
+  V(lvepxl, LVEPXL, 0x7C00020E)                                               \
+  /* Load Word and Zero by External PID Indexed */                            \
+  V(lwepx, LWEPX, 0x7C00003E)                                                 \
+  /* Store Byte by External PID Indexed */                                    \
+  V(stbepx, STBEPX, 0x7C0001BE)                                               \
+  /* Store Floating-Point Double by External PID Indexed */                   \
+  V(stfdepx, STFDEPX, 0x7C0005BE)                                             \
+  /* Store Halfword by External PID Indexed */                                \
+  V(sthepx, STHEPX, 0x7C00033E)                                               \
+  /* Store Vector by External PID Indexed */                                  \
+  V(stvepx, STVEPX, 0x7C00064E)                                               \
+  /* Store Vector by External PID Indexed Last */                             \
+  V(stvepxl, STVEPXL, 0x7C00060E)                                             \
+  /* Store Word by External PID Indexed */                                    \
+  V(stwepx, STWEPX, 0x7C00013E)                                               \
+  /* Load Doubleword by External PID Indexed */                               \
+  V(ldepx, LDEPX, 0x7C00003A)                                                 \
+  /* Store Doubleword by External PID Indexed */                              \
+  V(stdepx, STDEPX, 0x7C00013A)                                               \
+  /* TLB Search and Reserve Indexed */                                        \
+  V(tlbsrx, TLBSRX, 0x7C0006A5)                                               \
+  /* External Control In Word Indexed */                                      \
+  V(eciwx, ECIWX, 0x7C00026C)                                                 \
+  /* External Control Out Word Indexed */                                     \
+  V(ecowx, ECOWX, 0x7C00036C)                                                 \
+  /* Data Cache Block Lock Clear */                                           \
+  V(dcblc, DCBLC, 0x7C00030C)                                                 \
+  /* Data Cache Block Lock Query */                                           \
+  V(dcblq, DCBLQ, 0x7C00034D)                                                 \
+  /* Data Cache Block Touch and Lock Set */                                   \
+  V(dcbtls, DCBTLS, 0x7C00014C)                                               \
+  /* Data Cache Block Touch for Store and Lock Set */                         \
+  V(dcbtstls, DCBTSTLS, 0x7C00010C)                                           \
+  /* Instruction Cache Block Lock Clear */                                    \
+  V(icblc, ICBLC, 0x7C0001CC)                                                 \
+  /* Instruction Cache Block Lock Query */                                    \
+  V(icblq, ICBLQ, 0x7C00018D)                                                 \
+  /* Instruction Cache Block Touch and Lock Set */                            \
+  V(icbtls, ICBTLS, 0x7C0003CC)                                               \
+  /* Floating Compare Ordered */                                              \
+  V(fcmpo, FCMPO, 0xFC000040)                                                 \
+  /* Floating Compare Unordered */                                            \
+  V(fcmpu, FCMPU, 0xFC000000)                                                 \
+  /* Floating Test for software Divide */                                     \
+  V(ftdiv, FTDIV, 0xFC000100)                                                 \
+  /* Floating Test for software Square Root */                                \
+  V(ftsqrt, FTSQRT, 0xFC000140)                                               \
+  /* Load Floating-Point as Integer Word Algebraic Indexed */                 \
+  V(lfiwax, LFIWAX, 0x7C0006AE)                                               \
+  /* Load Floating-Point as Integer Word and Zero Indexed */                  \
+  V(lfiwzx, LFIWZX, 0x7C0006EE)                                               \
+  /* Move To Condition Register from FPSCR */                                 \
+  V(mcrfs, MCRFS, 0xFC000080)                                                 \
+  /* Store Floating-Point as Integer Word Indexed */                          \
+  V(stfiwx, STFIWX, 0x7C0007AE)                                               \
+  /* Load Floating-Point Double Pair Indexed */                               \
+  V(lfdpx, LFDPX, 0x7C00062E)                                                 \
+  /* Store Floating-Point Double Pair Indexed */                              \
+  V(stfdpx, STFDPX, 0x7C00072E)                                               \
+  /* Floating Absolute Value */                                               \
+  V(fabs, FABS, 0xFC000210)                                                   \
+  /* Floating Convert From Integer Doubleword */                              \
+  V(fcfid, FCFID, 0xFC00069C)                                                 \
+  /* Floating Convert From Integer Doubleword Single */                       \
+  V(fcfids, FCFIDS, 0xEC00069C)                                               \
+  /* Floating Convert From Integer Doubleword Unsigned */                     \
+  V(fcfidu, FCFIDU, 0xFC00079C)                                               \
+  /* Floating Convert From Integer Doubleword Unsigned Single */              \
+  V(fcfidus, FCFIDUS, 0xEC00079C)                                             \
+  /* Floating Copy Sign */                                                    \
+  V(fcpsgn, FCPSGN, 0xFC000010)                                               \
+  /* Floating Convert To Integer Doubleword */                                \
+  V(fctid, FCTID, 0xFC00065C)                                                 \
+  /* Floating Convert To Integer Doubleword Unsigned */                       \
+  V(fctidu, FCTIDU, 0xFC00075C)                                               \
+  /* Floating Convert To Integer Doubleword Unsigned with round toward */     \
+  /* Zero */                                                                  \
+  V(fctiduz, FCTIDUZ, 0xFC00075E)                                             \
+  /* Floating Convert To Integer Doubleword with round toward Zero */         \
+  V(fctidz, FCTIDZ, 0xFC00065E)                                               \
+  /* Floating Convert To Integer Word */                                      \
+  V(fctiw, FCTIW, 0xFC00001C)                                                 \
+  /* Floating Convert To Integer Word Unsigned */                             \
+  V(fctiwu, FCTIWU, 0xFC00011C)                                               \
+  /* Floating Convert To Integer Word Unsigned with round toward Zero */      \
+  V(fctiwuz, FCTIWUZ, 0xFC00011E)                                             \
+  /* Floating Convert To Integer Word with round to Zero */                   \
+  V(fctiwz, FCTIWZ, 0xFC00001E)                                               \
+  /* Floating Move Register */                                                \
+  V(fmr, FMR, 0xFC000090)                                                     \
+  /* Floating Negative Absolute Value */                                      \
+  V(fnabs, FNABS, 0xFC000110)                                                 \
+  /* Floating Negate */                                                       \
+  V(fneg, FNEG, 0xFC000050)                                                   \
+  /* Floating Round to Single-Precision */                                    \
+  V(frsp, FRSP, 0xFC000018)                                                   \
+  /* Move From FPSCR */                                                       \
+  V(mffs, MFFS, 0xFC00048E)                                                   \
+  /* Move To FPSCR Bit 0 */                                                   \
+  V(mtfsb0, MTFSB0, 0xFC00008C)                                               \
+  /* Move To FPSCR Bit 1 */                                                   \
+  V(mtfsb1, MTFSB1, 0xFC00004C)                                               \
+  /* Move To FPSCR Field Immediate */                                         \
+  V(mtfsfi, MTFSFI, 0xFC00010C)                                               \
+  /* Floating Round To Integer Minus */                                       \
+  V(frim, FRIM, 0xFC0003D0)                                                   \
+  /* Floating Round To Integer Nearest */                                     \
+  V(frin, FRIN, 0xFC000310)                                                   \
+  /* Floating Round To Integer Plus */                                        \
+  V(frip, FRIP, 0xFC000390)                                                   \
+  /* Floating Round To Integer toward Zero */                                 \
+  V(friz, FRIZ, 0xFC000350)                                                   \
+  /* Multiply Cross Halfword to Word Signed */                                \
+  V(mulchw, MULCHW, 0x10000150)                                               \
+  /* Multiply Cross Halfword to Word Unsigned */                              \
+  V(mulchwu, MULCHWU, 0x10000110)                                             \
+  /* Multiply High Halfword to Word Signed */                                 \
+  V(mulhhw, MULHHW, 0x10000050)                                               \
+  /* Multiply High Halfword to Word Unsigned */                               \
+  V(mulhhwu, MULHHWU, 0x10000010)                                             \
+  /* Multiply Low Halfword to Word Signed */                                  \
+  V(mullhw, MULLHW, 0x10000350)                                               \
+  /* Multiply Low Halfword to Word Unsigned */                                \
+  V(mullhwu, MULLHWU, 0x10000310)                                             \
+  /* Determine Leftmost Zero Byte DQ 56 E0000000 P 58 LSQ lq Load Quadword */ \
+  V(dlmzb, DLMZB, 0x7C00009C)                                                 \
+  /* Load Quadword And Reserve Indexed */                                     \
+  V(lqarx, LQARX, 0x7C000228)                                                 \
+  /* Store Quadword Conditional Indexed and record CR0 */                     \
+  V(stqcx, STQCX, 0x7C00016D)                                                 \
+  /* Load String Word Immediate */                                            \
+  V(lswi, LSWI, 0x7C0004AA)                                                   \
+  /* Load String Word Indexed */                                              \
+  V(lswx, LSWX, 0x7C00042A)                                                   \
+  /* Store String Word Immediate */                                           \
+  V(stswi, STSWI, 0x7C0005AA)                                                 \
+  /* Store String Word Indexed */                                             \
+  V(stswx, STSWX, 0x7C00052A)                                                 \
+  /* Clear BHRB */                                                            \
+  V(clrbhrb, CLRBHRB, 0x7C00035C)                                             \
+  /* Enforce In-order Execution of I/O */                                     \
+  V(eieio, EIEIO, 0x7C0006AC)                                                 \
+  /* Load Byte and Zero Caching Inhibited Indexed */                          \
+  V(lbzcix, LBZCIX, 0x7C0006AA)                                               \
+  /* Load Doubleword Caching Inhibited Indexed */                             \
+  V(ldcix, LDCIX, 0x7C0006EA)                                                 \
+  /* Load Halfword and Zero Caching Inhibited Indexed */                      \
+  V(lhzcix, LHZCIX, 0x7C00066A)                                               \
+  /* Load Word and Zero Caching Inhibited Indexed */                          \
+  V(lwzcix, LWZCIX, 0x7C00062A)                                               \
+  /* Move From Segment Register */                                            \
+  V(mfsr, MFSR, 0x7C0004A6)                                                   \
+  /* Move From Segment Register Indirect */                                   \
+  V(mfsrin, MFSRIN, 0x7C000526)                                               \
+  /* Move To Machine State Register Doubleword */                             \
+  V(mtmsrd, MTMSRD, 0x7C000164)                                               \
+  /* Move To Split Little Endian */                                           \
+  V(mtsle, MTSLE, 0x7C000126)                                                 \
+  /* Move To Segment Register */                                              \
+  V(mtsr, MTSR, 0x7C0001A4)                                                   \
+  /* Move To Segment Register Indirect */                                     \
+  V(mtsrin, MTSRIN, 0x7C0001E4)                                               \
+  /* SLB Find Entry ESID */                                                   \
+  V(slbfee, SLBFEE, 0x7C0007A7)                                               \
+  /* SLB Invalidate All */                                                    \
+  V(slbia, SLBIA, 0x7C0003E4)                                                 \
+  /* SLB Invalidate Entry */                                                  \
+  V(slbie, SLBIE, 0x7C000364)                                                 \
+  /* SLB Move From Entry ESID */                                              \
+  V(slbmfee, SLBMFEE, 0x7C000726)                                             \
+  /* SLB Move From Entry VSID */                                              \
+  V(slbmfev, SLBMFEV, 0x7C0006A6)                                             \
+  /* SLB Move To Entry */                                                     \
+  V(slbmte, SLBMTE, 0x7C000324)                                               \
+  /* Store Byte Caching Inhibited Indexed */                                  \
+  V(stbcix, STBCIX, 0x7C0007AA)                                               \
+  /* Store Doubleword Caching Inhibited Indexed */                            \
+  V(stdcix, STDCIX, 0x7C0007EA)                                               \
+  /* Store Halfword and Zero Caching Inhibited Indexed */                     \
+  V(sthcix, STHCIX, 0x7C00076A)                                               \
+  /* Store Word and Zero Caching Inhibited Indexed */                         \
+  V(stwcix, STWCIX, 0x7C00072A)                                               \
+  /* TLB Invalidate All */                                                    \
+  V(tlbia, TLBIA, 0x7C0002E4)                                                 \
+  /* TLB Invalidate Entry */                                                  \
+  V(tlbie, TLBIE, 0x7C000264)                                                 \
+  /* TLB Invalidate Entry Local */                                            \
+  V(tlbiel, TLBIEL, 0x7C000224)                                               \
+  /* Message Clear Privileged */                                              \
+  V(msgclrp, MSGCLRP, 0x7C00015C)                                             \
+  /* Message Send Privileged */                                               \
+  V(msgsndp, MSGSNDP, 0x7C00011C)                                             \
+  /* Message Clear */                                                         \
+  V(msgclr, MSGCLR, 0x7C0001DC)                                               \
+  /* Message Send */                                                          \
+  V(msgsnd, MSGSND, 0x7C00019C)                                               \
+  /* Move From Machine State Register */                                      \
+  V(mfmsr, MFMSR, 0x7C0000A6)                                                 \
+  /* Move To Machine State Register */                                        \
+  V(mtmsr, MTMSR, 0x7C000124)                                                 \
+  /* TLB Synchronize */                                                       \
+  V(tlbsync, TLBSYNC, 0x7C00046C)                                             \
+  /* Transaction Abort */                                                     \
+  V(tabort, TABORT, 0x7C00071D)                                               \
+  /* Transaction Abort Doubleword Conditional */                              \
+  V(tabortdc, TABORTDC, 0x7C00065D)                                           \
+  /* Transaction Abort Doubleword Conditional Immediate */                    \
+  V(tabortdci, TABORTDCI, 0x7C0006DD)                                         \
+  /* Transaction Abort Word Conditional */                                    \
+  V(tabortwc, TABORTWC, 0x7C00061D)                                           \
+  /* Transaction Abort Word Conditional Immediate */                          \
+  V(tabortwci, TABORTWCI, 0x7C00069D)                                         \
+  /* Transaction Begin */                                                     \
+  V(tbegin, TBEGIN, 0x7C00051D)                                               \
+  /* Transaction Check */                                                     \
+  V(tcheck, TCHECK, 0x7C00059C)                                               \
+  /* Transaction End */                                                       \
+  V(tend, TEND, 0x7C00055C)                                                   \
+  /* Transaction Recheckpoint */                                              \
+  V(trechkpt, TRECHKPT, 0x7C0007DD)                                           \
+  /* Transaction Reclaim */                                                   \
+  V(treclaim, TRECLAIM, 0x7C00075D)                                           \
+  /* Transaction Suspend or Resume */                                         \
+  V(tsr, TSR, 0x7C0005DC)                                                     \
+  /* Load Vector Element Byte Indexed */                                      \
+  V(lvebx, LVEBX, 0x7C00000E)                                                 \
+  /* Load Vector Element Halfword Indexed */                                  \
+  V(lvehx, LVEHX, 0x7C00004E)                                                 \
+  /* Load Vector Element Word Indexed */                                      \
+  V(lvewx, LVEWX, 0x7C00008E)                                                 \
+  /* Load Vector for Shift Left */                                            \
+  V(lvsl, LVSL, 0x7C00000C)                                                   \
+  /* Load Vector for Shift Right */                                           \
+  V(lvsr, LVSR, 0x7C00004C)                                                   \
+  /* Load Vector Indexed Last */                                              \
+  V(lvxl, LVXL, 0x7C0002CE)                                                   \
+  /* Store Vector Element Byte Indexed */                                     \
+  V(stvebx, STVEBX, 0x7C00010E)                                               \
+  /* Store Vector Element Halfword Indexed */                                 \
+  V(stvehx, STVEHX, 0x7C00014E)                                               \
+  /* Store Vector Element Word Indexed */                                     \
+  V(stvewx, STVEWX, 0x7C00018E)                                               \
+  /* Store Vector Indexed Last */                                             \
+  V(stvxl, STVXL, 0x7C0003CE)                                                 \
+  /* Floating Merge Even Word */                                              \
+  V(fmrgew, FMRGEW, 0xFC00078C)                                               \
+  /* Floating Merge Odd Word */                                               \
+  V(fmrgow, FMRGOW, 0xFC00068C)                                               \
+  /* Wait for Interrupt */                                                    \
+  V(wait, WAIT, 0x7C00007C)
+
+#define PPC_X_OPCODE_LIST(V)     \
+  PPC_X_OPCODE_A_FORM_LIST(V)    \
+  PPC_X_OPCODE_B_FORM_LIST(V)    \
+  PPC_X_OPCODE_C_FORM_LIST(V)    \
+  PPC_X_OPCODE_D_FORM_LIST(V)    \
+  PPC_X_OPCODE_E_FORM_LIST(V)    \
+  PPC_X_OPCODE_F_FORM_LIST(V)    \
+  PPC_X_OPCODE_EH_L_FORM_LIST(V) \
+  PPC_X_OPCODE_UNUSED_LIST(V)
+
+#define PPC_EVS_OPCODE_LIST(V) \
+  /* Vector Select */          \
+  V(evsel, EVSEL, 0x10000278)
+
+#define PPC_DS_OPCODE_LIST(V)            \
+  /* Load Doubleword */                  \
+  V(ld, LD, 0xE8000000)                  \
+  /* Load Doubleword with Update */      \
+  V(ldu, LDU, 0xE8000001)                \
+  /* Load Word Algebraic */              \
+  V(lwa, LWA, 0xE8000002)                \
+  /* Store Doubleword */                 \
+  V(std, STD, 0xF8000000)                \
+  /* Store Doubleword with Update */     \
+  V(stdu, STDU, 0xF8000001)              \
+  /* Load Floating-Point Double Pair */  \
+  V(lfdp, LFDP, 0xE4000000)              \
+  /* Store Floating-Point Double Pair */ \
+  V(stfdp, STFDP, 0xF4000000)            \
+  /* Store Quadword */                   \
+  V(stq, STQ, 0xF8000002)
+
+#define PPC_DQ_OPCODE_LIST(V) V(lsq, LSQ, 0xE0000000)
+
+#define PPC_D_OPCODE_LIST(V)                    \
+  /* Trap Doubleword Immediate */               \
+  V(tdi, TDI, 0x08000000)                       \
+  /* Add Immediate */                           \
+  V(addi, ADDI, 0x38000000)                     \
+  /* Add Immediate Carrying */                  \
+  V(addic, ADDIC, 0x30000000)                   \
+  /* Add Immediate Carrying & record CR0 */     \
+  V(addicx, ADDICx, 0x34000000)                 \
+  /* Add Immediate Shifted */                   \
+  V(addis, ADDIS, 0x3C000000)                   \
+  /* AND Immediate & record CR0 */              \
+  V(andix, ANDIx, 0x70000000)                   \
+  /* AND Immediate Shifted & record CR0 */      \
+  V(andisx, ANDISx, 0x74000000)                 \
+  /* Compare Immediate */                       \
+  V(cmpi, CMPI, 0x2C000000)                     \
+  /* Compare Logical Immediate */               \
+  V(cmpli, CMPLI, 0x28000000)                   \
+  /* Load Byte and Zero */                      \
+  V(lbz, LBZ, 0x88000000)                       \
+  /* Load Byte and Zero with Update */          \
+  V(lbzu, LBZU, 0x8C000000)                     \
+  /* Load Halfword Algebraic */                 \
+  V(lha, LHA, 0xA8000000)                       \
+  /* Load Halfword Algebraic with Update */     \
+  V(lhau, LHAU, 0xAC000000)                     \
+  /* Load Halfword and Zero */                  \
+  V(lhz, LHZ, 0xA0000000)                       \
+  /* Load Halfword and Zero with Update */      \
+  V(lhzu, LHZU, 0xA4000000)                     \
+  /* Load Multiple Word */                      \
+  V(lmw, LMW, 0xB8000000)                       \
+  /* Load Word and Zero */                      \
+  V(lwz, LWZ, 0x80000000)                       \
+  /* Load Word and Zero with Update */          \
+  V(lwzu, LWZU, 0x84000000)                     \
+  /* Multiply Low Immediate */                  \
+  V(mulli, MULLI, 0x1C000000)                   \
+  /* OR Immediate */                            \
+  V(ori, ORI, 0x60000000)                       \
+  /* OR Immediate Shifted */                    \
+  V(oris, ORIS, 0x64000000)                     \
+  /* Store Byte */                              \
+  V(stb, STB, 0x98000000)                       \
+  /* Store Byte with Update */                  \
+  V(stbu, STBU, 0x9C000000)                     \
+  /* Store Halfword */                          \
+  V(sth, STH, 0xB0000000)                       \
+  /* Store Halfword with Update */              \
+  V(sthu, STHU, 0xB4000000)                     \
+  /* Store Multiple Word */                     \
+  V(stmw, STMW, 0xBC000000)                     \
+  /* Store Word */                              \
+  V(stw, STW, 0x90000000)                       \
+  /* Store Word with Update */                  \
+  V(stwu, STWU, 0x94000000)                     \
+  /* Subtract From Immediate Carrying */        \
+  V(subfic, SUBFIC, 0x20000000)                 \
+  /* Trap Word Immediate */                     \
+  V(twi, TWI, 0x0C000000)                       \
+  /* XOR Immediate */                           \
+  V(xori, XORI, 0x68000000)                     \
+  /* XOR Immediate Shifted */                   \
+  V(xoris, XORIS, 0x6C000000)                   \
+  /* Load Floating-Point Double */              \
+  V(lfd, LFD, 0xC8000000)                       \
+  /* Load Floating-Point Double with Update */  \
+  V(lfdu, LFDU, 0xCC000000)                     \
+  /* Load Floating-Point Single */              \
+  V(lfs, LFS, 0xC0000000)                       \
+  /* Load Floating-Point Single with Update */  \
+  V(lfsu, LFSU, 0xC4000000)                     \
+  /* Store Floating-Point Double */             \
+  V(stfd, STFD, 0xD8000000)                     \
+  /* Store Floating-Point Double with Update */ \
+  V(stfdu, STFDU, 0xDC000000)                   \
+  /* Store Floating-Point Single */             \
+  V(stfs, STFS, 0xD0000000)                     \
+  /* Store Floating-Point Single with Update */ \
+  V(stfsu, STFSU, 0xD4000000)
+
+#define PPC_XFL_OPCODE_LIST(V) \
+  /* Move To FPSCR Fields */   \
+  V(mtfsf, MTFSF, 0xFC00058E)
+
+#define PPC_XFX_OPCODE_LIST(V)                  \
+  /* Move From Condition Register */            \
+  V(mfcr, MFCR, 0x7C000026)                     \
+  /* Move From One Condition Register Field */  \
+  V(mfocrf, MFOCRF, 0x7C100026)                 \
+  /* Move From Special Purpose Register */      \
+  V(mfspr, MFSPR, 0x7C0002A6)                   \
+  /* Move To Condition Register Fields */       \
+  V(mtcrf, MTCRF, 0x7C000120)                   \
+  /* Move To One Condition Register Field */    \
+  V(mtocrf, MTOCRF, 0x7C100120)                 \
+  /* Move To Special Purpose Register */        \
+  V(mtspr, MTSPR, 0x7C0003A6)                   \
+  /* Debugger Notify Halt */                    \
+  V(dnh, DNH, 0x4C00018C)                       \
+  /* Move From Device Control Register */       \
+  V(mfdcr, MFDCR, 0x7C000286)                   \
+  /* Move To Device Control Register */         \
+  V(mtdcr, MTDCR, 0x7C000386)                   \
+  /* Move from Performance Monitor Register */  \
+  V(mfpmr, MFPMR, 0x7C00029C)                   \
+  /* Move To Performance Monitor Register */    \
+  V(mtpmr, MTPMR, 0x7C00039C)                   \
+  /* Move From Branch History Rolling Buffer */ \
+  V(mfbhrbe, MFBHRBE, 0x7C00025C)               \
+  /* Move From Time Base */                     \
+  V(mftb, MFTB, 0x7C0002E6)
+
+#define PPC_MDS_OPCODE_LIST(V)                  \
+  /* Rotate Left Doubleword then Clear Left */  \
+  V(rldcl, RLDCL, 0x78000010)                   \
+  /* Rotate Left Doubleword then Clear Right */ \
+  V(rldcr, RLDCR, 0x78000012)
+
+#define PPC_A_OPCODE_LIST(V)                            \
+  /* Integer Select */                                  \
+  V(isel, ISEL, 0x7C00001E)                             \
+  /* Floating Add */                                    \
+  V(fadd, FADD, 0xFC00002A)                             \
+  /* Floating Add Single */                             \
+  V(fadds, FADDS, 0xEC00002A)                           \
+  /* Floating Divide */                                 \
+  V(fdiv, FDIV, 0xFC000024)                             \
+  /* Floating Divide Single */                          \
+  V(fdivs, FDIVS, 0xEC000024)                           \
+  /* Floating Multiply-Add */                           \
+  V(fmadd, FMADD, 0xFC00003A)                           \
+  /* Floating Multiply-Add Single */                    \
+  V(fmadds, FMADDS, 0xEC00003A)                         \
+  /* Floating Multiply-Subtract */                      \
+  V(fmsub, FMSUB, 0xFC000038)                           \
+  /* Floating Multiply-Subtract Single */               \
+  V(fmsubs, FMSUBS, 0xEC000038)                         \
+  /* Floating Multiply */                               \
+  V(fmul, FMUL, 0xFC000032)                             \
+  /* Floating Multiply Single */                        \
+  V(fmuls, FMULS, 0xEC000032)                           \
+  /* Floating Negative Multiply-Add */                  \
+  V(fnmadd, FNMADD, 0xFC00003E)                         \
+  /* Floating Negative Multiply-Add Single */           \
+  V(fnmadds, FNMADDS, 0xEC00003E)                       \
+  /* Floating Negative Multiply-Subtract */             \
+  V(fnmsub, FNMSUB, 0xFC00003C)                         \
+  /* Floating Negative Multiply-Subtract Single */      \
+  V(fnmsubs, FNMSUBS, 0xEC00003C)                       \
+  /* Floating Reciprocal Estimate Single */             \
+  V(fres, FRES, 0xEC000030)                             \
+  /* Floating Reciprocal Square Root Estimate */        \
+  V(frsqrte, FRSQRTE, 0xFC000034)                       \
+  /* Floating Select */                                 \
+  V(fsel, FSEL, 0xFC00002E)                             \
+  /* Floating Square Root */                            \
+  V(fsqrt, FSQRT, 0xFC00002C)                           \
+  /* Floating Square Root Single */                     \
+  V(fsqrts, FSQRTS, 0xEC00002C)                         \
+  /* Floating Subtract */                               \
+  V(fsub, FSUB, 0xFC000028)                             \
+  /* Floating Subtract Single */                        \
+  V(fsubs, FSUBS, 0xEC000028)                           \
+  /* Floating Reciprocal Estimate */                    \
+  V(fre, FRE, 0xFC000030)                               \
+  /* Floating Reciprocal Square Root Estimate Single */ \
+  V(frsqrtes, FRSQRTES, 0xEC000034)
+
+#define PPC_VA_OPCODE_A_FORM_LIST(V)                     \
+  /* Vector Permute */                                   \
+  V(vperm, VPERM, 0x1000002B)                            \
+  /* Vector Multiply-Low-Add Unsigned Halfword Modulo */ \
+  V(vmladduhm, VMLADDUHM, 0x10000022)                    \
+  /* Vector Select */                                    \
+  V(vsel, VSEL, 0x1000002A)
+
+#define PPC_VA_OPCODE_UNUSED_LIST(V)                             \
+  /* Vector Add Extended & write Carry Unsigned Quadword */      \
+  V(vaddecuq, VADDECUQ, 0x1000003D)                              \
+  /* Vector Add Extended Unsigned Quadword Modulo */             \
+  V(vaddeuqm, VADDEUQM, 0x1000003C)                              \
+  /* Vector Multiply-Add Single-Precision */                     \
+  V(vmaddfp, VMADDFP, 0x1000002E)                                \
+  /* Vector Multiply-High-Add Signed Halfword Saturate */        \
+  V(vmhaddshs, VMHADDSHS, 0x10000020)                            \
+  /* Vector Multiply-High-Round-Add Signed Halfword Saturate */  \
+  V(vmhraddshs, VMHRADDSHS, 0x10000021)                          \
+  /* Vector Multiply-Sum Mixed Byte Modulo */                    \
+  V(vmsummbm, VMSUMMBM, 0x10000025)                              \
+  /* Vector Multiply-Sum Signed Halfword Modulo */               \
+  V(vmsumshm, VMSUMSHM, 0x10000028)                              \
+  /* Vector Multiply-Sum Signed Halfword Saturate */             \
+  V(vmsumshs, VMSUMSHS, 0x10000029)                              \
+  /* Vector Multiply-Sum Unsigned Byte Modulo */                 \
+  V(vmsumubm, VMSUMUBM, 0x10000024)                              \
+  /* Vector Multiply-Sum Unsigned Halfword Modulo */             \
+  V(vmsumuhm, VMSUMUHM, 0x10000026)                              \
+  /* Vector Multiply-Sum Unsigned Halfword Saturate */           \
+  V(vmsumuhs, VMSUMUHS, 0x10000027)                              \
+  /* Vector Negative Multiply-Subtract Single-Precision */       \
+  V(vnmsubfp, VNMSUBFP, 0x1000002F)                              \
+  /* Vector Shift Left Double by Octet Immediate */              \
+  V(vsldoi, VSLDOI, 0x1000002C)                                  \
+  /* Vector Subtract Extended & write Carry Unsigned Quadword */ \
+  V(vsubecuq, VSUBECUQ, 0x1000003F)                              \
+  /* Vector Subtract Extended Unsigned Quadword Modulo */        \
+  V(vsubeuqm, VSUBEUQM, 0x1000003E)                              \
+  /* Vector Permute and Exclusive-OR */                          \
+  V(vpermxor, VPERMXOR, 0x1000002D)
+
+#define PPC_VA_OPCODE_LIST(V)  \
+  PPC_VA_OPCODE_A_FORM_LIST(V) \
+  PPC_VA_OPCODE_UNUSED_LIST(V)
+
+#define PPC_XX1_OPCODE_LIST(V)                            \
+  /* Load VSR Scalar Doubleword Indexed */                \
+  V(lxsdx, LXSDX, 0x7C000498)                             \
+  /* Load VSX Scalar as Integer Word Algebraic Indexed */ \
+  V(lxsiwax, LXSIWAX, 0x7C000098)                         \
+  /* Load VSX Scalar as Integer Word and Zero Indexed */  \
+  V(lxsiwzx, LXSIWZX, 0x7C000018)                         \
+  /* Load VSX Scalar Single-Precision Indexed */          \
+  V(lxsspx, LXSSPX, 0x7C000418)                           \
+  /* Load VSR Vector Doubleword*2 Indexed */              \
+  V(lxvd, LXVD, 0x7C000698)                               \
+  /* Load VSR Vector Doubleword & Splat Indexed */        \
+  V(lxvdsx, LXVDSX, 0x7C000298)                           \
+  /* Load VSR Vector Word*4 Indexed */                    \
+  V(lxvw, LXVW, 0x7C000618)                               \
+  /* Move From VSR Doubleword */                          \
+  V(mfvsrd, MFVSRD, 0x7C000066)                           \
+  /* Move From VSR Word and Zero */                       \
+  V(mfvsrwz, MFVSRWZ, 0x7C0000E6)                         \
+  /* Store VSR Scalar Doubleword Indexed */               \
+  V(stxsdx, STXSDX, 0x7C000598)                           \
+  /* Store VSX Scalar as Integer Word Indexed */          \
+  V(stxsiwx, STXSIWX, 0x7C000118)                         \
+  /* Store VSR Scalar Word Indexed */                     \
+  V(stxsspx, STXSSPX, 0x7C000518)                         \
+  /* Store VSR Vector Doubleword*2 Indexed */             \
+  V(stxvd, STXVD, 0x7C000798)                             \
+  /* Store VSR Vector Word*4 Indexed */                   \
+  V(stxvw, STXVW, 0x7C000718)
+
+#define PPC_B_OPCODE_LIST(V) \
+  /* Branch Conditional */   \
+  V(bc, BCX, 0x40000000)
+
+#define PPC_XO_OPCODE_LIST(V)                                               \
+  /* Divide Doubleword */                                                   \
+  V(divd, DIVD, 0x7C0003D2)                                                 \
+  /* Divide Doubleword Extended */                                          \
+  V(divde, DIVDE, 0x7C000352)                                               \
+  /* Divide Doubleword Extended & record OV */                              \
+  V(divdeo, DIVDEO, 0x7C000752)                                             \
+  /* Divide Doubleword Extended Unsigned */                                 \
+  V(divdeu, DIVDEU, 0x7C000312)                                             \
+  /* Divide Doubleword Extended Unsigned & record OV */                     \
+  V(divdeuo, DIVDEUO, 0x7C000712)                                           \
+  /* Divide Doubleword & record OV */                                       \
+  V(divdo, DIVDO, 0x7C0007D2)                                               \
+  /* Divide Doubleword Unsigned */                                          \
+  V(divdu, DIVDU, 0x7C000392)                                               \
+  /* Divide Doubleword Unsigned & record OV */                              \
+  V(divduo, DIVDUO, 0x7C000792)                                             \
+  /* Multiply High Doubleword */                                            \
+  V(mulhd, MULHD, 0x7C000092)                                               \
+  /* Multiply High Doubleword Unsigned */                                   \
+  V(mulhdu, MULHDU, 0x7C000012)                                             \
+  /* Multiply Low Doubleword */                                             \
+  V(mulld, MULLD, 0x7C0001D2)                                               \
+  /* Multiply Low Doubleword & record OV */                                 \
+  V(mulldo, MULLDO, 0x7C0005D2)                                             \
+  /* Add */                                                                 \
+  V(add, ADDX, 0x7C000214)                                                  \
+  /* Add Carrying */                                                        \
+  V(addc, ADDCX, 0x7C000014)                                                \
+  /* Add Carrying & record OV */                                            \
+  V(addco, ADDCO, 0x7C000414)                                               \
+  /* Add Extended */                                                        \
+  V(adde, ADDEX, 0x7C000114)                                                \
+  /* Add Extended & record OV & record OV */                                \
+  V(addeo, ADDEO, 0x7C000514)                                               \
+  /* Add to Minus One Extended */                                           \
+  V(addme, ADDME, 0x7C0001D4)                                               \
+  /* Add to Minus One Extended & record OV */                               \
+  V(addmeo, ADDMEO, 0x7C0005D4)                                             \
+  /* Add & record OV */                                                     \
+  V(addo, ADDO, 0x7C000614)                                                 \
+  /* Add to Zero Extended */                                                \
+  V(addze, ADDZEX, 0x7C000194)                                              \
+  /* Add to Zero Extended & record OV */                                    \
+  V(addzeo, ADDZEO, 0x7C000594)                                             \
+  /* Divide Word Format */                                                  \
+  V(divw, DIVW, 0x7C0003D6)                                                 \
+  /* Divide Word Extended */                                                \
+  V(divwe, DIVWE, 0x7C000356)                                               \
+  /* Divide Word Extended & record OV */                                    \
+  V(divweo, DIVWEO, 0x7C000756)                                             \
+  /* Divide Word Extended Unsigned */                                       \
+  V(divweu, DIVWEU, 0x7C000316)                                             \
+  /* Divide Word Extended Unsigned & record OV */                           \
+  V(divweuo, DIVWEUO, 0x7C000716)                                           \
+  /* Divide Word & record OV */                                             \
+  V(divwo, DIVWO, 0x7C0007D6)                                               \
+  /* Divide Word Unsigned */                                                \
+  V(divwu, DIVWU, 0x7C000396)                                               \
+  /* Divide Word Unsigned & record OV */                                    \
+  V(divwuo, DIVWUO, 0x7C000796)                                             \
+  /* Multiply High Word */                                                  \
+  V(mulhw, MULHWX, 0x7C000096)                                              \
+  /* Multiply High Word Unsigned */                                         \
+  V(mulhwu, MULHWUX, 0x7C000016)                                            \
+  /* Multiply Low Word */                                                   \
+  V(mullw, MULLW, 0x7C0001D6)                                               \
+  /* Multiply Low Word & record OV */                                       \
+  V(mullwo, MULLWO, 0x7C0005D6)                                             \
+  /* Negate */                                                              \
+  V(neg, NEGX, 0x7C0000D0)                                                  \
+  /* Negate & record OV */                                                  \
+  V(nego, NEGO, 0x7C0004D0)                                                 \
+  /* Subtract From */                                                       \
+  V(subf, SUBFX, 0x7C000050)                                                \
+  /* Subtract From Carrying */                                              \
+  V(subfc, SUBFCX, 0x7C000010)                                              \
+  /* Subtract From Carrying & record OV */                                  \
+  V(subfco, SUBFCO, 0x7C000410)                                             \
+  /* Subtract From Extended */                                              \
+  V(subfe, SUBFEX, 0x7C000110)                                              \
+  /* Subtract From Extended & record OV */                                  \
+  V(subfeo, SUBFEO, 0x7C000510)                                             \
+  /* Subtract From Minus One Extended */                                    \
+  V(subfme, SUBFME, 0x7C0001D0)                                             \
+  /* Subtract From Minus One Extended & record OV */                        \
+  V(subfmeo, SUBFMEO, 0x7C0005D0)                                           \
+  /* Subtract From & record OV */                                           \
+  V(subfo, SUBFO, 0x7C000450)                                               \
+  /* Subtract From Zero Extended */                                         \
+  V(subfze, SUBFZE, 0x7C000190)                                             \
+  /* Subtract From Zero Extended & record OV */                             \
+  V(subfzeo, SUBFZEO, 0x7C000590)                                           \
+  /* Add and Generate Sixes */                                              \
+  V(addg, ADDG, 0x7C000094)                                                 \
+  /* Multiply Accumulate Cross Halfword to Word Modulo Signed */            \
+  V(macchw, MACCHW, 0x10000158)                                             \
+  /* Multiply Accumulate Cross Halfword to Word Saturate Signed */          \
+  V(macchws, MACCHWS, 0x100001D8)                                           \
+  /* Multiply Accumulate Cross Halfword to Word Saturate Unsigned */        \
+  V(macchwsu, MACCHWSU, 0x10000198)                                         \
+  /* Multiply Accumulate Cross Halfword to Word Modulo Unsigned */          \
+  V(macchwu, MACCHWU, 0x10000118)                                           \
+  /* Multiply Accumulate High Halfword to Word Modulo Signed */             \
+  V(machhw, MACHHW, 0x10000058)                                             \
+  /* Multiply Accumulate High Halfword to Word Saturate Signed */           \
+  V(machhws, MACHHWS, 0x100000D8)                                           \
+  /* Multiply Accumulate High Halfword to Word Saturate Unsigned */         \
+  V(machhwsu, MACHHWSU, 0x10000098)                                         \
+  /* Multiply Accumulate High Halfword to Word Modulo Unsigned */           \
+  V(machhwu, MACHHWU, 0x10000018)                                           \
+  /* Multiply Accumulate Low Halfword to Word Modulo Signed */              \
+  V(maclhw, MACLHW, 0x10000358)                                             \
+  /* Multiply Accumulate Low Halfword to Word Saturate Signed */            \
+  V(maclhws, MACLHWS, 0x100003D8)                                           \
+  /* Multiply Accumulate Low Halfword to Word Saturate Unsigned */          \
+  V(maclhwsu, MACLHWSU, 0x10000398)                                         \
+  /* Multiply Accumulate Low Halfword to Word Modulo Unsigned */            \
+  V(maclhwu, MACLHWU, 0x10000318)                                           \
+  /* Negative Multiply Accumulate Cross Halfword to Word Modulo Signed */   \
+  V(nmacchw, NMACCHW, 0x1000015C)                                           \
+  /* Negative Multiply Accumulate Cross Halfword to Word Saturate Signed */ \
+  V(nmacchws, NMACCHWS, 0x100001DC)                                         \
+  /* Negative Multiply Accumulate High Halfword to Word Modulo Signed */    \
+  V(nmachhw, NMACHHW, 0x1000005C)                                           \
+  /* Negative Multiply Accumulate High Halfword to Word Saturate Signed */  \
+  V(nmachhws, NMACHHWS, 0x100000DC)                                         \
+  /* Negative Multiply Accumulate Low Halfword to Word Modulo Signed */     \
+  V(nmaclhw, NMACLHW, 0x1000035C)                                           \
+  /* Negative Multiply Accumulate Low Halfword to Word Saturate Signed */   \
+  V(nmaclhws, NMACLHWS, 0x100003DC)
+
+#define PPC_XL_OPCODE_LIST(V)                       \
+  /* Branch Conditional to Count Register */        \
+  V(bcctr, BCCTRX, 0x4C000420)                      \
+  /* Branch Conditional to Link Register */         \
+  V(bclr, BCLRX, 0x4C000020)                        \
+  /* Condition Register AND */                      \
+  V(crand, CRAND, 0x4C000202)                       \
+  /* Condition Register AND with Complement */      \
+  V(crandc, CRANDC, 0x4C000102)                     \
+  /* Condition Register Equivalent */               \
+  V(creqv, CREQV, 0x4C000242)                       \
+  /* Condition Register NAND */                     \
+  V(crnand, CRNAND, 0x4C0001C2)                     \
+  /* Condition Register NOR */                      \
+  V(crnor, CRNOR, 0x4C000042)                       \
+  /* Condition Register OR */                       \
+  V(cror, CROR, 0x4C000382)                         \
+  /* Condition Register OR with Complement */       \
+  V(crorc, CRORC, 0x4C000342)                       \
+  /* Condition Register XOR */                      \
+  V(crxor, CRXOR, 0x4C000182)                       \
+  /* Instruction Synchronize */                     \
+  V(isync, ISYNC, 0x4C00012C)                       \
+  /* Move Condition Register Field */               \
+  V(mcrf, MCRF, 0x4C000000)                         \
+  /* Return From Critical Interrupt */              \
+  V(rfci, RFCI, 0x4C000066)                         \
+  /* Return From Interrupt */                       \
+  V(rfi, RFI, 0x4C000064)                           \
+  /* Return From Machine Check Interrupt */         \
+  V(rfmci, RFMCI, 0x4C00004C)                       \
+  /* Embedded Hypervisor Privilege */               \
+  V(ehpriv, EHPRIV, 0x7C00021C)                     \
+  /* Return From Guest Interrupt */                 \
+  V(rfgi, RFGI, 0x4C0000CC)                         \
+  /* Doze */                                        \
+  V(doze, DOZE, 0x4C000324)                         \
+  /* Return From Interrupt Doubleword Hypervisor */ \
+  V(hrfid, HRFID, 0x4C000224)                       \
+  /* Nap */                                         \
+  V(nap, NAP, 0x4C000364)                           \
+  /* Return from Event Based Branch */              \
+  V(rfebb, RFEBB, 0x4C000124)                       \
+  /* Return from Interrupt Doubleword */            \
+  V(rfid, RFID, 0x4C000024)                         \
+  /* Rip Van Winkle */                              \
+  V(rvwinkle, RVWINKLE, 0x4C0003E4)                 \
+  /* Sleep */                                       \
+  V(sleep, SLEEP, 0x4C0003A4)
+
+#define PPC_XX4_OPCODE_LIST(V) \
+  /* VSX Select */             \
+  V(xxsel, XXSEL, 0xF0000030)
+
+#define PPC_I_OPCODE_LIST(V) \
+  /* Branch */               \
+  V(b, BX, 0x48000000)
+
+#define PPC_M_OPCODE_LIST(V)                          \
+  /* Rotate Left Word Immediate then Mask Insert */   \
+  V(rlwimi, RLWIMIX, 0x50000000)                      \
+  /* Rotate Left Word Immediate then AND with Mask */ \
+  V(rlwinm, RLWINMX, 0x54000000)                      \
+  /* Rotate Left Word then AND with Mask */           \
+  V(rlwnm, RLWNMX, 0x5C000000)
+
+#define PPC_VX_OPCODE_A_FORM_LIST(V) \
+  /* Vector Splat Byte */            \
+  V(vspltb, VSPLTB, 0x1000020C)      \
+  /* Vector Splat Word */            \
+  V(vspltw, VSPLTW, 0x1000028C)      \
+  /* Vector Splat Halfword */        \
+  V(vsplth, VSPLTH, 0x1000024C)
+
+#define PPC_VX_OPCODE_B_FORM_LIST(V)                       \
+  /* Vector Logical OR */                                  \
+  V(vor, VOR, 0x10000484)                                  \
+  /* Vector Logical XOR */                                 \
+  V(vxor, VXOR, 0x100004C4)                                \
+  /* Vector Logical NOR */                                 \
+  V(vnor, VNOR, 0x10000504)                                \
+  /* Vector Shift Right by Octet */                        \
+  V(vsro, VSRO, 0x1000044C)                                \
+  /* Vector Shift Left by Octet */                         \
+  V(vslo, VSLO, 0x1000040C)                                \
+  /* Vector Add Unsigned Doubleword Modulo */              \
+  V(vaddudm, VADDUDM, 0x100000C0)                          \
+  /* Vector Add Unsigned Word Modulo */                    \
+  V(vadduwm, VADDUWM, 0x10000080)                          \
+  /* Vector Add Unsigned Halfword Modulo */                \
+  V(vadduhm, VADDUHM, 0x10000040)                          \
+  /* Vector Add Unsigned Byte Modulo */                    \
+  V(vaddubm, VADDUBM, 0x10000000)                          \
+  /* Vector Add Single-Precision */                        \
+  V(vaddfp, VADDFP, 0x1000000A)                            \
+  /* Vector Subtract Single-Precision */                   \
+  V(vsubfp, VSUBFP, 0x1000004A)                            \
+  /* Vector Subtract Unsigned Doubleword Modulo */         \
+  V(vsubudm, VSUBUDM, 0x100004C0)                          \
+  /* Vector Subtract Unsigned Word Modulo */               \
+  V(vsubuwm, VSUBUWM, 0x10000480)                          \
+  /* Vector Subtract Unsigned Halfword Modulo */           \
+  V(vsubuhm, VSUBUHM, 0x10000440)                          \
+  /* Vector Subtract Unsigned Byte Modulo */               \
+  V(vsububm, VSUBUBM, 0x10000400)                          \
+  /* Vector Multiply Unsigned Word Modulo */               \
+  V(vmuluwm, VMULUWM, 0x10000089)                          \
+  /* Vector Pack Unsigned Halfword Unsigned Modulo */      \
+  V(vpkuhum, VPKUHUM, 0x1000000E)                          \
+  /* Vector Multiply Even Unsigned Byte */                 \
+  V(vmuleub, VMULEUB, 0x10000208)                          \
+  /* Vector Multiply Odd Unsigned Byte */                  \
+  V(vmuloub, VMULOUB, 0x10000008)                          \
+  /* Vector Sum across Quarter Signed Halfword Saturate */ \
+  V(vsum4shs, VSUM4SHS, 0x10000648)                        \
+  /* Vector Pack Unsigned Word Unsigned Saturate */        \
+  V(vpkuwus, VPKUWUS, 0x100000CE)                          \
+  /* Vector Sum across Half Signed Word Saturate */        \
+  V(vsum2sws, VSUM2SWS, 0x10000688)                        \
+  /* Vector Pack Unsigned Doubleword Unsigned Modulo */    \
+  V(vpkudum, VPKUDUM, 0x1000044E)                          \
+  /* Vector Maximum Signed Byte */                         \
+  V(vmaxsb, VMAXSB, 0x10000102)                            \
+  /* Vector Maximum Unsigned Byte */                       \
+  V(vmaxub, VMAXUB, 0x10000002)                            \
+  /* Vector Maximum Signed Doubleword */                   \
+  V(vmaxsd, VMAXSD, 0x100001C2)                            \
+  /* Vector Maximum Unsigned Doubleword */                 \
+  V(vmaxud, VMAXUD, 0x100000C2)                            \
+  /* Vector Maximum Signed Halfword */                     \
+  V(vmaxsh, VMAXSH, 0x10000142)                            \
+  /* Vector Maximum Unsigned Halfword */                   \
+  V(vmaxuh, VMAXUH, 0x10000042)                            \
+  /* Vector Maximum Signed Word */                         \
+  V(vmaxsw, VMAXSW, 0x10000182)                            \
+  /* Vector Maximum Unsigned Word */                       \
+  V(vmaxuw, VMAXUW, 0x10000082)                            \
+  /* Vector Minimum Signed Byte */                         \
+  V(vminsb, VMINSB, 0x10000302)                            \
+  /* Vector Minimum Unsigned Byte */                       \
+  V(vminub, VMINUB, 0x10000202)                            \
+  /* Vector Minimum Signed Doubleword */                   \
+  V(vminsd, VMINSD, 0x100003C2)                            \
+  /* Vector Minimum Unsigned Doubleword */                 \
+  V(vminud, VMINUD, 0x100002C2)                            \
+  /* Vector Minimum Signed Halfword */                     \
+  V(vminsh, VMINSH, 0x10000342)                            \
+  /* Vector Minimum Unsigned Halfword */                   \
+  V(vminuh, VMINUH, 0x10000242)                            \
+  /* Vector Minimum Signed Word */                         \
+  V(vminsw, VMINSW, 0x10000382)                            \
+  /* Vector Minimum Unsigned Word */                       \
+  V(vminuw, VMINUW, 0x10000282)                            \
+  /* Vector Shift Left Byte */                             \
+  V(vslb, VSLB, 0x10000104)                                \
+  /* Vector Shift Left Word */                             \
+  V(vslw, VSLW, 0x10000184)                                \
+  /* Vector Shift Left Halfword */                         \
+  V(vslh, VSLH, 0x10000144)                                \
+  /* Vector Shift Left Doubleword */                       \
+  V(vsld, VSLD, 0x100005C4)                                \
+  /* Vector Shift Right Byte */                            \
+  V(vsrb, VSRB, 0x10000204)                                \
+  /* Vector Shift Right Word */                            \
+  V(vsrw, VSRW, 0x10000284)                                \
+  /* Vector Shift Right Halfword */                        \
+  V(vsrh, VSRH, 0x10000244)                                \
+  /* Vector Shift Right Doubleword */                      \
+  V(vsrd, VSRD, 0x100006C4)                                \
+  /* Vector Shift Right Algebraic Byte */                  \
+  V(vsrab, VSRAB, 0x10000304)                              \
+  /* Vector Shift Right Algebraic Word */                  \
+  V(vsraw, VSRAW, 0x10000384)                              \
+  /* Vector Shift Right Algebraic Halfword */              \
+  V(vsrah, VSRAH, 0x10000344)                              \
+  /* Vector Shift Right Algebraic Doubleword */            \
+  V(vsrad, VSRAD, 0x100003C4)                              \
+  /* Vector Logical AND */                                 \
+  V(vand, VAND, 0x10000404)                                \
+  /* Vector Pack Signed Word Signed Saturate */            \
+  V(vpkswss, VPKSWSS, 0x100001CE)                          \
+  /* Vector Pack Signed Word Unsigned Saturate */          \
+  V(vpkswus, VPKSWUS, 0x1000014E)                          \
+  /* Vector Pack Signed Halfword Signed Saturate */        \
+  V(vpkshss, VPKSHSS, 0x1000018E)                          \
+  /* Vector Pack Signed Halfword Unsigned Saturate */      \
+  V(vpkshus, VPKSHUS, 0x1000010E)                          \
+  /* Vector Add Signed Halfword Saturate */                \
+  V(vaddshs, VADDSHS, 0x10000340)                          \
+  /* Vector Subtract Signed Halfword Saturate */           \
+  V(vsubshs, VSUBSHS, 0x10000740)                          \
+  /* Vector Add Unsigned Halfword Saturate */              \
+  V(vadduhs, VADDUHS, 0x10000240)                          \
+  /* Vector Subtract Unsigned Halfword Saturate */         \
+  V(vsubuhs, VSUBUHS, 0x10000640)                          \
+  /* Vector Add Signed Byte Saturate */                    \
+  V(vaddsbs, VADDSBS, 0x10000300)                          \
+  /* Vector Subtract Signed Byte Saturate */               \
+  V(vsubsbs, VSUBSBS, 0x10000700)                          \
+  /* Vector Add Unsigned Byte Saturate */                  \
+  V(vaddubs, VADDUBS, 0x10000200)                          \
+  /* Vector Subtract Unsigned Byte Saturate */             \
+  V(vsububs, VSUBUBS, 0x10000600)                          \
+  /* Vector Average Unsigned Byte */                       \
+  V(vavgub, VAVGUB, 0x10000402)                            \
+  /* Vector Average Unsigned Halfword */                   \
+  V(vavguh, VAVGUH, 0x10000442)                            \
+  /* Vector Logical AND with Complement */                 \
+  V(vandc, VANDC, 0x10000444)                              \
+  /* Vector Minimum Single-Precision */                    \
+  V(vminfp, VMINFP, 0x1000044A)                            \
+  /* Vector Maximum Single-Precision */                    \
+  V(vmaxfp, VMAXFP, 0x1000040A)
+
+#define PPC_VX_OPCODE_C_FORM_LIST(V)       \
+  /* Vector Unpack Low Signed Halfword */  \
+  V(vupklsh, VUPKLSH, 0x100002CE)          \
+  /* Vector Unpack High Signed Halfword */ \
+  V(vupkhsh, VUPKHSH, 0x1000024E)          \
+  /* Vector Unpack Low Signed Byte */      \
+  V(vupklsb, VUPKLSB, 0x1000028E)          \
+  /* Vector Unpack High Signed Byte */     \
+  V(vupkhsb, VUPKHSB, 0x1000020E)
+
+#define PPC_VX_OPCODE_UNUSED_LIST(V)                                      \
+  /* Decimal Add Modulo */                                                \
+  V(bcdadd, BCDADD, 0xF0000400)                                           \
+  /* Decimal Subtract Modulo */                                           \
+  V(bcdsub, BCDSUB, 0xF0000440)                                           \
+  /* Move From Vector Status and Control Register */                      \
+  V(mfvscr, MFVSCR, 0x10000604)                                           \
+  /* Move To Vector Status and Control Register */                        \
+  V(mtvscr, MTVSCR, 0x10000644)                                           \
+  /* Vector Add & write Carry Unsigned Quadword */                        \
+  V(vaddcuq, VADDCUQ, 0x10000140)                                         \
+  /* Vector Add and Write Carry-Out Unsigned Word */                      \
+  V(vaddcuw, VADDCUW, 0x10000180)                                         \
+  /* Vector Add Signed Word Saturate */                                   \
+  V(vaddsws, VADDSWS, 0x10000380)                                         \
+  /* Vector Add Unsigned Quadword Modulo */                               \
+  V(vadduqm, VADDUQM, 0x10000100)                                         \
+  /* Vector Add Unsigned Word Saturate */                                 \
+  V(vadduws, VADDUWS, 0x10000280)                                         \
+  /* Vector Average Signed Byte */                                        \
+  V(vavgsb, VAVGSB, 0x10000502)                                           \
+  /* Vector Average Signed Halfword */                                    \
+  V(vavgsh, VAVGSH, 0x10000542)                                           \
+  /* Vector Average Signed Word */                                        \
+  V(vavgsw, VAVGSW, 0x10000582)                                           \
+  /* Vector Average Unsigned Word */                                      \
+  V(vavguw, VAVGUW, 0x10000482)                                           \
+  /* Vector Bit Permute Quadword */                                       \
+  V(vbpermq, VBPERMQ, 0x1000054C)                                         \
+  /* Vector Convert From Signed Fixed-Point Word To Single-Precision */   \
+  V(vcfsx, VCFSX, 0x1000034A)                                             \
+  /* Vector Convert From Unsigned Fixed-Point Word To Single-Precision */ \
+  V(vcfux, VCFUX, 0x1000030A)                                             \
+  /* Vector Count Leading Zeros Byte */                                   \
+  V(vclzb, VCLZB, 0x10000702)                                             \
+  /* Vector Count Leading Zeros Doubleword */                             \
+  V(vclzd, VCLZD, 0x100007C2)                                             \
+  /* Vector Count Leading Zeros Halfword */                               \
+  V(vclzh, VCLZH, 0x10000742)                                             \
+  /* Vector Count Leading Zeros Word */                                   \
+  V(vclzw, VCLZW, 0x10000782)                                             \
+  /* Vector Convert From Single-Precision To Signed Fixed-Point Word */   \
+  /* Saturate */                                                          \
+  V(vctsxs, VCTSXS, 0x100003CA)                                           \
+  /* Vector Convert From Single-Precision To Unsigned Fixed-Point Word */ \
+  /* Saturate */                                                          \
+  V(vctuxs, VCTUXS, 0x1000038A)                                           \
+  /* Vector Equivalence */                                                \
+  V(veqv, VEQV, 0x10000684)                                               \
+  /* Vector 2 Raised to the Exponent Estimate Single-Precision */         \
+  V(vexptefp, VEXPTEFP, 0x1000018A)                                       \
+  /* Vector Gather Bits by Byte by Doubleword */                          \
+  V(vgbbd, VGBBD, 0x1000050C)                                             \
+  /* Vector Log Base 2 Estimate Single-Precision */                       \
+  V(vlogefp, VLOGEFP, 0x100001CA)                                         \
+  /* Vector Merge High Byte */                                            \
+  V(vmrghb, VMRGHB, 0x1000000C)                                           \
+  /* Vector Merge High Halfword */                                        \
+  V(vmrghh, VMRGHH, 0x1000004C)                                           \
+  /* Vector Merge High Word */                                            \
+  V(vmrghw, VMRGHW, 0x1000008C)                                           \
+  /* Vector Merge Low Byte */                                             \
+  V(vmrglb, VMRGLB, 0x1000010C)                                           \
+  /* Vector Merge Low Halfword */                                         \
+  V(vmrglh, VMRGLH, 0x1000014C)                                           \
+  /* Vector Merge Low Word */                                             \
+  V(vmrglw, VMRGLW, 0x1000018C)                                           \
+  /* Vector Multiply Even Signed Byte */                                  \
+  V(vmulesb, VMULESB, 0x10000308)                                         \
+  /* Vector Multiply Even Signed Halfword */                              \
+  V(vmulesh, VMULESH, 0x10000348)                                         \
+  /* Vector Multiply Even Signed Word */                                  \
+  V(vmulesw, VMULESW, 0x10000388)                                         \
+  /* Vector Multiply Even Unsigned Halfword */                            \
+  V(vmuleuh, VMULEUH, 0x10000248)                                         \
+  /* Vector Multiply Even Unsigned Word */                                \
+  V(vmuleuw, VMULEUW, 0x10000288)                                         \
+  /* Vector Multiply Odd Signed Byte */                                   \
+  V(vmulosb, VMULOSB, 0x10000108)                                         \
+  /* Vector Multiply Odd Signed Halfword */                               \
+  V(vmulosh, VMULOSH, 0x10000148)                                         \
+  /* Vector Multiply Odd Signed Word */                                   \
+  V(vmulosw, VMULOSW, 0x10000188)                                         \
+  /* Vector Multiply Odd Unsigned Halfword */                             \
+  V(vmulouh, VMULOUH, 0x10000048)                                         \
+  /* Vector Multiply Odd Unsigned Word */                                 \
+  V(vmulouw, VMULOUW, 0x10000088)                                         \
+  /* Vector NAND */                                                       \
+  V(vnand, VNAND, 0x10000584)                                             \
+  /* Vector OR with Complement */                                         \
+  V(vorc, VORC, 0x10000544)                                               \
+  /* Vector Pack Pixel */                                                 \
+  V(vpkpx, VPKPX, 0x1000030E)                                             \
+  /* Vector Pack Signed Doubleword Signed Saturate */                     \
+  V(vpksdss, VPKSDSS, 0x100005CE)                                         \
+  /* Vector Pack Signed Doubleword Unsigned Saturate */                   \
+  V(vpksdus, VPKSDUS, 0x1000054E)                                         \
+  /* Vector Pack Unsigned Doubleword Unsigned Saturate */                 \
+  V(vpkudus, VPKUDUS, 0x100004CE)                                         \
+  /* Vector Pack Unsigned Halfword Unsigned Saturate */                   \
+  V(vpkuhus, VPKUHUS, 0x1000008E)                                         \
+  /* Vector Pack Unsigned Word Unsigned Modulo */                         \
+  V(vpkuwum, VPKUWUM, 0x1000004E)                                         \
+  /* Vector Polynomial Multiply-Sum Byte */                               \
+  V(vpmsumb, VPMSUMB, 0x10000408)                                         \
+  /* Vector Polynomial Multiply-Sum Doubleword */                         \
+  V(vpmsumd, VPMSUMD, 0x100004C8)                                         \
+  /* Vector Polynomial Multiply-Sum Halfword */                           \
+  V(vpmsumh, VPMSUMH, 0x10000448)                                         \
+  /* Vector Polynomial Multiply-Sum Word */                               \
+  V(vpmsumw, VPMSUMW, 0x10000488)                                         \
+  /* Vector Population Count Byte */                                      \
+  V(vpopcntb, VPOPCNTB, 0x10000703)                                       \
+  /* Vector Population Count Doubleword */                                \
+  V(vpopcntd, VPOPCNTD, 0x100007C3)                                       \
+  /* Vector Population Count Halfword */                                  \
+  V(vpopcnth, VPOPCNTH, 0x10000743)                                       \
+  /* Vector Population Count Word */                                      \
+  V(vpopcntw, VPOPCNTW, 0x10000783)                                       \
+  /* Vector Reciprocal Estimate Single-Precision */                       \
+  V(vrefp, VREFP, 0x1000010A)                                             \
+  /* Vector Round to Single-Precision Integer toward -Infinity */         \
+  V(vrfim, VRFIM, 0x100002CA)                                             \
+  /* Vector Round to Single-Precision Integer Nearest */                  \
+  V(vrfin, VRFIN, 0x1000020A)                                             \
+  /* Vector Round to Single-Precision Integer toward +Infinity */         \
+  V(vrfip, VRFIP, 0x1000028A)                                             \
+  /* Vector Round to Single-Precision Integer toward Zero */              \
+  V(vrfiz, VRFIZ, 0x1000024A)                                             \
+  /* Vector Rotate Left Byte */                                           \
+  V(vrlb, VRLB, 0x10000004)                                               \
+  /* Vector Rotate Left Doubleword */                                     \
+  V(vrld, VRLD, 0x100000C4)                                               \
+  /* Vector Rotate Left Halfword */                                       \
+  V(vrlh, VRLH, 0x10000044)                                               \
+  /* Vector Rotate Left Word */                                           \
+  V(vrlw, VRLW, 0x10000084)                                               \
+  /* Vector Reciprocal Square Root Estimate Single-Precision */           \
+  V(vrsqrtefp, VRSQRTEFP, 0x1000014A)                                     \
+  /* Vector Shift Left */                                                 \
+  V(vsl, VSL, 0x100001C4)                                                 \
+  /* Vector Splat Immediate Signed Byte */                                \
+  V(vspltisb, VSPLTISB, 0x1000030C)                                       \
+  /* Vector Splat Immediate Signed Halfword */                            \
+  V(vspltish, VSPLTISH, 0x1000034C)                                       \
+  /* Vector Splat Immediate Signed Word */                                \
+  V(vspltisw, VSPLTISW, 0x1000038C)                                       \
+  /* Vector Shift Right */                                                \
+  V(vsr, VSR, 0x100002C4)                                                 \
+  /* Vector Subtract & write Carry Unsigned Quadword */                   \
+  V(vsubcuq, VSUBCUQ, 0x10000540)                                         \
+  /* Vector Subtract and Write Carry-Out Unsigned Word */                 \
+  V(vsubcuw, VSUBCUW, 0x10000580)                                         \
+  /* Vector Subtract Signed Word Saturate */                              \
+  V(vsubsws, VSUBSWS, 0x10000780)                                         \
+  /* Vector Subtract Unsigned Quadword Modulo */                          \
+  V(vsubuqm, VSUBUQM, 0x10000500)                                         \
+  /* Vector Subtract Unsigned Word Saturate */                            \
+  V(vsubuws, VSUBUWS, 0x10000680)                                         \
+  /* Vector Sum across Quarter Signed Byte Saturate */                    \
+  V(vsum4sbs, VSUM4SBS, 0x10000708)                                       \
+  /* Vector Sum across Quarter Unsigned Byte Saturate */                  \
+  V(vsum4bus, VSUM4BUS, 0x10000608)                                       \
+  /* Vector Sum across Signed Word Saturate */                            \
+  V(vsumsws, VSUMSWS, 0x10000788)                                         \
+  /* Vector Unpack High Pixel */                                          \
+  V(vupkhpx, VUPKHPX, 0x1000034E)                                         \
+  /* Vector Unpack High Signed Word */                                    \
+  V(vupkhsw, VUPKHSW, 0x1000064E)                                         \
+  /* Vector Unpack Low Pixel */                                           \
+  V(vupklpx, VUPKLPX, 0x100003CE)                                         \
+  /* Vector Unpack Low Signed Word */                                     \
+  V(vupklsw, VUPKLSW, 0x100006CE)                                         \
+  /* Vector AES Cipher */                                                 \
+  V(vcipher, VCIPHER, 0x10000508)                                         \
+  /* Vector AES Cipher Last */                                            \
+  V(vcipherlast, VCIPHERLAST, 0x10000509)                                 \
+  /* Vector AES Inverse Cipher */                                         \
+  V(vncipher, VNCIPHER, 0x10000548)                                       \
+  /* Vector AES Inverse Cipher Last */                                    \
+  V(vncipherlast, VNCIPHERLAST, 0x10000549)                               \
+  /* Vector AES S-Box */                                                  \
+  V(vsbox, VSBOX, 0x100005C8)                                             \
+  /* Vector SHA-512 Sigma Doubleword */                                   \
+  V(vshasigmad, VSHASIGMAD, 0x100006C2)                                   \
+  /* Vector SHA-256 Sigma Word */                                         \
+  V(vshasigmaw, VSHASIGMAW, 0x10000682)                                   \
+  /* Vector Merge Even Word */                                            \
+  V(vmrgew, VMRGEW, 0x1000078C)                                           \
+  /* Vector Merge Odd Word */                                             \
+  V(vmrgow, VMRGOW, 0x1000068C)
+
+#define PPC_VX_OPCODE_LIST(V)  \
+  PPC_VX_OPCODE_A_FORM_LIST(V) \
+  PPC_VX_OPCODE_B_FORM_LIST(V) \
+  PPC_VX_OPCODE_C_FORM_LIST(V) \
+  PPC_VX_OPCODE_UNUSED_LIST(V)
+
+#define PPC_XS_OPCODE_LIST(V)                      \
+  /* Shift Right Algebraic Doubleword Immediate */ \
+  V(sradi, SRADIX, 0x7C000674)
+
+#define PPC_MD_OPCODE_LIST(V)                             \
+  /* Rotate Left Doubleword Immediate then Clear */       \
+  V(rldic, RLDIC, 0x78000008)                             \
+  /* Rotate Left Doubleword Immediate then Clear Left */  \
+  V(rldicl, RLDICL, 0x78000000)                           \
+  /* Rotate Left Doubleword Immediate then Clear Right */ \
+  V(rldicr, RLDICR, 0x78000004)                           \
+  /* Rotate Left Doubleword Immediate then Mask Insert */ \
+  V(rldimi, RLDIMI, 0x7800000C)
+
+#define PPC_SC_OPCODE_LIST(V) \
+  /* System Call */           \
+  V(sc, SC, 0x44000002)
+
+#define PPC_OPCODE_LIST(V)       \
+  PPC_X_OPCODE_LIST(V)           \
+  PPC_X_OPCODE_EH_S_FORM_LIST(V) \
+  PPC_XO_OPCODE_LIST(V)          \
+  PPC_DS_OPCODE_LIST(V)          \
+  PPC_DQ_OPCODE_LIST(V)          \
+  PPC_MDS_OPCODE_LIST(V)         \
+  PPC_MD_OPCODE_LIST(V)          \
+  PPC_XS_OPCODE_LIST(V)          \
+  PPC_D_OPCODE_LIST(V)           \
+  PPC_I_OPCODE_LIST(V)           \
+  PPC_B_OPCODE_LIST(V)           \
+  PPC_XL_OPCODE_LIST(V)          \
+  PPC_A_OPCODE_LIST(V)           \
+  PPC_XFX_OPCODE_LIST(V)         \
+  PPC_M_OPCODE_LIST(V)           \
+  PPC_SC_OPCODE_LIST(V)          \
+  PPC_Z23_OPCODE_LIST(V)         \
+  PPC_Z22_OPCODE_LIST(V)         \
+  PPC_EVX_OPCODE_LIST(V)         \
+  PPC_XFL_OPCODE_LIST(V)         \
+  PPC_EVS_OPCODE_LIST(V)         \
+  PPC_VX_OPCODE_LIST(V)          \
+  PPC_VA_OPCODE_LIST(V)          \
+  PPC_VC_OPCODE_LIST(V)          \
+  PPC_XX1_OPCODE_LIST(V)         \
+  PPC_XX2_OPCODE_LIST(V)         \
+  PPC_XX3_OPCODE_LIST(V)         \
+  PPC_XX4_OPCODE_LIST(V)
+
+enum Opcode : uint32_t {
+#define DECLARE_INSTRUCTION(name, opcode_name, opcode_value) \
+  opcode_name = opcode_value,
+  PPC_OPCODE_LIST(DECLARE_INSTRUCTION)
+#undef DECLARE_INSTRUCTION
+      EXT0 = 0x10000000,  // Extended code set 0
+  EXT1 = 0x4C000000,      // Extended code set 1
+  EXT2 = 0x7C000000,      // Extended code set 2
+  EXT3 = 0xEC000000,      // Extended code set 3
+  EXT4 = 0xFC000000,      // Extended code set 4
+  EXT5 = 0x78000000,      // Extended code set 5 - 64bit only
+  EXT6 = 0xF0000000,      // Extended code set 6
+};
+
+// Instruction encoding bits and masks.
+enum {
+  // Instruction encoding bit
+  B1 = 1 << 1,
+  B2 = 1 << 2,
+  B3 = 1 << 3,
+  B4 = 1 << 4,
+  B5 = 1 << 5,
+  B7 = 1 << 7,
+  B8 = 1 << 8,
+  B9 = 1 << 9,
+  B12 = 1 << 12,
+  B18 = 1 << 18,
+  B19 = 1 << 19,
+  B20 = 1 << 20,
+  B22 = 1 << 22,
+  B23 = 1 << 23,
+  B24 = 1 << 24,
+  B25 = 1 << 25,
+  B26 = 1 << 26,
+  B27 = 1 << 27,
+  B28 = 1 << 28,
+  B6 = 1 << 6,
+  B10 = 1 << 10,
+  B11 = 1 << 11,
+  B16 = 1 << 16,
+  B17 = 1 << 17,
+  B21 = 1 << 21,
+
+  // Instruction bit masks
+  kCondMask = 0x1F << 21,
+  kOff12Mask = (1 << 12) - 1,
+  kImm24Mask = (1 << 24) - 1,
+  kOff16Mask = (1 << 16) - 1,
+  kImm16Mask = (1 << 16) - 1,
+  kImm22Mask = (1 << 22) - 1,
+  kImm26Mask = (1 << 26) - 1,
+  kBOfieldMask = 0x1f << 21,
+  kOpcodeMask = 0x3f << 26,
+  kExt1OpcodeMask = 0x3ff << 1,
+  kExt2OpcodeMask = 0x3ff << 1,
+  kExt2OpcodeVariant2Mask = 0x1ff << 2,
+  kExt5OpcodeMask = 0x3 << 2,
+  kBOMask = 0x1f << 21,
+  kBIMask = 0x1F << 16,
+  kBDMask = 0x14 << 2,
+  kAAMask = 0x01 << 1,
+  kLKMask = 0x01,
+  kRCMask = 0x01,
+  kTOMask = 0x1f << 21
+};
+
+// -----------------------------------------------------------------------------
+// Addressing modes and instruction variants.
+
+// Overflow Exception
+enum OEBit {
+  SetOE = 1 << 10,   // Set overflow exception
+  LeaveOE = 0 << 10  // No overflow exception
+};
+
+// Record bit
+enum RCBit {   // Bit 0
+  SetRC = 1,   // LT,GT,EQ,SO
+  LeaveRC = 0  // None
+};
+// Exclusive Access hint bit
+enum EHBit {   // Bit 0
+  SetEH = 1,   // Exclusive Access
+  LeaveEH = 0  // Atomic Update
+};
+
+// Link bit
+enum LKBit {   // Bit 0
+  SetLK = 1,   // Load effective address of next instruction
+  LeaveLK = 0  // No action
+};
+
+enum BOfield {        // Bits 25-21
+  DCBNZF = 0 << 21,   // Decrement CTR; branch if CTR != 0 and condition false
+  DCBEZF = 2 << 21,   // Decrement CTR; branch if CTR == 0 and condition false
+  BF = 4 << 21,       // Branch if condition false
+  DCBNZT = 8 << 21,   // Decrement CTR; branch if CTR != 0 and condition true
+  DCBEZT = 10 << 21,  // Decrement CTR; branch if CTR == 0 and condition true
+  BT = 12 << 21,      // Branch if condition true
+  DCBNZ = 16 << 21,   // Decrement CTR; branch if CTR != 0
+  DCBEZ = 18 << 21,   // Decrement CTR; branch if CTR == 0
+  BA = 20 << 21       // Branch always
+};
+
+#if V8_OS_AIX
+#undef CR_LT
+#undef CR_GT
+#undef CR_EQ
+#undef CR_SO
+#endif
+
+enum CRBit { CR_LT = 0, CR_GT = 1, CR_EQ = 2, CR_SO = 3, CR_FU = 3 };
+
+#define CRWIDTH 4
+
+// These are the documented bit positions biased down by 32
+enum FPSCRBit {
+  VXSOFT = 21,  // 53: Software-Defined Condition
+  VXSQRT = 22,  // 54: Invalid Square Root
+  VXCVI = 23    // 55: Invalid Integer Convert
+};
+
+// -----------------------------------------------------------------------------
+// Supervisor Call (svc) specific support.
+
+// Special Software Interrupt codes when used in the presence of the PPC
+// simulator.
+// svc (formerly swi) provides a 24bit immediate value. Use bits 22:0 for
+// standard SoftwareInterrupCode. Bit 23 is reserved for the stop feature.
+enum SoftwareInterruptCodes {
+  // transition to C code
+  kCallRtRedirected = 0x10,
+  // break point
+  kBreakpoint = 0x821008,  // bits23-0 of 0x7d821008 = twge r2, r2
+  // stop
+  kStopCode = 1 << 23
+};
+const uint32_t kStopCodeMask = kStopCode - 1;
+const uint32_t kMaxStopCode = kStopCode - 1;
+const int32_t kDefaultStopCode = -1;
+
+// FP rounding modes.
+enum FPRoundingMode {
+  RN = 0,  // Round to Nearest.
+  RZ = 1,  // Round towards zero.
+  RP = 2,  // Round towards Plus Infinity.
+  RM = 3,  // Round towards Minus Infinity.
+
+  // Aliases.
+  kRoundToNearest = RN,
+  kRoundToZero = RZ,
+  kRoundToPlusInf = RP,
+  kRoundToMinusInf = RM
+};
+
+const uint32_t kFPRoundingModeMask = 3;
+
+enum CheckForInexactConversion {
+  kCheckForInexactConversion,
+  kDontCheckForInexactConversion
+};
+
+// -----------------------------------------------------------------------------
+// Specific instructions, constants, and masks.
+// These constants are declared in assembler-arm.cc, as they use named registers
+// and other constants.
+
+// add(sp, sp, 4) instruction (aka Pop())
+extern const Instr kPopInstruction;
+
+// str(r, MemOperand(sp, 4, NegPreIndex), al) instruction (aka push(r))
+// register r is not encoded.
+extern const Instr kPushRegPattern;
+
+// ldr(r, MemOperand(sp, 4, PostIndex), al) instruction (aka pop(r))
+// register r is not encoded.
+extern const Instr kPopRegPattern;
+
+// use TWI to indicate redirection call for simulation mode
+const Instr rtCallRedirInstr = TWI;
+
+// -----------------------------------------------------------------------------
+// Instruction abstraction.
+
+// The class Instruction enables access to individual fields defined in the PPC
+// architecture instruction set encoding.
+// Note that the Assembler uses typedef int32_t Instr.
+//
+// Example: Test whether the instruction at ptr does set the condition code
+// bits.
+//
+// bool InstructionSetsConditionCodes(byte* ptr) {
+//   Instruction* instr = Instruction::At(ptr);
+//   int type = instr->TypeValue();
+//   return ((type == 0) || (type == 1)) && instr->HasS();
+// }
+//
+
+constexpr uint8_t kInstrSize = 4;
+constexpr uint8_t kInstrSizeLog2 = 2;
+constexpr uint8_t kPcLoadDelta = 8;
+
+class Instruction {
+ public:
+// Helper macro to define static accessors.
+// We use the cast to char* trick to bypass the strict anti-aliasing rules.
+#define DECLARE_STATIC_TYPED_ACCESSOR(return_type, Name) \
+  static inline return_type Name(Instr instr) {          \
+    char* temp = reinterpret_cast<char*>(&instr);        \
+    return reinterpret_cast<Instruction*>(temp)->Name(); \
+  }
+
+#define DECLARE_STATIC_ACCESSOR(Name) DECLARE_STATIC_TYPED_ACCESSOR(int, Name)
+
+  // Get the raw instruction bits.
+  inline Instr InstructionBits() const {
+    return *reinterpret_cast<const Instr*>(this);
+  }
+
+  // Set the raw instruction bits to value.
+  inline void SetInstructionBits(Instr value) {
+    *reinterpret_cast<Instr*>(this) = value;
+  }
+
+  // Read one particular bit out of the instruction bits.
+  inline int Bit(int nr) const { return (InstructionBits() >> nr) & 1; }
+
+  // Read a bit field's value out of the instruction bits.
+  inline int Bits(int hi, int lo) const {
+    return (InstructionBits() >> lo) & ((2 << (hi - lo)) - 1);
+  }
+
+  // Read a bit field out of the instruction bits.
+  inline uint32_t BitField(int hi, int lo) const {
+    return InstructionBits() & (((2 << (hi - lo)) - 1) << lo);
+  }
+
+  // Static support.
+
+  // Read one particular bit out of the instruction bits.
+  static inline int Bit(Instr instr, int nr) { return (instr >> nr) & 1; }
+
+  // Read the value of a bit field out of the instruction bits.
+  static inline int Bits(Instr instr, int hi, int lo) {
+    return (instr >> lo) & ((2 << (hi - lo)) - 1);
+  }
+
+  // Read a bit field out of the instruction bits.
+  static inline uint32_t BitField(Instr instr, int hi, int lo) {
+    return instr & (((2 << (hi - lo)) - 1) << lo);
+  }
+
+  inline int RSValue() const { return Bits(25, 21); }
+  inline int RTValue() const { return Bits(25, 21); }
+  inline int RAValue() const { return Bits(20, 16); }
+  DECLARE_STATIC_ACCESSOR(RAValue)
+  inline int RBValue() const { return Bits(15, 11); }
+  DECLARE_STATIC_ACCESSOR(RBValue)
+  inline int RCValue() const { return Bits(10, 6); }
+  DECLARE_STATIC_ACCESSOR(RCValue)
+
+  inline int OpcodeValue() const { return static_cast<Opcode>(Bits(31, 26)); }
+  inline uint32_t OpcodeField() const {
+    return static_cast<Opcode>(BitField(31, 26));
+  }
+
+#define OPCODE_CASES(name, opcode_name, opcode_value) case opcode_name:
+
+  inline Opcode OpcodeBase() const {
+    uint32_t opcode = OpcodeField();
+    uint32_t extcode = OpcodeField();
+    switch (opcode) {
+      PPC_D_OPCODE_LIST(OPCODE_CASES)
+      PPC_I_OPCODE_LIST(OPCODE_CASES)
+      PPC_B_OPCODE_LIST(OPCODE_CASES)
+      PPC_M_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+
+    opcode = extcode | BitField(10, 0);
+    switch (opcode) {
+      PPC_VX_OPCODE_LIST(OPCODE_CASES)
+      PPC_X_OPCODE_EH_S_FORM_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(9, 0);
+    switch (opcode) {
+      PPC_VC_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(10, 1) | BitField(20, 20);
+    switch (opcode) {
+      PPC_XFX_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(10, 1);
+    switch (opcode) {
+      PPC_X_OPCODE_LIST(OPCODE_CASES)
+      PPC_XL_OPCODE_LIST(OPCODE_CASES)
+      PPC_XFL_OPCODE_LIST(OPCODE_CASES)
+      PPC_XX1_OPCODE_LIST(OPCODE_CASES)
+      PPC_XX2_OPCODE_LIST(OPCODE_CASES)
+      PPC_EVX_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(9, 1);
+    switch (opcode) {
+      PPC_XO_OPCODE_LIST(OPCODE_CASES)
+      PPC_Z22_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(10, 2);
+    switch (opcode) {
+      PPC_XS_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(10, 3);
+    switch (opcode) {
+      PPC_EVS_OPCODE_LIST(OPCODE_CASES)
+      PPC_XX3_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(8, 1);
+    switch (opcode) {
+      PPC_Z23_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(5, 0);
+    switch (opcode) {
+      PPC_VA_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(5, 1);
+    switch (opcode) {
+      PPC_A_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(4, 1);
+    switch (opcode) {
+      PPC_MDS_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(4, 2);
+    switch (opcode) {
+      PPC_MD_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(5, 4);
+    switch (opcode) {
+      PPC_XX4_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(2, 0);
+    switch (opcode) {
+      PPC_DQ_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(1, 0);
+    switch (opcode) {
+      PPC_DS_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    opcode = extcode | BitField(1, 1);
+    switch (opcode) {
+      PPC_SC_OPCODE_LIST(OPCODE_CASES)
+      return static_cast<Opcode>(opcode);
+    }
+    UNIMPLEMENTED();
+    return static_cast<Opcode>(0);
+  }
+
+#undef OPCODE_CASES
+
+  // Fields used in Software interrupt instructions
+  inline SoftwareInterruptCodes SvcValue() const {
+    return static_cast<SoftwareInterruptCodes>(Bits(23, 0));
+  }
+
+  // Instructions are read of out a code stream. The only way to get a
+  // reference to an instruction is to convert a pointer. There is no way
+  // to allocate or create instances of class Instruction.
+  // Use the At(pc) function to create references to Instruction.
+  static Instruction* At(byte* pc) {
+    return reinterpret_cast<Instruction*>(pc);
+  }
+
+ private:
+  // We need to prevent the creation of instances of class Instruction.
+  DISALLOW_IMPLICIT_CONSTRUCTORS(Instruction);
+};
+
+// Helper functions for converting between register numbers and names.
+class Registers {
+ public:
+  // Lookup the register number for the name provided.
+  static int Number(const char* name);
+
+ private:
+  static const char* names_[kNumRegisters];
+};
+
+// Helper functions for converting between FP register numbers and names.
+class DoubleRegisters {
+ public:
+  // Lookup the register number for the name provided.
+  static int Number(const char* name);
+
+ private:
+  static const char* names_[kNumDoubleRegisters];
+};
+}  // namespace internal
+}  // namespace v8
+
+static constexpr int kR0DwarfCode = 0;
+static constexpr int kFpDwarfCode = 31;  // frame-pointer
+static constexpr int kLrDwarfCode = 65;  // return-address(lr)
+static constexpr int kSpDwarfCode = 1;   // stack-pointer (sp)
+
+#endif  // V8_CODEGEN_PPC_CONSTANTS_PPC_H_
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/cpu-ppc.cc b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/cpu-ppc.cc
--- a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/cpu-ppc.cc	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/cpu-ppc.cc	2025-06-04 10:11:01.000000000 +0800
@@ -0,0 +1,50 @@
+// Copyright 2014 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// CPU specific code for ppc independent of OS goes here.
+
+#if V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
+
+#include "src/codegen/cpu-features.h"
+
+#define INSTR_AND_DATA_CACHE_COHERENCY LWSYNC
+
+namespace v8 {
+namespace internal {
+
+void CpuFeatures::FlushICache(void* buffer, size_t size) {
+#if !defined(USE_SIMULATOR)
+  if (CpuFeatures::IsSupported(INSTR_AND_DATA_CACHE_COHERENCY)) {
+    __asm__ __volatile__(
+        "sync \n"
+        "icbi 0, %0  \n"
+        "isync  \n"
+        : /* no output */
+        : "r"(buffer)
+        : "memory");
+    return;
+  }
+
+  const int kCacheLineSize = CpuFeatures::icache_line_size();
+  intptr_t mask = kCacheLineSize - 1;
+  byte* start =
+      reinterpret_cast<byte*>(reinterpret_cast<intptr_t>(buffer) & ~mask);
+  byte* end = static_cast<byte*>(buffer) + size;
+  for (byte* pointer = start; pointer < end; pointer += kCacheLineSize) {
+    __asm__(
+        "dcbf 0, %0  \n"
+        "sync        \n"
+        "icbi 0, %0  \n"
+        "isync       \n"
+        : /* no output */
+        : "r"(pointer));
+  }
+
+#endif  // !USE_SIMULATOR
+}
+}  // namespace internal
+}  // namespace v8
+
+#undef INSTR_AND_DATA_CACHE_COHERENCY
+#endif  // V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/interface-descriptors-ppc.cc b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/interface-descriptors-ppc.cc
--- a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/interface-descriptors-ppc.cc	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/interface-descriptors-ppc.cc	2025-06-04 10:11:01.000000000 +0800
@@ -0,0 +1,332 @@
+// Copyright 2014 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#if V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
+
+#include "src/codegen/interface-descriptors.h"
+
+#include "src/execution/frames.h"
+
+namespace v8 {
+namespace internal {
+
+const Register CallInterfaceDescriptor::ContextRegister() { return cp; }
+
+void CallInterfaceDescriptor::DefaultInitializePlatformSpecific(
+    CallInterfaceDescriptorData* data, int register_parameter_count) {
+  const Register default_stub_registers[] = {r3, r4, r5, r6, r7};
+  CHECK_LE(static_cast<size_t>(register_parameter_count),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(register_parameter_count,
+                                   default_stub_registers);
+}
+
+void RecordWriteDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  const Register default_stub_registers[] = {r3, r4, r5, r6, r7};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+void EphemeronKeyBarrierDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  const Register default_stub_registers[] = {r3, r4, r5, r6, r7};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+const Register LoadDescriptor::ReceiverRegister() { return r4; }
+const Register LoadDescriptor::NameRegister() { return r5; }
+const Register LoadDescriptor::SlotRegister() { return r3; }
+
+const Register LoadWithVectorDescriptor::VectorRegister() { return r6; }
+
+const Register
+LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
+  return r7;
+}
+
+const Register StoreDescriptor::ReceiverRegister() { return r4; }
+const Register StoreDescriptor::NameRegister() { return r5; }
+const Register StoreDescriptor::ValueRegister() { return r3; }
+const Register StoreDescriptor::SlotRegister() { return r7; }
+
+const Register StoreWithVectorDescriptor::VectorRegister() { return r6; }
+
+const Register StoreTransitionDescriptor::SlotRegister() { return r7; }
+const Register StoreTransitionDescriptor::VectorRegister() { return r6; }
+const Register StoreTransitionDescriptor::MapRegister() { return r8; }
+
+const Register ApiGetterDescriptor::HolderRegister() { return r3; }
+const Register ApiGetterDescriptor::CallbackRegister() { return r6; }
+
+const Register GrowArrayElementsDescriptor::ObjectRegister() { return r3; }
+const Register GrowArrayElementsDescriptor::KeyRegister() { return r6; }
+
+// static
+const Register TypeConversionDescriptor::ArgumentRegister() { return r3; }
+
+void TypeofDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {r6};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallTrampolineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r3 : number of arguments
+  // r4 : the target to call
+  Register registers[] = {r4, r3};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r3 : number of arguments (on the stack, not including receiver)
+  // r4 : the target to call
+  // r7 : arguments list length (untagged)
+  // r5 : arguments list (FixedArray)
+  Register registers[] = {r4, r3, r7, r5};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallForwardVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r3 : number of arguments
+  // r5 : start index (to support rest parameters)
+  // r4 : the target to call
+  Register registers[] = {r4, r3, r5};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallFunctionTemplateDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r4 : function template info
+  // r5 : number of arguments (on the stack, not including receiver)
+  Register registers[] = {r4, r5};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallWithSpreadDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r3 : number of arguments (on the stack, not including receiver)
+  // r4 : the target to call
+  // r5 : the object to spread
+  Register registers[] = {r4, r3, r5};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallWithArrayLikeDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r4 : the target to call
+  // r5 : the arguments list
+  Register registers[] = {r4, r5};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r3 : number of arguments (on the stack, not including receiver)
+  // r4 : the target to call
+  // r6 : the new target
+  // r7 : arguments list length (untagged)
+  // r5 : arguments list (FixedArray)
+  Register registers[] = {r4, r6, r3, r7, r5};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructForwardVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r3 : number of arguments
+  // r6 : the new target
+  // r5 : start index (to support rest parameters)
+  // r4 : the target to call
+  Register registers[] = {r4, r6, r3, r5};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructWithSpreadDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r3 : number of arguments (on the stack, not including receiver)
+  // r4 : the target to call
+  // r6 : the new target
+  // r5 : the object to spread
+  Register registers[] = {r4, r6, r3, r5};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructWithArrayLikeDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r4 : the target to call
+  // r6 : the new target
+  // r5 : the arguments list
+  Register registers[] = {r4, r6, r5};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructStubDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r3 : number of arguments
+  // r4 : the target to call
+  // r6 : the new target
+  // r5 : allocation site or undefined
+  Register registers[] = {r4, r6, r3, r5};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void AbortDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {r4};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CompareDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {r4, r3};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void BinaryOpDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {r4, r3};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ArgumentsAdaptorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      r4,  // JSFunction
+      r6,  // the new target
+      r3,  // actual number of arguments
+      r5,  // expected number of arguments
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ApiCallbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      r4,  // kApiFunctionAddress
+      r5,  // kArgc
+      r6,  // kCallData
+      r3,  // kHolder
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterDispatchDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
+      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterPushArgsThenCallDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      r3,  // argument count (not including receiver)
+      r5,  // address of first argument
+      r4   // the target callable to be call
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterPushArgsThenConstructDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      r3,  // argument count (not including receiver)
+      r7,  // address of the first argument
+      r4,  // constructor to call
+      r6,  // new target
+      r5,  // allocation site feedback if available, undefined otherwise
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ResumeGeneratorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      r3,  // the value to pass to the generator
+      r4   // the JSGeneratorObject to resume
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void FrameDropperTrampolineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      r4,  // loaded new FP
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void RunMicrotasksEntryDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {r3, r4};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void BinaryOp_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // TODO(v8:8888): Implement on this platform.
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void CallTrampoline_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // TODO(v8:8888): Implement on this platform.
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void CallWithArrayLike_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // TODO(v8:8888): Implement on this platform.
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void CallWithSpread_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // TODO(v8:8888): Implement on this platform.
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void ConstructWithArrayLike_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // TODO(v8:8888): Implement on this platform.
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void ConstructWithSpread_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // TODO(v8:8888): Implement on this platform.
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void Compare_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // TODO(v8:8888): Implement on this platform.
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void UnaryOp_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // TODO(v8:8888): Implement on this platform.
+  DefaultInitializePlatformSpecific(data, 3);
+}
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/macro-assembler-ppc.cc b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/macro-assembler-ppc.cc
--- a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/macro-assembler-ppc.cc	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/macro-assembler-ppc.cc	2025-06-04 10:11:01.000000000 +0800
@@ -0,0 +1,3284 @@
+// Copyright 2014 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <assert.h>  // For assert
+#include <limits.h>  // For LONG_MIN, LONG_MAX.
+
+#if V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
+
+#include "src/base/bits.h"
+#include "src/base/division-by-constant.h"
+#include "src/codegen/callable.h"
+#include "src/codegen/code-factory.h"
+#include "src/codegen/external-reference-table.h"
+#include "src/codegen/macro-assembler.h"
+#include "src/codegen/register-configuration.h"
+#include "src/debug/debug.h"
+#include "src/execution/frames-inl.h"
+#include "src/heap/memory-chunk.h"
+#include "src/init/bootstrapper.h"
+#include "src/logging/counters.h"
+#include "src/runtime/runtime.h"
+#include "src/snapshot/embedded/embedded-data.h"
+#include "src/snapshot/snapshot.h"
+#include "src/wasm/wasm-code-manager.h"
+
+// Satisfy cpplint check, but don't include platform-specific header. It is
+// included recursively via macro-assembler.h.
+#if 0
+#include "src/codegen/ppc/macro-assembler-ppc.h"
+#endif
+
+namespace v8 {
+namespace internal {
+
+int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,
+                                                    Register exclusion1,
+                                                    Register exclusion2,
+                                                    Register exclusion3) const {
+  int bytes = 0;
+  RegList exclusions = 0;
+  if (exclusion1 != no_reg) {
+    exclusions |= exclusion1.bit();
+    if (exclusion2 != no_reg) {
+      exclusions |= exclusion2.bit();
+      if (exclusion3 != no_reg) {
+        exclusions |= exclusion3.bit();
+      }
+    }
+  }
+
+  RegList list = kJSCallerSaved & ~exclusions;
+  bytes += NumRegs(list) * kSystemPointerSize;
+
+  if (fp_mode == kSaveFPRegs) {
+    bytes += kNumCallerSavedDoubles * kDoubleSize;
+  }
+
+  return bytes;
+}
+
+int TurboAssembler::PushCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
+                                    Register exclusion2, Register exclusion3) {
+  int bytes = 0;
+  RegList exclusions = 0;
+  if (exclusion1 != no_reg) {
+    exclusions |= exclusion1.bit();
+    if (exclusion2 != no_reg) {
+      exclusions |= exclusion2.bit();
+      if (exclusion3 != no_reg) {
+        exclusions |= exclusion3.bit();
+      }
+    }
+  }
+
+  RegList list = kJSCallerSaved & ~exclusions;
+  MultiPush(list);
+  bytes += NumRegs(list) * kSystemPointerSize;
+
+  if (fp_mode == kSaveFPRegs) {
+    MultiPushDoubles(kCallerSavedDoubles);
+    bytes += kNumCallerSavedDoubles * kDoubleSize;
+  }
+
+  return bytes;
+}
+
+int TurboAssembler::PopCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
+                                   Register exclusion2, Register exclusion3) {
+  int bytes = 0;
+  if (fp_mode == kSaveFPRegs) {
+    MultiPopDoubles(kCallerSavedDoubles);
+    bytes += kNumCallerSavedDoubles * kDoubleSize;
+  }
+
+  RegList exclusions = 0;
+  if (exclusion1 != no_reg) {
+    exclusions |= exclusion1.bit();
+    if (exclusion2 != no_reg) {
+      exclusions |= exclusion2.bit();
+      if (exclusion3 != no_reg) {
+        exclusions |= exclusion3.bit();
+      }
+    }
+  }
+
+  RegList list = kJSCallerSaved & ~exclusions;
+  MultiPop(list);
+  bytes += NumRegs(list) * kSystemPointerSize;
+
+  return bytes;
+}
+
+void TurboAssembler::Jump(Register target) {
+  mtctr(target);
+  bctr();
+}
+
+void TurboAssembler::LoadFromConstantsTable(Register destination,
+                                            int constant_index) {
+  DCHECK(RootsTable::IsImmortalImmovable(RootIndex::kBuiltinsConstantsTable));
+
+  DCHECK_NE(destination, r0);
+  LoadRoot(destination, RootIndex::kBuiltinsConstantsTable);
+  LoadTaggedPointerField(
+      destination,
+      FieldMemOperand(destination,
+                      FixedArray::OffsetOfElementAt(constant_index)),
+      r0);
+}
+
+void TurboAssembler::LoadRootRelative(Register destination, int32_t offset) {
+  LoadP(destination, MemOperand(kRootRegister, offset), r0);
+}
+
+void TurboAssembler::LoadRootRegisterOffset(Register destination,
+                                            intptr_t offset) {
+  if (offset == 0) {
+    mr(destination, kRootRegister);
+  } else if (is_int16(offset)) {
+    addi(destination, kRootRegister, Operand(offset));
+  } else {
+    mov(destination, Operand(offset));
+    add(destination, kRootRegister, destination);
+  }
+}
+
+void TurboAssembler::Jump(intptr_t target, RelocInfo::Mode rmode,
+                          Condition cond, CRegister cr) {
+  Label skip;
+
+  if (cond != al) b(NegateCondition(cond), &skip, cr);
+
+  DCHECK(rmode == RelocInfo::CODE_TARGET || rmode == RelocInfo::RUNTIME_ENTRY);
+
+  mov(ip, Operand(target, rmode));
+  mtctr(ip);
+  bctr();
+
+  bind(&skip);
+}
+
+void TurboAssembler::Jump(Address target, RelocInfo::Mode rmode, Condition cond,
+                          CRegister cr) {
+  DCHECK(!RelocInfo::IsCodeTarget(rmode));
+  Jump(static_cast<intptr_t>(target), rmode, cond, cr);
+}
+
+void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
+                          Condition cond, CRegister cr) {
+  DCHECK(RelocInfo::IsCodeTarget(rmode));
+  DCHECK_IMPLIES(options().isolate_independent_code,
+                 Builtins::IsIsolateIndependentBuiltin(*code));
+
+  int builtin_index = Builtins::kNoBuiltinId;
+  bool target_is_isolate_independent_builtin =
+      isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&
+      Builtins::IsIsolateIndependent(builtin_index);
+
+  if (root_array_available_ && options().isolate_independent_code) {
+    Label skip;
+    Register scratch = ip;
+    int offset = code->builtin_index() * kSystemPointerSize +
+                 IsolateData::builtin_entry_table_offset();
+    LoadP(scratch, MemOperand(kRootRegister, offset), r0);
+    if (cond != al) b(NegateCondition(cond), &skip, cr);
+    Jump(scratch);
+    bind(&skip);
+    return;
+  } else if (options().inline_offheap_trampolines &&
+             target_is_isolate_independent_builtin) {
+    // Inline the trampoline.
+    Label skip;
+    RecordCommentForOffHeapTrampoline(builtin_index);
+    EmbeddedData d = EmbeddedData::FromBlob();
+    Address entry = d.InstructionStartOfBuiltin(builtin_index);
+    // Use ip directly instead of using UseScratchRegisterScope, as we do
+    // not preserve scratch registers across calls.
+    mov(ip, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
+    if (cond != al) b(NegateCondition(cond), &skip, cr);
+    Jump(ip);
+    bind(&skip);
+    return;
+  }
+  int32_t target_index = AddCodeTarget(code);
+  Jump(static_cast<intptr_t>(target_index), rmode, cond, cr);
+}
+
+void TurboAssembler::Jump(const ExternalReference& reference) {
+  UseScratchRegisterScope temps(this);
+  Register scratch = temps.Acquire();
+  Move(scratch, reference);
+  if (ABI_USES_FUNCTION_DESCRIPTORS) {
+    // AIX uses a function descriptor. When calling C code be
+    // aware of this descriptor and pick up values from it.
+    LoadP(ToRegister(ABI_TOC_REGISTER),
+          MemOperand(scratch, kSystemPointerSize));
+    LoadP(scratch, MemOperand(scratch, 0));
+  }
+  Jump(scratch);
+}
+
+void TurboAssembler::Call(Register target) {
+  BlockTrampolinePoolScope block_trampoline_pool(this);
+  // branch via link register and set LK bit for return point
+  mtctr(target);
+  bctrl();
+}
+
+void MacroAssembler::CallJSEntry(Register target) {
+  CHECK(target == r5);
+  Call(target);
+}
+
+int MacroAssembler::CallSizeNotPredictableCodeSize(Address target,
+                                                   RelocInfo::Mode rmode,
+                                                   Condition cond) {
+  return (2 + kMovInstructionsNoConstantPool) * kInstrSize;
+}
+
+void TurboAssembler::Call(Address target, RelocInfo::Mode rmode,
+                          Condition cond) {
+  BlockTrampolinePoolScope block_trampoline_pool(this);
+  DCHECK(cond == al);
+
+  // This can likely be optimized to make use of bc() with 24bit relative
+  //
+  // RecordRelocInfo(x.rmode_, x.immediate);
+  // bc( BA, .... offset, LKset);
+  //
+
+  mov(ip, Operand(target, rmode));
+  mtctr(ip);
+  bctrl();
+}
+
+void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
+                          Condition cond) {
+  BlockTrampolinePoolScope block_trampoline_pool(this);
+  DCHECK(RelocInfo::IsCodeTarget(rmode));
+  DCHECK_IMPLIES(options().isolate_independent_code,
+                 Builtins::IsIsolateIndependentBuiltin(*code));
+  DCHECK_IMPLIES(options().use_pc_relative_calls_and_jumps,
+                 Builtins::IsIsolateIndependentBuiltin(*code));
+
+  int builtin_index = Builtins::kNoBuiltinId;
+  bool target_is_isolate_independent_builtin =
+      isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&
+      Builtins::IsIsolateIndependent(builtin_index);
+
+  if (root_array_available_ && options().isolate_independent_code) {
+    Label skip;
+    int offset = code->builtin_index() * kSystemPointerSize +
+                 IsolateData::builtin_entry_table_offset();
+    LoadP(ip, MemOperand(kRootRegister, offset));
+    if (cond != al) b(NegateCondition(cond), &skip);
+    Call(ip);
+    bind(&skip);
+    return;
+  } else if (options().inline_offheap_trampolines &&
+             target_is_isolate_independent_builtin) {
+    // Inline the trampoline.
+    RecordCommentForOffHeapTrampoline(builtin_index);
+    EmbeddedData d = EmbeddedData::FromBlob();
+    Address entry = d.InstructionStartOfBuiltin(builtin_index);
+    // Use ip directly instead of using UseScratchRegisterScope, as we do
+    // not preserve scratch registers across calls.
+    mov(ip, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
+    Label skip;
+    if (cond != al) b(NegateCondition(cond), &skip);
+    Call(ip);
+    bind(&skip);
+    return;
+  }
+  DCHECK(code->IsExecutable());
+  int32_t target_index = AddCodeTarget(code);
+  Call(static_cast<Address>(target_index), rmode, cond);
+}
+
+void TurboAssembler::Drop(int count) {
+  if (count > 0) {
+    Add(sp, sp, count * kSystemPointerSize, r0);
+  }
+}
+
+void TurboAssembler::Drop(Register count, Register scratch) {
+  ShiftLeftImm(scratch, count, Operand(kSystemPointerSizeLog2));
+  add(sp, sp, scratch);
+}
+
+void TurboAssembler::Call(Label* target) { b(target, SetLK); }
+
+void TurboAssembler::Push(Handle<HeapObject> handle) {
+  mov(r0, Operand(handle));
+  push(r0);
+}
+
+void TurboAssembler::Push(Smi smi) {
+  mov(r0, Operand(smi));
+  push(r0);
+}
+
+void TurboAssembler::PushArray(Register array, Register size, Register scratch,
+                               Register scratch2, PushArrayOrder order) {
+  Label loop, done;
+
+  if (order == kNormal) {
+    cmpi(size, Operand::Zero());
+    beq(&done);
+    ShiftLeftImm(scratch, size, Operand(kSystemPointerSizeLog2));
+    add(scratch, array, scratch);
+    mtctr(size);
+
+    bind(&loop);
+    LoadPU(scratch2, MemOperand(scratch, -kSystemPointerSize));
+    StorePU(scratch2, MemOperand(sp, -kSystemPointerSize));
+    bdnz(&loop);
+
+    bind(&done);
+  } else {
+    cmpi(size, Operand::Zero());
+    beq(&done);
+
+    mtctr(size);
+    subi(scratch, array, Operand(kSystemPointerSize));
+
+    bind(&loop);
+    LoadPU(scratch2, MemOperand(scratch, kSystemPointerSize));
+    StorePU(scratch2, MemOperand(sp, -kSystemPointerSize));
+    bdnz(&loop);
+    bind(&done);
+  }
+}
+
+void TurboAssembler::Move(Register dst, Handle<HeapObject> value,
+                          RelocInfo::Mode rmode) {
+  // TODO(jgruber,v8:8887): Also consider a root-relative load when generating
+  // non-isolate-independent code. In many cases it might be cheaper than
+  // embedding the relocatable value.
+  if (root_array_available_ && options().isolate_independent_code) {
+    IndirectLoadConstant(dst, value);
+    return;
+  } else if (RelocInfo::IsCompressedEmbeddedObject(rmode)) {
+    EmbeddedObjectIndex index = AddEmbeddedObject(value);
+    DCHECK(is_uint32(index));
+    mov(dst, Operand(static_cast<int>(index), rmode));
+  } else {
+    DCHECK(RelocInfo::IsFullEmbeddedObject(rmode));
+    mov(dst, Operand(value.address(), rmode));
+  }
+}
+
+void TurboAssembler::Move(Register dst, ExternalReference reference) {
+  // TODO(jgruber,v8:8887): Also consider a root-relative load when generating
+  // non-isolate-independent code. In many cases it might be cheaper than
+  // embedding the relocatable value.
+  if (root_array_available_ && options().isolate_independent_code) {
+    IndirectLoadExternalReference(dst, reference);
+    return;
+  }
+  mov(dst, Operand(reference));
+}
+
+void TurboAssembler::Move(Register dst, Register src, Condition cond) {
+  DCHECK(cond == al);
+  if (dst != src) {
+    mr(dst, src);
+  }
+}
+
+void TurboAssembler::Move(DoubleRegister dst, DoubleRegister src) {
+  if (dst != src) {
+    fmr(dst, src);
+  }
+}
+
+void TurboAssembler::MultiPush(RegList regs, Register location) {
+  int16_t num_to_push = base::bits::CountPopulation(regs);
+  int16_t stack_offset = num_to_push * kSystemPointerSize;
+
+  subi(location, location, Operand(stack_offset));
+  for (int16_t i = Register::kNumRegisters - 1; i >= 0; i--) {
+    if ((regs & (1 << i)) != 0) {
+      stack_offset -= kSystemPointerSize;
+      StoreP(ToRegister(i), MemOperand(location, stack_offset));
+    }
+  }
+}
+
+void TurboAssembler::MultiPop(RegList regs, Register location) {
+  int16_t stack_offset = 0;
+
+  for (int16_t i = 0; i < Register::kNumRegisters; i++) {
+    if ((regs & (1 << i)) != 0) {
+      LoadP(ToRegister(i), MemOperand(location, stack_offset));
+      stack_offset += kSystemPointerSize;
+    }
+  }
+  addi(location, location, Operand(stack_offset));
+}
+
+void TurboAssembler::MultiPushDoubles(RegList dregs, Register location) {
+  int16_t num_to_push = base::bits::CountPopulation(dregs);
+  int16_t stack_offset = num_to_push * kDoubleSize;
+
+  subi(location, location, Operand(stack_offset));
+  for (int16_t i = DoubleRegister::kNumRegisters - 1; i >= 0; i--) {
+    if ((dregs & (1 << i)) != 0) {
+      DoubleRegister dreg = DoubleRegister::from_code(i);
+      stack_offset -= kDoubleSize;
+      stfd(dreg, MemOperand(location, stack_offset));
+    }
+  }
+}
+
+void TurboAssembler::MultiPopDoubles(RegList dregs, Register location) {
+  int16_t stack_offset = 0;
+
+  for (int16_t i = 0; i < DoubleRegister::kNumRegisters; i++) {
+    if ((dregs & (1 << i)) != 0) {
+      DoubleRegister dreg = DoubleRegister::from_code(i);
+      lfd(dreg, MemOperand(location, stack_offset));
+      stack_offset += kDoubleSize;
+    }
+  }
+  addi(location, location, Operand(stack_offset));
+}
+
+void TurboAssembler::LoadRoot(Register destination, RootIndex index,
+                              Condition cond) {
+  DCHECK(cond == al);
+  LoadP(destination,
+        MemOperand(kRootRegister, RootRegisterOffsetForRootIndex(index)), r0);
+}
+
+void TurboAssembler::LoadTaggedPointerField(const Register& destination,
+                                            const MemOperand& field_operand,
+                                            const Register& scratch) {
+  if (COMPRESS_POINTERS_BOOL) {
+    DecompressTaggedPointer(destination, field_operand);
+  } else {
+    LoadP(destination, field_operand, scratch);
+  }
+}
+
+void TurboAssembler::LoadAnyTaggedField(const Register& destination,
+                                        const MemOperand& field_operand,
+                                        const Register& scratch) {
+  if (COMPRESS_POINTERS_BOOL) {
+    DecompressAnyTagged(destination, field_operand);
+  } else {
+    LoadP(destination, field_operand, scratch);
+  }
+}
+
+void TurboAssembler::SmiUntag(Register dst, const MemOperand& src, RCBit rc) {
+  if (SmiValuesAre31Bits()) {
+    lwz(dst, src);
+  } else {
+    LoadP(dst, src);
+  }
+
+  SmiUntag(dst, rc);
+}
+
+void TurboAssembler::SmiUntagField(Register dst, const MemOperand& src,
+                                   RCBit rc) {
+  SmiUntag(dst, src, rc);
+}
+
+void TurboAssembler::StoreTaggedFieldX(const Register& value,
+                                       const MemOperand& dst_field_operand,
+                                       const Register& scratch) {
+  if (COMPRESS_POINTERS_BOOL) {
+    RecordComment("[ StoreTagged");
+    stwx(value, dst_field_operand);
+    RecordComment("]");
+  } else {
+    StorePX(value, dst_field_operand);
+  }
+}
+
+void TurboAssembler::StoreTaggedField(const Register& value,
+                                      const MemOperand& dst_field_operand,
+                                      const Register& scratch) {
+  if (COMPRESS_POINTERS_BOOL) {
+    RecordComment("[ StoreTagged");
+    StoreWord(value, dst_field_operand, scratch);
+    RecordComment("]");
+  } else {
+    StoreP(value, dst_field_operand, scratch);
+  }
+}
+
+void TurboAssembler::DecompressTaggedSigned(Register destination,
+                                            Register src) {
+  RecordComment("[ DecompressTaggedSigned");
+  ZeroExtWord32(destination, src);
+  RecordComment("]");
+}
+
+void TurboAssembler::DecompressTaggedSigned(Register destination,
+                                            MemOperand field_operand) {
+  RecordComment("[ DecompressTaggedSigned");
+  LoadWord(destination, field_operand, r0);
+  RecordComment("]");
+}
+
+void TurboAssembler::DecompressTaggedPointer(Register destination,
+                                             Register source) {
+  RecordComment("[ DecompressTaggedPointer");
+  ZeroExtWord32(destination, source);
+  add(destination, destination, kRootRegister);
+  RecordComment("]");
+}
+
+void TurboAssembler::DecompressTaggedPointer(Register destination,
+                                             MemOperand field_operand) {
+  RecordComment("[ DecompressTaggedPointer");
+  LoadWord(destination, field_operand, r0);
+  add(destination, destination, kRootRegister);
+  RecordComment("]");
+}
+
+void TurboAssembler::DecompressAnyTagged(Register destination,
+                                         MemOperand field_operand) {
+  RecordComment("[ DecompressAnyTagged");
+  LoadWord(destination, field_operand, r0);
+  add(destination, destination, kRootRegister);
+  RecordComment("]");
+}
+
+void TurboAssembler::DecompressAnyTagged(Register destination,
+                                         Register source) {
+  RecordComment("[ DecompressAnyTagged");
+  ZeroExtWord32(destination, source);
+  add(destination, destination, kRootRegister);
+  RecordComment("]");
+}
+
+void MacroAssembler::RecordWriteField(Register object, int offset,
+                                      Register value, Register dst,
+                                      LinkRegisterStatus lr_status,
+                                      SaveFPRegsMode save_fp,
+                                      RememberedSetAction remembered_set_action,
+                                      SmiCheck smi_check) {
+  // First, check if a write barrier is even needed. The tests below
+  // catch stores of Smis.
+  Label done;
+
+  // Skip barrier if writing a smi.
+  if (smi_check == INLINE_SMI_CHECK) {
+    JumpIfSmi(value, &done);
+  }
+
+  // Although the object register is tagged, the offset is relative to the start
+  // of the object, so so offset must be a multiple of kSystemPointerSize.
+  DCHECK(IsAligned(offset, kTaggedSize));
+
+  Add(dst, object, offset - kHeapObjectTag, r0);
+  if (emit_debug_code()) {
+    Label ok;
+    andi(r0, dst, Operand(kTaggedSize - 1));
+    beq(&ok, cr0);
+    stop();
+    bind(&ok);
+  }
+
+  RecordWrite(object, dst, value, lr_status, save_fp, remembered_set_action,
+              OMIT_SMI_CHECK);
+
+  bind(&done);
+
+  // Clobber clobbered input registers when running with the debug-code flag
+  // turned on to provoke errors.
+  if (emit_debug_code()) {
+    mov(value, Operand(bit_cast<intptr_t>(kZapValue + 4)));
+    mov(dst, Operand(bit_cast<intptr_t>(kZapValue + 8)));
+  }
+}
+
+void TurboAssembler::SaveRegisters(RegList registers) {
+  DCHECK_GT(NumRegs(registers), 0);
+  RegList regs = 0;
+  for (int i = 0; i < Register::kNumRegisters; ++i) {
+    if ((registers >> i) & 1u) {
+      regs |= Register::from_code(i).bit();
+    }
+  }
+
+  MultiPush(regs);
+}
+
+void TurboAssembler::RestoreRegisters(RegList registers) {
+  DCHECK_GT(NumRegs(registers), 0);
+  RegList regs = 0;
+  for (int i = 0; i < Register::kNumRegisters; ++i) {
+    if ((registers >> i) & 1u) {
+      regs |= Register::from_code(i).bit();
+    }
+  }
+  MultiPop(regs);
+}
+
+void TurboAssembler::CallEphemeronKeyBarrier(Register object, Register address,
+                                             SaveFPRegsMode fp_mode) {
+  EphemeronKeyBarrierDescriptor descriptor;
+  RegList registers = descriptor.allocatable_registers();
+
+  SaveRegisters(registers);
+
+  Register object_parameter(
+      descriptor.GetRegisterParameter(EphemeronKeyBarrierDescriptor::kObject));
+  Register slot_parameter(descriptor.GetRegisterParameter(
+      EphemeronKeyBarrierDescriptor::kSlotAddress));
+  Register fp_mode_parameter(
+      descriptor.GetRegisterParameter(EphemeronKeyBarrierDescriptor::kFPMode));
+
+  push(object);
+  push(address);
+
+  pop(slot_parameter);
+  pop(object_parameter);
+
+  Move(fp_mode_parameter, Smi::FromEnum(fp_mode));
+  Call(isolate()->builtins()->builtin_handle(Builtins::kEphemeronKeyBarrier),
+       RelocInfo::CODE_TARGET);
+  RestoreRegisters(registers);
+}
+
+void TurboAssembler::CallRecordWriteStub(
+    Register object, Register address,
+    RememberedSetAction remembered_set_action, SaveFPRegsMode fp_mode) {
+  CallRecordWriteStub(
+      object, address, remembered_set_action, fp_mode,
+      isolate()->builtins()->builtin_handle(Builtins::kRecordWrite),
+      kNullAddress);
+}
+
+void TurboAssembler::CallRecordWriteStub(
+    Register object, Register address,
+    RememberedSetAction remembered_set_action, SaveFPRegsMode fp_mode,
+    Address wasm_target) {
+  CallRecordWriteStub(object, address, remembered_set_action, fp_mode,
+                      Handle<Code>::null(), wasm_target);
+}
+
+void TurboAssembler::CallRecordWriteStub(
+    Register object, Register address,
+    RememberedSetAction remembered_set_action, SaveFPRegsMode fp_mode,
+    Handle<Code> code_target, Address wasm_target) {
+  DCHECK_NE(code_target.is_null(), wasm_target == kNullAddress);
+  // TODO(albertnetymk): For now we ignore remembered_set_action and fp_mode,
+  // i.e. always emit remember set and save FP registers in RecordWriteStub. If
+  // large performance regression is observed, we should use these values to
+  // avoid unnecessary work.
+
+  RecordWriteDescriptor descriptor;
+  RegList registers = descriptor.allocatable_registers();
+
+  SaveRegisters(registers);
+
+  Register object_parameter(
+      descriptor.GetRegisterParameter(RecordWriteDescriptor::kObject));
+  Register slot_parameter(
+      descriptor.GetRegisterParameter(RecordWriteDescriptor::kSlot));
+  Register remembered_set_parameter(
+      descriptor.GetRegisterParameter(RecordWriteDescriptor::kRememberedSet));
+  Register fp_mode_parameter(
+      descriptor.GetRegisterParameter(RecordWriteDescriptor::kFPMode));
+
+  push(object);
+  push(address);
+
+  pop(slot_parameter);
+  pop(object_parameter);
+
+  Move(remembered_set_parameter, Smi::FromEnum(remembered_set_action));
+  Move(fp_mode_parameter, Smi::FromEnum(fp_mode));
+  if (code_target.is_null()) {
+    Call(wasm_target, RelocInfo::WASM_STUB_CALL);
+  } else {
+    Call(code_target, RelocInfo::CODE_TARGET);
+  }
+
+  RestoreRegisters(registers);
+}
+
+// Will clobber 4 registers: object, address, scratch, ip.  The
+// register 'object' contains a heap object pointer.  The heap object
+// tag is shifted away.
+void MacroAssembler::RecordWrite(Register object, Register address,
+                                 Register value, LinkRegisterStatus lr_status,
+                                 SaveFPRegsMode fp_mode,
+                                 RememberedSetAction remembered_set_action,
+                                 SmiCheck smi_check) {
+  DCHECK(object != value);
+  if (emit_debug_code()) {
+    LoadTaggedPointerField(r0, MemOperand(address));
+    cmp(r0, value);
+    Check(eq, AbortReason::kWrongAddressOrValuePassedToRecordWrite);
+  }
+
+  if ((remembered_set_action == OMIT_REMEMBERED_SET &&
+       !FLAG_incremental_marking) ||
+      FLAG_disable_write_barriers) {
+    return;
+  }
+
+  // First, check if a write barrier is even needed. The tests below
+  // catch stores of smis and stores into the young generation.
+  Label done;
+
+  if (smi_check == INLINE_SMI_CHECK) {
+    JumpIfSmi(value, &done);
+  }
+
+  CheckPageFlag(value,
+                value,  // Used as scratch.
+                MemoryChunk::kPointersToHereAreInterestingMask, eq, &done);
+  CheckPageFlag(object,
+                value,  // Used as scratch.
+                MemoryChunk::kPointersFromHereAreInterestingMask, eq, &done);
+
+  // Record the actual write.
+  if (lr_status == kLRHasNotBeenSaved) {
+    mflr(r0);
+    push(r0);
+  }
+  CallRecordWriteStub(object, address, remembered_set_action, fp_mode);
+  if (lr_status == kLRHasNotBeenSaved) {
+    pop(r0);
+    mtlr(r0);
+  }
+
+  bind(&done);
+
+  // Clobber clobbered registers when running with the debug-code flag
+  // turned on to provoke errors.
+  if (emit_debug_code()) {
+    mov(address, Operand(bit_cast<intptr_t>(kZapValue + 12)));
+    mov(value, Operand(bit_cast<intptr_t>(kZapValue + 16)));
+  }
+}
+
+void TurboAssembler::PushCommonFrame(Register marker_reg) {
+  int fp_delta = 0;
+  mflr(r0);
+  if (FLAG_enable_embedded_constant_pool) {
+    if (marker_reg.is_valid()) {
+      Push(r0, fp, kConstantPoolRegister, marker_reg);
+      fp_delta = 2;
+    } else {
+      Push(r0, fp, kConstantPoolRegister);
+      fp_delta = 1;
+    }
+  } else {
+    if (marker_reg.is_valid()) {
+      Push(r0, fp, marker_reg);
+      fp_delta = 1;
+    } else {
+      Push(r0, fp);
+      fp_delta = 0;
+    }
+  }
+  addi(fp, sp, Operand(fp_delta * kSystemPointerSize));
+}
+
+void TurboAssembler::PushStandardFrame(Register function_reg) {
+  int fp_delta = 0;
+  mflr(r0);
+  if (FLAG_enable_embedded_constant_pool) {
+    if (function_reg.is_valid()) {
+      Push(r0, fp, kConstantPoolRegister, cp, function_reg);
+      fp_delta = 3;
+    } else {
+      Push(r0, fp, kConstantPoolRegister, cp);
+      fp_delta = 2;
+    }
+  } else {
+    if (function_reg.is_valid()) {
+      Push(r0, fp, cp, function_reg);
+      fp_delta = 2;
+    } else {
+      Push(r0, fp, cp);
+      fp_delta = 1;
+    }
+  }
+  addi(fp, sp, Operand(fp_delta * kSystemPointerSize));
+  Push(kJavaScriptCallArgCountRegister);
+}
+
+void TurboAssembler::RestoreFrameStateForTailCall() {
+  if (FLAG_enable_embedded_constant_pool) {
+    LoadP(kConstantPoolRegister,
+          MemOperand(fp, StandardFrameConstants::kConstantPoolOffset));
+    set_constant_pool_available(false);
+  }
+  LoadP(r0, MemOperand(fp, StandardFrameConstants::kCallerPCOffset));
+  LoadP(fp, MemOperand(fp, StandardFrameConstants::kCallerFPOffset));
+  mtlr(r0);
+}
+
+void TurboAssembler::CanonicalizeNaN(const DoubleRegister dst,
+                                     const DoubleRegister src) {
+  // Turn potential sNaN into qNaN.
+  fsub(dst, src, kDoubleRegZero);
+}
+
+void TurboAssembler::ConvertIntToDouble(Register src, DoubleRegister dst) {
+  MovIntToDouble(dst, src, r0);
+  fcfid(dst, dst);
+}
+
+void TurboAssembler::ConvertUnsignedIntToDouble(Register src,
+                                                DoubleRegister dst) {
+  MovUnsignedIntToDouble(dst, src, r0);
+  fcfid(dst, dst);
+}
+
+void TurboAssembler::ConvertIntToFloat(Register src, DoubleRegister dst) {
+  MovIntToDouble(dst, src, r0);
+  fcfids(dst, dst);
+}
+
+void TurboAssembler::ConvertUnsignedIntToFloat(Register src,
+                                               DoubleRegister dst) {
+  MovUnsignedIntToDouble(dst, src, r0);
+  fcfids(dst, dst);
+}
+
+#if V8_TARGET_ARCH_PPC64
+void TurboAssembler::ConvertInt64ToDouble(Register src,
+                                          DoubleRegister double_dst) {
+  MovInt64ToDouble(double_dst, src);
+  fcfid(double_dst, double_dst);
+}
+
+void TurboAssembler::ConvertUnsignedInt64ToFloat(Register src,
+                                                 DoubleRegister double_dst) {
+  MovInt64ToDouble(double_dst, src);
+  fcfidus(double_dst, double_dst);
+}
+
+void TurboAssembler::ConvertUnsignedInt64ToDouble(Register src,
+                                                  DoubleRegister double_dst) {
+  MovInt64ToDouble(double_dst, src);
+  fcfidu(double_dst, double_dst);
+}
+
+void TurboAssembler::ConvertInt64ToFloat(Register src,
+                                         DoubleRegister double_dst) {
+  MovInt64ToDouble(double_dst, src);
+  fcfids(double_dst, double_dst);
+}
+#endif
+
+void TurboAssembler::ConvertDoubleToInt64(const DoubleRegister double_input,
+#if !V8_TARGET_ARCH_PPC64
+                                          const Register dst_hi,
+#endif
+                                          const Register dst,
+                                          const DoubleRegister double_dst,
+                                          FPRoundingMode rounding_mode) {
+  if (rounding_mode == kRoundToZero) {
+    fctidz(double_dst, double_input);
+  } else {
+    SetRoundingMode(rounding_mode);
+    fctid(double_dst, double_input);
+    ResetRoundingMode();
+  }
+
+  MovDoubleToInt64(
+#if !V8_TARGET_ARCH_PPC64
+      dst_hi,
+#endif
+      dst, double_dst);
+}
+
+#if V8_TARGET_ARCH_PPC64
+void TurboAssembler::ConvertDoubleToUnsignedInt64(
+    const DoubleRegister double_input, const Register dst,
+    const DoubleRegister double_dst, FPRoundingMode rounding_mode) {
+  if (rounding_mode == kRoundToZero) {
+    fctiduz(double_dst, double_input);
+  } else {
+    SetRoundingMode(rounding_mode);
+    fctidu(double_dst, double_input);
+    ResetRoundingMode();
+  }
+
+  MovDoubleToInt64(dst, double_dst);
+}
+#endif
+
+#if !V8_TARGET_ARCH_PPC64
+void TurboAssembler::ShiftLeftPair(Register dst_low, Register dst_high,
+                                   Register src_low, Register src_high,
+                                   Register scratch, Register shift) {
+  DCHECK(!AreAliased(dst_low, src_high));
+  DCHECK(!AreAliased(dst_high, src_low));
+  DCHECK(!AreAliased(dst_low, dst_high, shift));
+  Label less_than_32;
+  Label done;
+  cmpi(shift, Operand(32));
+  blt(&less_than_32);
+  // If shift >= 32
+  andi(scratch, shift, Operand(0x1F));
+  slw(dst_high, src_low, scratch);
+  li(dst_low, Operand::Zero());
+  b(&done);
+  bind(&less_than_32);
+  // If shift < 32
+  subfic(scratch, shift, Operand(32));
+  slw(dst_high, src_high, shift);
+  srw(scratch, src_low, scratch);
+  orx(dst_high, dst_high, scratch);
+  slw(dst_low, src_low, shift);
+  bind(&done);
+}
+
+void TurboAssembler::ShiftLeftPair(Register dst_low, Register dst_high,
+                                   Register src_low, Register src_high,
+                                   uint32_t shift) {
+  DCHECK(!AreAliased(dst_low, src_high));
+  DCHECK(!AreAliased(dst_high, src_low));
+  if (shift == 32) {
+    Move(dst_high, src_low);
+    li(dst_low, Operand::Zero());
+  } else if (shift > 32) {
+    shift &= 0x1F;
+    slwi(dst_high, src_low, Operand(shift));
+    li(dst_low, Operand::Zero());
+  } else if (shift == 0) {
+    Move(dst_low, src_low);
+    Move(dst_high, src_high);
+  } else {
+    slwi(dst_high, src_high, Operand(shift));
+    rlwimi(dst_high, src_low, shift, 32 - shift, 31);
+    slwi(dst_low, src_low, Operand(shift));
+  }
+}
+
+void TurboAssembler::ShiftRightPair(Register dst_low, Register dst_high,
+                                    Register src_low, Register src_high,
+                                    Register scratch, Register shift) {
+  DCHECK(!AreAliased(dst_low, src_high));
+  DCHECK(!AreAliased(dst_high, src_low));
+  DCHECK(!AreAliased(dst_low, dst_high, shift));
+  Label less_than_32;
+  Label done;
+  cmpi(shift, Operand(32));
+  blt(&less_than_32);
+  // If shift >= 32
+  andi(scratch, shift, Operand(0x1F));
+  srw(dst_low, src_high, scratch);
+  li(dst_high, Operand::Zero());
+  b(&done);
+  bind(&less_than_32);
+  // If shift < 32
+  subfic(scratch, shift, Operand(32));
+  srw(dst_low, src_low, shift);
+  slw(scratch, src_high, scratch);
+  orx(dst_low, dst_low, scratch);
+  srw(dst_high, src_high, shift);
+  bind(&done);
+}
+
+void TurboAssembler::ShiftRightPair(Register dst_low, Register dst_high,
+                                    Register src_low, Register src_high,
+                                    uint32_t shift) {
+  DCHECK(!AreAliased(dst_low, src_high));
+  DCHECK(!AreAliased(dst_high, src_low));
+  if (shift == 32) {
+    Move(dst_low, src_high);
+    li(dst_high, Operand::Zero());
+  } else if (shift > 32) {
+    shift &= 0x1F;
+    srwi(dst_low, src_high, Operand(shift));
+    li(dst_high, Operand::Zero());
+  } else if (shift == 0) {
+    Move(dst_low, src_low);
+    Move(dst_high, src_high);
+  } else {
+    srwi(dst_low, src_low, Operand(shift));
+    rlwimi(dst_low, src_high, 32 - shift, 0, shift - 1);
+    srwi(dst_high, src_high, Operand(shift));
+  }
+}
+
+void TurboAssembler::ShiftRightAlgPair(Register dst_low, Register dst_high,
+                                       Register src_low, Register src_high,
+                                       Register scratch, Register shift) {
+  DCHECK(!AreAliased(dst_low, src_high, shift));
+  DCHECK(!AreAliased(dst_high, src_low, shift));
+  Label less_than_32;
+  Label done;
+  cmpi(shift, Operand(32));
+  blt(&less_than_32);
+  // If shift >= 32
+  andi(scratch, shift, Operand(0x1F));
+  sraw(dst_low, src_high, scratch);
+  srawi(dst_high, src_high, 31);
+  b(&done);
+  bind(&less_than_32);
+  // If shift < 32
+  subfic(scratch, shift, Operand(32));
+  srw(dst_low, src_low, shift);
+  slw(scratch, src_high, scratch);
+  orx(dst_low, dst_low, scratch);
+  sraw(dst_high, src_high, shift);
+  bind(&done);
+}
+
+void TurboAssembler::ShiftRightAlgPair(Register dst_low, Register dst_high,
+                                       Register src_low, Register src_high,
+                                       uint32_t shift) {
+  DCHECK(!AreAliased(dst_low, src_high));
+  DCHECK(!AreAliased(dst_high, src_low));
+  if (shift == 32) {
+    Move(dst_low, src_high);
+    srawi(dst_high, src_high, 31);
+  } else if (shift > 32) {
+    shift &= 0x1F;
+    srawi(dst_low, src_high, shift);
+    srawi(dst_high, src_high, 31);
+  } else if (shift == 0) {
+    Move(dst_low, src_low);
+    Move(dst_high, src_high);
+  } else {
+    srwi(dst_low, src_low, Operand(shift));
+    rlwimi(dst_low, src_high, 32 - shift, 0, shift - 1);
+    srawi(dst_high, src_high, shift);
+  }
+}
+#endif
+
+void TurboAssembler::LoadConstantPoolPointerRegisterFromCodeTargetAddress(
+    Register code_target_address) {
+  lwz(kConstantPoolRegister,
+      MemOperand(code_target_address,
+                 Code::kConstantPoolOffsetOffset - Code::kHeaderSize));
+  add(kConstantPoolRegister, kConstantPoolRegister, code_target_address);
+}
+
+void TurboAssembler::LoadPC(Register dst) {
+  b(4, SetLK);
+  mflr(dst);
+}
+
+void TurboAssembler::ComputeCodeStartAddress(Register dst) {
+  mflr(r0);
+  LoadPC(dst);
+  subi(dst, dst, Operand(pc_offset() - kInstrSize));
+  mtlr(r0);
+}
+
+void TurboAssembler::LoadConstantPoolPointerRegister() {
+  LoadPC(kConstantPoolRegister);
+  int32_t delta = -pc_offset() + 4;
+  add_label_offset(kConstantPoolRegister, kConstantPoolRegister,
+                   ConstantPoolPosition(), delta);
+}
+
+void TurboAssembler::StubPrologue(StackFrame::Type type) {
+  {
+    ConstantPoolUnavailableScope constant_pool_unavailable(this);
+    mov(r11, Operand(StackFrame::TypeToMarker(type)));
+    PushCommonFrame(r11);
+  }
+  if (FLAG_enable_embedded_constant_pool) {
+    LoadConstantPoolPointerRegister();
+    set_constant_pool_available(true);
+  }
+}
+
+void TurboAssembler::Prologue() {
+  PushStandardFrame(r4);
+  if (FLAG_enable_embedded_constant_pool) {
+    // base contains prologue address
+    LoadConstantPoolPointerRegister();
+    set_constant_pool_available(true);
+  }
+}
+
+void TurboAssembler::EnterFrame(StackFrame::Type type,
+                                bool load_constant_pool_pointer_reg) {
+  if (FLAG_enable_embedded_constant_pool && load_constant_pool_pointer_reg) {
+    // Push type explicitly so we can leverage the constant pool.
+    // This path cannot rely on ip containing code entry.
+    PushCommonFrame();
+    LoadConstantPoolPointerRegister();
+    mov(ip, Operand(StackFrame::TypeToMarker(type)));
+    push(ip);
+  } else {
+    mov(ip, Operand(StackFrame::TypeToMarker(type)));
+    PushCommonFrame(ip);
+  }
+}
+
+int TurboAssembler::LeaveFrame(StackFrame::Type type, int stack_adjustment) {
+  ConstantPoolUnavailableScope constant_pool_unavailable(this);
+  // r3: preserved
+  // r4: preserved
+  // r5: preserved
+
+  // Drop the execution stack down to the frame pointer and restore
+  // the caller's state.
+  int frame_ends;
+  LoadP(r0, MemOperand(fp, StandardFrameConstants::kCallerPCOffset));
+  LoadP(ip, MemOperand(fp, StandardFrameConstants::kCallerFPOffset));
+  if (FLAG_enable_embedded_constant_pool) {
+    LoadP(kConstantPoolRegister,
+          MemOperand(fp, StandardFrameConstants::kConstantPoolOffset));
+  }
+  mtlr(r0);
+  frame_ends = pc_offset();
+  Add(sp, fp, StandardFrameConstants::kCallerSPOffset + stack_adjustment, r0);
+  mr(fp, ip);
+  return frame_ends;
+}
+
+// ExitFrame layout (probably wrongish.. needs updating)
+//
+//  SP -> previousSP
+//        LK reserved
+//        sp_on_exit (for debug?)
+// oldSP->prev SP
+//        LK
+//        <parameters on stack>
+
+// Prior to calling EnterExitFrame, we've got a bunch of parameters
+// on the stack that we need to wrap a real frame around.. so first
+// we reserve a slot for LK and push the previous SP which is captured
+// in the fp register (r31)
+// Then - we buy a new frame
+
+void MacroAssembler::EnterExitFrame(bool save_doubles, int stack_space,
+                                    StackFrame::Type frame_type) {
+  DCHECK(frame_type == StackFrame::EXIT ||
+         frame_type == StackFrame::BUILTIN_EXIT);
+  // Set up the frame structure on the stack.
+  DCHECK_EQ(2 * kSystemPointerSize, ExitFrameConstants::kCallerSPDisplacement);
+  DCHECK_EQ(1 * kSystemPointerSize, ExitFrameConstants::kCallerPCOffset);
+  DCHECK_EQ(0 * kSystemPointerSize, ExitFrameConstants::kCallerFPOffset);
+  DCHECK_GT(stack_space, 0);
+
+  // This is an opportunity to build a frame to wrap
+  // all of the pushes that have happened inside of V8
+  // since we were called from C code
+
+  mov(ip, Operand(StackFrame::TypeToMarker(frame_type)));
+  PushCommonFrame(ip);
+  // Reserve room for saved entry sp.
+  subi(sp, fp, Operand(ExitFrameConstants::kFixedFrameSizeFromFp));
+
+  if (emit_debug_code()) {
+    li(r8, Operand::Zero());
+    StoreP(r8, MemOperand(fp, ExitFrameConstants::kSPOffset));
+  }
+  if (FLAG_enable_embedded_constant_pool) {
+    StoreP(kConstantPoolRegister,
+           MemOperand(fp, ExitFrameConstants::kConstantPoolOffset));
+  }
+
+  // Save the frame pointer and the context in top.
+  Move(r8, ExternalReference::Create(IsolateAddressId::kCEntryFPAddress,
+                                     isolate()));
+  StoreP(fp, MemOperand(r8));
+  Move(r8,
+       ExternalReference::Create(IsolateAddressId::kContextAddress, isolate()));
+  StoreP(cp, MemOperand(r8));
+
+  // Optionally save all volatile double registers.
+  if (save_doubles) {
+    MultiPushDoubles(kCallerSavedDoubles);
+    // Note that d0 will be accessible at
+    //   fp - ExitFrameConstants::kFrameSize -
+    //   kNumCallerSavedDoubles * kDoubleSize,
+    // since the sp slot and code slot were pushed after the fp.
+  }
+
+  addi(sp, sp, Operand(-stack_space * kSystemPointerSize));
+
+  // Allocate and align the frame preparing for calling the runtime
+  // function.
+  const int frame_alignment = ActivationFrameAlignment();
+  if (frame_alignment > kSystemPointerSize) {
+    DCHECK(base::bits::IsPowerOfTwo(frame_alignment));
+    ClearRightImm(sp, sp,
+                  Operand(base::bits::WhichPowerOfTwo(frame_alignment)));
+  }
+  li(r0, Operand::Zero());
+  StorePU(r0,
+          MemOperand(sp, -kNumRequiredStackFrameSlots * kSystemPointerSize));
+
+  // Set the exit frame sp value to point just before the return address
+  // location.
+  addi(r8, sp, Operand((kStackFrameExtraParamSlot + 1) * kSystemPointerSize));
+  StoreP(r8, MemOperand(fp, ExitFrameConstants::kSPOffset));
+}
+
+int TurboAssembler::ActivationFrameAlignment() {
+#if !defined(USE_SIMULATOR)
+  // Running on the real platform. Use the alignment as mandated by the local
+  // environment.
+  // Note: This will break if we ever start generating snapshots on one PPC
+  // platform for another PPC platform with a different alignment.
+  return base::OS::ActivationFrameAlignment();
+#else  // Simulated
+  // If we are using the simulator then we should always align to the expected
+  // alignment. As the simulator is used to generate snapshots we do not know
+  // if the target platform will need alignment, so this is controlled from a
+  // flag.
+  return FLAG_sim_stack_alignment;
+#endif
+}
+
+void MacroAssembler::LeaveExitFrame(bool save_doubles, Register argument_count,
+                                    bool argument_count_is_length) {
+  ConstantPoolUnavailableScope constant_pool_unavailable(this);
+  // Optionally restore all double registers.
+  if (save_doubles) {
+    // Calculate the stack location of the saved doubles and restore them.
+    const int kNumRegs = kNumCallerSavedDoubles;
+    const int offset =
+        (ExitFrameConstants::kFixedFrameSizeFromFp + kNumRegs * kDoubleSize);
+    addi(r6, fp, Operand(-offset));
+    MultiPopDoubles(kCallerSavedDoubles, r6);
+  }
+
+  // Clear top frame.
+  li(r6, Operand::Zero());
+  Move(ip, ExternalReference::Create(IsolateAddressId::kCEntryFPAddress,
+                                     isolate()));
+  StoreP(r6, MemOperand(ip));
+
+  // Restore current context from top and clear it in debug mode.
+  Move(ip,
+       ExternalReference::Create(IsolateAddressId::kContextAddress, isolate()));
+  LoadP(cp, MemOperand(ip));
+
+#ifdef DEBUG
+  mov(r6, Operand(Context::kInvalidContext));
+  Move(ip,
+       ExternalReference::Create(IsolateAddressId::kContextAddress, isolate()));
+  StoreP(r6, MemOperand(ip));
+#endif
+
+  // Tear down the exit frame, pop the arguments, and return.
+  LeaveFrame(StackFrame::EXIT);
+
+  if (argument_count.is_valid()) {
+    if (!argument_count_is_length) {
+      ShiftLeftImm(argument_count, argument_count,
+                   Operand(kSystemPointerSizeLog2));
+    }
+    add(sp, sp, argument_count);
+  }
+}
+
+void TurboAssembler::MovFromFloatResult(const DoubleRegister dst) {
+  Move(dst, d1);
+}
+
+void TurboAssembler::MovFromFloatParameter(const DoubleRegister dst) {
+  Move(dst, d1);
+}
+
+void TurboAssembler::PrepareForTailCall(Register callee_args_count,
+                                        Register caller_args_count,
+                                        Register scratch0, Register scratch1) {
+  DCHECK(!AreAliased(callee_args_count, caller_args_count, scratch0, scratch1));
+
+  // Calculate the end of destination area where we will put the arguments
+  // after we drop current frame. We add kSystemPointerSize to count the
+  // receiver argument which is not included into formal parameters count.
+  Register dst_reg = scratch0;
+  ShiftLeftImm(dst_reg, caller_args_count, Operand(kSystemPointerSizeLog2));
+  add(dst_reg, fp, dst_reg);
+  addi(dst_reg, dst_reg,
+       Operand(StandardFrameConstants::kCallerSPOffset + kSystemPointerSize));
+
+  Register src_reg = caller_args_count;
+  // Calculate the end of source area. +kSystemPointerSize is for the receiver.
+  ShiftLeftImm(src_reg, callee_args_count, Operand(kSystemPointerSizeLog2));
+  add(src_reg, sp, src_reg);
+  addi(src_reg, src_reg, Operand(kSystemPointerSize));
+
+  if (FLAG_debug_code) {
+    cmpl(src_reg, dst_reg);
+    Check(lt, AbortReason::kStackAccessBelowStackPointer);
+  }
+
+  // Restore caller's frame pointer and return address now as they will be
+  // overwritten by the copying loop.
+  RestoreFrameStateForTailCall();
+
+  // Now copy callee arguments to the caller frame going backwards to avoid
+  // callee arguments corruption (source and destination areas could overlap).
+
+  // Both src_reg and dst_reg are pointing to the word after the one to copy,
+  // so they must be pre-decremented in the loop.
+  Register tmp_reg = scratch1;
+  Label loop;
+  addi(tmp_reg, callee_args_count, Operand(1));  // +1 for receiver
+  mtctr(tmp_reg);
+  bind(&loop);
+  LoadPU(tmp_reg, MemOperand(src_reg, -kSystemPointerSize));
+  StorePU(tmp_reg, MemOperand(dst_reg, -kSystemPointerSize));
+  bdnz(&loop);
+
+  // Leave current frame.
+  mr(sp, dst_reg);
+}
+
+void MacroAssembler::InvokePrologue(Register expected_parameter_count,
+                                    Register actual_parameter_count,
+                                    Label* done, InvokeFlag flag) {
+  Label regular_invoke;
+
+  // Check whether the expected and actual arguments count match. If not,
+  // setup registers according to contract with ArgumentsAdaptorTrampoline:
+  //  r3: actual arguments count
+  //  r4: function (passed through to callee)
+  //  r5: expected arguments count
+
+  // The code below is made a lot easier because the calling code already sets
+  // up actual and expected registers according to the contract if values are
+  // passed in registers.
+
+  // The code below is made a lot easier because the calling code already sets
+  // up actual and expected registers according to the contract.
+  // ARM has some checks as per below, considering add them for PPC
+  // DCHECK_EQ(actual_parameter_count, r3);
+  // DCHECK_EQ(expected_parameter_count, r5);
+
+  cmp(expected_parameter_count, actual_parameter_count);
+  beq(&regular_invoke);
+
+  Handle<Code> adaptor = BUILTIN_CODE(isolate(), ArgumentsAdaptorTrampoline);
+  if (flag == CALL_FUNCTION) {
+    Call(adaptor);
+    b(done);
+  } else {
+    Jump(adaptor, RelocInfo::CODE_TARGET);
+  }
+    bind(&regular_invoke);
+}
+
+void MacroAssembler::CheckDebugHook(Register fun, Register new_target,
+                                    Register expected_parameter_count,
+                                    Register actual_parameter_count) {
+  Label skip_hook;
+
+  ExternalReference debug_hook_active =
+      ExternalReference::debug_hook_on_function_call_address(isolate());
+  Move(r7, debug_hook_active);
+  LoadByte(r7, MemOperand(r7), r0);
+  extsb(r7, r7);
+  CmpSmiLiteral(r7, Smi::zero(), r0);
+  beq(&skip_hook);
+
+  {
+    // Load receiver to pass it later to DebugOnFunctionCall hook.
+    LoadReceiver(r7, actual_parameter_count);
+    FrameScope frame(this,
+                     has_frame() ? StackFrame::NONE : StackFrame::INTERNAL);
+
+    SmiTag(expected_parameter_count);
+    Push(expected_parameter_count);
+
+    SmiTag(actual_parameter_count);
+    Push(actual_parameter_count);
+
+    if (new_target.is_valid()) {
+      Push(new_target);
+    }
+    Push(fun, fun, r7);
+    CallRuntime(Runtime::kDebugOnFunctionCall);
+    Pop(fun);
+    if (new_target.is_valid()) {
+      Pop(new_target);
+    }
+
+    Pop(actual_parameter_count);
+    SmiUntag(actual_parameter_count);
+
+    Pop(expected_parameter_count);
+    SmiUntag(expected_parameter_count);
+  }
+  bind(&skip_hook);
+}
+
+void MacroAssembler::InvokeFunctionCode(Register function, Register new_target,
+                                        Register expected_parameter_count,
+                                        Register actual_parameter_count,
+                                        InvokeFlag flag) {
+  // You can't call a function without a valid frame.
+  DCHECK_IMPLIES(flag == CALL_FUNCTION, has_frame());
+  DCHECK_EQ(function, r4);
+  DCHECK_IMPLIES(new_target.is_valid(), new_target == r6);
+
+  // On function call, call into the debugger if necessary.
+  CheckDebugHook(function, new_target, expected_parameter_count,
+                 actual_parameter_count);
+
+  // Clear the new.target register if not given.
+  if (!new_target.is_valid()) {
+    LoadRoot(r6, RootIndex::kUndefinedValue);
+  }
+
+  Label done;
+  InvokePrologue(expected_parameter_count, actual_parameter_count, &done, flag);
+  // We call indirectly through the code field in the function to
+  // allow recompilation to take effect without changing any of the
+  // call sites.
+  Register code = kJavaScriptCallCodeStartRegister;
+  LoadTaggedPointerField(code,
+                         FieldMemOperand(function, JSFunction::kCodeOffset));
+  if (flag == CALL_FUNCTION) {
+    CallCodeObject(code);
+  } else {
+    DCHECK(flag == JUMP_FUNCTION);
+    JumpCodeObject(code);
+  }
+
+    // Continue here if InvokePrologue does handle the invocation due to
+    // mismatched parameter counts.
+    bind(&done);
+}
+
+void MacroAssembler::InvokeFunctionWithNewTarget(
+    Register fun, Register new_target, Register actual_parameter_count,
+    InvokeFlag flag) {
+  // You can't call a function without a valid frame.
+  DCHECK_IMPLIES(flag == CALL_FUNCTION, has_frame());
+
+  // Contract with called JS functions requires that function is passed in r4.
+  DCHECK_EQ(fun, r4);
+
+  Register expected_reg = r5;
+  Register temp_reg = r7;
+
+  LoadTaggedPointerField(
+      temp_reg, FieldMemOperand(r4, JSFunction::kSharedFunctionInfoOffset));
+  LoadTaggedPointerField(cp, FieldMemOperand(r4, JSFunction::kContextOffset));
+  LoadHalfWord(expected_reg,
+               FieldMemOperand(
+                   temp_reg, SharedFunctionInfo::kFormalParameterCountOffset));
+
+  InvokeFunctionCode(fun, new_target, expected_reg, actual_parameter_count,
+                     flag);
+}
+
+void MacroAssembler::InvokeFunction(Register function,
+                                    Register expected_parameter_count,
+                                    Register actual_parameter_count,
+                                    InvokeFlag flag) {
+  // You can't call a function without a valid frame.
+  DCHECK_IMPLIES(flag == CALL_FUNCTION, has_frame());
+
+  // Contract with called JS functions requires that function is passed in r4.
+  DCHECK_EQ(function, r4);
+
+  // Get the function and setup the context.
+  LoadTaggedPointerField(cp, FieldMemOperand(r4, JSFunction::kContextOffset));
+
+  InvokeFunctionCode(r4, no_reg, expected_parameter_count,
+                     actual_parameter_count, flag);
+}
+
+void MacroAssembler::MaybeDropFrames() {
+  // Check whether we need to drop frames to restart a function on the stack.
+  ExternalReference restart_fp =
+      ExternalReference::debug_restart_fp_address(isolate());
+  Move(r4, restart_fp);
+  LoadP(r4, MemOperand(r4));
+  cmpi(r4, Operand::Zero());
+  Jump(BUILTIN_CODE(isolate(), FrameDropperTrampoline), RelocInfo::CODE_TARGET,
+       ne);
+}
+
+void MacroAssembler::PushStackHandler() {
+  // Adjust this code if not the case.
+  STATIC_ASSERT(StackHandlerConstants::kSize == 2 * kSystemPointerSize);
+  STATIC_ASSERT(StackHandlerConstants::kNextOffset == 0 * kSystemPointerSize);
+
+  Push(Smi::zero());  // Padding.
+
+  // Link the current handler as the next handler.
+  // Preserve r4-r8.
+  Move(r3,
+       ExternalReference::Create(IsolateAddressId::kHandlerAddress, isolate()));
+  LoadP(r0, MemOperand(r3));
+  push(r0);
+
+  // Set this new handler as the current one.
+  StoreP(sp, MemOperand(r3));
+}
+
+void MacroAssembler::PopStackHandler() {
+  STATIC_ASSERT(StackHandlerConstants::kSize == 2 * kSystemPointerSize);
+  STATIC_ASSERT(StackHandlerConstants::kNextOffset == 0);
+
+  pop(r4);
+  Move(ip,
+       ExternalReference::Create(IsolateAddressId::kHandlerAddress, isolate()));
+  StoreP(r4, MemOperand(ip));
+
+  Drop(1);  // Drop padding.
+}
+
+void MacroAssembler::CompareObjectType(Register object, Register map,
+                                       Register type_reg, InstanceType type) {
+  const Register temp = type_reg == no_reg ? r0 : type_reg;
+
+  LoadMap(map, object);
+  CompareInstanceType(map, temp, type);
+}
+
+void MacroAssembler::CompareInstanceType(Register map, Register type_reg,
+                                         InstanceType type) {
+  STATIC_ASSERT(Map::kInstanceTypeOffset < 4096);
+  STATIC_ASSERT(LAST_TYPE <= 0xFFFF);
+  lhz(type_reg, FieldMemOperand(map, Map::kInstanceTypeOffset));
+  cmpi(type_reg, Operand(type));
+}
+
+void MacroAssembler::CompareRoot(Register obj, RootIndex index) {
+  DCHECK(obj != r0);
+  LoadRoot(r0, index);
+  cmp(obj, r0);
+}
+
+void TurboAssembler::AddAndCheckForOverflow(Register dst, Register left,
+                                            Register right,
+                                            Register overflow_dst,
+                                            Register scratch) {
+  DCHECK(dst != overflow_dst);
+  DCHECK(dst != scratch);
+  DCHECK(overflow_dst != scratch);
+  DCHECK(overflow_dst != left);
+  DCHECK(overflow_dst != right);
+
+  bool left_is_right = left == right;
+  RCBit xorRC = left_is_right ? SetRC : LeaveRC;
+
+  // C = A+B; C overflows if A/B have same sign and C has diff sign than A
+  if (dst == left) {
+    mr(scratch, left);                        // Preserve left.
+    add(dst, left, right);                    // Left is overwritten.
+    xor_(overflow_dst, dst, scratch, xorRC);  // Original left.
+    if (!left_is_right) xor_(scratch, dst, right);
+  } else if (dst == right) {
+    mr(scratch, right);     // Preserve right.
+    add(dst, left, right);  // Right is overwritten.
+    xor_(overflow_dst, dst, left, xorRC);
+    if (!left_is_right) xor_(scratch, dst, scratch);  // Original right.
+  } else {
+    add(dst, left, right);
+    xor_(overflow_dst, dst, left, xorRC);
+    if (!left_is_right) xor_(scratch, dst, right);
+  }
+  if (!left_is_right) and_(overflow_dst, scratch, overflow_dst, SetRC);
+}
+
+void TurboAssembler::AddAndCheckForOverflow(Register dst, Register left,
+                                            intptr_t right,
+                                            Register overflow_dst,
+                                            Register scratch) {
+  Register original_left = left;
+  DCHECK(dst != overflow_dst);
+  DCHECK(dst != scratch);
+  DCHECK(overflow_dst != scratch);
+  DCHECK(overflow_dst != left);
+
+  // C = A+B; C overflows if A/B have same sign and C has diff sign than A
+  if (dst == left) {
+    // Preserve left.
+    original_left = overflow_dst;
+    mr(original_left, left);
+  }
+  Add(dst, left, right, scratch);
+  xor_(overflow_dst, dst, original_left);
+  if (right >= 0) {
+    and_(overflow_dst, overflow_dst, dst, SetRC);
+  } else {
+    andc(overflow_dst, overflow_dst, dst, SetRC);
+  }
+}
+
+void TurboAssembler::SubAndCheckForOverflow(Register dst, Register left,
+                                            Register right,
+                                            Register overflow_dst,
+                                            Register scratch) {
+  DCHECK(dst != overflow_dst);
+  DCHECK(dst != scratch);
+  DCHECK(overflow_dst != scratch);
+  DCHECK(overflow_dst != left);
+  DCHECK(overflow_dst != right);
+
+  // C = A-B; C overflows if A/B have diff signs and C has diff sign than A
+  if (dst == left) {
+    mr(scratch, left);      // Preserve left.
+    sub(dst, left, right);  // Left is overwritten.
+    xor_(overflow_dst, dst, scratch);
+    xor_(scratch, scratch, right);
+    and_(overflow_dst, overflow_dst, scratch, SetRC);
+  } else if (dst == right) {
+    mr(scratch, right);     // Preserve right.
+    sub(dst, left, right);  // Right is overwritten.
+    xor_(overflow_dst, dst, left);
+    xor_(scratch, left, scratch);
+    and_(overflow_dst, overflow_dst, scratch, SetRC);
+  } else {
+    sub(dst, left, right);
+    xor_(overflow_dst, dst, left);
+    xor_(scratch, left, right);
+    and_(overflow_dst, scratch, overflow_dst, SetRC);
+  }
+}
+
+void MacroAssembler::JumpIfIsInRange(Register value, unsigned lower_limit,
+                                     unsigned higher_limit,
+                                     Label* on_in_range) {
+  Register scratch = r0;
+  if (lower_limit != 0) {
+    mov(scratch, Operand(lower_limit));
+    sub(scratch, value, scratch);
+    cmpli(scratch, Operand(higher_limit - lower_limit));
+  } else {
+    mov(scratch, Operand(higher_limit));
+    cmpl(value, scratch);
+  }
+  ble(on_in_range);
+}
+
+void TurboAssembler::TruncateDoubleToI(Isolate* isolate, Zone* zone,
+                                       Register result,
+                                       DoubleRegister double_input,
+                                       StubCallMode stub_mode) {
+  Label done;
+
+  TryInlineTruncateDoubleToI(result, double_input, &done);
+
+  // If we fell through then inline version didn't succeed - call stub instead.
+  mflr(r0);
+  push(r0);
+  // Put input on stack.
+  stfdu(double_input, MemOperand(sp, -kDoubleSize));
+
+  if (stub_mode == StubCallMode::kCallWasmRuntimeStub) {
+    Call(wasm::WasmCode::kDoubleToI, RelocInfo::WASM_STUB_CALL);
+  } else {
+    Call(BUILTIN_CODE(isolate, DoubleToI), RelocInfo::CODE_TARGET);
+  }
+
+  LoadP(result, MemOperand(sp));
+  addi(sp, sp, Operand(kDoubleSize));
+  pop(r0);
+  mtlr(r0);
+
+  bind(&done);
+}
+
+void TurboAssembler::TryInlineTruncateDoubleToI(Register result,
+                                                DoubleRegister double_input,
+                                                Label* done) {
+  DoubleRegister double_scratch = kScratchDoubleReg;
+#if !V8_TARGET_ARCH_PPC64
+  Register scratch = ip;
+#endif
+
+  ConvertDoubleToInt64(double_input,
+#if !V8_TARGET_ARCH_PPC64
+                       scratch,
+#endif
+                       result, double_scratch);
+
+// Test for overflow
+#if V8_TARGET_ARCH_PPC64
+  TestIfInt32(result, r0);
+#else
+  TestIfInt32(scratch, result, r0);
+#endif
+  beq(done);
+}
+
+void MacroAssembler::CallRuntime(const Runtime::Function* f, int num_arguments,
+                                 SaveFPRegsMode save_doubles) {
+  // All parameters are on the stack.  r3 has the return value after call.
+
+  // If the expected number of arguments of the runtime function is
+  // constant, we check that the actual number of arguments match the
+  // expectation.
+  CHECK(f->nargs < 0 || f->nargs == num_arguments);
+
+  // TODO(1236192): Most runtime routines don't need the number of
+  // arguments passed in because it is constant. At some point we
+  // should remove this need and make the runtime routine entry code
+  // smarter.
+  mov(r3, Operand(num_arguments));
+  Move(r4, ExternalReference::Create(f));
+#if V8_TARGET_ARCH_PPC64
+  Handle<Code> code =
+      CodeFactory::CEntry(isolate(), f->result_size, save_doubles);
+#else
+  Handle<Code> code = CodeFactory::CEntry(isolate(), 1, save_doubles);
+#endif
+  Call(code, RelocInfo::CODE_TARGET);
+}
+
+void MacroAssembler::TailCallRuntime(Runtime::FunctionId fid) {
+  const Runtime::Function* function = Runtime::FunctionForId(fid);
+  DCHECK_EQ(1, function->result_size);
+  if (function->nargs >= 0) {
+    mov(r3, Operand(function->nargs));
+  }
+  JumpToExternalReference(ExternalReference::Create(fid));
+}
+
+void MacroAssembler::JumpToExternalReference(const ExternalReference& builtin,
+                                             bool builtin_exit_frame) {
+  Move(r4, builtin);
+  Handle<Code> code = CodeFactory::CEntry(isolate(), 1, kDontSaveFPRegs,
+                                          kArgvOnStack, builtin_exit_frame);
+  Jump(code, RelocInfo::CODE_TARGET);
+}
+
+void MacroAssembler::JumpToInstructionStream(Address entry) {
+  mov(kOffHeapTrampolineRegister, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
+  Jump(kOffHeapTrampolineRegister);
+}
+
+void MacroAssembler::LoadWeakValue(Register out, Register in,
+                                   Label* target_if_cleared) {
+  cmpwi(in, Operand(kClearedWeakHeapObjectLower32));
+  beq(target_if_cleared);
+
+  mov(r0, Operand(~kWeakHeapObjectMask));
+  and_(out, in, r0);
+}
+
+void MacroAssembler::IncrementCounter(StatsCounter* counter, int value,
+                                      Register scratch1, Register scratch2) {
+  DCHECK_GT(value, 0);
+  if (FLAG_native_code_counters && counter->Enabled()) {
+    // This operation has to be exactly 32-bit wide in case the external
+    // reference table redirects the counter to a uint32_t dummy_stats_counter_
+    // field.
+    Move(scratch2, ExternalReference::Create(counter));
+    lwz(scratch1, MemOperand(scratch2));
+    addi(scratch1, scratch1, Operand(value));
+    stw(scratch1, MemOperand(scratch2));
+  }
+}
+
+void MacroAssembler::DecrementCounter(StatsCounter* counter, int value,
+                                      Register scratch1, Register scratch2) {
+  DCHECK_GT(value, 0);
+  if (FLAG_native_code_counters && counter->Enabled()) {
+    // This operation has to be exactly 32-bit wide in case the external
+    // reference table redirects the counter to a uint32_t dummy_stats_counter_
+    // field.
+    Move(scratch2, ExternalReference::Create(counter));
+    lwz(scratch1, MemOperand(scratch2));
+    subi(scratch1, scratch1, Operand(value));
+    stw(scratch1, MemOperand(scratch2));
+  }
+}
+
+void TurboAssembler::Assert(Condition cond, AbortReason reason, CRegister cr) {
+  if (emit_debug_code()) Check(cond, reason, cr);
+}
+
+void TurboAssembler::Check(Condition cond, AbortReason reason, CRegister cr) {
+  Label L;
+  b(cond, &L, cr);
+  Abort(reason);
+  // will not return here
+  bind(&L);
+}
+
+void TurboAssembler::Abort(AbortReason reason) {
+  Label abort_start;
+  bind(&abort_start);
+#ifdef DEBUG
+  const char* msg = GetAbortReason(reason);
+  RecordComment("Abort message: ");
+  RecordComment(msg);
+#endif
+
+  // Avoid emitting call to builtin if requested.
+  if (trap_on_abort()) {
+    stop();
+    return;
+  }
+
+  if (should_abort_hard()) {
+    // We don't care if we constructed a frame. Just pretend we did.
+    FrameScope assume_frame(this, StackFrame::NONE);
+    mov(r3, Operand(static_cast<int>(reason)));
+    PrepareCallCFunction(1, r4);
+    CallCFunction(ExternalReference::abort_with_reason(), 1);
+    return;
+  }
+
+  LoadSmiLiteral(r4, Smi::FromInt(static_cast<int>(reason)));
+
+  // Disable stub call restrictions to always allow calls to abort.
+  if (!has_frame_) {
+    // We don't actually want to generate a pile of code for this, so just
+    // claim there is a stack frame, without generating one.
+    FrameScope scope(this, StackFrame::NONE);
+    Call(BUILTIN_CODE(isolate(), Abort), RelocInfo::CODE_TARGET);
+  } else {
+    Call(BUILTIN_CODE(isolate(), Abort), RelocInfo::CODE_TARGET);
+  }
+  // will not return here
+}
+
+void MacroAssembler::LoadMap(Register destination, Register object) {
+  LoadTaggedPointerField(destination,
+                         FieldMemOperand(object, HeapObject::kMapOffset));
+}
+
+void MacroAssembler::LoadNativeContextSlot(int index, Register dst) {
+  LoadMap(dst, cp);
+  LoadTaggedPointerField(
+      dst, FieldMemOperand(
+               dst, Map::kConstructorOrBackPointerOrNativeContextOffset));
+  LoadTaggedPointerField(dst, MemOperand(dst, Context::SlotOffset(index)));
+}
+
+void MacroAssembler::AssertNotSmi(Register object) {
+  if (emit_debug_code()) {
+    STATIC_ASSERT(kSmiTag == 0);
+    TestIfSmi(object, r0);
+    Check(ne, AbortReason::kOperandIsASmi, cr0);
+  }
+}
+
+void MacroAssembler::AssertSmi(Register object) {
+  if (emit_debug_code()) {
+    STATIC_ASSERT(kSmiTag == 0);
+    TestIfSmi(object, r0);
+    Check(eq, AbortReason::kOperandIsNotASmi, cr0);
+  }
+}
+
+void MacroAssembler::AssertConstructor(Register object) {
+  if (emit_debug_code()) {
+    STATIC_ASSERT(kSmiTag == 0);
+    TestIfSmi(object, r0);
+    Check(ne, AbortReason::kOperandIsASmiAndNotAConstructor, cr0);
+    push(object);
+    LoadMap(object, object);
+    lbz(object, FieldMemOperand(object, Map::kBitFieldOffset));
+    andi(object, object, Operand(Map::Bits1::IsConstructorBit::kMask));
+    pop(object);
+    Check(ne, AbortReason::kOperandIsNotAConstructor, cr0);
+  }
+}
+
+void MacroAssembler::AssertFunction(Register object) {
+  if (emit_debug_code()) {
+    STATIC_ASSERT(kSmiTag == 0);
+    TestIfSmi(object, r0);
+    Check(ne, AbortReason::kOperandIsASmiAndNotAFunction, cr0);
+    push(object);
+    CompareObjectType(object, object, object, JS_FUNCTION_TYPE);
+    pop(object);
+    Check(eq, AbortReason::kOperandIsNotAFunction);
+  }
+}
+
+void MacroAssembler::AssertBoundFunction(Register object) {
+  if (emit_debug_code()) {
+    STATIC_ASSERT(kSmiTag == 0);
+    TestIfSmi(object, r0);
+    Check(ne, AbortReason::kOperandIsASmiAndNotABoundFunction, cr0);
+    push(object);
+    CompareObjectType(object, object, object, JS_BOUND_FUNCTION_TYPE);
+    pop(object);
+    Check(eq, AbortReason::kOperandIsNotABoundFunction);
+  }
+}
+
+void MacroAssembler::AssertGeneratorObject(Register object) {
+  if (!emit_debug_code()) return;
+  TestIfSmi(object, r0);
+  Check(ne, AbortReason::kOperandIsASmiAndNotAGeneratorObject, cr0);
+
+  // Load map
+  Register map = object;
+  push(object);
+  LoadMap(map, object);
+
+  // Check if JSGeneratorObject
+  Label do_check;
+  Register instance_type = object;
+  CompareInstanceType(map, instance_type, JS_GENERATOR_OBJECT_TYPE);
+  beq(&do_check);
+
+  // Check if JSAsyncFunctionObject (See MacroAssembler::CompareInstanceType)
+  cmpi(instance_type, Operand(JS_ASYNC_FUNCTION_OBJECT_TYPE));
+  beq(&do_check);
+
+  // Check if JSAsyncGeneratorObject (See MacroAssembler::CompareInstanceType)
+  cmpi(instance_type, Operand(JS_ASYNC_GENERATOR_OBJECT_TYPE));
+
+  bind(&do_check);
+  // Restore generator object to register and perform assertion
+  pop(object);
+  Check(eq, AbortReason::kOperandIsNotAGeneratorObject);
+}
+
+void MacroAssembler::AssertUndefinedOrAllocationSite(Register object,
+                                                     Register scratch) {
+  if (emit_debug_code()) {
+    Label done_checking;
+    AssertNotSmi(object);
+    CompareRoot(object, RootIndex::kUndefinedValue);
+    beq(&done_checking);
+    LoadMap(scratch, object);
+    CompareInstanceType(scratch, scratch, ALLOCATION_SITE_TYPE);
+    Assert(eq, AbortReason::kExpectedUndefinedOrCell);
+    bind(&done_checking);
+  }
+}
+
+static const int kRegisterPassedArguments = 8;
+
+int TurboAssembler::CalculateStackPassedWords(int num_reg_arguments,
+                                              int num_double_arguments) {
+  int stack_passed_words = 0;
+  if (num_double_arguments > DoubleRegister::kNumRegisters) {
+    stack_passed_words +=
+        2 * (num_double_arguments - DoubleRegister::kNumRegisters);
+  }
+  // Up to 8 simple arguments are passed in registers r3..r10.
+  if (num_reg_arguments > kRegisterPassedArguments) {
+    stack_passed_words += num_reg_arguments - kRegisterPassedArguments;
+  }
+  return stack_passed_words;
+}
+
+void TurboAssembler::PrepareCallCFunction(int num_reg_arguments,
+                                          int num_double_arguments,
+                                          Register scratch) {
+  int frame_alignment = ActivationFrameAlignment();
+  int stack_passed_arguments =
+      CalculateStackPassedWords(num_reg_arguments, num_double_arguments);
+  int stack_space = kNumRequiredStackFrameSlots;
+
+  if (frame_alignment > kSystemPointerSize) {
+    // Make stack end at alignment and make room for stack arguments
+    // -- preserving original value of sp.
+    mr(scratch, sp);
+    addi(sp, sp, Operand(-(stack_passed_arguments + 1) * kSystemPointerSize));
+    DCHECK(base::bits::IsPowerOfTwo(frame_alignment));
+    ClearRightImm(sp, sp,
+                  Operand(base::bits::WhichPowerOfTwo(frame_alignment)));
+    StoreP(scratch,
+           MemOperand(sp, stack_passed_arguments * kSystemPointerSize));
+  } else {
+    // Make room for stack arguments
+    stack_space += stack_passed_arguments;
+  }
+
+  // Allocate frame with required slots to make ABI work.
+  li(r0, Operand::Zero());
+  StorePU(r0, MemOperand(sp, -stack_space * kSystemPointerSize));
+}
+
+void TurboAssembler::PrepareCallCFunction(int num_reg_arguments,
+                                          Register scratch) {
+  PrepareCallCFunction(num_reg_arguments, 0, scratch);
+}
+
+void TurboAssembler::MovToFloatParameter(DoubleRegister src) { Move(d1, src); }
+
+void TurboAssembler::MovToFloatResult(DoubleRegister src) { Move(d1, src); }
+
+void TurboAssembler::MovToFloatParameters(DoubleRegister src1,
+                                          DoubleRegister src2) {
+  if (src2 == d1) {
+    DCHECK(src1 != d2);
+    Move(d2, src2);
+    Move(d1, src1);
+  } else {
+    Move(d1, src1);
+    Move(d2, src2);
+  }
+}
+
+void TurboAssembler::CallCFunction(ExternalReference function,
+                                   int num_reg_arguments,
+                                   int num_double_arguments,
+                                   bool has_function_descriptor) {
+  Move(ip, function);
+  CallCFunctionHelper(ip, num_reg_arguments, num_double_arguments,
+                      has_function_descriptor);
+}
+
+void TurboAssembler::CallCFunction(Register function, int num_reg_arguments,
+                                   int num_double_arguments,
+                                   bool has_function_descriptor) {
+  CallCFunctionHelper(function, num_reg_arguments, num_double_arguments,
+                      has_function_descriptor);
+}
+
+void TurboAssembler::CallCFunction(ExternalReference function,
+                                   int num_arguments,
+                                   bool has_function_descriptor) {
+  CallCFunction(function, num_arguments, 0, has_function_descriptor);
+}
+
+void TurboAssembler::CallCFunction(Register function, int num_arguments,
+                                   bool has_function_descriptor) {
+  CallCFunction(function, num_arguments, 0, has_function_descriptor);
+}
+
+void TurboAssembler::CallCFunctionHelper(Register function,
+                                         int num_reg_arguments,
+                                         int num_double_arguments,
+                                         bool has_function_descriptor) {
+  DCHECK_LE(num_reg_arguments + num_double_arguments, kMaxCParameters);
+  DCHECK(has_frame());
+
+  // Save the frame pointer and PC so that the stack layout remains iterable,
+  // even without an ExitFrame which normally exists between JS and C frames.
+  Register addr_scratch = r7;
+  Register scratch = r8;
+  Push(scratch);
+  mflr(scratch);
+  // See x64 code for reasoning about how to address the isolate data fields.
+  if (root_array_available()) {
+    LoadPC(r0);
+    StoreP(r0, MemOperand(kRootRegister,
+                          IsolateData::fast_c_call_caller_pc_offset()));
+    StoreP(fp, MemOperand(kRootRegister,
+                          IsolateData::fast_c_call_caller_fp_offset()));
+  } else {
+    DCHECK_NOT_NULL(isolate());
+    Push(addr_scratch);
+
+    Move(addr_scratch,
+         ExternalReference::fast_c_call_caller_pc_address(isolate()));
+    LoadPC(r0);
+    StoreP(r0, MemOperand(addr_scratch));
+    Move(addr_scratch,
+         ExternalReference::fast_c_call_caller_fp_address(isolate()));
+    StoreP(fp, MemOperand(addr_scratch));
+    Pop(addr_scratch);
+  }
+  mtlr(scratch);
+  Pop(scratch);
+
+  // Just call directly. The function called cannot cause a GC, or
+  // allow preemption, so the return address in the link register
+  // stays correct.
+  Register dest = function;
+  if (ABI_USES_FUNCTION_DESCRIPTORS && has_function_descriptor) {
+    // AIX/PPC64BE Linux uses a function descriptor. When calling C code be
+    // aware of this descriptor and pick up values from it
+    LoadP(ToRegister(ABI_TOC_REGISTER),
+          MemOperand(function, kSystemPointerSize));
+    LoadP(ip, MemOperand(function, 0));
+    dest = ip;
+  } else if (ABI_CALL_VIA_IP) {
+    // pLinux and Simualtor, not AIX
+    Move(ip, function);
+    dest = ip;
+  }
+
+  Call(dest);
+
+  // We don't unset the PC; the FP is the source of truth.
+  Register zero_scratch = r0;
+  mov(zero_scratch, Operand::Zero());
+
+  if (root_array_available()) {
+    StoreP(
+        zero_scratch,
+        MemOperand(kRootRegister, IsolateData::fast_c_call_caller_fp_offset()));
+  } else {
+    DCHECK_NOT_NULL(isolate());
+    Push(addr_scratch);
+    Move(addr_scratch,
+         ExternalReference::fast_c_call_caller_fp_address(isolate()));
+    StoreP(zero_scratch, MemOperand(addr_scratch));
+    Pop(addr_scratch);
+  }
+
+  // Remove frame bought in PrepareCallCFunction
+  int stack_passed_arguments =
+      CalculateStackPassedWords(num_reg_arguments, num_double_arguments);
+  int stack_space = kNumRequiredStackFrameSlots + stack_passed_arguments;
+  if (ActivationFrameAlignment() > kSystemPointerSize) {
+    LoadP(sp, MemOperand(sp, stack_space * kSystemPointerSize));
+  } else {
+    addi(sp, sp, Operand(stack_space * kSystemPointerSize));
+  }
+}
+
+void TurboAssembler::CheckPageFlag(
+    Register object,
+    Register scratch,  // scratch may be same register as object
+    int mask, Condition cc, Label* condition_met) {
+  DCHECK(cc == ne || cc == eq);
+  ClearRightImm(scratch, object, Operand(kPageSizeBits));
+  LoadP(scratch, MemOperand(scratch, BasicMemoryChunk::kFlagsOffset));
+
+  mov(r0, Operand(mask));
+  and_(r0, scratch, r0, SetRC);
+
+  if (cc == ne) {
+    bne(condition_met, cr0);
+  }
+  if (cc == eq) {
+    beq(condition_met, cr0);
+  }
+}
+
+void TurboAssembler::SetRoundingMode(FPRoundingMode RN) { mtfsfi(7, RN); }
+
+void TurboAssembler::ResetRoundingMode() {
+  mtfsfi(7, kRoundToNearest);  // reset (default is kRoundToNearest)
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//
+// New MacroAssembler Interfaces added for PPC
+//
+////////////////////////////////////////////////////////////////////////////////
+void TurboAssembler::LoadIntLiteral(Register dst, int value) {
+  mov(dst, Operand(value));
+}
+
+void TurboAssembler::LoadSmiLiteral(Register dst, Smi smi) {
+  mov(dst, Operand(smi));
+}
+
+void TurboAssembler::LoadDoubleLiteral(DoubleRegister result, Double value,
+                                       Register scratch) {
+  if (FLAG_enable_embedded_constant_pool && is_constant_pool_available() &&
+      !(scratch == r0 && ConstantPoolAccessIsInOverflow())) {
+    ConstantPoolEntry::Access access = ConstantPoolAddEntry(value);
+    if (access == ConstantPoolEntry::OVERFLOWED) {
+      addis(scratch, kConstantPoolRegister, Operand::Zero());
+      lfd(result, MemOperand(scratch, 0));
+    } else {
+      lfd(result, MemOperand(kConstantPoolRegister, 0));
+    }
+    return;
+  }
+
+  // avoid gcc strict aliasing error using union cast
+  union {
+    uint64_t dval;
+#if V8_TARGET_ARCH_PPC64
+    intptr_t ival;
+#else
+    intptr_t ival[2];
+#endif
+  } litVal;
+
+  litVal.dval = value.AsUint64();
+
+#if V8_TARGET_ARCH_PPC64
+  if (CpuFeatures::IsSupported(FPR_GPR_MOV)) {
+    mov(scratch, Operand(litVal.ival));
+    mtfprd(result, scratch);
+    return;
+  }
+#endif
+
+  addi(sp, sp, Operand(-kDoubleSize));
+#if V8_TARGET_ARCH_PPC64
+  mov(scratch, Operand(litVal.ival));
+  std(scratch, MemOperand(sp));
+#else
+  LoadIntLiteral(scratch, litVal.ival[0]);
+  stw(scratch, MemOperand(sp, 0));
+  LoadIntLiteral(scratch, litVal.ival[1]);
+  stw(scratch, MemOperand(sp, 4));
+#endif
+  nop(GROUP_ENDING_NOP);  // LHS/RAW optimization
+  lfd(result, MemOperand(sp, 0));
+  addi(sp, sp, Operand(kDoubleSize));
+}
+
+void TurboAssembler::MovIntToDouble(DoubleRegister dst, Register src,
+                                    Register scratch) {
+// sign-extend src to 64-bit
+#if V8_TARGET_ARCH_PPC64
+  if (CpuFeatures::IsSupported(FPR_GPR_MOV)) {
+    mtfprwa(dst, src);
+    return;
+  }
+#endif
+
+  DCHECK(src != scratch);
+  subi(sp, sp, Operand(kDoubleSize));
+#if V8_TARGET_ARCH_PPC64
+  extsw(scratch, src);
+  std(scratch, MemOperand(sp, 0));
+#else
+  srawi(scratch, src, 31);
+  stw(scratch, MemOperand(sp, Register::kExponentOffset));
+  stw(src, MemOperand(sp, Register::kMantissaOffset));
+#endif
+  nop(GROUP_ENDING_NOP);  // LHS/RAW optimization
+  lfd(dst, MemOperand(sp, 0));
+  addi(sp, sp, Operand(kDoubleSize));
+}
+
+void TurboAssembler::MovUnsignedIntToDouble(DoubleRegister dst, Register src,
+                                            Register scratch) {
+// zero-extend src to 64-bit
+#if V8_TARGET_ARCH_PPC64
+  if (CpuFeatures::IsSupported(FPR_GPR_MOV)) {
+    mtfprwz(dst, src);
+    return;
+  }
+#endif
+
+  DCHECK(src != scratch);
+  subi(sp, sp, Operand(kDoubleSize));
+#if V8_TARGET_ARCH_PPC64
+  clrldi(scratch, src, Operand(32));
+  std(scratch, MemOperand(sp, 0));
+#else
+  li(scratch, Operand::Zero());
+  stw(scratch, MemOperand(sp, Register::kExponentOffset));
+  stw(src, MemOperand(sp, Register::kMantissaOffset));
+#endif
+  nop(GROUP_ENDING_NOP);  // LHS/RAW optimization
+  lfd(dst, MemOperand(sp, 0));
+  addi(sp, sp, Operand(kDoubleSize));
+}
+
+void TurboAssembler::MovInt64ToDouble(DoubleRegister dst,
+#if !V8_TARGET_ARCH_PPC64
+                                      Register src_hi,
+#endif
+                                      Register src) {
+#if V8_TARGET_ARCH_PPC64
+  if (CpuFeatures::IsSupported(FPR_GPR_MOV)) {
+    mtfprd(dst, src);
+    return;
+  }
+#endif
+
+  subi(sp, sp, Operand(kDoubleSize));
+#if V8_TARGET_ARCH_PPC64
+  std(src, MemOperand(sp, 0));
+#else
+  stw(src_hi, MemOperand(sp, Register::kExponentOffset));
+  stw(src, MemOperand(sp, Register::kMantissaOffset));
+#endif
+  nop(GROUP_ENDING_NOP);  // LHS/RAW optimization
+  lfd(dst, MemOperand(sp, 0));
+  addi(sp, sp, Operand(kDoubleSize));
+}
+
+#if V8_TARGET_ARCH_PPC64
+void TurboAssembler::MovInt64ComponentsToDouble(DoubleRegister dst,
+                                                Register src_hi,
+                                                Register src_lo,
+                                                Register scratch) {
+  if (CpuFeatures::IsSupported(FPR_GPR_MOV)) {
+    sldi(scratch, src_hi, Operand(32));
+    rldimi(scratch, src_lo, 0, 32);
+    mtfprd(dst, scratch);
+    return;
+  }
+
+  subi(sp, sp, Operand(kDoubleSize));
+  stw(src_hi, MemOperand(sp, Register::kExponentOffset));
+  stw(src_lo, MemOperand(sp, Register::kMantissaOffset));
+  nop(GROUP_ENDING_NOP);  // LHS/RAW optimization
+  lfd(dst, MemOperand(sp));
+  addi(sp, sp, Operand(kDoubleSize));
+}
+#endif
+
+void TurboAssembler::InsertDoubleLow(DoubleRegister dst, Register src,
+                                     Register scratch) {
+#if V8_TARGET_ARCH_PPC64
+  if (CpuFeatures::IsSupported(FPR_GPR_MOV)) {
+    mffprd(scratch, dst);
+    rldimi(scratch, src, 0, 32);
+    mtfprd(dst, scratch);
+    return;
+  }
+#endif
+
+  subi(sp, sp, Operand(kDoubleSize));
+  stfd(dst, MemOperand(sp));
+  stw(src, MemOperand(sp, Register::kMantissaOffset));
+  nop(GROUP_ENDING_NOP);  // LHS/RAW optimization
+  lfd(dst, MemOperand(sp));
+  addi(sp, sp, Operand(kDoubleSize));
+}
+
+void TurboAssembler::InsertDoubleHigh(DoubleRegister dst, Register src,
+                                      Register scratch) {
+#if V8_TARGET_ARCH_PPC64
+  if (CpuFeatures::IsSupported(FPR_GPR_MOV)) {
+    mffprd(scratch, dst);
+    rldimi(scratch, src, 32, 0);
+    mtfprd(dst, scratch);
+    return;
+  }
+#endif
+
+  subi(sp, sp, Operand(kDoubleSize));
+  stfd(dst, MemOperand(sp));
+  stw(src, MemOperand(sp, Register::kExponentOffset));
+  nop(GROUP_ENDING_NOP);  // LHS/RAW optimization
+  lfd(dst, MemOperand(sp));
+  addi(sp, sp, Operand(kDoubleSize));
+}
+
+void TurboAssembler::MovDoubleLowToInt(Register dst, DoubleRegister src) {
+#if V8_TARGET_ARCH_PPC64
+  if (CpuFeatures::IsSupported(FPR_GPR_MOV)) {
+    mffprwz(dst, src);
+    return;
+  }
+#endif
+
+  subi(sp, sp, Operand(kDoubleSize));
+  stfd(src, MemOperand(sp));
+  nop(GROUP_ENDING_NOP);  // LHS/RAW optimization
+  lwz(dst, MemOperand(sp, Register::kMantissaOffset));
+  addi(sp, sp, Operand(kDoubleSize));
+}
+
+void TurboAssembler::MovDoubleHighToInt(Register dst, DoubleRegister src) {
+#if V8_TARGET_ARCH_PPC64
+  if (CpuFeatures::IsSupported(FPR_GPR_MOV)) {
+    mffprd(dst, src);
+    srdi(dst, dst, Operand(32));
+    return;
+  }
+#endif
+
+  subi(sp, sp, Operand(kDoubleSize));
+  stfd(src, MemOperand(sp));
+  nop(GROUP_ENDING_NOP);  // LHS/RAW optimization
+  lwz(dst, MemOperand(sp, Register::kExponentOffset));
+  addi(sp, sp, Operand(kDoubleSize));
+}
+
+void TurboAssembler::MovDoubleToInt64(
+#if !V8_TARGET_ARCH_PPC64
+    Register dst_hi,
+#endif
+    Register dst, DoubleRegister src) {
+#if V8_TARGET_ARCH_PPC64
+  if (CpuFeatures::IsSupported(FPR_GPR_MOV)) {
+    mffprd(dst, src);
+    return;
+  }
+#endif
+
+  subi(sp, sp, Operand(kDoubleSize));
+  stfd(src, MemOperand(sp));
+  nop(GROUP_ENDING_NOP);  // LHS/RAW optimization
+#if V8_TARGET_ARCH_PPC64
+  ld(dst, MemOperand(sp, 0));
+#else
+  lwz(dst_hi, MemOperand(sp, Register::kExponentOffset));
+  lwz(dst, MemOperand(sp, Register::kMantissaOffset));
+#endif
+  addi(sp, sp, Operand(kDoubleSize));
+}
+
+void TurboAssembler::MovIntToFloat(DoubleRegister dst, Register src) {
+  subi(sp, sp, Operand(kFloatSize));
+  stw(src, MemOperand(sp, 0));
+  nop(GROUP_ENDING_NOP);  // LHS/RAW optimization
+  lfs(dst, MemOperand(sp, 0));
+  addi(sp, sp, Operand(kFloatSize));
+}
+
+void TurboAssembler::MovFloatToInt(Register dst, DoubleRegister src) {
+  subi(sp, sp, Operand(kFloatSize));
+  stfs(src, MemOperand(sp, 0));
+  nop(GROUP_ENDING_NOP);  // LHS/RAW optimization
+  lwz(dst, MemOperand(sp, 0));
+  addi(sp, sp, Operand(kFloatSize));
+}
+
+void TurboAssembler::Add(Register dst, Register src, intptr_t value,
+                         Register scratch) {
+  if (is_int16(value)) {
+    addi(dst, src, Operand(value));
+  } else {
+    mov(scratch, Operand(value));
+    add(dst, src, scratch);
+  }
+}
+
+void TurboAssembler::Cmpi(Register src1, const Operand& src2, Register scratch,
+                          CRegister cr) {
+  intptr_t value = src2.immediate();
+  if (is_int16(value)) {
+    cmpi(src1, src2, cr);
+  } else {
+    mov(scratch, src2);
+    cmp(src1, scratch, cr);
+  }
+}
+
+void TurboAssembler::Cmpli(Register src1, const Operand& src2, Register scratch,
+                           CRegister cr) {
+  intptr_t value = src2.immediate();
+  if (is_uint16(value)) {
+    cmpli(src1, src2, cr);
+  } else {
+    mov(scratch, src2);
+    cmpl(src1, scratch, cr);
+  }
+}
+
+void TurboAssembler::Cmpwi(Register src1, const Operand& src2, Register scratch,
+                           CRegister cr) {
+  intptr_t value = src2.immediate();
+  if (is_int16(value)) {
+    cmpwi(src1, src2, cr);
+  } else {
+    mov(scratch, src2);
+    cmpw(src1, scratch, cr);
+  }
+}
+
+void MacroAssembler::Cmplwi(Register src1, const Operand& src2,
+                            Register scratch, CRegister cr) {
+  intptr_t value = src2.immediate();
+  if (is_uint16(value)) {
+    cmplwi(src1, src2, cr);
+  } else {
+    mov(scratch, src2);
+    cmplw(src1, scratch, cr);
+  }
+}
+
+void MacroAssembler::And(Register ra, Register rs, const Operand& rb,
+                         RCBit rc) {
+  if (rb.is_reg()) {
+    and_(ra, rs, rb.rm(), rc);
+  } else {
+    if (is_uint16(rb.immediate()) && RelocInfo::IsNone(rb.rmode_) &&
+        rc == SetRC) {
+      andi(ra, rs, rb);
+    } else {
+      // mov handles the relocation.
+      DCHECK(rs != r0);
+      mov(r0, rb);
+      and_(ra, rs, r0, rc);
+    }
+  }
+}
+
+void MacroAssembler::Or(Register ra, Register rs, const Operand& rb, RCBit rc) {
+  if (rb.is_reg()) {
+    orx(ra, rs, rb.rm(), rc);
+  } else {
+    if (is_uint16(rb.immediate()) && RelocInfo::IsNone(rb.rmode_) &&
+        rc == LeaveRC) {
+      ori(ra, rs, rb);
+    } else {
+      // mov handles the relocation.
+      DCHECK(rs != r0);
+      mov(r0, rb);
+      orx(ra, rs, r0, rc);
+    }
+  }
+}
+
+void MacroAssembler::Xor(Register ra, Register rs, const Operand& rb,
+                         RCBit rc) {
+  if (rb.is_reg()) {
+    xor_(ra, rs, rb.rm(), rc);
+  } else {
+    if (is_uint16(rb.immediate()) && RelocInfo::IsNone(rb.rmode_) &&
+        rc == LeaveRC) {
+      xori(ra, rs, rb);
+    } else {
+      // mov handles the relocation.
+      DCHECK(rs != r0);
+      mov(r0, rb);
+      xor_(ra, rs, r0, rc);
+    }
+  }
+}
+
+void MacroAssembler::CmpSmiLiteral(Register src1, Smi smi, Register scratch,
+                                   CRegister cr) {
+#if defined(V8_COMPRESS_POINTERS) || defined(V8_31BIT_SMIS_ON_64BIT_ARCH)
+  Cmpwi(src1, Operand(smi), scratch, cr);
+#else
+  LoadSmiLiteral(scratch, smi);
+  cmp(src1, scratch, cr);
+#endif
+}
+
+void MacroAssembler::CmplSmiLiteral(Register src1, Smi smi, Register scratch,
+                                    CRegister cr) {
+#if defined(V8_COMPRESS_POINTERS) || defined(V8_31BIT_SMIS_ON_64BIT_ARCH)
+  Cmpli(src1, Operand(smi), scratch, cr);
+#else
+  LoadSmiLiteral(scratch, smi);
+  cmpl(src1, scratch, cr);
+#endif
+}
+
+void MacroAssembler::AddSmiLiteral(Register dst, Register src, Smi smi,
+                                   Register scratch) {
+#if defined(V8_COMPRESS_POINTERS) || defined(V8_31BIT_SMIS_ON_64BIT_ARCH)
+  Add(dst, src, static_cast<intptr_t>(smi.ptr()), scratch);
+#else
+  LoadSmiLiteral(scratch, smi);
+  add(dst, src, scratch);
+#endif
+}
+
+void MacroAssembler::SubSmiLiteral(Register dst, Register src, Smi smi,
+                                   Register scratch) {
+#if defined(V8_COMPRESS_POINTERS) || defined(V8_31BIT_SMIS_ON_64BIT_ARCH)
+  Add(dst, src, -(static_cast<intptr_t>(smi.ptr())), scratch);
+#else
+  LoadSmiLiteral(scratch, smi);
+  sub(dst, src, scratch);
+#endif
+}
+
+void MacroAssembler::AndSmiLiteral(Register dst, Register src, Smi smi,
+                                   Register scratch, RCBit rc) {
+#if defined(V8_COMPRESS_POINTERS) || defined(V8_31BIT_SMIS_ON_64BIT_ARCH)
+  And(dst, src, Operand(smi), rc);
+#else
+  LoadSmiLiteral(scratch, smi);
+  and_(dst, src, scratch, rc);
+#endif
+}
+
+// Load a "pointer" sized value from the memory location
+void TurboAssembler::LoadP(Register dst, const MemOperand& mem,
+                           Register scratch) {
+  DCHECK_EQ(mem.rb(), no_reg);
+  int offset = mem.offset();
+  int misaligned = (offset & 3);
+  int adj = (offset & 3) - 4;
+  int alignedOffset = (offset & ~3) + 4;
+
+  if (!is_int16(offset) || (misaligned && !is_int16(alignedOffset))) {
+    /* cannot use d-form */
+    mov(scratch, Operand(offset));
+    LoadPX(dst, MemOperand(mem.ra(), scratch));
+  } else {
+    if (misaligned) {
+      // adjust base to conform to offset alignment requirements
+      // Todo: enhance to use scratch if dst is unsuitable
+      DCHECK_NE(dst, r0);
+      addi(dst, mem.ra(), Operand(adj));
+      ld(dst, MemOperand(dst, alignedOffset));
+    } else {
+      ld(dst, mem);
+    }
+  }
+}
+
+void TurboAssembler::LoadPU(Register dst, const MemOperand& mem,
+                            Register scratch) {
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    /* cannot use d-form */
+    DCHECK(scratch != no_reg);
+    mov(scratch, Operand(offset));
+    LoadPUX(dst, MemOperand(mem.ra(), scratch));
+  } else {
+#if V8_TARGET_ARCH_PPC64
+    ldu(dst, mem);
+#else
+    lwzu(dst, mem);
+#endif
+  }
+}
+
+// Store a "pointer" sized value to the memory location
+void TurboAssembler::StoreP(Register src, const MemOperand& mem,
+                            Register scratch) {
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    /* cannot use d-form */
+    DCHECK(scratch != no_reg);
+    mov(scratch, Operand(offset));
+    StorePX(src, MemOperand(mem.ra(), scratch));
+  } else {
+#if V8_TARGET_ARCH_PPC64
+    int misaligned = (offset & 3);
+    if (misaligned) {
+      // adjust base to conform to offset alignment requirements
+      // a suitable scratch is required here
+      DCHECK(scratch != no_reg);
+      if (scratch == r0) {
+        LoadIntLiteral(scratch, offset);
+        stdx(src, MemOperand(mem.ra(), scratch));
+      } else {
+        addi(scratch, mem.ra(), Operand((offset & 3) - 4));
+        std(src, MemOperand(scratch, (offset & ~3) + 4));
+      }
+    } else {
+      std(src, mem);
+    }
+#else
+    stw(src, mem);
+#endif
+  }
+}
+
+void TurboAssembler::StorePU(Register src, const MemOperand& mem,
+                             Register scratch) {
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    /* cannot use d-form */
+    DCHECK(scratch != no_reg);
+    mov(scratch, Operand(offset));
+    StorePUX(src, MemOperand(mem.ra(), scratch));
+  } else {
+#if V8_TARGET_ARCH_PPC64
+    stdu(src, mem);
+#else
+    stwu(src, mem);
+#endif
+  }
+}
+
+void TurboAssembler::LoadWordArith(Register dst, const MemOperand& mem,
+                                   Register scratch) {
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    DCHECK(scratch != no_reg);
+    mov(scratch, Operand(offset));
+    lwax(dst, MemOperand(mem.ra(), scratch));
+  } else {
+#if V8_TARGET_ARCH_PPC64
+    int misaligned = (offset & 3);
+    if (misaligned) {
+      // adjust base to conform to offset alignment requirements
+      // Todo: enhance to use scratch if dst is unsuitable
+      DCHECK(dst != r0);
+      addi(dst, mem.ra(), Operand((offset & 3) - 4));
+      lwa(dst, MemOperand(dst, (offset & ~3) + 4));
+    } else {
+      lwa(dst, mem);
+    }
+#else
+    lwz(dst, mem);
+#endif
+  }
+}
+
+// Variable length depending on whether offset fits into immediate field
+// MemOperand currently only supports d-form
+void TurboAssembler::LoadWord(Register dst, const MemOperand& mem,
+                              Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    LoadIntLiteral(scratch, offset);
+    lwzx(dst, MemOperand(base, scratch));
+  } else {
+    lwz(dst, mem);
+  }
+}
+
+// Variable length depending on whether offset fits into immediate field
+// MemOperand current only supports d-form
+void TurboAssembler::StoreWord(Register src, const MemOperand& mem,
+                               Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    LoadIntLiteral(scratch, offset);
+    stwx(src, MemOperand(base, scratch));
+  } else {
+    stw(src, mem);
+  }
+}
+
+void MacroAssembler::LoadHalfWordArith(Register dst, const MemOperand& mem,
+                                       Register scratch) {
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    DCHECK(scratch != no_reg);
+    mov(scratch, Operand(offset));
+    lhax(dst, MemOperand(mem.ra(), scratch));
+  } else {
+    lha(dst, mem);
+  }
+}
+
+// Variable length depending on whether offset fits into immediate field
+// MemOperand currently only supports d-form
+void MacroAssembler::LoadHalfWord(Register dst, const MemOperand& mem,
+                                  Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    DCHECK_NE(scratch, no_reg);
+    LoadIntLiteral(scratch, offset);
+    lhzx(dst, MemOperand(base, scratch));
+  } else {
+    lhz(dst, mem);
+  }
+}
+
+// Variable length depending on whether offset fits into immediate field
+// MemOperand current only supports d-form
+void MacroAssembler::StoreHalfWord(Register src, const MemOperand& mem,
+                                   Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    LoadIntLiteral(scratch, offset);
+    sthx(src, MemOperand(base, scratch));
+  } else {
+    sth(src, mem);
+  }
+}
+
+// Variable length depending on whether offset fits into immediate field
+// MemOperand currently only supports d-form
+void MacroAssembler::LoadByte(Register dst, const MemOperand& mem,
+                              Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    LoadIntLiteral(scratch, offset);
+    lbzx(dst, MemOperand(base, scratch));
+  } else {
+    lbz(dst, mem);
+  }
+}
+
+// Variable length depending on whether offset fits into immediate field
+// MemOperand current only supports d-form
+void MacroAssembler::StoreByte(Register src, const MemOperand& mem,
+                               Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    LoadIntLiteral(scratch, offset);
+    stbx(src, MemOperand(base, scratch));
+  } else {
+    stb(src, mem);
+  }
+}
+
+void TurboAssembler::LoadDouble(DoubleRegister dst, const MemOperand& mem,
+                                Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    mov(scratch, Operand(offset));
+    lfdx(dst, MemOperand(base, scratch));
+  } else {
+    lfd(dst, mem);
+  }
+}
+
+void TurboAssembler::LoadFloat32(DoubleRegister dst, const MemOperand& mem,
+                                 Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    mov(scratch, Operand(offset));
+    lfsx(dst, MemOperand(base, scratch));
+  } else {
+    lfs(dst, mem);
+  }
+}
+
+void MacroAssembler::LoadDoubleU(DoubleRegister dst, const MemOperand& mem,
+                                 Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    mov(scratch, Operand(offset));
+    lfdux(dst, MemOperand(base, scratch));
+  } else {
+    lfdu(dst, mem);
+  }
+}
+
+void TurboAssembler::LoadSingle(DoubleRegister dst, const MemOperand& mem,
+                                Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    mov(scratch, Operand(offset));
+    lfsx(dst, MemOperand(base, scratch));
+  } else {
+    lfs(dst, mem);
+  }
+}
+
+void TurboAssembler::LoadSingleU(DoubleRegister dst, const MemOperand& mem,
+                                 Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    mov(scratch, Operand(offset));
+    lfsux(dst, MemOperand(base, scratch));
+  } else {
+    lfsu(dst, mem);
+  }
+}
+
+void TurboAssembler::LoadSimd128(Simd128Register dst, const MemOperand& mem,
+                                 Register ScratchReg,
+                                 Simd128Register ScratchDoubleReg) {
+  // lvx needs the stack to be 16 byte aligned.
+  // We first use lxvd/stxvd to copy the content on an aligned address. lxvd
+  // itself reverses the lanes so it cannot be used as is.
+  lxvd(ScratchDoubleReg, mem);
+  mr(ScratchReg, sp);
+  ClearRightImm(
+      sp, sp,
+      Operand(base::bits::WhichPowerOfTwo(16)));  // equivalent to &= -16
+  addi(sp, sp, Operand(-16));
+  stxvd(kScratchDoubleReg, MemOperand(r0, sp));
+  // Load it with correct lane ordering.
+  lvx(dst, MemOperand(r0, sp));
+  mr(sp, ScratchReg);
+}
+
+void TurboAssembler::StoreDouble(DoubleRegister src, const MemOperand& mem,
+                                 Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    mov(scratch, Operand(offset));
+    stfdx(src, MemOperand(base, scratch));
+  } else {
+    stfd(src, mem);
+  }
+}
+
+void TurboAssembler::StoreDoubleU(DoubleRegister src, const MemOperand& mem,
+                                  Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    mov(scratch, Operand(offset));
+    stfdux(src, MemOperand(base, scratch));
+  } else {
+    stfdu(src, mem);
+  }
+}
+
+void TurboAssembler::StoreSingle(DoubleRegister src, const MemOperand& mem,
+                                 Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    mov(scratch, Operand(offset));
+    stfsx(src, MemOperand(base, scratch));
+  } else {
+    stfs(src, mem);
+  }
+}
+
+void TurboAssembler::StoreSingleU(DoubleRegister src, const MemOperand& mem,
+                                  Register scratch) {
+  Register base = mem.ra();
+  int offset = mem.offset();
+
+  if (!is_int16(offset)) {
+    mov(scratch, Operand(offset));
+    stfsux(src, MemOperand(base, scratch));
+  } else {
+    stfsu(src, mem);
+  }
+}
+
+void TurboAssembler::StoreSimd128(Simd128Register src, const MemOperand& mem,
+                                  Register ScratchReg,
+                                  Simd128Register ScratchDoubleReg) {
+  // stvx needs the stack to be 16 byte aligned.
+  // We use lxvd/stxvd to store the content on an aligned address. stxvd
+  // itself reverses the lanes so it cannot be used as is.
+  mr(ScratchReg, sp);
+  ClearRightImm(
+      sp, sp,
+      Operand(base::bits::WhichPowerOfTwo(16)));  // equivalent to &= -16
+  addi(sp, sp, Operand(-16));
+  stvx(src, MemOperand(r0, sp));
+  lxvd(ScratchDoubleReg, MemOperand(r0, sp));
+  mr(sp, ScratchReg);
+  stxvd(ScratchDoubleReg, mem);
+}
+
+Register GetRegisterThatIsNotOneOf(Register reg1, Register reg2, Register reg3,
+                                   Register reg4, Register reg5,
+                                   Register reg6) {
+  RegList regs = 0;
+  if (reg1.is_valid()) regs |= reg1.bit();
+  if (reg2.is_valid()) regs |= reg2.bit();
+  if (reg3.is_valid()) regs |= reg3.bit();
+  if (reg4.is_valid()) regs |= reg4.bit();
+  if (reg5.is_valid()) regs |= reg5.bit();
+  if (reg6.is_valid()) regs |= reg6.bit();
+
+  const RegisterConfiguration* config = RegisterConfiguration::Default();
+  for (int i = 0; i < config->num_allocatable_general_registers(); ++i) {
+    int code = config->GetAllocatableGeneralCode(i);
+    Register candidate = Register::from_code(code);
+    if (regs & candidate.bit()) continue;
+    return candidate;
+  }
+  UNREACHABLE();
+}
+
+void TurboAssembler::SwapP(Register src, Register dst, Register scratch) {
+  if (src == dst) return;
+  DCHECK(!AreAliased(src, dst, scratch));
+  mr(scratch, src);
+  mr(src, dst);
+  mr(dst, scratch);
+}
+
+void TurboAssembler::SwapP(Register src, MemOperand dst, Register scratch) {
+  if (dst.ra() != r0 && dst.ra().is_valid())
+    DCHECK(!AreAliased(src, dst.ra(), scratch));
+  if (dst.rb() != r0 && dst.rb().is_valid())
+    DCHECK(!AreAliased(src, dst.rb(), scratch));
+  DCHECK(!AreAliased(src, scratch));
+  mr(scratch, src);
+  LoadP(src, dst, r0);
+  StoreP(scratch, dst, r0);
+}
+
+void TurboAssembler::SwapP(MemOperand src, MemOperand dst, Register scratch_0,
+                           Register scratch_1) {
+  if (src.ra() != r0 && src.ra().is_valid())
+    DCHECK(!AreAliased(src.ra(), scratch_0, scratch_1));
+  if (src.rb() != r0 && src.rb().is_valid())
+    DCHECK(!AreAliased(src.rb(), scratch_0, scratch_1));
+  if (dst.ra() != r0 && dst.ra().is_valid())
+    DCHECK(!AreAliased(dst.ra(), scratch_0, scratch_1));
+  if (dst.rb() != r0 && dst.rb().is_valid())
+    DCHECK(!AreAliased(dst.rb(), scratch_0, scratch_1));
+  DCHECK(!AreAliased(scratch_0, scratch_1));
+  if (is_int16(src.offset()) || is_int16(dst.offset())) {
+    if (!is_int16(src.offset())) {
+      // swap operand
+      MemOperand temp = src;
+      src = dst;
+      dst = temp;
+    }
+    LoadP(scratch_1, dst, scratch_0);
+    LoadP(scratch_0, src);
+    StoreP(scratch_1, src);
+    StoreP(scratch_0, dst, scratch_1);
+  } else {
+    LoadP(scratch_1, dst, scratch_0);
+    push(scratch_1);
+    LoadP(scratch_0, src, scratch_1);
+    StoreP(scratch_0, dst, scratch_1);
+    pop(scratch_1);
+    StoreP(scratch_1, src, scratch_0);
+  }
+}
+
+void TurboAssembler::SwapFloat32(DoubleRegister src, DoubleRegister dst,
+                                 DoubleRegister scratch) {
+  if (src == dst) return;
+  DCHECK(!AreAliased(src, dst, scratch));
+  fmr(scratch, src);
+  fmr(src, dst);
+  fmr(dst, scratch);
+}
+
+void TurboAssembler::SwapFloat32(DoubleRegister src, MemOperand dst,
+                                 DoubleRegister scratch) {
+  DCHECK(!AreAliased(src, scratch));
+  fmr(scratch, src);
+  LoadSingle(src, dst, r0);
+  StoreSingle(scratch, dst, r0);
+}
+
+void TurboAssembler::SwapFloat32(MemOperand src, MemOperand dst,
+                                 DoubleRegister scratch_0,
+                                 DoubleRegister scratch_1) {
+  DCHECK(!AreAliased(scratch_0, scratch_1));
+  LoadSingle(scratch_0, src, r0);
+  LoadSingle(scratch_1, dst, r0);
+  StoreSingle(scratch_0, dst, r0);
+  StoreSingle(scratch_1, src, r0);
+}
+
+void TurboAssembler::SwapDouble(DoubleRegister src, DoubleRegister dst,
+                                DoubleRegister scratch) {
+  if (src == dst) return;
+  DCHECK(!AreAliased(src, dst, scratch));
+  fmr(scratch, src);
+  fmr(src, dst);
+  fmr(dst, scratch);
+}
+
+void TurboAssembler::SwapDouble(DoubleRegister src, MemOperand dst,
+                                DoubleRegister scratch) {
+  DCHECK(!AreAliased(src, scratch));
+  fmr(scratch, src);
+  LoadDouble(src, dst, r0);
+  StoreDouble(scratch, dst, r0);
+}
+
+void TurboAssembler::SwapDouble(MemOperand src, MemOperand dst,
+                                DoubleRegister scratch_0,
+                                DoubleRegister scratch_1) {
+  DCHECK(!AreAliased(scratch_0, scratch_1));
+  LoadDouble(scratch_0, src, r0);
+  LoadDouble(scratch_1, dst, r0);
+  StoreDouble(scratch_0, dst, r0);
+  StoreDouble(scratch_1, src, r0);
+}
+
+void TurboAssembler::SwapSimd128(Simd128Register src, Simd128Register dst,
+                                 Simd128Register scratch) {
+  if (src == dst) return;
+  vor(scratch, src, src);
+  vor(src, dst, dst);
+  vor(dst, scratch, scratch);
+}
+
+void TurboAssembler::SwapSimd128(Simd128Register src, MemOperand dst,
+                                 Simd128Register scratch) {
+  DCHECK(!AreAliased(src, scratch));
+  // push d0, to be used as scratch
+  addi(sp, sp, Operand(-kSimd128Size));
+  StoreSimd128(d0, MemOperand(r0, sp), r0, scratch);
+  mov(ip, Operand(dst.offset()));
+  LoadSimd128(d0, MemOperand(dst.ra(), ip), r0, scratch);
+  StoreSimd128(src, MemOperand(dst.ra(), ip), r0, scratch);
+  vor(src, d0, d0);
+  // restore d0
+  LoadSimd128(d0, MemOperand(r0, sp), ip, scratch);
+  addi(sp, sp, Operand(kSimd128Size));
+}
+
+void TurboAssembler::SwapSimd128(MemOperand src, MemOperand dst,
+                                 Simd128Register scratch) {
+  // push d0 and d1, to be used as scratch
+  addi(sp, sp, Operand(2 * -kSimd128Size));
+  StoreSimd128(d0, MemOperand(r0, sp), ip, scratch);
+  li(ip, Operand(kSimd128Size));
+  StoreSimd128(d1, MemOperand(ip, sp), r0, scratch);
+
+  mov(ip, Operand(src.offset()));
+  LoadSimd128(d0, MemOperand(src.ra(), ip), r0, scratch);
+  mov(ip, Operand(dst.offset()));
+  LoadSimd128(d1, MemOperand(dst.ra(), ip), r0, scratch);
+
+  StoreSimd128(d0, MemOperand(dst.ra(), ip), r0, scratch);
+  mov(ip, Operand(src.offset()));
+  StoreSimd128(d1, MemOperand(src.ra(), ip), r0, scratch);
+
+  // restore d0 and d1
+  LoadSimd128(d0, MemOperand(r0, sp), ip, scratch);
+  li(ip, Operand(kSimd128Size));
+  LoadSimd128(d1, MemOperand(ip, sp), r0, scratch);
+  addi(sp, sp, Operand(2 * kSimd128Size));
+}
+
+void TurboAssembler::ResetSpeculationPoisonRegister() {
+  mov(kSpeculationPoisonRegister, Operand(-1));
+}
+
+void TurboAssembler::JumpIfEqual(Register x, int32_t y, Label* dest) {
+  Cmpi(x, Operand(y), r0);
+  beq(dest);
+}
+
+void TurboAssembler::JumpIfLessThan(Register x, int32_t y, Label* dest) {
+  Cmpi(x, Operand(y), r0);
+  blt(dest);
+}
+
+void TurboAssembler::LoadEntryFromBuiltinIndex(Register builtin_index) {
+  STATIC_ASSERT(kSystemPointerSize == 8);
+  STATIC_ASSERT(kSmiTagSize == 1);
+  STATIC_ASSERT(kSmiTag == 0);
+
+  // The builtin_index register contains the builtin index as a Smi.
+  if (SmiValuesAre32Bits()) {
+    ShiftRightArithImm(builtin_index, builtin_index,
+                       kSmiShift - kSystemPointerSizeLog2);
+  } else {
+    DCHECK(SmiValuesAre31Bits());
+    ShiftLeftImm(builtin_index, builtin_index,
+                 Operand(kSystemPointerSizeLog2 - kSmiShift));
+  }
+  addi(builtin_index, builtin_index,
+       Operand(IsolateData::builtin_entry_table_offset()));
+  LoadPX(builtin_index, MemOperand(kRootRegister, builtin_index));
+}
+
+void TurboAssembler::CallBuiltinByIndex(Register builtin_index) {
+  LoadEntryFromBuiltinIndex(builtin_index);
+  Call(builtin_index);
+}
+
+void TurboAssembler::LoadCodeObjectEntry(Register destination,
+                                         Register code_object) {
+  // Code objects are called differently depending on whether we are generating
+  // builtin code (which will later be embedded into the binary) or compiling
+  // user JS code at runtime.
+  // * Builtin code runs in --jitless mode and thus must not call into on-heap
+  //   Code targets. Instead, we dispatch through the builtins entry table.
+  // * Codegen at runtime does not have this restriction and we can use the
+  //   shorter, branchless instruction sequence. The assumption here is that
+  //   targets are usually generated code and not builtin Code objects.
+
+  if (options().isolate_independent_code) {
+    DCHECK(root_array_available());
+    Label if_code_is_off_heap, out;
+
+    Register scratch = r11;
+
+    DCHECK(!AreAliased(destination, scratch));
+    DCHECK(!AreAliased(code_object, scratch));
+
+    // Check whether the Code object is an off-heap trampoline. If so, call its
+    // (off-heap) entry point directly without going through the (on-heap)
+    // trampoline.  Otherwise, just call the Code object as always.
+    LoadWordArith(scratch, FieldMemOperand(code_object, Code::kFlagsOffset));
+    mov(r0, Operand(Code::IsOffHeapTrampoline::kMask));
+    and_(r0, scratch, r0, SetRC);
+    bne(&if_code_is_off_heap, cr0);
+
+    // Not an off-heap trampoline, the entry point is at
+    // Code::raw_instruction_start().
+    addi(destination, code_object, Operand(Code::kHeaderSize - kHeapObjectTag));
+    b(&out);
+
+    // An off-heap trampoline, the entry point is loaded from the builtin entry
+    // table.
+    bind(&if_code_is_off_heap);
+    LoadWordArith(scratch,
+                  FieldMemOperand(code_object, Code::kBuiltinIndexOffset));
+    ShiftLeftImm(destination, scratch, Operand(kSystemPointerSizeLog2));
+    add(destination, destination, kRootRegister);
+    LoadP(destination,
+          MemOperand(destination, IsolateData::builtin_entry_table_offset()),
+          r0);
+
+    bind(&out);
+  } else {
+    addi(destination, code_object, Operand(Code::kHeaderSize - kHeapObjectTag));
+  }
+}
+
+void TurboAssembler::CallCodeObject(Register code_object) {
+  LoadCodeObjectEntry(code_object, code_object);
+  Call(code_object);
+}
+
+void TurboAssembler::JumpCodeObject(Register code_object) {
+  LoadCodeObjectEntry(code_object, code_object);
+  Jump(code_object);
+}
+
+void TurboAssembler::StoreReturnAddressAndCall(Register target) {
+  // This generates the final instruction sequence for calls to C functions
+  // once an exit frame has been constructed.
+  //
+  // Note that this assumes the caller code (i.e. the Code object currently
+  // being generated) is immovable or that the callee function cannot trigger
+  // GC, since the callee function will return to it.
+
+  static constexpr int after_call_offset = 5 * kInstrSize;
+  Label start_call;
+  Register dest = target;
+
+  if (ABI_USES_FUNCTION_DESCRIPTORS) {
+    // AIX/PPC64BE Linux uses a function descriptor. When calling C code be
+    // aware of this descriptor and pick up values from it
+    LoadP(ToRegister(ABI_TOC_REGISTER), MemOperand(target, kSystemPointerSize));
+    LoadP(ip, MemOperand(target, 0));
+    dest = ip;
+  } else if (ABI_CALL_VIA_IP && dest != ip) {
+    Move(ip, target);
+    dest = ip;
+  }
+
+  LoadPC(r7);
+  bind(&start_call);
+  addi(r7, r7, Operand(after_call_offset));
+  StoreP(r7, MemOperand(sp, kStackFrameExtraParamSlot * kSystemPointerSize));
+  Call(dest);
+
+  DCHECK_EQ(after_call_offset - kInstrSize,
+            SizeOfCodeGeneratedSince(&start_call));
+}
+
+void TurboAssembler::CallForDeoptimization(Address target, int deopt_id,
+                                           Label* exit, DeoptimizeKind kind) {
+  USE(exit, kind);
+  NoRootArrayScope no_root_array(this);
+
+  // Save the deopt id in r29 (we don't need the roots array from now on).
+  DCHECK_LE(deopt_id, 0xFFFF);
+
+  mov(r29, Operand(deopt_id));
+  Call(target, RelocInfo::RUNTIME_ENTRY);
+}
+
+void TurboAssembler::ZeroExtByte(Register dst, Register src) {
+  clrldi(dst, src, Operand(56));
+}
+
+void TurboAssembler::ZeroExtHalfWord(Register dst, Register src) {
+  clrldi(dst, src, Operand(48));
+}
+
+void TurboAssembler::ZeroExtWord32(Register dst, Register src) {
+  clrldi(dst, src, Operand(32));
+}
+
+void TurboAssembler::Trap() { stop(); }
+void TurboAssembler::DebugBreak() { stop(); }
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/macro-assembler-ppc.h b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/macro-assembler-ppc.h
--- a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/macro-assembler-ppc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/macro-assembler-ppc.h	2025-06-04 10:11:01.000000000 +0800
@@ -0,0 +1,1048 @@
+// Copyright 2014 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef INCLUDED_FROM_MACRO_ASSEMBLER_H
+#error This header must be included via macro-assembler.h
+#endif
+
+#ifndef V8_CODEGEN_PPC_MACRO_ASSEMBLER_PPC_H_
+#define V8_CODEGEN_PPC_MACRO_ASSEMBLER_PPC_H_
+
+#include "src/codegen/bailout-reason.h"
+#include "src/codegen/ppc/assembler-ppc.h"
+#include "src/common/globals.h"
+#include "src/numbers/double.h"
+#include "src/objects/contexts.h"
+
+namespace v8 {
+namespace internal {
+
+// ----------------------------------------------------------------------------
+// Static helper functions
+
+// Generate a MemOperand for loading a field from an object.
+inline MemOperand FieldMemOperand(Register object, int offset) {
+  return MemOperand(object, offset - kHeapObjectTag);
+}
+
+enum RememberedSetAction { EMIT_REMEMBERED_SET, OMIT_REMEMBERED_SET };
+enum SmiCheck { INLINE_SMI_CHECK, OMIT_SMI_CHECK };
+enum LinkRegisterStatus { kLRHasNotBeenSaved, kLRHasBeenSaved };
+
+Register GetRegisterThatIsNotOneOf(Register reg1, Register reg2 = no_reg,
+                                   Register reg3 = no_reg,
+                                   Register reg4 = no_reg,
+                                   Register reg5 = no_reg,
+                                   Register reg6 = no_reg);
+
+// These exist to provide portability between 32 and 64bit
+#if V8_TARGET_ARCH_PPC64
+#define LoadPX ldx
+#define LoadPUX ldux
+#define StorePX stdx
+#define StorePUX stdux
+#define ShiftLeftImm sldi
+#define ShiftRightImm srdi
+#define ClearLeftImm clrldi
+#define ClearRightImm clrrdi
+#define ShiftRightArithImm sradi
+#define ShiftLeft_ sld
+#define ShiftRight_ srd
+#define ShiftRightArith srad
+#else
+#define LoadPX lwzx
+#define LoadPUX lwzux
+#define StorePX stwx
+#define StorePUX stwux
+#define ShiftLeftImm slwi
+#define ShiftRightImm srwi
+#define ClearLeftImm clrlwi
+#define ClearRightImm clrrwi
+#define ShiftRightArithImm srawi
+#define ShiftLeft_ slw
+#define ShiftRight_ srw
+#define ShiftRightArith sraw
+#endif
+
+class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
+ public:
+  using TurboAssemblerBase::TurboAssemblerBase;
+
+  // Converts the integer (untagged smi) in |src| to a double, storing
+  // the result to |dst|
+  void ConvertIntToDouble(Register src, DoubleRegister dst);
+
+  // Converts the unsigned integer (untagged smi) in |src| to
+  // a double, storing the result to |dst|
+  void ConvertUnsignedIntToDouble(Register src, DoubleRegister dst);
+
+  // Converts the integer (untagged smi) in |src| to
+  // a float, storing the result in |dst|
+  void ConvertIntToFloat(Register src, DoubleRegister dst);
+
+  // Converts the unsigned integer (untagged smi) in |src| to
+  // a float, storing the result in |dst|
+  void ConvertUnsignedIntToFloat(Register src, DoubleRegister dst);
+
+#if V8_TARGET_ARCH_PPC64
+  void ConvertInt64ToFloat(Register src, DoubleRegister double_dst);
+  void ConvertInt64ToDouble(Register src, DoubleRegister double_dst);
+  void ConvertUnsignedInt64ToFloat(Register src, DoubleRegister double_dst);
+  void ConvertUnsignedInt64ToDouble(Register src, DoubleRegister double_dst);
+#endif
+
+  // Converts the double_input to an integer.  Note that, upon return,
+  // the contents of double_dst will also hold the fixed point representation.
+  void ConvertDoubleToInt64(const DoubleRegister double_input,
+#if !V8_TARGET_ARCH_PPC64
+                            const Register dst_hi,
+#endif
+                            const Register dst, const DoubleRegister double_dst,
+                            FPRoundingMode rounding_mode = kRoundToZero);
+
+#if V8_TARGET_ARCH_PPC64
+  // Converts the double_input to an unsigned integer.  Note that, upon return,
+  // the contents of double_dst will also hold the fixed point representation.
+  void ConvertDoubleToUnsignedInt64(
+      const DoubleRegister double_input, const Register dst,
+      const DoubleRegister double_dst,
+      FPRoundingMode rounding_mode = kRoundToZero);
+#endif
+
+  // Activation support.
+  void EnterFrame(StackFrame::Type type,
+                  bool load_constant_pool_pointer_reg = false);
+
+  // Returns the pc offset at which the frame ends.
+  int LeaveFrame(StackFrame::Type type, int stack_adjustment = 0);
+
+  // Push a fixed frame, consisting of lr, fp, constant pool.
+  void PushCommonFrame(Register marker_reg = no_reg);
+
+  // Generates function and stub prologue code.
+  void StubPrologue(StackFrame::Type type);
+  void Prologue();
+
+  // Push a standard frame, consisting of lr, fp, constant pool,
+  // context and JS function
+  void PushStandardFrame(Register function_reg);
+
+  // Restore caller's frame pointer and return address prior to being
+  // overwritten by tail call stack preparation.
+  void RestoreFrameStateForTailCall();
+
+  // Get the actual activation frame alignment for target environment.
+  static int ActivationFrameAlignment();
+
+  void InitializeRootRegister() {
+    ExternalReference isolate_root = ExternalReference::isolate_root(isolate());
+    mov(kRootRegister, Operand(isolate_root));
+  }
+
+  // These exist to provide portability between 32 and 64bit
+  void LoadP(Register dst, const MemOperand& mem, Register scratch = no_reg);
+  void LoadPU(Register dst, const MemOperand& mem, Register scratch = no_reg);
+  void LoadWordArith(Register dst, const MemOperand& mem,
+                     Register scratch = no_reg);
+  void StoreP(Register src, const MemOperand& mem, Register scratch = no_reg);
+  void StorePU(Register src, const MemOperand& mem, Register scratch = no_reg);
+
+  void LoadDouble(DoubleRegister dst, const MemOperand& mem,
+                  Register scratch = no_reg);
+  void LoadFloat32(DoubleRegister dst, const MemOperand& mem,
+                   Register scratch = no_reg);
+  void LoadDoubleLiteral(DoubleRegister result, Double value, Register scratch);
+  void LoadSimd128(Simd128Register dst, const MemOperand& mem,
+                   Register ScratchReg, Simd128Register ScratchDoubleReg);
+
+  // load a literal signed int value <value> to GPR <dst>
+  void LoadIntLiteral(Register dst, int value);
+  // load an SMI value <value> to GPR <dst>
+  void LoadSmiLiteral(Register dst, Smi smi);
+
+  void LoadSingle(DoubleRegister dst, const MemOperand& mem,
+                  Register scratch = no_reg);
+  void LoadSingleU(DoubleRegister dst, const MemOperand& mem,
+                   Register scratch = no_reg);
+  void LoadPC(Register dst);
+  void ComputeCodeStartAddress(Register dst);
+
+  void StoreDouble(DoubleRegister src, const MemOperand& mem,
+                   Register scratch = no_reg);
+  void StoreDoubleU(DoubleRegister src, const MemOperand& mem,
+                    Register scratch = no_reg);
+
+  void StoreSingle(DoubleRegister src, const MemOperand& mem,
+                   Register scratch = no_reg);
+  void StoreSingleU(DoubleRegister src, const MemOperand& mem,
+                    Register scratch = no_reg);
+  void StoreSimd128(Simd128Register src, const MemOperand& mem,
+                    Register ScratchReg, Simd128Register ScratchDoubleReg);
+
+  void Cmpi(Register src1, const Operand& src2, Register scratch,
+            CRegister cr = cr7);
+  void Cmpli(Register src1, const Operand& src2, Register scratch,
+             CRegister cr = cr7);
+  void Cmpwi(Register src1, const Operand& src2, Register scratch,
+             CRegister cr = cr7);
+  void CompareTagged(Register src1, Register src2, CRegister cr = cr7) {
+    if (COMPRESS_POINTERS_BOOL) {
+      cmpw(src1, src2, cr);
+    } else {
+      cmp(src1, src2, cr);
+    }
+  }
+
+  // Set new rounding mode RN to FPSCR
+  void SetRoundingMode(FPRoundingMode RN);
+
+  // reset rounding mode to default (kRoundToNearest)
+  void ResetRoundingMode();
+  void Add(Register dst, Register src, intptr_t value, Register scratch);
+
+  void Push(Register src) { push(src); }
+  // Push a handle.
+  void Push(Handle<HeapObject> handle);
+  void Push(Smi smi);
+
+  // Push two registers.  Pushes leftmost register first (to highest address).
+  void Push(Register src1, Register src2) {
+    StorePU(src2, MemOperand(sp, -2 * kSystemPointerSize));
+    StoreP(src1, MemOperand(sp, kSystemPointerSize));
+  }
+
+  // Push three registers.  Pushes leftmost register first (to highest address).
+  void Push(Register src1, Register src2, Register src3) {
+    StorePU(src3, MemOperand(sp, -3 * kSystemPointerSize));
+    StoreP(src2, MemOperand(sp, kSystemPointerSize));
+    StoreP(src1, MemOperand(sp, 2 * kSystemPointerSize));
+  }
+
+  // Push four registers.  Pushes leftmost register first (to highest address).
+  void Push(Register src1, Register src2, Register src3, Register src4) {
+    StorePU(src4, MemOperand(sp, -4 * kSystemPointerSize));
+    StoreP(src3, MemOperand(sp, kSystemPointerSize));
+    StoreP(src2, MemOperand(sp, 2 * kSystemPointerSize));
+    StoreP(src1, MemOperand(sp, 3 * kSystemPointerSize));
+  }
+
+  // Push five registers.  Pushes leftmost register first (to highest address).
+  void Push(Register src1, Register src2, Register src3, Register src4,
+            Register src5) {
+    StorePU(src5, MemOperand(sp, -5 * kSystemPointerSize));
+    StoreP(src4, MemOperand(sp, kSystemPointerSize));
+    StoreP(src3, MemOperand(sp, 2 * kSystemPointerSize));
+    StoreP(src2, MemOperand(sp, 3 * kSystemPointerSize));
+    StoreP(src1, MemOperand(sp, 4 * kSystemPointerSize));
+  }
+
+  enum PushArrayOrder { kNormal, kReverse };
+  void PushArray(Register array, Register size, Register scratch,
+                 Register scratch2, PushArrayOrder order = kNormal);
+
+  void Pop(Register dst) { pop(dst); }
+
+  // Pop two registers. Pops rightmost register first (from lower address).
+  void Pop(Register src1, Register src2) {
+    LoadP(src2, MemOperand(sp, 0));
+    LoadP(src1, MemOperand(sp, kSystemPointerSize));
+    addi(sp, sp, Operand(2 * kSystemPointerSize));
+  }
+
+  // Pop three registers.  Pops rightmost register first (from lower address).
+  void Pop(Register src1, Register src2, Register src3) {
+    LoadP(src3, MemOperand(sp, 0));
+    LoadP(src2, MemOperand(sp, kSystemPointerSize));
+    LoadP(src1, MemOperand(sp, 2 * kSystemPointerSize));
+    addi(sp, sp, Operand(3 * kSystemPointerSize));
+  }
+
+  // Pop four registers.  Pops rightmost register first (from lower address).
+  void Pop(Register src1, Register src2, Register src3, Register src4) {
+    LoadP(src4, MemOperand(sp, 0));
+    LoadP(src3, MemOperand(sp, kSystemPointerSize));
+    LoadP(src2, MemOperand(sp, 2 * kSystemPointerSize));
+    LoadP(src1, MemOperand(sp, 3 * kSystemPointerSize));
+    addi(sp, sp, Operand(4 * kSystemPointerSize));
+  }
+
+  // Pop five registers.  Pops rightmost register first (from lower address).
+  void Pop(Register src1, Register src2, Register src3, Register src4,
+           Register src5) {
+    LoadP(src5, MemOperand(sp, 0));
+    LoadP(src4, MemOperand(sp, kSystemPointerSize));
+    LoadP(src3, MemOperand(sp, 2 * kSystemPointerSize));
+    LoadP(src2, MemOperand(sp, 3 * kSystemPointerSize));
+    LoadP(src1, MemOperand(sp, 4 * kSystemPointerSize));
+    addi(sp, sp, Operand(5 * kSystemPointerSize));
+  }
+
+  void SaveRegisters(RegList registers);
+  void RestoreRegisters(RegList registers);
+
+  void CallRecordWriteStub(Register object, Register address,
+                           RememberedSetAction remembered_set_action,
+                           SaveFPRegsMode fp_mode);
+  void CallRecordWriteStub(Register object, Register address,
+                           RememberedSetAction remembered_set_action,
+                           SaveFPRegsMode fp_mode, Address wasm_target);
+  void CallEphemeronKeyBarrier(Register object, Register address,
+                               SaveFPRegsMode fp_mode);
+
+  void MultiPush(RegList regs, Register location = sp);
+  void MultiPop(RegList regs, Register location = sp);
+
+  void MultiPushDoubles(RegList dregs, Register location = sp);
+  void MultiPopDoubles(RegList dregs, Register location = sp);
+
+  // Calculate how much stack space (in bytes) are required to store caller
+  // registers excluding those specified in the arguments.
+  int RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,
+                                      Register exclusion1 = no_reg,
+                                      Register exclusion2 = no_reg,
+                                      Register exclusion3 = no_reg) const;
+
+  // Push caller saved registers on the stack, and return the number of bytes
+  // stack pointer is adjusted.
+  int PushCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1 = no_reg,
+                      Register exclusion2 = no_reg,
+                      Register exclusion3 = no_reg);
+  // Restore caller saved registers from the stack, and return the number of
+  // bytes stack pointer is adjusted.
+  int PopCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1 = no_reg,
+                     Register exclusion2 = no_reg,
+                     Register exclusion3 = no_reg);
+
+  // Load an object from the root table.
+  void LoadRoot(Register destination, RootIndex index) override {
+    LoadRoot(destination, index, al);
+  }
+  void LoadRoot(Register destination, RootIndex index, Condition cond);
+
+  void SwapP(Register src, Register dst, Register scratch);
+  void SwapP(Register src, MemOperand dst, Register scratch);
+  void SwapP(MemOperand src, MemOperand dst, Register scratch_0,
+             Register scratch_1);
+  void SwapFloat32(DoubleRegister src, DoubleRegister dst,
+                   DoubleRegister scratch);
+  void SwapFloat32(DoubleRegister src, MemOperand dst, DoubleRegister scratch);
+  void SwapFloat32(MemOperand src, MemOperand dst, DoubleRegister scratch_0,
+                   DoubleRegister scratch_1);
+  void SwapDouble(DoubleRegister src, DoubleRegister dst,
+                  DoubleRegister scratch);
+  void SwapDouble(DoubleRegister src, MemOperand dst, DoubleRegister scratch);
+  void SwapDouble(MemOperand src, MemOperand dst, DoubleRegister scratch_0,
+                  DoubleRegister scratch_1);
+  void SwapSimd128(Simd128Register src, Simd128Register dst,
+                   Simd128Register scratch);
+  void SwapSimd128(Simd128Register src, MemOperand dst,
+                   Simd128Register scratch);
+  void SwapSimd128(MemOperand src, MemOperand dst, Simd128Register scratch);
+
+  // Before calling a C-function from generated code, align arguments on stack.
+  // After aligning the frame, non-register arguments must be stored in
+  // sp[0], sp[4], etc., not pushed. The argument count assumes all arguments
+  // are word sized. If double arguments are used, this function assumes that
+  // all double arguments are stored before core registers; otherwise the
+  // correct alignment of the double values is not guaranteed.
+  // Some compilers/platforms require the stack to be aligned when calling
+  // C++ code.
+  // Needs a scratch register to do some arithmetic. This register will be
+  // trashed.
+  void PrepareCallCFunction(int num_reg_arguments, int num_double_registers,
+                            Register scratch);
+  void PrepareCallCFunction(int num_reg_arguments, Register scratch);
+
+  void PrepareForTailCall(Register callee_args_count,
+                          Register caller_args_count, Register scratch0,
+                          Register scratch1);
+
+  // There are two ways of passing double arguments on ARM, depending on
+  // whether soft or hard floating point ABI is used. These functions
+  // abstract parameter passing for the three different ways we call
+  // C functions from generated code.
+  void MovToFloatParameter(DoubleRegister src);
+  void MovToFloatParameters(DoubleRegister src1, DoubleRegister src2);
+  void MovToFloatResult(DoubleRegister src);
+
+  // Calls a C function and cleans up the space for arguments allocated
+  // by PrepareCallCFunction. The called function is not allowed to trigger a
+  // garbage collection, since that might move the code and invalidate the
+  // return address (unless this is somehow accounted for by the called
+  // function).
+  void CallCFunction(ExternalReference function, int num_arguments,
+                     bool has_function_descriptor = true);
+  void CallCFunction(Register function, int num_arguments,
+                     bool has_function_descriptor = true);
+  void CallCFunction(ExternalReference function, int num_reg_arguments,
+                     int num_double_arguments,
+                     bool has_function_descriptor = true);
+  void CallCFunction(Register function, int num_reg_arguments,
+                     int num_double_arguments,
+                     bool has_function_descriptor = true);
+
+  void MovFromFloatParameter(DoubleRegister dst);
+  void MovFromFloatResult(DoubleRegister dst);
+
+  void Trap() override;
+  void DebugBreak() override;
+
+  // Calls Abort(msg) if the condition cond is not satisfied.
+  // Use --debug_code to enable.
+  void Assert(Condition cond, AbortReason reason, CRegister cr = cr7);
+
+  // Like Assert(), but always enabled.
+  void Check(Condition cond, AbortReason reason, CRegister cr = cr7);
+
+  // Print a message to stdout and abort execution.
+  void Abort(AbortReason reason);
+
+#if !V8_TARGET_ARCH_PPC64
+  void ShiftLeftPair(Register dst_low, Register dst_high, Register src_low,
+                     Register src_high, Register scratch, Register shift);
+  void ShiftLeftPair(Register dst_low, Register dst_high, Register src_low,
+                     Register src_high, uint32_t shift);
+  void ShiftRightPair(Register dst_low, Register dst_high, Register src_low,
+                      Register src_high, Register scratch, Register shift);
+  void ShiftRightPair(Register dst_low, Register dst_high, Register src_low,
+                      Register src_high, uint32_t shift);
+  void ShiftRightAlgPair(Register dst_low, Register dst_high, Register src_low,
+                         Register src_high, Register scratch, Register shift);
+  void ShiftRightAlgPair(Register dst_low, Register dst_high, Register src_low,
+                         Register src_high, uint32_t shift);
+#endif
+
+  void LoadFromConstantsTable(Register destination,
+                              int constant_index) override;
+  void LoadRootRegisterOffset(Register destination, intptr_t offset) override;
+  void LoadRootRelative(Register destination, int32_t offset) override;
+
+  // Jump, Call, and Ret pseudo instructions implementing inter-working.
+  void Jump(Register target);
+  void Jump(Address target, RelocInfo::Mode rmode, Condition cond = al,
+            CRegister cr = cr7);
+  void Jump(Handle<Code> code, RelocInfo::Mode rmode, Condition cond = al,
+            CRegister cr = cr7);
+  void Jump(const ExternalReference& reference) override;
+  void Jump(intptr_t target, RelocInfo::Mode rmode, Condition cond = al,
+            CRegister cr = cr7);
+  void Call(Register target);
+  void Call(Address target, RelocInfo::Mode rmode, Condition cond = al);
+  void Call(Handle<Code> code, RelocInfo::Mode rmode = RelocInfo::CODE_TARGET,
+            Condition cond = al);
+  void Call(Label* target);
+
+  // Load the builtin given by the Smi in |builtin_index| into the same
+  // register.
+  void LoadEntryFromBuiltinIndex(Register builtin_index);
+  void LoadCodeObjectEntry(Register destination, Register code_object) override;
+  void CallCodeObject(Register code_object) override;
+  void JumpCodeObject(Register code_object) override;
+
+  void CallBuiltinByIndex(Register builtin_index) override;
+  void CallForDeoptimization(Address target, int deopt_id, Label* exit,
+                             DeoptimizeKind kind);
+
+  // Emit code to discard a non-negative number of pointer-sized elements
+  // from the stack, clobbering only the sp register.
+  void Drop(int count);
+  void Drop(Register count, Register scratch = r0);
+
+  void Ret() { blr(); }
+  void Ret(Condition cond, CRegister cr = cr7) { bclr(cond, cr); }
+  void Ret(int drop) {
+    Drop(drop);
+    blr();
+  }
+
+  // If the value is a NaN, canonicalize the value else, do nothing.
+  void CanonicalizeNaN(const DoubleRegister dst, const DoubleRegister src);
+  void CanonicalizeNaN(const DoubleRegister value) {
+    CanonicalizeNaN(value, value);
+  }
+  void CheckPageFlag(Register object, Register scratch, int mask, Condition cc,
+                     Label* condition_met);
+
+  // Move values between integer and floating point registers.
+  void MovIntToDouble(DoubleRegister dst, Register src, Register scratch);
+  void MovUnsignedIntToDouble(DoubleRegister dst, Register src,
+                              Register scratch);
+  void MovInt64ToDouble(DoubleRegister dst,
+#if !V8_TARGET_ARCH_PPC64
+                        Register src_hi,
+#endif
+                        Register src);
+#if V8_TARGET_ARCH_PPC64
+  void MovInt64ComponentsToDouble(DoubleRegister dst, Register src_hi,
+                                  Register src_lo, Register scratch);
+#endif
+  void InsertDoubleLow(DoubleRegister dst, Register src, Register scratch);
+  void InsertDoubleHigh(DoubleRegister dst, Register src, Register scratch);
+  void MovDoubleLowToInt(Register dst, DoubleRegister src);
+  void MovDoubleHighToInt(Register dst, DoubleRegister src);
+  void MovDoubleToInt64(
+#if !V8_TARGET_ARCH_PPC64
+      Register dst_hi,
+#endif
+      Register dst, DoubleRegister src);
+  void MovIntToFloat(DoubleRegister dst, Register src);
+  void MovFloatToInt(Register dst, DoubleRegister src);
+  // Register move. May do nothing if the registers are identical.
+  void Move(Register dst, Smi smi) { LoadSmiLiteral(dst, smi); }
+  void Move(Register dst, Handle<HeapObject> value,
+            RelocInfo::Mode rmode = RelocInfo::FULL_EMBEDDED_OBJECT);
+  void Move(Register dst, ExternalReference reference);
+  void Move(Register dst, Register src, Condition cond = al);
+  void Move(DoubleRegister dst, DoubleRegister src);
+
+  void SmiUntag(Register dst, const MemOperand& src, RCBit rc);
+  void SmiUntag(Register reg, RCBit rc = LeaveRC) { SmiUntag(reg, reg, rc); }
+
+  void SmiUntag(Register dst, Register src, RCBit rc = LeaveRC) {
+    if (COMPRESS_POINTERS_BOOL) {
+      srawi(dst, src, kSmiShift, rc);
+    } else {
+      ShiftRightArithImm(dst, src, kSmiShift, rc);
+    }
+  }
+
+  void ZeroExtByte(Register dst, Register src);
+  void ZeroExtHalfWord(Register dst, Register src);
+  void ZeroExtWord32(Register dst, Register src);
+
+  // ---------------------------------------------------------------------------
+  // Bit testing/extraction
+  //
+  // Bit numbering is such that the least significant bit is bit 0
+  // (for consistency between 32/64-bit).
+
+  // Extract consecutive bits (defined by rangeStart - rangeEnd) from src
+  // and, if !test, shift them into the least significant bits of dst.
+  inline void ExtractBitRange(Register dst, Register src, int rangeStart,
+                              int rangeEnd, RCBit rc = LeaveRC,
+                              bool test = false) {
+    DCHECK(rangeStart >= rangeEnd && rangeStart < kBitsPerSystemPointer);
+    int rotate = (rangeEnd == 0) ? 0 : kBitsPerSystemPointer - rangeEnd;
+    int width = rangeStart - rangeEnd + 1;
+    if (rc == SetRC && rangeStart < 16 && (rangeEnd == 0 || test)) {
+      // Prefer faster andi when applicable.
+      andi(dst, src, Operand(((1 << width) - 1) << rangeEnd));
+    } else {
+#if V8_TARGET_ARCH_PPC64
+      rldicl(dst, src, rotate, kBitsPerSystemPointer - width, rc);
+#else
+      rlwinm(dst, src, rotate, kBitsPerSystemPointer - width,
+             kBitsPerSystemPointer - 1, rc);
+#endif
+    }
+  }
+
+  inline void ExtractBit(Register dst, Register src, uint32_t bitNumber,
+                         RCBit rc = LeaveRC, bool test = false) {
+    ExtractBitRange(dst, src, bitNumber, bitNumber, rc, test);
+  }
+
+  // Extract consecutive bits (defined by mask) from src and place them
+  // into the least significant bits of dst.
+  inline void ExtractBitMask(Register dst, Register src, uintptr_t mask,
+                             RCBit rc = LeaveRC, bool test = false) {
+    int start = kBitsPerSystemPointer - 1;
+    int end;
+    uintptr_t bit = (1L << start);
+
+    while (bit && (mask & bit) == 0) {
+      start--;
+      bit >>= 1;
+    }
+    end = start;
+    bit >>= 1;
+
+    while (bit && (mask & bit)) {
+      end--;
+      bit >>= 1;
+    }
+
+    // 1-bits in mask must be contiguous
+    DCHECK(bit == 0 || (mask & ((bit << 1) - 1)) == 0);
+
+    ExtractBitRange(dst, src, start, end, rc, test);
+  }
+
+  // Test single bit in value.
+  inline void TestBit(Register value, int bitNumber, Register scratch = r0) {
+    ExtractBitRange(scratch, value, bitNumber, bitNumber, SetRC, true);
+  }
+
+  // Test consecutive bit range in value.  Range is defined by mask.
+  inline void TestBitMask(Register value, uintptr_t mask,
+                          Register scratch = r0) {
+    ExtractBitMask(scratch, value, mask, SetRC, true);
+  }
+  // Test consecutive bit range in value.  Range is defined by
+  // rangeStart - rangeEnd.
+  inline void TestBitRange(Register value, int rangeStart, int rangeEnd,
+                           Register scratch = r0) {
+    ExtractBitRange(scratch, value, rangeStart, rangeEnd, SetRC, true);
+  }
+
+  inline void TestIfSmi(Register value, Register scratch) {
+    TestBitRange(value, kSmiTagSize - 1, 0, scratch);
+  }
+  // Jump the register contains a smi.
+  inline void JumpIfSmi(Register value, Label* smi_label) {
+    TestIfSmi(value, r0);
+    beq(smi_label, cr0);  // branch if SMI
+  }
+  void JumpIfEqual(Register x, int32_t y, Label* dest);
+  void JumpIfLessThan(Register x, int32_t y, Label* dest);
+
+#if V8_TARGET_ARCH_PPC64
+  inline void TestIfInt32(Register value, Register scratch,
+                          CRegister cr = cr7) {
+    // High bits must be identical to fit into an 32-bit integer
+    extsw(scratch, value);
+    cmp(scratch, value, cr);
+  }
+#else
+  inline void TestIfInt32(Register hi_word, Register lo_word, Register scratch,
+                          CRegister cr = cr7) {
+    // High bits must be identical to fit into an 32-bit integer
+    srawi(scratch, lo_word, 31);
+    cmp(scratch, hi_word, cr);
+  }
+#endif
+
+  // Overflow handling functions.
+  // Usage: call the appropriate arithmetic function and then call one of the
+  // flow control functions with the corresponding label.
+
+  // Compute dst = left + right, setting condition codes. dst may be same as
+  // either left or right (or a unique register). left and right must not be
+  // the same register.
+  void AddAndCheckForOverflow(Register dst, Register left, Register right,
+                              Register overflow_dst, Register scratch = r0);
+  void AddAndCheckForOverflow(Register dst, Register left, intptr_t right,
+                              Register overflow_dst, Register scratch = r0);
+
+  // Compute dst = left - right, setting condition codes. dst may be same as
+  // either left or right (or a unique register). left and right must not be
+  // the same register.
+  void SubAndCheckForOverflow(Register dst, Register left, Register right,
+                              Register overflow_dst, Register scratch = r0);
+
+  // Performs a truncating conversion of a floating point number as used by
+  // the JS bitwise operations. See ECMA-262 9.5: ToInt32. Goes to 'done' if it
+  // succeeds, otherwise falls through if result is saturated. On return
+  // 'result' either holds answer, or is clobbered on fall through.
+  void TryInlineTruncateDoubleToI(Register result, DoubleRegister input,
+                                  Label* done);
+  void TruncateDoubleToI(Isolate* isolate, Zone* zone, Register result,
+                         DoubleRegister double_input, StubCallMode stub_mode);
+
+  void LoadConstantPoolPointerRegister();
+
+  // Loads the constant pool pointer (kConstantPoolRegister).
+  void LoadConstantPoolPointerRegisterFromCodeTargetAddress(
+      Register code_target_address);
+  void AbortConstantPoolBuilding() {
+#ifdef DEBUG
+    // Avoid DCHECK(!is_linked()) failure in ~Label()
+    bind(ConstantPoolPosition());
+#endif
+  }
+
+  // Generates an instruction sequence s.t. the return address points to the
+  // instruction following the call.
+  // The return address on the stack is used by frame iteration.
+  void StoreReturnAddressAndCall(Register target);
+
+  void ResetSpeculationPoisonRegister();
+
+  // Control-flow integrity:
+
+  // Define a function entrypoint. This doesn't emit any code for this
+  // architecture, as control-flow integrity is not supported for it.
+  void CodeEntry() {}
+  // Define an exception handler.
+  void ExceptionHandler() {}
+  // Define an exception handler and bind a label.
+  void BindExceptionHandler(Label* label) { bind(label); }
+
+  // ---------------------------------------------------------------------------
+  // Pointer compression Support
+
+  // Loads a field containing a HeapObject and decompresses it if pointer
+  // compression is enabled.
+  void LoadTaggedPointerField(const Register& destination,
+                              const MemOperand& field_operand,
+                              const Register& scratch = no_reg);
+
+  // Loads a field containing any tagged value and decompresses it if necessary.
+  void LoadAnyTaggedField(const Register& destination,
+                          const MemOperand& field_operand,
+                          const Register& scratch = no_reg);
+
+  // Loads a field containing smi value and untags it.
+  void SmiUntagField(Register dst, const MemOperand& src, RCBit rc = LeaveRC);
+
+  // Compresses and stores tagged value to given on-heap location.
+  void StoreTaggedField(const Register& value,
+                        const MemOperand& dst_field_operand,
+                        const Register& scratch = no_reg);
+  void StoreTaggedFieldX(const Register& value,
+                         const MemOperand& dst_field_operand,
+                         const Register& scratch = no_reg);
+
+  void DecompressTaggedSigned(Register destination, MemOperand field_operand);
+  void DecompressTaggedSigned(Register destination, Register src);
+  void DecompressTaggedPointer(Register destination, MemOperand field_operand);
+  void DecompressTaggedPointer(Register destination, Register source);
+  void DecompressAnyTagged(Register destination, MemOperand field_operand);
+  void DecompressAnyTagged(Register destination, Register source);
+
+  void LoadWord(Register dst, const MemOperand& mem, Register scratch);
+  void StoreWord(Register src, const MemOperand& mem, Register scratch);
+
+ private:
+  static const int kSmiShift = kSmiTagSize + kSmiShiftSize;
+
+  int CalculateStackPassedWords(int num_reg_arguments,
+                                int num_double_arguments);
+  void CallCFunctionHelper(Register function, int num_reg_arguments,
+                           int num_double_arguments,
+                           bool has_function_descriptor);
+  void CallRecordWriteStub(Register object, Register address,
+                           RememberedSetAction remembered_set_action,
+                           SaveFPRegsMode fp_mode, Handle<Code> code_target,
+                           Address wasm_target);
+};
+
+// MacroAssembler implements a collection of frequently used acros.
+class V8_EXPORT_PRIVATE MacroAssembler : public TurboAssembler {
+ public:
+  using TurboAssembler::TurboAssembler;
+
+  // It assumes that the arguments are located below the stack pointer.
+  // argc is the number of arguments not including the receiver.
+  // TODO(victorgomes): Remove this function once we stick with the reversed
+  // arguments order.
+  void LoadReceiver(Register dest, Register argc) {
+#ifdef V8_REVERSE_JSARGS
+    LoadP(dest, MemOperand(sp, 0));
+#else
+    ShiftLeftImm(dest, argc, Operand(kSystemPointerSizeLog2));
+    LoadPX(dest, MemOperand(sp, dest));
+#endif
+  }
+
+  void StoreReceiver(Register rec, Register argc, Register scratch) {
+#ifdef V8_REVERSE_JSARGS
+    StoreP(rec, MemOperand(sp, 0));
+#else
+    ShiftLeftImm(scratch, argc, Operand(kSystemPointerSizeLog2));
+    StorePX(rec, MemOperand(sp, scratch));
+#endif
+  }
+
+  // ---------------------------------------------------------------------------
+  // GC Support
+
+  // Notify the garbage collector that we wrote a pointer into an object.
+  // |object| is the object being stored into, |value| is the object being
+  // stored.  value and scratch registers are clobbered by the operation.
+  // The offset is the offset from the start of the object, not the offset from
+  // the tagged HeapObject pointer.  For use with FieldMemOperand(reg, off).
+  void RecordWriteField(
+      Register object, int offset, Register value, Register scratch,
+      LinkRegisterStatus lr_status, SaveFPRegsMode save_fp,
+      RememberedSetAction remembered_set_action = EMIT_REMEMBERED_SET,
+      SmiCheck smi_check = INLINE_SMI_CHECK);
+
+  // For a given |object| notify the garbage collector that the slot |address|
+  // has been written.  |value| is the object being stored. The value and
+  // address registers are clobbered by the operation.
+  void RecordWrite(
+      Register object, Register address, Register value,
+      LinkRegisterStatus lr_status, SaveFPRegsMode save_fp,
+      RememberedSetAction remembered_set_action = EMIT_REMEMBERED_SET,
+      SmiCheck smi_check = INLINE_SMI_CHECK);
+
+  // Enter exit frame.
+  // stack_space - extra stack space, used for parameters before call to C.
+  // At least one slot (for the return address) should be provided.
+  void EnterExitFrame(bool save_doubles, int stack_space = 1,
+                      StackFrame::Type frame_type = StackFrame::EXIT);
+
+  // Leave the current exit frame. Expects the return value in r0.
+  // Expect the number of values, pushed prior to the exit frame, to
+  // remove in a register (or no_reg, if there is nothing to remove).
+  void LeaveExitFrame(bool save_doubles, Register argument_count,
+                      bool argument_count_is_length = false);
+
+  void LoadMap(Register destination, Register object);
+
+  // Load the global proxy from the current context.
+  void LoadGlobalProxy(Register dst) {
+    LoadNativeContextSlot(Context::GLOBAL_PROXY_INDEX, dst);
+  }
+
+  void LoadNativeContextSlot(int index, Register dst);
+
+  // ----------------------------------------------------------------
+  // new PPC macro-assembler interfaces that are slightly higher level
+  // than assembler-ppc and may generate variable length sequences
+
+  // load a literal double value <value> to FPR <result>
+
+  void LoadHalfWord(Register dst, const MemOperand& mem,
+                    Register scratch = no_reg);
+  void LoadHalfWordArith(Register dst, const MemOperand& mem,
+                         Register scratch = no_reg);
+  void StoreHalfWord(Register src, const MemOperand& mem, Register scratch);
+
+  void LoadByte(Register dst, const MemOperand& mem, Register scratch);
+  void StoreByte(Register src, const MemOperand& mem, Register scratch);
+
+  void LoadDoubleU(DoubleRegister dst, const MemOperand& mem,
+                   Register scratch = no_reg);
+
+  void Cmplwi(Register src1, const Operand& src2, Register scratch,
+              CRegister cr = cr7);
+  void And(Register ra, Register rs, const Operand& rb, RCBit rc = LeaveRC);
+  void Or(Register ra, Register rs, const Operand& rb, RCBit rc = LeaveRC);
+  void Xor(Register ra, Register rs, const Operand& rb, RCBit rc = LeaveRC);
+
+  void AddSmiLiteral(Register dst, Register src, Smi smi, Register scratch);
+  void SubSmiLiteral(Register dst, Register src, Smi smi, Register scratch);
+  void CmpSmiLiteral(Register src1, Smi smi, Register scratch,
+                     CRegister cr = cr7);
+  void CmplSmiLiteral(Register src1, Smi smi, Register scratch,
+                      CRegister cr = cr7);
+  void AndSmiLiteral(Register dst, Register src, Smi smi, Register scratch,
+                     RCBit rc = LeaveRC);
+
+  // ---------------------------------------------------------------------------
+  // JavaScript invokes
+
+  // Removes current frame and its arguments from the stack preserving
+  // the arguments and a return address pushed to the stack for the next call.
+  // Both |callee_args_count| and |caller_args_countg| do not include
+  // receiver. |callee_args_count| is not modified. |caller_args_count|
+  // is trashed.
+
+  // Invoke the JavaScript function code by either calling or jumping.
+  void InvokeFunctionCode(Register function, Register new_target,
+                          Register expected_parameter_count,
+                          Register actual_parameter_count, InvokeFlag flag);
+
+  // On function call, call into the debugger if necessary.
+  void CheckDebugHook(Register fun, Register new_target,
+                      Register expected_parameter_count,
+                      Register actual_parameter_count);
+
+  // Invoke the JavaScript function in the given register. Changes the
+  // current context to the context in the function before invoking.
+  void InvokeFunctionWithNewTarget(Register function, Register new_target,
+                                   Register actual_parameter_count,
+                                   InvokeFlag flag);
+  void InvokeFunction(Register function, Register expected_parameter_count,
+                      Register actual_parameter_count, InvokeFlag flag);
+
+  // Frame restart support
+  void MaybeDropFrames();
+
+  // Exception handling
+
+  // Push a new stack handler and link into stack handler chain.
+  void PushStackHandler();
+
+  // Unlink the stack handler on top of the stack from the stack handler chain.
+  // Must preserve the result register.
+  void PopStackHandler();
+
+  // ---------------------------------------------------------------------------
+  // Support functions.
+
+  // Compare object type for heap object.  heap_object contains a non-Smi
+  // whose object type should be compared with the given type.  This both
+  // sets the flags and leaves the object type in the type_reg register.
+  // It leaves the map in the map register (unless the type_reg and map register
+  // are the same register).  It leaves the heap object in the heap_object
+  // register unless the heap_object register is the same register as one of the
+  // other registers.
+  // Type_reg can be no_reg. In that case ip is used.
+  void CompareObjectType(Register heap_object, Register map, Register type_reg,
+                         InstanceType type);
+
+  // Compare instance type in a map.  map contains a valid map object whose
+  // object type should be compared with the given type.  This both
+  // sets the flags and leaves the object type in the type_reg register.
+  void CompareInstanceType(Register map, Register type_reg, InstanceType type);
+
+  // Compare the object in a register to a value from the root list.
+  // Uses the ip register as scratch.
+  void CompareRoot(Register obj, RootIndex index);
+  void PushRoot(RootIndex index) {
+    LoadRoot(r0, index);
+    Push(r0);
+  }
+
+  // Compare the object in a register to a value and jump if they are equal.
+  void JumpIfRoot(Register with, RootIndex index, Label* if_equal) {
+    CompareRoot(with, index);
+    beq(if_equal);
+  }
+
+  // Compare the object in a register to a value and jump if they are not equal.
+  void JumpIfNotRoot(Register with, RootIndex index, Label* if_not_equal) {
+    CompareRoot(with, index);
+    bne(if_not_equal);
+  }
+
+  // Checks if value is in range [lower_limit, higher_limit] using a single
+  // comparison.
+  void JumpIfIsInRange(Register value, unsigned lower_limit,
+                       unsigned higher_limit, Label* on_in_range);
+
+  // ---------------------------------------------------------------------------
+  // Runtime calls
+
+  static int CallSizeNotPredictableCodeSize(Address target,
+                                            RelocInfo::Mode rmode,
+                                            Condition cond = al);
+  void CallJSEntry(Register target);
+
+  // Call a runtime routine.
+  void CallRuntime(const Runtime::Function* f, int num_arguments,
+                   SaveFPRegsMode save_doubles = kDontSaveFPRegs);
+  void CallRuntimeSaveDoubles(Runtime::FunctionId fid) {
+    const Runtime::Function* function = Runtime::FunctionForId(fid);
+    CallRuntime(function, function->nargs, kSaveFPRegs);
+  }
+
+  // Convenience function: Same as above, but takes the fid instead.
+  void CallRuntime(Runtime::FunctionId fid,
+                   SaveFPRegsMode save_doubles = kDontSaveFPRegs) {
+    const Runtime::Function* function = Runtime::FunctionForId(fid);
+    CallRuntime(function, function->nargs, save_doubles);
+  }
+
+  // Convenience function: Same as above, but takes the fid instead.
+  void CallRuntime(Runtime::FunctionId fid, int num_arguments,
+                   SaveFPRegsMode save_doubles = kDontSaveFPRegs) {
+    CallRuntime(Runtime::FunctionForId(fid), num_arguments, save_doubles);
+  }
+
+  // Convenience function: tail call a runtime routine (jump).
+  void TailCallRuntime(Runtime::FunctionId fid);
+
+  // Jump to a runtime routine.
+  void JumpToExternalReference(const ExternalReference& builtin,
+                               bool builtin_exit_frame = false);
+
+  // Generates a trampoline to jump to the off-heap instruction stream.
+  void JumpToInstructionStream(Address entry);
+
+  // ---------------------------------------------------------------------------
+  // In-place weak references.
+  void LoadWeakValue(Register out, Register in, Label* target_if_cleared);
+
+  // ---------------------------------------------------------------------------
+  // StatsCounter support
+
+  void IncrementCounter(StatsCounter* counter, int value, Register scratch1,
+                        Register scratch2);
+  void DecrementCounter(StatsCounter* counter, int value, Register scratch1,
+                        Register scratch2);
+
+  // ---------------------------------------------------------------------------
+  // Smi utilities
+
+  // Shift left by kSmiShift
+  void SmiTag(Register reg, RCBit rc = LeaveRC) { SmiTag(reg, reg, rc); }
+  void SmiTag(Register dst, Register src, RCBit rc = LeaveRC) {
+    ShiftLeftImm(dst, src, Operand(kSmiShift), rc);
+  }
+
+  void SmiToPtrArrayOffset(Register dst, Register src) {
+#if defined(V8_COMPRESS_POINTERS) || defined(V8_31BIT_SMIS_ON_64BIT_ARCH)
+    STATIC_ASSERT(kSmiTag == 0 && kSmiShift < kSystemPointerSizeLog2);
+    ShiftLeftImm(dst, src, Operand(kSystemPointerSizeLog2 - kSmiShift));
+#else
+    STATIC_ASSERT(kSmiTag == 0 && kSmiShift > kSystemPointerSizeLog2);
+    ShiftRightArithImm(dst, src, kSmiShift - kSystemPointerSizeLog2);
+#endif
+  }
+
+  // Jump if either of the registers contain a non-smi.
+  inline void JumpIfNotSmi(Register value, Label* not_smi_label) {
+    TestIfSmi(value, r0);
+    bne(not_smi_label, cr0);
+  }
+
+  // Abort execution if argument is a smi, enabled via --debug-code.
+  void AssertNotSmi(Register object);
+  void AssertSmi(Register object);
+
+#if !defined(V8_COMPRESS_POINTERS) && !defined(V8_31BIT_SMIS_ON_64BIT_ARCH)
+  // Ensure it is permissible to read/write int value directly from
+  // upper half of the smi.
+  STATIC_ASSERT(kSmiTag == 0);
+  STATIC_ASSERT(kSmiTagSize + kSmiShiftSize == 32);
+#endif
+#if V8_TARGET_ARCH_PPC64 && V8_TARGET_LITTLE_ENDIAN
+#define SmiWordOffset(offset) (offset + kSystemPointerSize / 2)
+#else
+#define SmiWordOffset(offset) offset
+#endif
+
+  // Abort execution if argument is not a Constructor, enabled via --debug-code.
+  void AssertConstructor(Register object);
+
+  // Abort execution if argument is not a JSFunction, enabled via --debug-code.
+  void AssertFunction(Register object);
+
+  // Abort execution if argument is not a JSBoundFunction,
+  // enabled via --debug-code.
+  void AssertBoundFunction(Register object);
+
+  // Abort execution if argument is not a JSGeneratorObject (or subclass),
+  // enabled via --debug-code.
+  void AssertGeneratorObject(Register object);
+
+  // Abort execution if argument is not undefined or an AllocationSite, enabled
+  // via --debug-code.
+  void AssertUndefinedOrAllocationSite(Register object, Register scratch);
+
+  // ---------------------------------------------------------------------------
+  // Patching helpers.
+
+  template <typename Field>
+  void DecodeField(Register dst, Register src, RCBit rc = LeaveRC) {
+    ExtractBitRange(dst, src, Field::kShift + Field::kSize - 1, Field::kShift,
+                    rc);
+  }
+
+  template <typename Field>
+  void DecodeField(Register reg, RCBit rc = LeaveRC) {
+    DecodeField<Field>(reg, reg, rc);
+  }
+
+ private:
+  static const int kSmiShift = kSmiTagSize + kSmiShiftSize;
+
+  // Helper functions for generating invokes.
+  void InvokePrologue(Register expected_parameter_count,
+                      Register actual_parameter_count, Label* done,
+                      InvokeFlag flag);
+
+  DISALLOW_IMPLICIT_CONSTRUCTORS(MacroAssembler);
+};
+
+#define ACCESS_MASM(masm) masm->
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_PPC_MACRO_ASSEMBLER_PPC_H_
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/register-ppc.h b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/register-ppc.h
--- a/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/register-ppc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/codegen/ppc64/register-ppc.h	2025-06-04 10:11:01.000000000 +0800
@@ -0,0 +1,320 @@
+// Copyright 2018 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_PPC_REGISTER_PPC_H_
+#define V8_CODEGEN_PPC_REGISTER_PPC_H_
+
+#include "src/codegen/register.h"
+#include "src/codegen/reglist.h"
+
+namespace v8 {
+namespace internal {
+
+// clang-format off
+#define GENERAL_REGISTERS(V)                              \
+  V(r0)  V(sp)  V(r2)  V(r3)  V(r4)  V(r5)  V(r6)  V(r7)  \
+  V(r8)  V(r9)  V(r10) V(r11) V(ip) V(r13) V(r14) V(r15)  \
+  V(r16) V(r17) V(r18) V(r19) V(r20) V(r21) V(r22) V(r23) \
+  V(r24) V(r25) V(r26) V(r27) V(r28) V(r29) V(r30) V(fp)
+
+#if V8_EMBEDDED_CONSTANT_POOL
+#define ALLOCATABLE_GENERAL_REGISTERS(V)                  \
+  V(r3)  V(r4)  V(r5)  V(r6)  V(r7)                       \
+  V(r8)  V(r9)  V(r10) V(r14) V(r15)                      \
+  V(r16) V(r17) V(r18) V(r19) V(r20) V(r21) V(r22) V(r23) \
+  V(r24) V(r25) V(r26) V(r27) V(r30)
+#else
+#define ALLOCATABLE_GENERAL_REGISTERS(V)                  \
+  V(r3)  V(r4)  V(r5)  V(r6)  V(r7)                       \
+  V(r8)  V(r9)  V(r10) V(r14) V(r15)                      \
+  V(r16) V(r17) V(r18) V(r19) V(r20) V(r21) V(r22) V(r23) \
+  V(r24) V(r25) V(r26) V(r27) V(r28) V(r30)
+#endif
+
+#define LOW_DOUBLE_REGISTERS(V)                           \
+  V(d0)  V(d1)  V(d2)  V(d3)  V(d4)  V(d5)  V(d6)  V(d7)  \
+  V(d8)  V(d9)  V(d10) V(d11) V(d12) V(d13) V(d14) V(d15)
+
+#define NON_LOW_DOUBLE_REGISTERS(V)                       \
+  V(d16) V(d17) V(d18) V(d19) V(d20) V(d21) V(d22) V(d23) \
+  V(d24) V(d25) V(d26) V(d27) V(d28) V(d29) V(d30) V(d31)
+
+#define DOUBLE_REGISTERS(V) \
+  LOW_DOUBLE_REGISTERS(V) NON_LOW_DOUBLE_REGISTERS(V)
+
+#define FLOAT_REGISTERS DOUBLE_REGISTERS
+#define SIMD128_REGISTERS DOUBLE_REGISTERS
+
+#define ALLOCATABLE_DOUBLE_REGISTERS(V)                   \
+  V(d1)  V(d2)  V(d3)  V(d4)  V(d5)  V(d6)  V(d7)         \
+  V(d8)  V(d9)  V(d10) V(d11) V(d12) V(d15)               \
+  V(d16) V(d17) V(d18) V(d19) V(d20) V(d21) V(d22) V(d23) \
+  V(d24) V(d25) V(d26) V(d27) V(d28) V(d29) V(d30) V(d31)
+
+#define C_REGISTERS(V)                                            \
+  V(cr0)  V(cr1)  V(cr2)  V(cr3)  V(cr4)  V(cr5)  V(cr6)  V(cr7)  \
+  V(cr8)  V(cr9)  V(cr10) V(cr11) V(cr12) V(cr15)
+// clang-format on
+
+// Register list in load/store instructions
+// Note that the bit values must match those used in actual instruction encoding
+
+// Caller-saved/arguments registers
+const RegList kJSCallerSaved = 1 << 3 |   // r3  a1
+                               1 << 4 |   // r4  a2
+                               1 << 5 |   // r5  a3
+                               1 << 6 |   // r6  a4
+                               1 << 7 |   // r7  a5
+                               1 << 8 |   // r8  a6
+                               1 << 9 |   // r9  a7
+                               1 << 10 |  // r10 a8
+                               1 << 11;
+
+const int kNumJSCallerSaved = 9;
+
+// Return the code of the n-th caller-saved register available to JavaScript
+// e.g. JSCallerSavedReg(0) returns r0.code() == 0
+int JSCallerSavedCode(int n);
+
+// Callee-saved registers preserved when switching from C to JavaScript
+const RegList kCalleeSaved = 1 << 14 |  // r14
+                             1 << 15 |  // r15
+                             1 << 16 |  // r16
+                             1 << 17 |  // r17
+                             1 << 18 |  // r18
+                             1 << 19 |  // r19
+                             1 << 20 |  // r20
+                             1 << 21 |  // r21
+                             1 << 22 |  // r22
+                             1 << 23 |  // r23
+                             1 << 24 |  // r24
+                             1 << 25 |  // r25
+                             1 << 26 |  // r26
+                             1 << 27 |  // r27
+                             1 << 28 |  // r28
+                             1 << 29 |  // r29
+                             1 << 30 |  // r20
+                             1 << 31;   // r31
+
+const int kNumCalleeSaved = 18;
+
+const RegList kCallerSavedDoubles = 1 << 0 |   // d0
+                                    1 << 1 |   // d1
+                                    1 << 2 |   // d2
+                                    1 << 3 |   // d3
+                                    1 << 4 |   // d4
+                                    1 << 5 |   // d5
+                                    1 << 6 |   // d6
+                                    1 << 7 |   // d7
+                                    1 << 8 |   // d8
+                                    1 << 9 |   // d9
+                                    1 << 10 |  // d10
+                                    1 << 11 |  // d11
+                                    1 << 12 |  // d12
+                                    1 << 13;   // d13
+
+const int kNumCallerSavedDoubles = 14;
+
+const RegList kCalleeSavedDoubles = 1 << 14 |  // d14
+                                    1 << 15 |  // d15
+                                    1 << 16 |  // d16
+                                    1 << 17 |  // d17
+                                    1 << 18 |  // d18
+                                    1 << 19 |  // d19
+                                    1 << 20 |  // d20
+                                    1 << 21 |  // d21
+                                    1 << 22 |  // d22
+                                    1 << 23 |  // d23
+                                    1 << 24 |  // d24
+                                    1 << 25 |  // d25
+                                    1 << 26 |  // d26
+                                    1 << 27 |  // d27
+                                    1 << 28 |  // d28
+                                    1 << 29 |  // d29
+                                    1 << 30 |  // d30
+                                    1 << 31;   // d31
+
+const int kNumCalleeSavedDoubles = 18;
+
+// The following constants describe the stack frame linkage area as
+// defined by the ABI.  Note that kNumRequiredStackFrameSlots must
+// satisfy alignment requirements (rounding up if required).
+#if V8_TARGET_ARCH_PPC64 &&     \
+    (V8_TARGET_LITTLE_ENDIAN || \
+     (defined(_CALL_ELF) && _CALL_ELF == 2))  // ELFv2 ABI
+// [0] back chain
+// [1] condition register save area
+// [2] link register save area
+// [3] TOC save area
+// [4] Parameter1 save area
+// ...
+// [11] Parameter8 save area
+// [12] Parameter9 slot (if necessary)
+// ...
+const int kNumRequiredStackFrameSlots = 12;
+const int kStackFrameLRSlot = 2;
+const int kStackFrameExtraParamSlot = 12;
+#else  // AIX
+// [0] back chain
+// [1] condition register save area
+// [2] link register save area
+// [3] reserved for compiler
+// [4] reserved by binder
+// [5] TOC save area
+// [6] Parameter1 save area
+// ...
+// [13] Parameter8 save area
+// [14] Parameter9 slot (if necessary)
+// ...
+const int kNumRequiredStackFrameSlots = 14;
+const int kStackFrameLRSlot = 2;
+const int kStackFrameExtraParamSlot = 14;
+#endif
+
+enum RegisterCode {
+#define REGISTER_CODE(R) kRegCode_##R,
+  GENERAL_REGISTERS(REGISTER_CODE)
+#undef REGISTER_CODE
+      kRegAfterLast
+};
+
+class Register : public RegisterBase<Register, kRegAfterLast> {
+ public:
+#if V8_TARGET_LITTLE_ENDIAN
+  static constexpr int kMantissaOffset = 0;
+  static constexpr int kExponentOffset = 4;
+#else
+  static constexpr int kMantissaOffset = 4;
+  static constexpr int kExponentOffset = 0;
+#endif
+
+ private:
+  friend class RegisterBase;
+  explicit constexpr Register(int code) : RegisterBase(code) {}
+};
+
+ASSERT_TRIVIALLY_COPYABLE(Register);
+static_assert(sizeof(Register) == sizeof(int),
+              "Register can efficiently be passed by value");
+
+#define DEFINE_REGISTER(R) \
+  constexpr Register R = Register::from_code(kRegCode_##R);
+GENERAL_REGISTERS(DEFINE_REGISTER)
+#undef DEFINE_REGISTER
+constexpr Register no_reg = Register::no_reg();
+
+// Aliases
+constexpr Register kConstantPoolRegister = r28;  // Constant pool.
+constexpr Register kRootRegister = r29;          // Roots array pointer.
+constexpr Register cp = r30;                     // JavaScript context pointer.
+
+// PPC64 calling convention
+constexpr Register arg_reg_1 = r3;
+constexpr Register arg_reg_2 = r4;
+constexpr Register arg_reg_3 = r5;
+constexpr Register arg_reg_4 = r6;
+
+constexpr bool kPadArguments = false;
+constexpr bool kSimpleFPAliasing = true;
+constexpr bool kSimdMaskRegisters = false;
+
+enum DoubleRegisterCode {
+#define REGISTER_CODE(R) kDoubleCode_##R,
+  DOUBLE_REGISTERS(REGISTER_CODE)
+#undef REGISTER_CODE
+      kDoubleAfterLast
+};
+
+// Double word FP register.
+class DoubleRegister : public RegisterBase<DoubleRegister, kDoubleAfterLast> {
+ public:
+  // A few double registers are reserved: one as a scratch register and one to
+  // hold 0.0, that does not fit in the immediate field of vmov instructions.
+  // d14: 0.0
+  // d15: scratch register.
+  static constexpr int kSizeInBytes = 8;
+  inline static int NumRegisters();
+
+ private:
+  friend class RegisterBase;
+  explicit constexpr DoubleRegister(int code) : RegisterBase(code) {}
+};
+
+ASSERT_TRIVIALLY_COPYABLE(DoubleRegister);
+static_assert(sizeof(DoubleRegister) == sizeof(int),
+              "DoubleRegister can efficiently be passed by value");
+
+using FloatRegister = DoubleRegister;
+
+// TODO(ppc) Define SIMD registers.
+using Simd128Register = DoubleRegister;
+
+#define DEFINE_REGISTER(R) \
+  constexpr DoubleRegister R = DoubleRegister::from_code(kDoubleCode_##R);
+DOUBLE_REGISTERS(DEFINE_REGISTER)
+#undef DEFINE_REGISTER
+constexpr DoubleRegister no_dreg = DoubleRegister::no_reg();
+
+constexpr DoubleRegister kFirstCalleeSavedDoubleReg = d14;
+constexpr DoubleRegister kLastCalleeSavedDoubleReg = d31;
+constexpr DoubleRegister kDoubleRegZero = d14;
+constexpr DoubleRegister kScratchDoubleReg = d13;
+
+Register ToRegister(int num);
+
+enum CRegisterCode {
+#define REGISTER_CODE(R) kCCode_##R,
+  C_REGISTERS(REGISTER_CODE)
+#undef REGISTER_CODE
+      kCAfterLast
+};
+
+// Coprocessor register
+class CRegister : public RegisterBase<CRegister, kCAfterLast> {
+  friend class RegisterBase;
+  explicit constexpr CRegister(int code) : RegisterBase(code) {}
+};
+
+constexpr CRegister no_creg = CRegister::no_reg();
+#define DECLARE_C_REGISTER(R) \
+  constexpr CRegister R = CRegister::from_code(kCCode_##R);
+C_REGISTERS(DECLARE_C_REGISTER)
+#undef DECLARE_C_REGISTER
+
+// Define {RegisterName} methods for the register types.
+DEFINE_REGISTER_NAMES(Register, GENERAL_REGISTERS)
+DEFINE_REGISTER_NAMES(DoubleRegister, DOUBLE_REGISTERS)
+
+// Give alias names to registers for calling conventions.
+constexpr Register kReturnRegister0 = r3;
+constexpr Register kReturnRegister1 = r4;
+constexpr Register kReturnRegister2 = r5;
+constexpr Register kJSFunctionRegister = r4;
+constexpr Register kContextRegister = r30;
+constexpr Register kAllocateSizeRegister = r4;
+constexpr Register kSpeculationPoisonRegister = r14;
+constexpr Register kInterpreterAccumulatorRegister = r3;
+constexpr Register kInterpreterBytecodeOffsetRegister = r15;
+constexpr Register kInterpreterBytecodeArrayRegister = r16;
+constexpr Register kInterpreterDispatchTableRegister = r17;
+
+constexpr Register kJavaScriptCallArgCountRegister = r3;
+constexpr Register kJavaScriptCallCodeStartRegister = r5;
+constexpr Register kJavaScriptCallTargetRegister = kJSFunctionRegister;
+constexpr Register kJavaScriptCallNewTargetRegister = r6;
+constexpr Register kJavaScriptCallExtraArg1Register = r5;
+
+constexpr Register kOffHeapTrampolineRegister = ip;
+constexpr Register kRuntimeCallFunctionRegister = r4;
+constexpr Register kRuntimeCallArgCountRegister = r3;
+constexpr Register kRuntimeCallArgvRegister = r5;
+constexpr Register kWasmInstanceRegister = r10;
+constexpr Register kWasmCompileLazyFuncIndexRegister = r15;
+
+constexpr DoubleRegister kFPReturnRegister0 = d1;
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_PPC_REGISTER_PPC_H_
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/regexp/ppc/regexp-macro-assembler-ppc.cc b/qtwebengine/src/3rdparty/chromium/v8/src/regexp/ppc/regexp-macro-assembler-ppc.cc
--- a/qtwebengine/src/3rdparty/chromium/v8/src/regexp/ppc/regexp-macro-assembler-ppc.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/regexp/ppc/regexp-macro-assembler-ppc.cc	2025-06-06 09:02:23.000000000 +0800
@@ -1174,7 +1174,7 @@
                                                   Address re_frame) {
   Code re_code = Code::cast(Object(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
-      frame_entry<Isolate*>(re_frame, kIsolate),
+      frame_entry<Isolate*>(re_frame, kIsolate), 
       frame_entry<intptr_t>(re_frame, kStartIndex),
       static_cast<RegExp::CallOrigin>(
           frame_entry<intptr_t>(re_frame, kDirectCall)),
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/regexp/regexp-macro-assembler.cc b/qtwebengine/src/3rdparty/chromium/v8/src/regexp/regexp-macro-assembler.cc
--- a/qtwebengine/src/3rdparty/chromium/v8/src/regexp/regexp-macro-assembler.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/regexp/regexp-macro-assembler.cc	2025-06-06 09:02:14.000000000 +0800
@@ -165,18 +165,18 @@
 #ifndef COMPILING_IRREGEXP_FOR_EXTERNAL_EMBEDDER
 
 // This method may only be called after an interrupt.
+// Remove argument : uintptr_t gap, only 8 arguments used
 int NativeRegExpMacroAssembler::CheckStackGuardState(
     Isolate* isolate, int start_index, RegExp::CallOrigin call_origin,
     Address* return_address, Code re_code, Address* subject,
-    const byte** input_start, const byte** input_end,
-    uintptr_t gap) {
+    const byte** input_start, const byte** input_end) {
   DisallowHeapAllocation no_gc;
   Address old_pc = PointerAuthentication::AuthenticatePC(return_address, 0);
   DCHECK_LE(re_code.raw_instruction_start(), old_pc);
   DCHECK_LE(old_pc, re_code.raw_instruction_end());
 
   StackLimitCheck check(isolate);
-  bool js_has_overflowed = check.JsHasOverflowed(gap);
+  bool js_has_overflowed = check.JsHasOverflowed(); // remove gap
 
   if (call_origin == RegExp::CallOrigin::kFromJs) {
     // Direct calls from JavaScript can be interrupted in two ways:
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/src/regexp/regexp-macro-assembler.h b/qtwebengine/src/3rdparty/chromium/v8/src/regexp/regexp-macro-assembler.h
--- a/qtwebengine/src/3rdparty/chromium/v8/src/regexp/regexp-macro-assembler.h	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/src/regexp/regexp-macro-assembler.h	2025-06-06 09:05:56.000000000 +0800
@@ -261,7 +261,8 @@
                                   RegExp::CallOrigin call_origin,
                                   Address* return_address, Code re_code,
                                   Address* subject, const byte** input_start,
-                                  const byte** input_end, uintptr_t gap);
+                                  const byte** input_end);
+  // remove argument: , uintptr_t gap);
 
   // Byte map of one byte characters with a 0xff if the character is a word
   // character (digit, letter or underscore) and 0x00 otherwise.
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/test/BUILD.gn b/qtwebengine/src/3rdparty/chromium/v8/test/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/v8/test/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/test/BUILD.gn	2025-06-03 14:20:02.000000000 +0800
@@ -36,7 +36,7 @@
       "benchmarks/cpp:gn_all",
       "cctest:cctest",
       "cctest:generate-bytecode-expectations",
-      "unittests:unittests",
+      #"unittests:unittests",
     ]
   }
 }
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/test/cctest/BUILD.gn b/qtwebengine/src/3rdparty/chromium/v8/test/cctest/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/v8/test/cctest/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/test/cctest/BUILD.gn	2025-06-05 15:21:44.000000000 +0800
@@ -397,7 +397,7 @@
     if (is_win) {
       sources += [ "test-stack-unwinding-win64.cc" ]
     }
-  } else if (v8_current_cpu == "ppc" || v8_current_cpu == "ppc64") {
+  } else if (v8_current_cpu == "ppc" || v8_current_cpu == "ppc64" || v8_current_cpu == "ppc64le") {
     sources += [  ### gcmole(arch:ppc) ###
       "test-assembler-ppc.cc",
       "test-disasm-ppc.cc",
@@ -444,7 +444,7 @@
   }
 
   cflags = []
-  if (v8_current_cpu == "ppc" || v8_current_cpu == "ppc64" ||
+  if (v8_current_cpu == "ppc" || v8_current_cpu == "ppc64" || v8_current_cpu == "ppc64le"  ||
       v8_current_cpu == "arm" || v8_current_cpu == "arm64" ||
       v8_current_cpu == "s390" || v8_current_cpu == "s390x" ||
       v8_current_cpu == "mips" || v8_current_cpu == "mips64" ||
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/test/unittests/BUILD.gn b/qtwebengine/src/3rdparty/chromium/v8/test/unittests/BUILD.gn
--- a/qtwebengine/src/3rdparty/chromium/v8/test/unittests/BUILD.gn	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/test/unittests/BUILD.gn	2025-06-05 15:22:08.000000000 +0800
@@ -419,7 +419,7 @@
       "compiler/x64/instruction-selector-x64-unittest.cc",
       "wasm/trap-handler-x64-unittest.cc",
     ]
-  } else if (v8_current_cpu == "ppc" || v8_current_cpu == "ppc64") {
+  } else if (v8_current_cpu == "ppc" || v8_current_cpu == "ppc64" || v8_current_cpu == "ppc64le") {
     sources += [
       "assembler/turbo-assembler-ppc-unittest.cc",
       "compiler/ppc/instruction-selector-ppc-unittest.cc",
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/third_party/binutils/download.py b/qtwebengine/src/3rdparty/chromium/v8/third_party/binutils/download.py
--- a/qtwebengine/src/3rdparty/chromium/v8/third_party/binutils/download.py	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/third_party/binutils/download.py	2025-05-30 15:39:34.000000000 +0800
@@ -89,6 +89,8 @@
     return 0
 
   arch = DetectHostArch()
+  if arch == 'ppc64le':
+    return FetchAndExtract(arch)
   if arch == 'x64':
     return FetchAndExtract(arch)
   if arch == 'ia32':
diff -Naur a/qtwebengine/src/3rdparty/chromium/v8/tools/dev/gm.py b/qtwebengine/src/3rdparty/chromium/v8/tools/dev/gm.py
--- a/qtwebengine/src/3rdparty/chromium/v8/tools/dev/gm.py	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/chromium/v8/tools/dev/gm.py	2025-06-05 15:22:58.000000000 +0800
@@ -41,7 +41,7 @@
 BUILD_TARGETS_ALL = ["all"]
 
 # All arches that this script understands.
-ARCHES = ["ia32", "x64", "arm", "arm64", "mipsel", "mips64el", "ppc", "ppc64",
+ARCHES = ["ia32", "x64", "arm", "arm64", "mipsel", "mips64el", "ppc", "ppc64", "ppc64le", 
           "s390", "s390x", "android_arm", "android_arm64"]
 # Arches that get built/run when you don't specify any.
 DEFAULT_ARCHES = ["ia32", "x64", "arm", "arm64"]
@@ -249,7 +249,7 @@
   def GetV8TargetCpu(self):
     if self.arch == "android_arm": return "\nv8_target_cpu = \"arm\""
     if self.arch == "android_arm64": return "\nv8_target_cpu = \"arm64\""
-    if self.arch in ("arm", "arm64", "mipsel", "mips64el", "ppc", "ppc64",
+    if self.arch in ("arm", "arm64", "mipsel", "mips64el", "ppc", "ppc64", "ppc64le", 
                      "s390", "s390x"):
       return "\nv8_target_cpu = \"%s\"" % self.arch
     return ""
diff -Naur a/qtwebengine/src/3rdparty/gn/util/sys_info.cc b/qtwebengine/src/3rdparty/gn/util/sys_info.cc
--- a/qtwebengine/src/3rdparty/gn/util/sys_info.cc	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/3rdparty/gn/util/sys_info.cc	2025-06-05 17:13:04.000000000 +0800
@@ -30,6 +30,10 @@
     arch = "x86_64";
   } else if (std::string(info.sysname) == "AIX") {
     arch = "ppc64";
+#if defined(__powerpc64__)
+  } else if (std::string(info.sysname) == "Linux") {
+    arch = "ppc64";
+#endif
   }
   return arch;
 #elif defined(OS_WIN)
diff -Naur a/qtwebengine/src/buildtools/config/support.pri b/qtwebengine/src/buildtools/config/support.pri
--- a/qtwebengine/src/buildtools/config/support.pri	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/buildtools/config/support.pri	2025-05-30 16:46:29.000000000 +0800
@@ -110,7 +110,7 @@
 defineTest(qtwebengine_checkForArch) {
     module = $$1
     !qtConfig(webengine-arch-support) {
-        qtwebengine_skipBuild("$${module} can only be built for x86, x86-64, ARM, Aarch64, and MIPSel architectures.")
+        qtwebengine_skipBuild("$${module} can only be built for x86, x86-64, ARM, Aarch64, PowerPC and MIPSel architectures.")
         return(false)
     }
     return(true)
diff -Naur a/qtwebengine/src/buildtools/configure_host.pro b/qtwebengine/src/buildtools/configure_host.pro
--- a/qtwebengine/src/buildtools/configure_host.pro	2024-04-03 17:31:09.000000000 +0800
+++ b/qtwebengine/src/buildtools/configure_host.pro	2025-05-30 16:46:43.000000000 +0800
@@ -16,9 +16,10 @@
 else: GN_USE_GOLD=false
 
 GN_V8_HOST_CPU = $$GN_HOST_CPU
-contains(GN_TARGET_CPU, "arm")|contains(GN_TARGET_CPU, "mipsel")|contains(GN_TARGET_CPU, "x86") {
+contains(GN_TARGET_CPU, "ppc")|contains(GN_TARGET_CPU, "arm")|contains(GN_TARGET_CPU, "mipsel")|contains(GN_TARGET_CPU, "x86") {
     # The v8 snapshot need a host that matches bitwidth, so we build makesnapshot to 32-bit variants of host.
-    contains(GN_V8_HOST_CPU, x64): GN_V8_HOST_CPU = "x86"
+    contains(GN_V8_HOST_CPU, ppc64le): GN_V8_HOST_CPU = "ppcle"
+    else: contains(GN_V8_HOST_CPU, x64): GN_V8_HOST_CPU = "x86"
     else: contains(GN_V8_HOST_CPU, arm64): GN_V8_HOST_CPU = "arm"
     else: contains(GN_V8_HOST_CPU, mips64el): GN_V8_HOST_CPU = "mipsel"
 }
diff -Naur a/qtwebengine/src/buildtools/qtbuildtools-config_p.h b/qtwebengine/src/buildtools/qtbuildtools-config_p.h
--- a/qtwebengine/src/buildtools/qtbuildtools-config_p.h	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/buildtools/qtbuildtools-config_p.h	2025-05-23 16:34:46.000000000 +0800
@@ -0,0 +1,60 @@
+#define QT_FEATURE_build_qtpdf 1
+#define QT_FEATURE_build_qtwebengine_core 1
+#define QT_FEATURE_webengine_arch_support -1
+#define QT_FEATURE_webengine_arm_thumb -1
+#define QT_FEATURE_webengine_bison 1
+#define QT_FEATURE_webengine_submodule 1
+#define QT_FEATURE_webengine_nowhitespace 1
+#define QT_FEATURE_webengine_no_platform_support -1
+#define QT_FEATURE_webengine_core_support -1
+#define QT_FEATURE_webengine_developer_build 1
+#define QT_FEATURE_webengine_flex 1
+#define QT_FEATURE_webengine_gperf 1
+#define QT_FEATURE_webengine_host_pkg_config 1
+#define QT_FEATURE_webengine_jumbo_build 1
+#define QT_FEATURE_webengine_nodejs 1
+#define QT_FEATURE_webengine_nodejs10 1
+#define QT_FEATURE_webengine_noexecstack 1
+#define QT_FEATURE_webengine_system_x11 1
+#define QT_FEATURE_webengine_system_libdrm 1
+#define QT_FEATURE_webengine_system_xcomposite 1
+#define QT_FEATURE_webengine_system_xcursor 1
+#define QT_FEATURE_webengine_system_xi 1
+#define QT_FEATURE_webengine_system_xproto_gl 1
+#define QT_FEATURE_webengine_system_xtst 1
+#define QT_FEATURE_webengine_system_xkbfile -1
+#define QT_FEATURE_webengine_ozone_x11 -1
+#define QT_FEATURE_webengine_python 1
+#define QT_FEATURE_webengine_qt_freetype -1
+#define QT_FEATURE_webengine_qt_harfbuzz -1
+#define QT_FEATURE_webengine_qt_jpeg -1
+#define QT_FEATURE_webengine_qt_png -1
+#define QT_FEATURE_webengine_qt_zlib -1
+#define QT_FEATURE_webengine_qtpdf_support -1
+#define QT_FEATURE_webengine_sanitizer -1
+#define QT_FEATURE_webengine_system_dbus 1
+#define QT_FEATURE_webengine_system_ffmpeg -1
+#define QT_FEATURE_webengine_system_fontconfig 1
+#define QT_FEATURE_webengine_system_freetype 1
+#define QT_FEATURE_webengine_system_glib 1
+#define QT_FEATURE_webengine_system_glibc 1
+#define QT_FEATURE_webengine_system_gn -1
+#define QT_FEATURE_webengine_system_harfbuzz -1
+#define QT_FEATURE_webengine_system_icu -1
+#define QT_FEATURE_webengine_system_jpeg 1
+#define QT_FEATURE_webengine_system_khr 1
+#define QT_FEATURE_webengine_system_lcms2 -1
+#define QT_FEATURE_webengine_system_libevent 1
+#define QT_FEATURE_webengine_system_libvpx -1
+#define QT_FEATURE_webengine_system_libwebp -1
+#define QT_FEATURE_webengine_system_libxml2 -1
+#define QT_FEATURE_webengine_system_minizip -1
+#define QT_FEATURE_webengine_system_ninja -1
+#define QT_FEATURE_webengine_system_nss -1
+#define QT_FEATURE_webengine_system_opus -1
+#define QT_FEATURE_webengine_system_png 1
+#define QT_FEATURE_webengine_system_re2 -1
+#define QT_FEATURE_webengine_system_snappy -1
+#define QT_FEATURE_webengine_system_zlib 1
+#define QT_FEATURE_webengine_win_compiler64 -1
+#define QT_FEATURE_webengine_winversion -1
diff -Naur a/qtwebengine/src/buildtools/qtbuildtools-config.pri b/qtwebengine/src/buildtools/qtbuildtools-config.pri
--- a/qtwebengine/src/buildtools/qtbuildtools-config.pri	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/buildtools/qtbuildtools-config.pri	2025-05-23 16:34:46.000000000 +0800
@@ -0,0 +1,31 @@
+QT.buildtools.enabled_features = 
+QT.buildtools.disabled_features = 
+QT.buildtools.QT_CONFIG = 
+QT.buildtools.exports = 
+QT.buildtools_private.enabled_features = build-qtpdf build-qtwebengine-core webengine-bison webengine-submodule webengine-nowhitespace webengine-developer-build webengine-flex webengine-gperf webengine-host-pkg-config webengine-jumbo-build webengine-nodejs webengine-nodejs10 webengine-noexecstack webengine-system-x11 webengine-system-libdrm webengine-system-xcomposite webengine-system-xcursor webengine-system-xi webengine-system-xproto-gl webengine-system-xtst webengine-python webengine-system-dbus webengine-system-fontconfig webengine-system-freetype webengine-system-glib webengine-system-glibc webengine-system-jpeg webengine-system-khr webengine-system-libevent webengine-system-png webengine-system-zlib
+QT.buildtools_private.disabled_features = webengine-arch-support webengine-arm-thumb webengine-no-platform-support webengine-core-support webengine-system-xkbfile webengine-ozone-x11 webengine-qt-freetype webengine-qt-harfbuzz webengine-qt-jpeg webengine-qt-png webengine-qt-zlib webengine-qtpdf-support webengine-sanitizer webengine-system-ffmpeg webengine-system-gn webengine-system-harfbuzz webengine-system-icu webengine-system-lcms2 webengine-system-libvpx webengine-system-libwebp webengine-system-libxml2 webengine-system-minizip webengine-system-ninja webengine-system-nss webengine-system-opus webengine-system-re2 webengine-system-snappy webengine-win-compiler64 webengine-winversion
+QT.buildtools_private.libraries = webengine_x11 webengine_libdrm webengine_xcomposite webengine_xcursor webengine_xi webengine_xproto_gl webengine_xtst webengine_dbus webengine_fontconfig webengine_freetype webengine_glib webengine_jpeglib webengine_libevent webengine_png webengine_zlib
+QMAKE_PKG_CONFIG_HOST = /usr/bin/pkg-config
+QMAKE_JUMBO_MERGE_LIMIT = 8
+QMAKE_LIBS_WEBENGINE_X11 = -lX11
+QMAKE_LIBS_WEBENGINE_LIBDRM = -ldrm
+QMAKE_INCDIR_WEBENGINE_LIBDRM = /usr/include/libdrm /usr/include/valgrind
+QMAKE_LIBS_WEBENGINE_XCOMPOSITE = -lXcomposite
+QMAKE_LIBS_WEBENGINE_XCURSOR = -lXcursor
+QMAKE_LIBS_WEBENGINE_XI = -lXi
+QMAKE_LIBS_WEBENGINE_XPROTO_GL = 
+QMAKE_LIBS_WEBENGINE_XTST = -lXtst
+QMAKE_PYTHON2 = /usr/bin/python2
+QMAKE_LIBS_WEBENGINE_DBUS = -ldbus-1
+QMAKE_INCDIR_WEBENGINE_DBUS = /usr/include/dbus-1.0 /usr/lib64/dbus-1.0/include
+QMAKE_LIBS_WEBENGINE_FONTCONFIG = -lfontconfig -lfreetype
+QMAKE_INCDIR_WEBENGINE_FONTCONFIG = /usr/include/freetype2 /usr/include/libpng16 /usr/include/uuid
+QMAKE_LIBS_WEBENGINE_FREETYPE = -lfreetype
+QMAKE_INCDIR_WEBENGINE_FREETYPE = /usr/include/freetype2 /usr/include/libpng16
+QMAKE_LIBS_WEBENGINE_GLIB = -lglib-2.0
+QMAKE_INCDIR_WEBENGINE_GLIB = /usr/include/glib-2.0 /usr/lib64/glib-2.0/include
+QMAKE_LIBS_WEBENGINE_JPEGLIB = -ljpeg
+QMAKE_LIBS_WEBENGINE_LIBEVENT = -levent
+QMAKE_LIBS_WEBENGINE_PNG = -lpng16 -lz
+QMAKE_INCDIR_WEBENGINE_PNG = /usr/include/libpng16
+QMAKE_LIBS_WEBENGINE_ZLIB = -lz
diff -Naur a/qtwebengine/src/core/qtwebenginecore-config.pri b/qtwebengine/src/core/qtwebenginecore-config.pri
--- a/qtwebengine/src/core/qtwebenginecore-config.pri	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/core/qtwebenginecore-config.pri	2025-05-23 16:34:46.000000000 +0800
@@ -0,0 +1,8 @@
+QT.webenginecore.enabled_features = 
+QT.webenginecore.disabled_features = 
+QT.webenginecore.QT_CONFIG = 
+QT.webenginecore.exports = 
+QT.webenginecore_private.enabled_features = 
+QT.webenginecore_private.disabled_features = 
+QT.webenginecore_private.libraries = 
+QT.webenginecore.skip = true
diff -Naur a/qtwebengine/src/pdf/qtpdf-config.pri b/qtwebengine/src/pdf/qtpdf-config.pri
--- a/qtwebengine/src/pdf/qtpdf-config.pri	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/pdf/qtpdf-config.pri	2025-05-23 16:34:46.000000000 +0800
@@ -0,0 +1,8 @@
+QT.pdf.enabled_features = 
+QT.pdf.disabled_features = 
+QT.pdf.QT_CONFIG = 
+QT.pdf.exports = 
+QT.pdf_private.enabled_features = 
+QT.pdf_private.disabled_features = 
+QT.pdf_private.libraries = 
+QT.pdf.skip = true
diff -Naur a/qtwebengine/src/pdfwidgets/qtpdfwidgets-config.pri b/qtwebengine/src/pdfwidgets/qtpdfwidgets-config.pri
--- a/qtwebengine/src/pdfwidgets/qtpdfwidgets-config.pri	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/pdfwidgets/qtpdfwidgets-config.pri	2025-05-23 16:34:46.000000000 +0800
@@ -0,0 +1,8 @@
+QT.pdfwidgets.enabled_features = 
+QT.pdfwidgets.disabled_features = 
+QT.pdfwidgets.QT_CONFIG = 
+QT.pdfwidgets.exports = 
+QT.pdfwidgets_private.enabled_features = 
+QT.pdfwidgets_private.disabled_features = 
+QT.pdfwidgets_private.libraries = 
+QT.pdfwidgets.skip = true
diff -Naur a/qtwebengine/src/webengine/qtwebengine-config.pri b/qtwebengine/src/webengine/qtwebengine-config.pri
--- a/qtwebengine/src/webengine/qtwebengine-config.pri	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/webengine/qtwebengine-config.pri	2025-05-23 16:34:46.000000000 +0800
@@ -0,0 +1,8 @@
+QT.webengine.enabled_features = 
+QT.webengine.disabled_features = 
+QT.webengine.QT_CONFIG = 
+QT.webengine.exports = 
+QT.webengine_private.enabled_features = 
+QT.webengine_private.disabled_features = 
+QT.webengine_private.libraries = 
+QT.webengine.skip = true
diff -Naur a/qtwebengine/src/webenginewidgets/qtwebenginewidgets-config.pri b/qtwebengine/src/webenginewidgets/qtwebenginewidgets-config.pri
--- a/qtwebengine/src/webenginewidgets/qtwebenginewidgets-config.pri	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/src/webenginewidgets/qtwebenginewidgets-config.pri	2025-05-23 16:34:46.000000000 +0800
@@ -0,0 +1,8 @@
+QT.webenginewidgets.enabled_features = 
+QT.webenginewidgets.disabled_features = 
+QT.webenginewidgets.QT_CONFIG = 
+QT.webenginewidgets.exports = 
+QT.webenginewidgets_private.enabled_features = 
+QT.webenginewidgets_private.disabled_features = 
+QT.webenginewidgets_private.libraries = 
+QT.webenginewidgets.skip = true
diff -Naur a/qtwebengine/tests/tests.pro.user b/qtwebengine/tests/tests.pro.user
--- a/qtwebengine/tests/tests.pro.user	1970-01-01 08:00:00.000000000 +0800
+++ b/qtwebengine/tests/tests.pro.user	2025-06-10 10:44:22.486179187 +0800
@@ -0,0 +1,112 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE QtCreatorProject>
+<!-- Written by QtCreator 8.0.2, 2025-06-10T10:44:22. -->
+<qtcreator>
+ <data>
+  <variable>EnvironmentId</variable>
+  <value type="QByteArray">{539022a6-4b5b-4968-9b6b-3c3695f09221}</value>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.ActiveTarget</variable>
+  <value type="int">0</value>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.EditorSettings</variable>
+  <valuemap type="QVariantMap">
+   <value type="bool" key="EditorConfiguration.AutoIndent">true</value>
+   <value type="bool" key="EditorConfiguration.AutoSpacesForTabs">false</value>
+   <value type="bool" key="EditorConfiguration.CamelCaseNavigation">true</value>
+   <valuemap type="QVariantMap" key="EditorConfiguration.CodeStyle.0">
+    <value type="QString" key="language">Cpp</value>
+    <valuemap type="QVariantMap" key="value">
+     <value type="QByteArray" key="CurrentPreferences">CppGlobal</value>
+    </valuemap>
+   </valuemap>
+   <valuemap type="QVariantMap" key="EditorConfiguration.CodeStyle.1">
+    <value type="QString" key="language">QmlJS</value>
+    <valuemap type="QVariantMap" key="value">
+     <value type="QByteArray" key="CurrentPreferences">QmlJSGlobal</value>
+    </valuemap>
+   </valuemap>
+   <value type="int" key="EditorConfiguration.CodeStyle.Count">2</value>
+   <value type="QByteArray" key="EditorConfiguration.Codec">UTF-8</value>
+   <value type="bool" key="EditorConfiguration.ConstrainTooltips">false</value>
+   <value type="int" key="EditorConfiguration.IndentSize">4</value>
+   <value type="bool" key="EditorConfiguration.KeyboardTooltips">false</value>
+   <value type="int" key="EditorConfiguration.MarginColumn">80</value>
+   <value type="bool" key="EditorConfiguration.MouseHiding">true</value>
+   <value type="bool" key="EditorConfiguration.MouseNavigation">true</value>
+   <value type="int" key="EditorConfiguration.PaddingMode">1</value>
+   <value type="bool" key="EditorConfiguration.PreferSingleLineComments">false</value>
+   <value type="bool" key="EditorConfiguration.ScrollWheelZooming">true</value>
+   <value type="bool" key="EditorConfiguration.ShowMargin">false</value>
+   <value type="int" key="EditorConfiguration.SmartBackspaceBehavior">0</value>
+   <value type="bool" key="EditorConfiguration.SmartSelectionChanging">true</value>
+   <value type="bool" key="EditorConfiguration.SpacesForTabs">true</value>
+   <value type="int" key="EditorConfiguration.TabKeyBehavior">0</value>
+   <value type="int" key="EditorConfiguration.TabSize">8</value>
+   <value type="bool" key="EditorConfiguration.UseGlobal">true</value>
+   <value type="bool" key="EditorConfiguration.UseIndenter">false</value>
+   <value type="int" key="EditorConfiguration.Utf8BomBehavior">1</value>
+   <value type="bool" key="EditorConfiguration.addFinalNewLine">true</value>
+   <value type="bool" key="EditorConfiguration.cleanIndentation">true</value>
+   <value type="bool" key="EditorConfiguration.cleanWhitespace">true</value>
+   <value type="QString" key="EditorConfiguration.ignoreFileTypes">*.md, *.MD, Makefile</value>
+   <value type="bool" key="EditorConfiguration.inEntireDocument">false</value>
+   <value type="bool" key="EditorConfiguration.skipTrailingWhitespace">true</value>
+  </valuemap>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.PluginSettings</variable>
+  <valuemap type="QVariantMap">
+   <valuemap type="QVariantMap" key="AutoTest.ActiveFrameworks">
+    <value type="bool" key="AutoTest.Framework.Boost">true</value>
+    <value type="bool" key="AutoTest.Framework.CTest">false</value>
+    <value type="bool" key="AutoTest.Framework.Catch">true</value>
+    <value type="bool" key="AutoTest.Framework.GTest">true</value>
+    <value type="bool" key="AutoTest.Framework.QtQuickTest">true</value>
+    <value type="bool" key="AutoTest.Framework.QtTest">true</value>
+   </valuemap>
+   <valuemap type="QVariantMap" key="AutoTest.CheckStates"/>
+   <value type="int" key="AutoTest.RunAfterBuild">0</value>
+   <value type="bool" key="AutoTest.UseGlobal">true</value>
+   <valuemap type="QVariantMap" key="ClangTools">
+    <value type="bool" key="ClangTools.AnalyzeOpenFiles">true</value>
+    <value type="bool" key="ClangTools.BuildBeforeAnalysis">true</value>
+    <value type="QString" key="ClangTools.DiagnosticConfig">Builtin.DefaultTidyAndClazy</value>
+    <value type="int" key="ClangTools.ParallelJobs">20</value>
+    <valuelist type="QVariantList" key="ClangTools.SelectedDirs"/>
+    <valuelist type="QVariantList" key="ClangTools.SelectedFiles"/>
+    <valuelist type="QVariantList" key="ClangTools.SuppressedDiagnostics"/>
+    <value type="bool" key="ClangTools.UseGlobalSettings">true</value>
+   </valuemap>
+  </valuemap>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.Target.0</variable>
+  <valuemap type="QVariantMap">
+   <value type="QString" key="DeviceType">Desktop</value>
+   <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Qt 5.15.17 (qt51517+webengine_release_0609)</value>
+   <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName">Qt 5.15.17 (qt51517+webengine_release_0609)</value>
+   <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">{c8e71d99-768c-4c01-9c09-d989d83c1085}</value>
+   <value type="int" key="ProjectExplorer.Target.ActiveBuildConfiguration">-1</value>
+   <value type="int" key="ProjectExplorer.Target.ActiveDeployConfiguration">-1</value>
+   <value type="int" key="ProjectExplorer.Target.ActiveRunConfiguration">-1</value>
+   <value type="int" key="ProjectExplorer.Target.BuildConfigurationCount">0</value>
+   <value type="int" key="ProjectExplorer.Target.DeployConfigurationCount">0</value>
+   <value type="int" key="ProjectExplorer.Target.RunConfigurationCount">0</value>
+  </valuemap>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.TargetCount</variable>
+  <value type="int">1</value>
+ </data>
+ <data>
+  <variable>ProjectExplorer.Project.Updater.FileVersion</variable>
+  <value type="int">22</value>
+ </data>
+ <data>
+  <variable>Version</variable>
+  <value type="int">22</value>
+ </data>
+</qtcreator>
